var Hae = Object.defineProperty;
var zH = (n) => {
  throw TypeError(n);
};
var Vae = (n, t, e) => t in n ? Hae(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var T = (n, t, e) => Vae(n, typeof t != "symbol" ? t + "" : t, e), Zj = (n, t, e) => t.has(n) || zH("Cannot " + e);
var _ = (n, t, e) => (Zj(n, t, "read from private field"), e ? e.call(n) : t.get(n)), J = (n, t, e) => t.has(n) ? zH("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), q = (n, t, e, r) => (Zj(n, t, "write to private field"), r ? r.call(n, e) : t.set(n, e), e), Q = (n, t, e) => (Zj(n, t, "access private method"), e);
var ec = (n, t, e, r) => ({
  set _(i) {
    q(n, t, i, e);
  },
  get _() {
    return _(n, t, r);
  }
});
function Wae(n, t) {
  for (var e = 0; e < t.length; e++) {
    const r = t[e];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(n, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var ga = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ep(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var BF = { exports: {} }, xE = {}, HF = { exports: {} }, An = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UH;
function Gae() {
  if (UH) return An;
  UH = 1;
  var n = Symbol.for("react.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), m = Symbol.iterator;
  function v(ce) {
    return ce === null || typeof ce != "object" ? null : (ce = m && ce[m] || ce["@@iterator"], typeof ce == "function" ? ce : null);
  }
  var S = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, w = Object.assign, E = {};
  function A(ce, ye, Fe) {
    this.props = ce, this.context = ye, this.refs = E, this.updater = Fe || S;
  }
  A.prototype.isReactComponent = {}, A.prototype.setState = function(ce, ye) {
    if (typeof ce != "object" && typeof ce != "function" && ce != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, ce, ye, "setState");
  }, A.prototype.forceUpdate = function(ce) {
    this.updater.enqueueForceUpdate(this, ce, "forceUpdate");
  };
  function P() {
  }
  P.prototype = A.prototype;
  function R(ce, ye, Fe) {
    this.props = ce, this.context = ye, this.refs = E, this.updater = Fe || S;
  }
  var M = R.prototype = new P();
  M.constructor = R, w(M, A.prototype), M.isPureReactComponent = !0;
  var j = Array.isArray, $ = Object.prototype.hasOwnProperty, U = { current: null }, F = { key: !0, ref: !0, __self: !0, __source: !0 };
  function B(ce, ye, Fe) {
    var Xe, je = {}, nt = null, Ze = null;
    if (ye != null) for (Xe in ye.ref !== void 0 && (Ze = ye.ref), ye.key !== void 0 && (nt = "" + ye.key), ye) $.call(ye, Xe) && !F.hasOwnProperty(Xe) && (je[Xe] = ye[Xe]);
    var tt = arguments.length - 2;
    if (tt === 1) je.children = Fe;
    else if (1 < tt) {
      for (var et = Array(tt), at = 0; at < tt; at++) et[at] = arguments[at + 2];
      je.children = et;
    }
    if (ce && ce.defaultProps) for (Xe in tt = ce.defaultProps, tt) je[Xe] === void 0 && (je[Xe] = tt[Xe]);
    return { $$typeof: n, type: ce, key: nt, ref: Ze, props: je, _owner: U.current };
  }
  function G(ce, ye) {
    return { $$typeof: n, type: ce.type, key: ye, ref: ce.ref, props: ce.props, _owner: ce._owner };
  }
  function X(ce) {
    return typeof ce == "object" && ce !== null && ce.$$typeof === n;
  }
  function te(ce) {
    var ye = { "=": "=0", ":": "=2" };
    return "$" + ce.replace(/[=:]/g, function(Fe) {
      return ye[Fe];
    });
  }
  var ne = /\/+/g;
  function K(ce, ye) {
    return typeof ce == "object" && ce !== null && ce.key != null ? te("" + ce.key) : ye.toString(36);
  }
  function Z(ce, ye, Fe, Xe, je) {
    var nt = typeof ce;
    (nt === "undefined" || nt === "boolean") && (ce = null);
    var Ze = !1;
    if (ce === null) Ze = !0;
    else switch (nt) {
      case "string":
      case "number":
        Ze = !0;
        break;
      case "object":
        switch (ce.$$typeof) {
          case n:
          case t:
            Ze = !0;
        }
    }
    if (Ze) return Ze = ce, je = je(Ze), ce = Xe === "" ? "." + K(Ze, 0) : Xe, j(je) ? (Fe = "", ce != null && (Fe = ce.replace(ne, "$&/") + "/"), Z(je, ye, Fe, "", function(at) {
      return at;
    })) : je != null && (X(je) && (je = G(je, Fe + (!je.key || Ze && Ze.key === je.key ? "" : ("" + je.key).replace(ne, "$&/") + "/") + ce)), ye.push(je)), 1;
    if (Ze = 0, Xe = Xe === "" ? "." : Xe + ":", j(ce)) for (var tt = 0; tt < ce.length; tt++) {
      nt = ce[tt];
      var et = Xe + K(nt, tt);
      Ze += Z(nt, ye, Fe, et, je);
    }
    else if (et = v(ce), typeof et == "function") for (ce = et.call(ce), tt = 0; !(nt = ce.next()).done; ) nt = nt.value, et = Xe + K(nt, tt++), Ze += Z(nt, ye, Fe, et, je);
    else if (nt === "object") throw ye = String(ce), Error("Objects are not valid as a React child (found: " + (ye === "[object Object]" ? "object with keys {" + Object.keys(ce).join(", ") + "}" : ye) + "). If you meant to render a collection of children, use an array instead.");
    return Ze;
  }
  function oe(ce, ye, Fe) {
    if (ce == null) return ce;
    var Xe = [], je = 0;
    return Z(ce, Xe, "", "", function(nt) {
      return ye.call(Fe, nt, je++);
    }), Xe;
  }
  function fe(ce) {
    if (ce._status === -1) {
      var ye = ce._result;
      ye = ye(), ye.then(function(Fe) {
        (ce._status === 0 || ce._status === -1) && (ce._status = 1, ce._result = Fe);
      }, function(Fe) {
        (ce._status === 0 || ce._status === -1) && (ce._status = 2, ce._result = Fe);
      }), ce._status === -1 && (ce._status = 0, ce._result = ye);
    }
    if (ce._status === 1) return ce._result.default;
    throw ce._result;
  }
  var ie = { current: null }, ue = { transition: null }, Se = { ReactCurrentDispatcher: ie, ReactCurrentBatchConfig: ue, ReactCurrentOwner: U };
  function ke() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return An.Children = { map: oe, forEach: function(ce, ye, Fe) {
    oe(ce, function() {
      ye.apply(this, arguments);
    }, Fe);
  }, count: function(ce) {
    var ye = 0;
    return oe(ce, function() {
      ye++;
    }), ye;
  }, toArray: function(ce) {
    return oe(ce, function(ye) {
      return ye;
    }) || [];
  }, only: function(ce) {
    if (!X(ce)) throw Error("React.Children.only expected to receive a single React element child.");
    return ce;
  } }, An.Component = A, An.Fragment = e, An.Profiler = i, An.PureComponent = R, An.StrictMode = r, An.Suspense = u, An.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Se, An.act = ke, An.cloneElement = function(ce, ye, Fe) {
    if (ce == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ce + ".");
    var Xe = w({}, ce.props), je = ce.key, nt = ce.ref, Ze = ce._owner;
    if (ye != null) {
      if (ye.ref !== void 0 && (nt = ye.ref, Ze = U.current), ye.key !== void 0 && (je = "" + ye.key), ce.type && ce.type.defaultProps) var tt = ce.type.defaultProps;
      for (et in ye) $.call(ye, et) && !F.hasOwnProperty(et) && (Xe[et] = ye[et] === void 0 && tt !== void 0 ? tt[et] : ye[et]);
    }
    var et = arguments.length - 2;
    if (et === 1) Xe.children = Fe;
    else if (1 < et) {
      tt = Array(et);
      for (var at = 0; at < et; at++) tt[at] = arguments[at + 2];
      Xe.children = tt;
    }
    return { $$typeof: n, type: ce.type, key: je, ref: nt, props: Xe, _owner: Ze };
  }, An.createContext = function(ce) {
    return ce = { $$typeof: o, _currentValue: ce, _currentValue2: ce, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, ce.Provider = { $$typeof: s, _context: ce }, ce.Consumer = ce;
  }, An.createElement = B, An.createFactory = function(ce) {
    var ye = B.bind(null, ce);
    return ye.type = ce, ye;
  }, An.createRef = function() {
    return { current: null };
  }, An.forwardRef = function(ce) {
    return { $$typeof: l, render: ce };
  }, An.isValidElement = X, An.lazy = function(ce) {
    return { $$typeof: f, _payload: { _status: -1, _result: ce }, _init: fe };
  }, An.memo = function(ce, ye) {
    return { $$typeof: d, type: ce, compare: ye === void 0 ? null : ye };
  }, An.startTransition = function(ce) {
    var ye = ue.transition;
    ue.transition = {};
    try {
      ce();
    } finally {
      ue.transition = ye;
    }
  }, An.unstable_act = ke, An.useCallback = function(ce, ye) {
    return ie.current.useCallback(ce, ye);
  }, An.useContext = function(ce) {
    return ie.current.useContext(ce);
  }, An.useDebugValue = function() {
  }, An.useDeferredValue = function(ce) {
    return ie.current.useDeferredValue(ce);
  }, An.useEffect = function(ce, ye) {
    return ie.current.useEffect(ce, ye);
  }, An.useId = function() {
    return ie.current.useId();
  }, An.useImperativeHandle = function(ce, ye, Fe) {
    return ie.current.useImperativeHandle(ce, ye, Fe);
  }, An.useInsertionEffect = function(ce, ye) {
    return ie.current.useInsertionEffect(ce, ye);
  }, An.useLayoutEffect = function(ce, ye) {
    return ie.current.useLayoutEffect(ce, ye);
  }, An.useMemo = function(ce, ye) {
    return ie.current.useMemo(ce, ye);
  }, An.useReducer = function(ce, ye, Fe) {
    return ie.current.useReducer(ce, ye, Fe);
  }, An.useRef = function(ce) {
    return ie.current.useRef(ce);
  }, An.useState = function(ce) {
    return ie.current.useState(ce);
  }, An.useSyncExternalStore = function(ce, ye, Fe) {
    return ie.current.useSyncExternalStore(ce, ye, Fe);
  }, An.useTransition = function() {
    return ie.current.useTransition();
  }, An.version = "18.3.1", An;
}
var WE = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
WE.exports;
var BH;
function Kae() {
  return BH || (BH = 1, function(n, t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = "18.3.1", r = Symbol.for("react.element"), i = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), d = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), S = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), A = Symbol.iterator, P = "@@iterator";
      function R(W) {
        if (W === null || typeof W != "object")
          return null;
        var le = A && W[A] || W[P];
        return typeof le == "function" ? le : null;
      }
      var M = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, j = {
        transition: null
      }, $ = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, U = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, F = {}, B = null;
      function G(W) {
        B = W;
      }
      F.setExtraStackFrame = function(W) {
        B = W;
      }, F.getCurrentStack = null, F.getStackAddendum = function() {
        var W = "";
        B && (W += B);
        var le = F.getCurrentStack;
        return le && (W += le() || ""), W;
      };
      var X = !1, te = !1, ne = !1, K = !1, Z = !1, oe = {
        ReactCurrentDispatcher: M,
        ReactCurrentBatchConfig: j,
        ReactCurrentOwner: U
      };
      oe.ReactDebugCurrentFrame = F, oe.ReactCurrentActQueue = $;
      function fe(W) {
        {
          for (var le = arguments.length, Ce = new Array(le > 1 ? le - 1 : 0), Pe = 1; Pe < le; Pe++)
            Ce[Pe - 1] = arguments[Pe];
          ue("warn", W, Ce);
        }
      }
      function ie(W) {
        {
          for (var le = arguments.length, Ce = new Array(le > 1 ? le - 1 : 0), Pe = 1; Pe < le; Pe++)
            Ce[Pe - 1] = arguments[Pe];
          ue("error", W, Ce);
        }
      }
      function ue(W, le, Ce) {
        {
          var Pe = oe.ReactDebugCurrentFrame, He = Pe.getStackAddendum();
          He !== "" && (le += "%s", Ce = Ce.concat([He]));
          var yt = Ce.map(function(Qe) {
            return String(Qe);
          });
          yt.unshift("Warning: " + le), Function.prototype.apply.call(console[W], console, yt);
        }
      }
      var Se = {};
      function ke(W, le) {
        {
          var Ce = W.constructor, Pe = Ce && (Ce.displayName || Ce.name) || "ReactClass", He = Pe + "." + le;
          if (Se[He])
            return;
          ie("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", le, Pe), Se[He] = !0;
        }
      }
      var ce = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(W) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(W, le, Ce) {
          ke(W, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(W, le, Ce, Pe) {
          ke(W, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(W, le, Ce, Pe) {
          ke(W, "setState");
        }
      }, ye = Object.assign, Fe = {};
      Object.freeze(Fe);
      function Xe(W, le, Ce) {
        this.props = W, this.context = le, this.refs = Fe, this.updater = Ce || ce;
      }
      Xe.prototype.isReactComponent = {}, Xe.prototype.setState = function(W, le) {
        if (typeof W != "object" && typeof W != "function" && W != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, W, le, "setState");
      }, Xe.prototype.forceUpdate = function(W) {
        this.updater.enqueueForceUpdate(this, W, "forceUpdate");
      };
      {
        var je = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, nt = function(W, le) {
          Object.defineProperty(Xe.prototype, W, {
            get: function() {
              fe("%s(...) is deprecated in plain JavaScript React classes. %s", le[0], le[1]);
            }
          });
        };
        for (var Ze in je)
          je.hasOwnProperty(Ze) && nt(Ze, je[Ze]);
      }
      function tt() {
      }
      tt.prototype = Xe.prototype;
      function et(W, le, Ce) {
        this.props = W, this.context = le, this.refs = Fe, this.updater = Ce || ce;
      }
      var at = et.prototype = new tt();
      at.constructor = et, ye(at, Xe.prototype), at.isPureReactComponent = !0;
      function Yt() {
        var W = {
          current: null
        };
        return Object.seal(W), W;
      }
      var Un = Array.isArray;
      function pt(W) {
        return Un(W);
      }
      function Ut(W) {
        {
          var le = typeof Symbol == "function" && Symbol.toStringTag, Ce = le && W[Symbol.toStringTag] || W.constructor.name || "Object";
          return Ce;
        }
      }
      function jt(W) {
        try {
          return $t(W), !1;
        } catch {
          return !0;
        }
      }
      function $t(W) {
        return "" + W;
      }
      function yn(W) {
        if (jt(W))
          return ie("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ut(W)), $t(W);
      }
      function hi(W, le, Ce) {
        var Pe = W.displayName;
        if (Pe)
          return Pe;
        var He = le.displayName || le.name || "";
        return He !== "" ? Ce + "(" + He + ")" : Ce;
      }
      function Nr(W) {
        return W.displayName || "Context";
      }
      function fi(W) {
        if (W == null)
          return null;
        if (typeof W.tag == "number" && ie("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof W == "function")
          return W.displayName || W.name || null;
        if (typeof W == "string")
          return W;
        switch (W) {
          case s:
            return "Fragment";
          case i:
            return "Portal";
          case l:
            return "Profiler";
          case o:
            return "StrictMode";
          case m:
            return "Suspense";
          case v:
            return "SuspenseList";
        }
        if (typeof W == "object")
          switch (W.$$typeof) {
            case d:
              var le = W;
              return Nr(le) + ".Consumer";
            case u:
              var Ce = W;
              return Nr(Ce._context) + ".Provider";
            case f:
              return hi(W, W.render, "ForwardRef");
            case S:
              var Pe = W.displayName || null;
              return Pe !== null ? Pe : fi(W.type) || "Memo";
            case w: {
              var He = W, yt = He._payload, Qe = He._init;
              try {
                return fi(Qe(yt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var oi = Object.prototype.hasOwnProperty, es = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Di, Ss, wi;
      wi = {};
      function ts(W) {
        if (oi.call(W, "ref")) {
          var le = Object.getOwnPropertyDescriptor(W, "ref").get;
          if (le && le.isReactWarning)
            return !1;
        }
        return W.ref !== void 0;
      }
      function On(W) {
        if (oi.call(W, "key")) {
          var le = Object.getOwnPropertyDescriptor(W, "key").get;
          if (le && le.isReactWarning)
            return !1;
        }
        return W.key !== void 0;
      }
      function Kr(W, le) {
        var Ce = function() {
          Di || (Di = !0, ie("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        Ce.isReactWarning = !0, Object.defineProperty(W, "key", {
          get: Ce,
          configurable: !0
        });
      }
      function ns(W, le) {
        var Ce = function() {
          Ss || (Ss = !0, ie("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        Ce.isReactWarning = !0, Object.defineProperty(W, "ref", {
          get: Ce,
          configurable: !0
        });
      }
      function vr(W) {
        if (typeof W.ref == "string" && U.current && W.__self && U.current.stateNode !== W.__self) {
          var le = fi(U.current.type);
          wi[le] || (ie('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', le, W.ref), wi[le] = !0);
        }
      }
      var Je = function(W, le, Ce, Pe, He, yt, Qe) {
        var Ct = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: W,
          key: le,
          ref: Ce,
          props: Qe,
          // Record the component responsible for creating this element.
          _owner: yt
        };
        return Ct._store = {}, Object.defineProperty(Ct._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Ct, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Pe
        }), Object.defineProperty(Ct, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: He
        }), Object.freeze && (Object.freeze(Ct.props), Object.freeze(Ct)), Ct;
      };
      function It(W, le, Ce) {
        var Pe, He = {}, yt = null, Qe = null, Ct = null, sn = null;
        if (le != null) {
          ts(le) && (Qe = le.ref, vr(le)), On(le) && (yn(le.key), yt = "" + le.key), Ct = le.__self === void 0 ? null : le.__self, sn = le.__source === void 0 ? null : le.__source;
          for (Pe in le)
            oi.call(le, Pe) && !es.hasOwnProperty(Pe) && (He[Pe] = le[Pe]);
        }
        var En = arguments.length - 2;
        if (En === 1)
          He.children = Ce;
        else if (En > 1) {
          for (var er = Array(En), Wn = 0; Wn < En; Wn++)
            er[Wn] = arguments[Wn + 2];
          Object.freeze && Object.freeze(er), He.children = er;
        }
        if (W && W.defaultProps) {
          var Er = W.defaultProps;
          for (Pe in Er)
            He[Pe] === void 0 && (He[Pe] = Er[Pe]);
        }
        if (yt || Qe) {
          var Ir = typeof W == "function" ? W.displayName || W.name || "Unknown" : W;
          yt && Kr(He, Ir), Qe && ns(He, Ir);
        }
        return Je(W, yt, Qe, Ct, sn, U.current, He);
      }
      function hn(W, le) {
        var Ce = Je(W.type, le, W.ref, W._self, W._source, W._owner, W.props);
        return Ce;
      }
      function Bn(W, le, Ce) {
        if (W == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + W + ".");
        var Pe, He = ye({}, W.props), yt = W.key, Qe = W.ref, Ct = W._self, sn = W._source, En = W._owner;
        if (le != null) {
          ts(le) && (Qe = le.ref, En = U.current), On(le) && (yn(le.key), yt = "" + le.key);
          var er;
          W.type && W.type.defaultProps && (er = W.type.defaultProps);
          for (Pe in le)
            oi.call(le, Pe) && !es.hasOwnProperty(Pe) && (le[Pe] === void 0 && er !== void 0 ? He[Pe] = er[Pe] : He[Pe] = le[Pe]);
        }
        var Wn = arguments.length - 2;
        if (Wn === 1)
          He.children = Ce;
        else if (Wn > 1) {
          for (var Er = Array(Wn), Ir = 0; Ir < Wn; Ir++)
            Er[Ir] = arguments[Ir + 2];
          He.children = Er;
        }
        return Je(W.type, yt, Qe, Ct, sn, En, He);
      }
      function Ln(W) {
        return typeof W == "object" && W !== null && W.$$typeof === r;
      }
      var Yr = ".", kr = ":";
      function rs(W) {
        var le = /[=:]/g, Ce = {
          "=": "=0",
          ":": "=2"
        }, Pe = W.replace(le, function(He) {
          return Ce[He];
        });
        return "$" + Pe;
      }
      var wn = !1, is = /\/+/g;
      function Zn(W) {
        return W.replace(is, "$&/");
      }
      function Qn(W, le) {
        return typeof W == "object" && W !== null && W.key != null ? (yn(W.key), rs("" + W.key)) : le.toString(36);
      }
      function so(W, le, Ce, Pe, He) {
        var yt = typeof W;
        (yt === "undefined" || yt === "boolean") && (W = null);
        var Qe = !1;
        if (W === null)
          Qe = !0;
        else
          switch (yt) {
            case "string":
            case "number":
              Qe = !0;
              break;
            case "object":
              switch (W.$$typeof) {
                case r:
                case i:
                  Qe = !0;
              }
          }
        if (Qe) {
          var Ct = W, sn = He(Ct), En = Pe === "" ? Yr + Qn(Ct, 0) : Pe;
          if (pt(sn)) {
            var er = "";
            En != null && (er = Zn(En) + "/"), so(sn, le, er, "", function(bw) {
              return bw;
            });
          } else sn != null && (Ln(sn) && (sn.key && (!Ct || Ct.key !== sn.key) && yn(sn.key), sn = hn(
            sn,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            Ce + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (sn.key && (!Ct || Ct.key !== sn.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              Zn("" + sn.key) + "/"
            ) : "") + En
          )), le.push(sn));
          return 1;
        }
        var Wn, Er, Ir = 0, Pn = Pe === "" ? Yr : Pe + kr;
        if (pt(W))
          for (var gu = 0; gu < W.length; gu++)
            Wn = W[gu], Er = Pn + Qn(Wn, gu), Ir += so(Wn, le, Ce, Er, He);
        else {
          var Op = R(W);
          if (typeof Op == "function") {
            var zm = W;
            Op === zm.entries && (wn || fe("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), wn = !0);
            for (var Sw = Op.call(zm), Gl, Um = 0; !(Gl = Sw.next()).done; )
              Wn = Gl.value, Er = Pn + Qn(Wn, Um++), Ir += so(Wn, le, Ce, Er, He);
          } else if (yt === "object") {
            var Bm = String(W);
            throw new Error("Objects are not valid as a React child (found: " + (Bm === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : Bm) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Ir;
      }
      function ss(W, le, Ce) {
        if (W == null)
          return W;
        var Pe = [], He = 0;
        return so(W, Pe, "", "", function(yt) {
          return le.call(Ce, yt, He++);
        }), Pe;
      }
      function Za(W) {
        var le = 0;
        return ss(W, function() {
          le++;
        }), le;
      }
      function Hl(W, le, Ce) {
        ss(W, function() {
          le.apply(this, arguments);
        }, Ce);
      }
      function Ec(W) {
        return ss(W, function(le) {
          return le;
        }) || [];
      }
      function oo(W) {
        if (!Ln(W))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return W;
      }
      function _c(W) {
        var le = {
          $$typeof: d,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: W,
          _currentValue2: W,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        le.Provider = {
          $$typeof: u,
          _context: le
        };
        var Ce = !1, Pe = !1, He = !1;
        {
          var yt = {
            $$typeof: d,
            _context: le
          };
          Object.defineProperties(yt, {
            Provider: {
              get: function() {
                return Pe || (Pe = !0, ie("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), le.Provider;
              },
              set: function(Qe) {
                le.Provider = Qe;
              }
            },
            _currentValue: {
              get: function() {
                return le._currentValue;
              },
              set: function(Qe) {
                le._currentValue = Qe;
              }
            },
            _currentValue2: {
              get: function() {
                return le._currentValue2;
              },
              set: function(Qe) {
                le._currentValue2 = Qe;
              }
            },
            _threadCount: {
              get: function() {
                return le._threadCount;
              },
              set: function(Qe) {
                le._threadCount = Qe;
              }
            },
            Consumer: {
              get: function() {
                return Ce || (Ce = !0, ie("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), le.Consumer;
              }
            },
            displayName: {
              get: function() {
                return le.displayName;
              },
              set: function(Qe) {
                He || (fe("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Qe), He = !0);
              }
            }
          }), le.Consumer = yt;
        }
        return le._currentRenderer = null, le._currentRenderer2 = null, le;
      }
      var ao = -1, Qa = 0, lo = 1, xa = 2;
      function os(W) {
        if (W._status === ao) {
          var le = W._result, Ce = le();
          if (Ce.then(function(yt) {
            if (W._status === Qa || W._status === ao) {
              var Qe = W;
              Qe._status = lo, Qe._result = yt;
            }
          }, function(yt) {
            if (W._status === Qa || W._status === ao) {
              var Qe = W;
              Qe._status = xa, Qe._result = yt;
            }
          }), W._status === ao) {
            var Pe = W;
            Pe._status = Qa, Pe._result = Ce;
          }
        }
        if (W._status === lo) {
          var He = W._result;
          return He === void 0 && ie(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, He), "default" in He || ie(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, He), He.default;
        } else
          throw W._result;
      }
      function bs(W) {
        var le = {
          // We use these fields to store the result.
          _status: ao,
          _result: W
        }, Ce = {
          $$typeof: w,
          _payload: le,
          _init: os
        };
        {
          var Pe, He;
          Object.defineProperties(Ce, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Pe;
              },
              set: function(yt) {
                ie("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Pe = yt, Object.defineProperty(Ce, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return He;
              },
              set: function(yt) {
                ie("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), He = yt, Object.defineProperty(Ce, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return Ce;
      }
      function as(W) {
        W != null && W.$$typeof === S ? ie("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof W != "function" ? ie("forwardRef requires a render function but was given %s.", W === null ? "null" : typeof W) : W.length !== 0 && W.length !== 2 && ie("forwardRef render functions accept exactly two parameters: props and ref. %s", W.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), W != null && (W.defaultProps != null || W.propTypes != null) && ie("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var le = {
          $$typeof: f,
          render: W
        };
        {
          var Ce;
          Object.defineProperty(le, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ce;
            },
            set: function(Pe) {
              Ce = Pe, !W.name && !W.displayName && (W.displayName = Pe);
            }
          });
        }
        return le;
      }
      var Ja;
      Ja = Symbol.for("react.module.reference");
      function de(W) {
        return !!(typeof W == "string" || typeof W == "function" || W === s || W === l || Z || W === o || W === m || W === v || K || W === E || X || te || ne || typeof W == "object" && W !== null && (W.$$typeof === w || W.$$typeof === S || W.$$typeof === u || W.$$typeof === d || W.$$typeof === f || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        W.$$typeof === Ja || W.getModuleId !== void 0));
      }
      function Be(W, le) {
        de(W) || ie("memo: The first argument must be a component. Instead received: %s", W === null ? "null" : typeof W);
        var Ce = {
          $$typeof: S,
          type: W,
          compare: le === void 0 ? null : le
        };
        {
          var Pe;
          Object.defineProperty(Ce, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Pe;
            },
            set: function(He) {
              Pe = He, !W.name && !W.displayName && (W.displayName = He);
            }
          });
        }
        return Ce;
      }
      function Ke() {
        var W = M.current;
        return W === null && ie(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), W;
      }
      function Pt(W) {
        var le = Ke();
        if (W._context !== void 0) {
          var Ce = W._context;
          Ce.Consumer === W ? ie("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Ce.Provider === W && ie("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return le.useContext(W);
      }
      function en(W) {
        var le = Ke();
        return le.useState(W);
      }
      function bn(W, le, Ce) {
        var Pe = Ke();
        return Pe.useReducer(W, le, Ce);
      }
      function Bt(W) {
        var le = Ke();
        return le.useRef(W);
      }
      function fn(W, le) {
        var Ce = Ke();
        return Ce.useEffect(W, le);
      }
      function pi(W, le) {
        var Ce = Ke();
        return Ce.useInsertionEffect(W, le);
      }
      function fr(W, le) {
        var Ce = Ke();
        return Ce.useLayoutEffect(W, le);
      }
      function Yn(W, le) {
        var Ce = Ke();
        return Ce.useCallback(W, le);
      }
      function ls(W, le) {
        var Ce = Ke();
        return Ce.useMemo(W, le);
      }
      function el(W, le, Ce) {
        var Pe = Ke();
        return Pe.useImperativeHandle(W, le, Ce);
      }
      function Hn(W, le) {
        {
          var Ce = Ke();
          return Ce.useDebugValue(W, le);
        }
      }
      function Oi() {
        var W = Ke();
        return W.useTransition();
      }
      function xs(W) {
        var le = Ke();
        return le.useDeferredValue(W);
      }
      function on() {
        var W = Ke();
        return W.useId();
      }
      function $o(W, le, Ce) {
        var Pe = Ke();
        return Pe.useSyncExternalStore(W, le, Ce);
      }
      var Tc = 0, co, Pc, Us, Nh, ws, Fh, $h;
      function du() {
      }
      du.__reactDisabledLog = !0;
      function md() {
        {
          if (Tc === 0) {
            co = console.log, Pc = console.info, Us = console.warn, Nh = console.error, ws = console.group, Fh = console.groupCollapsed, $h = console.groupEnd;
            var W = {
              configurable: !0,
              enumerable: !0,
              value: du,
              writable: !0
            };
            Object.defineProperties(console, {
              info: W,
              log: W,
              warn: W,
              error: W,
              group: W,
              groupCollapsed: W,
              groupEnd: W
            });
          }
          Tc++;
        }
      }
      function zo() {
        {
          if (Tc--, Tc === 0) {
            var W = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ye({}, W, {
                value: co
              }),
              info: ye({}, W, {
                value: Pc
              }),
              warn: ye({}, W, {
                value: Us
              }),
              error: ye({}, W, {
                value: Nh
              }),
              group: ye({}, W, {
                value: ws
              }),
              groupCollapsed: ye({}, W, {
                value: Fh
              }),
              groupEnd: ye({}, W, {
                value: $h
              })
            });
          }
          Tc < 0 && ie("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Uo = oe.ReactCurrentDispatcher, cs;
      function Ac(W, le, Ce) {
        {
          if (cs === void 0)
            try {
              throw Error();
            } catch (He) {
              var Pe = He.stack.trim().match(/\n( *(at )?)/);
              cs = Pe && Pe[1] || "";
            }
          return `
` + cs + W;
        }
      }
      var kc = !1, Ic;
      {
        var vd = typeof WeakMap == "function" ? WeakMap : Map;
        Ic = new vd();
      }
      function hu(W, le) {
        if (!W || kc)
          return "";
        {
          var Ce = Ic.get(W);
          if (Ce !== void 0)
            return Ce;
        }
        var Pe;
        kc = !0;
        var He = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var yt;
        yt = Uo.current, Uo.current = null, md();
        try {
          if (le) {
            var Qe = function() {
              throw Error();
            };
            if (Object.defineProperty(Qe.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Qe, []);
              } catch (Pn) {
                Pe = Pn;
              }
              Reflect.construct(W, [], Qe);
            } else {
              try {
                Qe.call();
              } catch (Pn) {
                Pe = Pn;
              }
              W.call(Qe.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Pn) {
              Pe = Pn;
            }
            W();
          }
        } catch (Pn) {
          if (Pn && Pe && typeof Pn.stack == "string") {
            for (var Ct = Pn.stack.split(`
`), sn = Pe.stack.split(`
`), En = Ct.length - 1, er = sn.length - 1; En >= 1 && er >= 0 && Ct[En] !== sn[er]; )
              er--;
            for (; En >= 1 && er >= 0; En--, er--)
              if (Ct[En] !== sn[er]) {
                if (En !== 1 || er !== 1)
                  do
                    if (En--, er--, er < 0 || Ct[En] !== sn[er]) {
                      var Wn = `
` + Ct[En].replace(" at new ", " at ");
                      return W.displayName && Wn.includes("<anonymous>") && (Wn = Wn.replace("<anonymous>", W.displayName)), typeof W == "function" && Ic.set(W, Wn), Wn;
                    }
                  while (En >= 1 && er >= 0);
                break;
              }
          }
        } finally {
          kc = !1, Uo.current = yt, zo(), Error.prepareStackTrace = He;
        }
        var Er = W ? W.displayName || W.name : "", Ir = Er ? Ac(Er) : "";
        return typeof W == "function" && Ic.set(W, Ir), Ir;
      }
      function Vl(W, le, Ce) {
        return hu(W, !1);
      }
      function $m(W) {
        var le = W.prototype;
        return !!(le && le.isReactComponent);
      }
      function wa(W, le, Ce) {
        if (W == null)
          return "";
        if (typeof W == "function")
          return hu(W, $m(W));
        if (typeof W == "string")
          return Ac(W);
        switch (W) {
          case m:
            return Ac("Suspense");
          case v:
            return Ac("SuspenseList");
        }
        if (typeof W == "object")
          switch (W.$$typeof) {
            case f:
              return Vl(W.render);
            case S:
              return wa(W.type, le, Ce);
            case w: {
              var Pe = W, He = Pe._payload, yt = Pe._init;
              try {
                return wa(yt(He), le, Ce);
              } catch {
              }
            }
          }
        return "";
      }
      var Cn = {}, Ca = oe.ReactDebugCurrentFrame;
      function fu(W) {
        if (W) {
          var le = W._owner, Ce = wa(W.type, W._source, le ? le.type : null);
          Ca.setExtraStackFrame(Ce);
        } else
          Ca.setExtraStackFrame(null);
      }
      function yd(W, le, Ce, Pe, He) {
        {
          var yt = Function.call.bind(oi);
          for (var Qe in W)
            if (yt(W, Qe)) {
              var Ct = void 0;
              try {
                if (typeof W[Qe] != "function") {
                  var sn = Error((Pe || "React class") + ": " + Ce + " type `" + Qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof W[Qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw sn.name = "Invariant Violation", sn;
                }
                Ct = W[Qe](le, Qe, Pe, Ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (En) {
                Ct = En;
              }
              Ct && !(Ct instanceof Error) && (fu(He), ie("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Pe || "React class", Ce, Qe, typeof Ct), fu(null)), Ct instanceof Error && !(Ct.message in Cn) && (Cn[Ct.message] = !0, fu(He), ie("Failed %s type: %s", Ce, Ct.message), fu(null));
            }
        }
      }
      function ln(W) {
        if (W) {
          var le = W._owner, Ce = wa(W.type, W._source, le ? le.type : null);
          G(Ce);
        } else
          G(null);
      }
      var Sd;
      Sd = !1;
      function bd() {
        if (U.current) {
          var W = fi(U.current.type);
          if (W)
            return `

Check the render method of \`` + W + "`.";
        }
        return "";
      }
      function tn(W) {
        if (W !== void 0) {
          var le = W.fileName.replace(/^.*[\\\/]/, ""), Ce = W.lineNumber;
          return `

Check your code at ` + le + ":" + Ce + ".";
        }
        return "";
      }
      function pu(W) {
        return W != null ? tn(W.__source) : "";
      }
      var Fr = {};
      function gi(W) {
        var le = bd();
        if (!le) {
          var Ce = typeof W == "string" ? W : W.displayName || W.name;
          Ce && (le = `

Check the top-level render call using <` + Ce + ">.");
        }
        return le;
      }
      function us(W, le) {
        if (!(!W._store || W._store.validated || W.key != null)) {
          W._store.validated = !0;
          var Ce = gi(le);
          if (!Fr[Ce]) {
            Fr[Ce] = !0;
            var Pe = "";
            W && W._owner && W._owner !== U.current && (Pe = " It was passed a child from " + fi(W._owner.type) + "."), ln(W), ie('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ce, Pe), ln(null);
          }
        }
      }
      function Rc(W, le) {
        if (typeof W == "object") {
          if (pt(W))
            for (var Ce = 0; Ce < W.length; Ce++) {
              var Pe = W[Ce];
              Ln(Pe) && us(Pe, le);
            }
          else if (Ln(W))
            W._store && (W._store.validated = !0);
          else if (W) {
            var He = R(W);
            if (typeof He == "function" && He !== W.entries)
              for (var yt = He.call(W), Qe; !(Qe = yt.next()).done; )
                Ln(Qe.value) && us(Qe.value, le);
          }
        }
      }
      function Cr(W) {
        {
          var le = W.type;
          if (le == null || typeof le == "string")
            return;
          var Ce;
          if (typeof le == "function")
            Ce = le.propTypes;
          else if (typeof le == "object" && (le.$$typeof === f || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          le.$$typeof === S))
            Ce = le.propTypes;
          else
            return;
          if (Ce) {
            var Pe = fi(le);
            yd(Ce, W.props, "prop", Pe, W);
          } else if (le.PropTypes !== void 0 && !Sd) {
            Sd = !0;
            var He = fi(le);
            ie("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", He || "Unknown");
          }
          typeof le.getDefaultProps == "function" && !le.getDefaultProps.isReactClassApproved && ie("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Jn(W) {
        {
          for (var le = Object.keys(W.props), Ce = 0; Ce < le.length; Ce++) {
            var Pe = le[Ce];
            if (Pe !== "children" && Pe !== "key") {
              ln(W), ie("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Pe), ln(null);
              break;
            }
          }
          W.ref !== null && (ln(W), ie("Invalid attribute `ref` supplied to `React.Fragment`."), ln(null));
        }
      }
      function xd(W, le, Ce) {
        var Pe = de(W);
        if (!Pe) {
          var He = "";
          (W === void 0 || typeof W == "object" && W !== null && Object.keys(W).length === 0) && (He += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var yt = pu(le);
          yt ? He += yt : He += bd();
          var Qe;
          W === null ? Qe = "null" : pt(W) ? Qe = "array" : W !== void 0 && W.$$typeof === r ? (Qe = "<" + (fi(W.type) || "Unknown") + " />", He = " Did you accidentally export a JSX literal instead of a component?") : Qe = typeof W, ie("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Qe, He);
        }
        var Ct = It.apply(this, arguments);
        if (Ct == null)
          return Ct;
        if (Pe)
          for (var sn = 2; sn < arguments.length; sn++)
            Rc(arguments[sn], W);
        return W === s ? Jn(Ct) : Cr(Ct), Ct;
      }
      var Bs = !1;
      function Ci(W) {
        var le = xd.bind(null, W);
        return le.type = W, Bs || (Bs = !0, fe("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(le, "type", {
          enumerable: !1,
          get: function() {
            return fe("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: W
            }), W;
          }
        }), le;
      }
      function Ea(W, le, Ce) {
        for (var Pe = Bn.apply(this, arguments), He = 2; He < arguments.length; He++)
          Rc(arguments[He], Pe.type);
        return Cr(Pe), Pe;
      }
      function zh(W, le) {
        var Ce = j.transition;
        j.transition = {};
        var Pe = j.transition;
        j.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          W();
        } finally {
          if (j.transition = Ce, Ce === null && Pe._updatedFibers) {
            var He = Pe._updatedFibers.size;
            He > 10 && fe("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Pe._updatedFibers.clear();
          }
        }
      }
      var uo = !1, Wl = null;
      function Dp(W) {
        if (Wl === null)
          try {
            var le = ("require" + Math.random()).slice(0, 7), Ce = n && n[le];
            Wl = Ce.call(n, "timers").setImmediate;
          } catch {
            Wl = function(He) {
              uo === !1 && (uo = !0, typeof MessageChannel > "u" && ie("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var yt = new MessageChannel();
              yt.port1.onmessage = He, yt.port2.postMessage(void 0);
            };
          }
        return Wl(W);
      }
      var Bo = 0, Mc = !1;
      function se(W) {
        {
          var le = Bo;
          Bo++, $.current === null && ($.current = []);
          var Ce = $.isBatchingLegacy, Pe;
          try {
            if ($.isBatchingLegacy = !0, Pe = W(), !Ce && $.didScheduleLegacyUpdate) {
              var He = $.current;
              He !== null && ($.didScheduleLegacyUpdate = !1, Vn(He));
            }
          } catch (Er) {
            throw ve(le), Er;
          } finally {
            $.isBatchingLegacy = Ce;
          }
          if (Pe !== null && typeof Pe == "object" && typeof Pe.then == "function") {
            var yt = Pe, Qe = !1, Ct = {
              then: function(Er, Ir) {
                Qe = !0, yt.then(function(Pn) {
                  ve(le), Bo === 0 ? $e(Pn, Er, Ir) : Er(Pn);
                }, function(Pn) {
                  ve(le), Ir(Pn);
                });
              }
            };
            return !Mc && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Qe || (Mc = !0, ie("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Ct;
          } else {
            var sn = Pe;
            if (ve(le), Bo === 0) {
              var En = $.current;
              En !== null && (Vn(En), $.current = null);
              var er = {
                then: function(Er, Ir) {
                  $.current === null ? ($.current = [], $e(sn, Er, Ir)) : Er(sn);
                }
              };
              return er;
            } else {
              var Wn = {
                then: function(Er, Ir) {
                  Er(sn);
                }
              };
              return Wn;
            }
          }
        }
      }
      function ve(W) {
        W !== Bo - 1 && ie("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Bo = W;
      }
      function $e(W, le, Ce) {
        {
          var Pe = $.current;
          if (Pe !== null)
            try {
              Vn(Pe), Dp(function() {
                Pe.length === 0 ? ($.current = null, le(W)) : $e(W, le, Ce);
              });
            } catch (He) {
              Ce(He);
            }
          else
            le(W);
        }
      }
      var st = !1;
      function Vn(W) {
        if (!st) {
          st = !0;
          var le = 0;
          try {
            for (; le < W.length; le++) {
              var Ce = W[le];
              do
                Ce = Ce(!0);
              while (Ce !== null);
            }
            W.length = 0;
          } catch (Pe) {
            throw W = W.slice(le + 1), Pe;
          } finally {
            st = !1;
          }
        }
      }
      var Zt = xd, pr = Ea, Xr = Ci, gr = {
        map: ss,
        forEach: Hl,
        count: Za,
        toArray: Ec,
        only: oo
      };
      t.Children = gr, t.Component = Xe, t.Fragment = s, t.Profiler = l, t.PureComponent = et, t.StrictMode = o, t.Suspense = m, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oe, t.act = se, t.cloneElement = pr, t.createContext = _c, t.createElement = Zt, t.createFactory = Xr, t.createRef = Yt, t.forwardRef = as, t.isValidElement = Ln, t.lazy = bs, t.memo = Be, t.startTransition = zh, t.unstable_act = se, t.useCallback = Yn, t.useContext = Pt, t.useDebugValue = Hn, t.useDeferredValue = xs, t.useEffect = fn, t.useId = on, t.useImperativeHandle = el, t.useInsertionEffect = pi, t.useLayoutEffect = fr, t.useMemo = ls, t.useReducer = bn, t.useRef = Bt, t.useState = en, t.useSyncExternalStore = $o, t.useTransition = Oi, t.version = e, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(WE, WE.exports)), WE.exports;
}
process.env.NODE_ENV === "production" ? HF.exports = Gae() : HF.exports = Kae();
var D = HF.exports;
const Gn = /* @__PURE__ */ Ep(D), Yae = /* @__PURE__ */ Wae({
  __proto__: null,
  default: Gn
}, [D]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HH;
function Xae() {
  if (HH) return xE;
  HH = 1;
  var n = D, t = Symbol.for("react.element"), e = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, d) {
    var f, m = {}, v = null, S = null;
    d !== void 0 && (v = "" + d), u.key !== void 0 && (v = "" + u.key), u.ref !== void 0 && (S = u.ref);
    for (f in u) r.call(u, f) && !s.hasOwnProperty(f) && (m[f] = u[f]);
    if (l && l.defaultProps) for (f in u = l.defaultProps, u) m[f] === void 0 && (m[f] = u[f]);
    return { $$typeof: t, type: l, key: v, ref: S, props: m, _owner: i.current };
  }
  return xE.Fragment = e, xE.jsx = o, xE.jsxs = o, xE;
}
var wE = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VH;
function qae() {
  return VH || (VH = 1, process.env.NODE_ENV !== "production" && function() {
    var n = D, t = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), S = Symbol.for("react.offscreen"), w = Symbol.iterator, E = "@@iterator";
    function A(de) {
      if (de === null || typeof de != "object")
        return null;
      var Be = w && de[w] || de[E];
      return typeof Be == "function" ? Be : null;
    }
    var P = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function R(de) {
      {
        for (var Be = arguments.length, Ke = new Array(Be > 1 ? Be - 1 : 0), Pt = 1; Pt < Be; Pt++)
          Ke[Pt - 1] = arguments[Pt];
        M("error", de, Ke);
      }
    }
    function M(de, Be, Ke) {
      {
        var Pt = P.ReactDebugCurrentFrame, en = Pt.getStackAddendum();
        en !== "" && (Be += "%s", Ke = Ke.concat([en]));
        var bn = Ke.map(function(Bt) {
          return String(Bt);
        });
        bn.unshift("Warning: " + Be), Function.prototype.apply.call(console[de], console, bn);
      }
    }
    var j = !1, $ = !1, U = !1, F = !1, B = !1, G;
    G = Symbol.for("react.module.reference");
    function X(de) {
      return !!(typeof de == "string" || typeof de == "function" || de === r || de === s || B || de === i || de === d || de === f || F || de === S || j || $ || U || typeof de == "object" && de !== null && (de.$$typeof === v || de.$$typeof === m || de.$$typeof === o || de.$$typeof === l || de.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      de.$$typeof === G || de.getModuleId !== void 0));
    }
    function te(de, Be, Ke) {
      var Pt = de.displayName;
      if (Pt)
        return Pt;
      var en = Be.displayName || Be.name || "";
      return en !== "" ? Ke + "(" + en + ")" : Ke;
    }
    function ne(de) {
      return de.displayName || "Context";
    }
    function K(de) {
      if (de == null)
        return null;
      if (typeof de.tag == "number" && R("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof de == "function")
        return de.displayName || de.name || null;
      if (typeof de == "string")
        return de;
      switch (de) {
        case r:
          return "Fragment";
        case e:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case d:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof de == "object")
        switch (de.$$typeof) {
          case l:
            var Be = de;
            return ne(Be) + ".Consumer";
          case o:
            var Ke = de;
            return ne(Ke._context) + ".Provider";
          case u:
            return te(de, de.render, "ForwardRef");
          case m:
            var Pt = de.displayName || null;
            return Pt !== null ? Pt : K(de.type) || "Memo";
          case v: {
            var en = de, bn = en._payload, Bt = en._init;
            try {
              return K(Bt(bn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Z = Object.assign, oe = 0, fe, ie, ue, Se, ke, ce, ye;
    function Fe() {
    }
    Fe.__reactDisabledLog = !0;
    function Xe() {
      {
        if (oe === 0) {
          fe = console.log, ie = console.info, ue = console.warn, Se = console.error, ke = console.group, ce = console.groupCollapsed, ye = console.groupEnd;
          var de = {
            configurable: !0,
            enumerable: !0,
            value: Fe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: de,
            log: de,
            warn: de,
            error: de,
            group: de,
            groupCollapsed: de,
            groupEnd: de
          });
        }
        oe++;
      }
    }
    function je() {
      {
        if (oe--, oe === 0) {
          var de = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Z({}, de, {
              value: fe
            }),
            info: Z({}, de, {
              value: ie
            }),
            warn: Z({}, de, {
              value: ue
            }),
            error: Z({}, de, {
              value: Se
            }),
            group: Z({}, de, {
              value: ke
            }),
            groupCollapsed: Z({}, de, {
              value: ce
            }),
            groupEnd: Z({}, de, {
              value: ye
            })
          });
        }
        oe < 0 && R("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var nt = P.ReactCurrentDispatcher, Ze;
    function tt(de, Be, Ke) {
      {
        if (Ze === void 0)
          try {
            throw Error();
          } catch (en) {
            var Pt = en.stack.trim().match(/\n( *(at )?)/);
            Ze = Pt && Pt[1] || "";
          }
        return `
` + Ze + de;
      }
    }
    var et = !1, at;
    {
      var Yt = typeof WeakMap == "function" ? WeakMap : Map;
      at = new Yt();
    }
    function Un(de, Be) {
      if (!de || et)
        return "";
      {
        var Ke = at.get(de);
        if (Ke !== void 0)
          return Ke;
      }
      var Pt;
      et = !0;
      var en = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var bn;
      bn = nt.current, nt.current = null, Xe();
      try {
        if (Be) {
          var Bt = function() {
            throw Error();
          };
          if (Object.defineProperty(Bt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Bt, []);
            } catch (Oi) {
              Pt = Oi;
            }
            Reflect.construct(de, [], Bt);
          } else {
            try {
              Bt.call();
            } catch (Oi) {
              Pt = Oi;
            }
            de.call(Bt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Oi) {
            Pt = Oi;
          }
          de();
        }
      } catch (Oi) {
        if (Oi && Pt && typeof Oi.stack == "string") {
          for (var fn = Oi.stack.split(`
`), pi = Pt.stack.split(`
`), fr = fn.length - 1, Yn = pi.length - 1; fr >= 1 && Yn >= 0 && fn[fr] !== pi[Yn]; )
            Yn--;
          for (; fr >= 1 && Yn >= 0; fr--, Yn--)
            if (fn[fr] !== pi[Yn]) {
              if (fr !== 1 || Yn !== 1)
                do
                  if (fr--, Yn--, Yn < 0 || fn[fr] !== pi[Yn]) {
                    var ls = `
` + fn[fr].replace(" at new ", " at ");
                    return de.displayName && ls.includes("<anonymous>") && (ls = ls.replace("<anonymous>", de.displayName)), typeof de == "function" && at.set(de, ls), ls;
                  }
                while (fr >= 1 && Yn >= 0);
              break;
            }
        }
      } finally {
        et = !1, nt.current = bn, je(), Error.prepareStackTrace = en;
      }
      var el = de ? de.displayName || de.name : "", Hn = el ? tt(el) : "";
      return typeof de == "function" && at.set(de, Hn), Hn;
    }
    function pt(de, Be, Ke) {
      return Un(de, !1);
    }
    function Ut(de) {
      var Be = de.prototype;
      return !!(Be && Be.isReactComponent);
    }
    function jt(de, Be, Ke) {
      if (de == null)
        return "";
      if (typeof de == "function")
        return Un(de, Ut(de));
      if (typeof de == "string")
        return tt(de);
      switch (de) {
        case d:
          return tt("Suspense");
        case f:
          return tt("SuspenseList");
      }
      if (typeof de == "object")
        switch (de.$$typeof) {
          case u:
            return pt(de.render);
          case m:
            return jt(de.type, Be, Ke);
          case v: {
            var Pt = de, en = Pt._payload, bn = Pt._init;
            try {
              return jt(bn(en), Be, Ke);
            } catch {
            }
          }
        }
      return "";
    }
    var $t = Object.prototype.hasOwnProperty, yn = {}, hi = P.ReactDebugCurrentFrame;
    function Nr(de) {
      if (de) {
        var Be = de._owner, Ke = jt(de.type, de._source, Be ? Be.type : null);
        hi.setExtraStackFrame(Ke);
      } else
        hi.setExtraStackFrame(null);
    }
    function fi(de, Be, Ke, Pt, en) {
      {
        var bn = Function.call.bind($t);
        for (var Bt in de)
          if (bn(de, Bt)) {
            var fn = void 0;
            try {
              if (typeof de[Bt] != "function") {
                var pi = Error((Pt || "React class") + ": " + Ke + " type `" + Bt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof de[Bt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pi.name = "Invariant Violation", pi;
              }
              fn = de[Bt](Be, Bt, Pt, Ke, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (fr) {
              fn = fr;
            }
            fn && !(fn instanceof Error) && (Nr(en), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Pt || "React class", Ke, Bt, typeof fn), Nr(null)), fn instanceof Error && !(fn.message in yn) && (yn[fn.message] = !0, Nr(en), R("Failed %s type: %s", Ke, fn.message), Nr(null));
          }
      }
    }
    var oi = Array.isArray;
    function es(de) {
      return oi(de);
    }
    function Di(de) {
      {
        var Be = typeof Symbol == "function" && Symbol.toStringTag, Ke = Be && de[Symbol.toStringTag] || de.constructor.name || "Object";
        return Ke;
      }
    }
    function Ss(de) {
      try {
        return wi(de), !1;
      } catch {
        return !0;
      }
    }
    function wi(de) {
      return "" + de;
    }
    function ts(de) {
      if (Ss(de))
        return R("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Di(de)), wi(de);
    }
    var On = P.ReactCurrentOwner, Kr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ns, vr, Je;
    Je = {};
    function It(de) {
      if ($t.call(de, "ref")) {
        var Be = Object.getOwnPropertyDescriptor(de, "ref").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return de.ref !== void 0;
    }
    function hn(de) {
      if ($t.call(de, "key")) {
        var Be = Object.getOwnPropertyDescriptor(de, "key").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return de.key !== void 0;
    }
    function Bn(de, Be) {
      if (typeof de.ref == "string" && On.current && Be && On.current.stateNode !== Be) {
        var Ke = K(On.current.type);
        Je[Ke] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', K(On.current.type), de.ref), Je[Ke] = !0);
      }
    }
    function Ln(de, Be) {
      {
        var Ke = function() {
          ns || (ns = !0, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        Ke.isReactWarning = !0, Object.defineProperty(de, "key", {
          get: Ke,
          configurable: !0
        });
      }
    }
    function Yr(de, Be) {
      {
        var Ke = function() {
          vr || (vr = !0, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        Ke.isReactWarning = !0, Object.defineProperty(de, "ref", {
          get: Ke,
          configurable: !0
        });
      }
    }
    var kr = function(de, Be, Ke, Pt, en, bn, Bt) {
      var fn = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: de,
        key: Be,
        ref: Ke,
        props: Bt,
        // Record the component responsible for creating this element.
        _owner: bn
      };
      return fn._store = {}, Object.defineProperty(fn._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(fn, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Pt
      }), Object.defineProperty(fn, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: en
      }), Object.freeze && (Object.freeze(fn.props), Object.freeze(fn)), fn;
    };
    function rs(de, Be, Ke, Pt, en) {
      {
        var bn, Bt = {}, fn = null, pi = null;
        Ke !== void 0 && (ts(Ke), fn = "" + Ke), hn(Be) && (ts(Be.key), fn = "" + Be.key), It(Be) && (pi = Be.ref, Bn(Be, en));
        for (bn in Be)
          $t.call(Be, bn) && !Kr.hasOwnProperty(bn) && (Bt[bn] = Be[bn]);
        if (de && de.defaultProps) {
          var fr = de.defaultProps;
          for (bn in fr)
            Bt[bn] === void 0 && (Bt[bn] = fr[bn]);
        }
        if (fn || pi) {
          var Yn = typeof de == "function" ? de.displayName || de.name || "Unknown" : de;
          fn && Ln(Bt, Yn), pi && Yr(Bt, Yn);
        }
        return kr(de, fn, pi, en, Pt, On.current, Bt);
      }
    }
    var wn = P.ReactCurrentOwner, is = P.ReactDebugCurrentFrame;
    function Zn(de) {
      if (de) {
        var Be = de._owner, Ke = jt(de.type, de._source, Be ? Be.type : null);
        is.setExtraStackFrame(Ke);
      } else
        is.setExtraStackFrame(null);
    }
    var Qn;
    Qn = !1;
    function so(de) {
      return typeof de == "object" && de !== null && de.$$typeof === t;
    }
    function ss() {
      {
        if (wn.current) {
          var de = K(wn.current.type);
          if (de)
            return `

Check the render method of \`` + de + "`.";
        }
        return "";
      }
    }
    function Za(de) {
      return "";
    }
    var Hl = {};
    function Ec(de) {
      {
        var Be = ss();
        if (!Be) {
          var Ke = typeof de == "string" ? de : de.displayName || de.name;
          Ke && (Be = `

Check the top-level render call using <` + Ke + ">.");
        }
        return Be;
      }
    }
    function oo(de, Be) {
      {
        if (!de._store || de._store.validated || de.key != null)
          return;
        de._store.validated = !0;
        var Ke = Ec(Be);
        if (Hl[Ke])
          return;
        Hl[Ke] = !0;
        var Pt = "";
        de && de._owner && de._owner !== wn.current && (Pt = " It was passed a child from " + K(de._owner.type) + "."), Zn(de), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ke, Pt), Zn(null);
      }
    }
    function _c(de, Be) {
      {
        if (typeof de != "object")
          return;
        if (es(de))
          for (var Ke = 0; Ke < de.length; Ke++) {
            var Pt = de[Ke];
            so(Pt) && oo(Pt, Be);
          }
        else if (so(de))
          de._store && (de._store.validated = !0);
        else if (de) {
          var en = A(de);
          if (typeof en == "function" && en !== de.entries)
            for (var bn = en.call(de), Bt; !(Bt = bn.next()).done; )
              so(Bt.value) && oo(Bt.value, Be);
        }
      }
    }
    function ao(de) {
      {
        var Be = de.type;
        if (Be == null || typeof Be == "string")
          return;
        var Ke;
        if (typeof Be == "function")
          Ke = Be.propTypes;
        else if (typeof Be == "object" && (Be.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Be.$$typeof === m))
          Ke = Be.propTypes;
        else
          return;
        if (Ke) {
          var Pt = K(Be);
          fi(Ke, de.props, "prop", Pt, de);
        } else if (Be.PropTypes !== void 0 && !Qn) {
          Qn = !0;
          var en = K(Be);
          R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", en || "Unknown");
        }
        typeof Be.getDefaultProps == "function" && !Be.getDefaultProps.isReactClassApproved && R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Qa(de) {
      {
        for (var Be = Object.keys(de.props), Ke = 0; Ke < Be.length; Ke++) {
          var Pt = Be[Ke];
          if (Pt !== "children" && Pt !== "key") {
            Zn(de), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Pt), Zn(null);
            break;
          }
        }
        de.ref !== null && (Zn(de), R("Invalid attribute `ref` supplied to `React.Fragment`."), Zn(null));
      }
    }
    var lo = {};
    function xa(de, Be, Ke, Pt, en, bn) {
      {
        var Bt = X(de);
        if (!Bt) {
          var fn = "";
          (de === void 0 || typeof de == "object" && de !== null && Object.keys(de).length === 0) && (fn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pi = Za();
          pi ? fn += pi : fn += ss();
          var fr;
          de === null ? fr = "null" : es(de) ? fr = "array" : de !== void 0 && de.$$typeof === t ? (fr = "<" + (K(de.type) || "Unknown") + " />", fn = " Did you accidentally export a JSX literal instead of a component?") : fr = typeof de, R("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", fr, fn);
        }
        var Yn = rs(de, Be, Ke, en, bn);
        if (Yn == null)
          return Yn;
        if (Bt) {
          var ls = Be.children;
          if (ls !== void 0)
            if (Pt)
              if (es(ls)) {
                for (var el = 0; el < ls.length; el++)
                  _c(ls[el], de);
                Object.freeze && Object.freeze(ls);
              } else
                R("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _c(ls, de);
        }
        if ($t.call(Be, "key")) {
          var Hn = K(de), Oi = Object.keys(Be).filter(function($o) {
            return $o !== "key";
          }), xs = Oi.length > 0 ? "{key: someKey, " + Oi.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!lo[Hn + xs]) {
            var on = Oi.length > 0 ? "{" + Oi.join(": ..., ") + ": ...}" : "{}";
            R(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, xs, Hn, on, Hn), lo[Hn + xs] = !0;
          }
        }
        return de === r ? Qa(Yn) : ao(Yn), Yn;
      }
    }
    function os(de, Be, Ke) {
      return xa(de, Be, Ke, !0);
    }
    function bs(de, Be, Ke) {
      return xa(de, Be, Ke, !1);
    }
    var as = bs, Ja = os;
    wE.Fragment = r, wE.jsx = as, wE.jsxs = Ja;
  }()), wE;
}
process.env.NODE_ENV === "production" ? BF.exports = Xae() : BF.exports = qae();
var y = BF.exports, CE = function(n) {
  return n && n.Math === Math && n;
}, Va = (
  // eslint-disable-next-line es/no-global-this -- safe
  CE(typeof globalThis == "object" && globalThis) || CE(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  CE(typeof self == "object" && self) || CE(typeof ga == "object" && ga) || CE(typeof ga == "object" && ga) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), wz = {}, Wa = function(n) {
  try {
    return !!n();
  } catch {
    return !0;
  }
}, Zae = Wa, km = !Zae(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), Qae = Wa, y2 = !Qae(function() {
  var n = (function() {
  }).bind();
  return typeof n != "function" || n.hasOwnProperty("prototype");
}), Jae = y2, Zk = Function.prototype.call, _p = Jae ? Zk.bind(Zk) : function() {
  return Zk.apply(Zk, arguments);
}, tW = {}, nW = {}.propertyIsEnumerable, rW = Object.getOwnPropertyDescriptor, ele = rW && !nW.call({ 1: 2 }, 1);
tW.f = ele ? function(t) {
  var e = rW(this, t);
  return !!e && e.enumerable;
} : nW;
var iW = function(n, t) {
  return {
    enumerable: !(n & 1),
    configurable: !(n & 2),
    writable: !(n & 4),
    value: t
  };
}, sW = y2, oW = Function.prototype, VF = oW.call, tle = sW && oW.bind.bind(VF, VF), no = sW ? tle : function(n) {
  return function() {
    return VF.apply(n, arguments);
  };
}, aW = no, nle = aW({}.toString), rle = aW("".slice), ow = function(n) {
  return rle(nle(n), 8, -1);
}, ile = no, sle = Wa, ole = ow, Qj = Object, ale = ile("".split), lle = sle(function() {
  return !Qj("z").propertyIsEnumerable(0);
}) ? function(n) {
  return ole(n) === "String" ? ale(n, "") : Qj(n);
} : Qj, S2 = function(n) {
  return n == null;
}, cle = S2, ule = TypeError, aw = function(n) {
  if (cle(n)) throw new ule("Can't call method on " + n);
  return n;
}, dle = lle, hle = aw, b2 = function(n) {
  return dle(hle(n));
}, Jj = typeof document == "object" && document.all, Ga = typeof Jj > "u" && Jj !== void 0 ? function(n) {
  return typeof n == "function" || n === Jj;
} : function(n) {
  return typeof n == "function";
}, fle = Ga, vS = function(n) {
  return typeof n == "object" ? n !== null : fle(n);
}, eN = Va, ple = Ga, gle = function(n) {
  return ple(n) ? n : void 0;
}, x2 = function(n, t) {
  return arguments.length < 2 ? gle(eN[n]) : eN[n] && eN[n][t];
}, mle = no, lW = mle({}.isPrototypeOf), vle = Va, WH = vle.navigator, GH = WH && WH.userAgent, yle = GH ? String(GH) : "", cW = Va, tN = yle, KH = cW.process, YH = cW.Deno, XH = KH && KH.versions || YH && YH.version, qH = XH && XH.v8, rd, tM;
qH && (rd = qH.split("."), tM = rd[0] > 0 && rd[0] < 4 ? 1 : +(rd[0] + rd[1]));
!tM && tN && (rd = tN.match(/Edge\/(\d+)/), (!rd || rd[1] >= 74) && (rd = tN.match(/Chrome\/(\d+)/), rd && (tM = +rd[1])));
var Sle = tM, ZH = Sle, ble = Wa, xle = Va, wle = xle.String, uW = !!Object.getOwnPropertySymbols && !ble(function() {
  var n = Symbol("symbol detection");
  return !wle(n) || !(Object(n) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && ZH && ZH < 41;
}), Cle = uW, dW = Cle && !Symbol.sham && typeof Symbol.iterator == "symbol", Ele = x2, _le = Ga, Tle = lW, Ple = dW, Ale = Object, hW = Ple ? function(n) {
  return typeof n == "symbol";
} : function(n) {
  var t = Ele("Symbol");
  return _le(t) && Tle(t.prototype, Ale(n));
}, kle = String, Ile = function(n) {
  try {
    return kle(n);
  } catch {
    return "Object";
  }
}, Rle = Ga, Mle = Ile, Dle = TypeError, Cz = function(n) {
  if (Rle(n)) return n;
  throw new Dle(Mle(n) + " is not a function");
}, Ole = Cz, Lle = S2, Ez = function(n, t) {
  var e = n[t];
  return Lle(e) ? void 0 : Ole(e);
}, nN = _p, rN = Ga, iN = vS, jle = TypeError, Nle = function(n, t) {
  var e, r;
  if (t === "string" && rN(e = n.toString) && !iN(r = nN(e, n)) || rN(e = n.valueOf) && !iN(r = nN(e, n)) || t !== "string" && rN(e = n.toString) && !iN(r = nN(e, n))) return r;
  throw new jle("Can't convert object to primitive value");
}, fW = { exports: {} }, QH = Va, Fle = Object.defineProperty, _z = function(n, t) {
  try {
    Fle(QH, n, { value: t, configurable: !0, writable: !0 });
  } catch {
    QH[n] = t;
  }
  return t;
}, $le = Va, zle = _z, JH = "__core-js_shared__", e8 = fW.exports = $le[JH] || zle(JH, {});
(e8.versions || (e8.versions = [])).push({
  version: "3.38.0",
  mode: "global",
  copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.38.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var Tz = fW.exports, t8 = Tz, Pz = function(n, t) {
  return t8[n] || (t8[n] = t || {});
}, Ule = aw, Ble = Object, MT = function(n) {
  return Ble(Ule(n));
}, Hle = no, Vle = MT, Wle = Hle({}.hasOwnProperty), Im = Object.hasOwn || function(t, e) {
  return Wle(Vle(t), e);
}, Gle = no, Kle = 0, Yle = Math.random(), Xle = Gle(1 .toString), pW = function(n) {
  return "Symbol(" + (n === void 0 ? "" : n) + ")_" + Xle(++Kle + Yle, 36);
}, qle = Va, Zle = Pz, n8 = Im, Qle = pW, Jle = uW, ece = dW, D0 = qle.Symbol, sN = Zle("wks"), tce = ece ? D0.for || D0 : D0 && D0.withoutSetter || Qle, Tp = function(n) {
  return n8(sN, n) || (sN[n] = Jle && n8(D0, n) ? D0[n] : tce("Symbol." + n)), sN[n];
}, nce = _p, r8 = vS, i8 = hW, rce = Ez, ice = Nle, sce = Tp, oce = TypeError, ace = sce("toPrimitive"), lce = function(n, t) {
  if (!r8(n) || i8(n)) return n;
  var e = rce(n, ace), r;
  if (e) {
    if (t === void 0 && (t = "default"), r = nce(e, n, t), !r8(r) || i8(r)) return r;
    throw new oce("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), ice(n, t);
}, cce = lce, uce = hW, gW = function(n) {
  var t = cce(n, "string");
  return uce(t) ? t : t + "";
}, dce = Va, s8 = vS, WF = dce.document, hce = s8(WF) && s8(WF.createElement), mW = function(n) {
  return hce ? WF.createElement(n) : {};
}, fce = km, pce = Wa, gce = mW, vW = !fce && !pce(function() {
  return Object.defineProperty(gce("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), mce = km, vce = _p, yce = tW, Sce = iW, bce = b2, xce = gW, wce = Im, Cce = vW, o8 = Object.getOwnPropertyDescriptor;
wz.f = mce ? o8 : function(t, e) {
  if (t = bce(t), e = xce(e), Cce) try {
    return o8(t, e);
  } catch {
  }
  if (wce(t, e)) return Sce(!vce(yce.f, t, e), t[e]);
};
var lw = {}, Ece = km, _ce = Wa, yW = Ece && _ce(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), Tce = vS, Pce = String, Ace = TypeError, yS = function(n) {
  if (Tce(n)) return n;
  throw new Ace(Pce(n) + " is not an object");
}, kce = km, Ice = vW, Rce = yW, Qk = yS, a8 = gW, Mce = TypeError, oN = Object.defineProperty, Dce = Object.getOwnPropertyDescriptor, aN = "enumerable", lN = "configurable", cN = "writable";
lw.f = kce ? Rce ? function(t, e, r) {
  if (Qk(t), e = a8(e), Qk(r), typeof t == "function" && e === "prototype" && "value" in r && cN in r && !r[cN]) {
    var i = Dce(t, e);
    i && i[cN] && (t[e] = r.value, r = {
      configurable: lN in r ? r[lN] : i[lN],
      enumerable: aN in r ? r[aN] : i[aN],
      writable: !1
    });
  }
  return oN(t, e, r);
} : oN : function(t, e, r) {
  if (Qk(t), e = a8(e), Qk(r), Ice) try {
    return oN(t, e, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new Mce("Accessors not supported");
  return "value" in r && (t[e] = r.value), t;
};
var Oce = km, Lce = lw, jce = iW, Az = Oce ? function(n, t, e) {
  return Lce.f(n, t, jce(1, e));
} : function(n, t, e) {
  return n[t] = e, n;
}, SW = { exports: {} }, GF = km, Nce = Im, bW = Function.prototype, Fce = GF && Object.getOwnPropertyDescriptor, kz = Nce(bW, "name"), $ce = kz && (function() {
}).name === "something", zce = kz && (!GF || GF && Fce(bW, "name").configurable), Uce = {
  EXISTS: kz,
  PROPER: $ce,
  CONFIGURABLE: zce
}, Bce = no, Hce = Ga, KF = Tz, Vce = Bce(Function.toString);
Hce(KF.inspectSource) || (KF.inspectSource = function(n) {
  return Vce(n);
});
var xW = KF.inspectSource, Wce = Va, Gce = Ga, l8 = Wce.WeakMap, Kce = Gce(l8) && /native code/.test(String(l8)), Yce = Pz, Xce = pW, c8 = Yce("keys"), wW = function(n) {
  return c8[n] || (c8[n] = Xce(n));
}, Iz = {}, qce = Kce, CW = Va, Zce = vS, Qce = Az, uN = Im, dN = Tz, Jce = wW, eue = Iz, u8 = "Object already initialized", YF = CW.TypeError, tue = CW.WeakMap, nM, j1, rM, nue = function(n) {
  return rM(n) ? j1(n) : nM(n, {});
}, rue = function(n) {
  return function(t) {
    var e;
    if (!Zce(t) || (e = j1(t)).type !== n)
      throw new YF("Incompatible receiver, " + n + " required");
    return e;
  };
};
if (qce || dN.state) {
  var Kd = dN.state || (dN.state = new tue());
  Kd.get = Kd.get, Kd.has = Kd.has, Kd.set = Kd.set, nM = function(n, t) {
    if (Kd.has(n)) throw new YF(u8);
    return t.facade = n, Kd.set(n, t), t;
  }, j1 = function(n) {
    return Kd.get(n) || {};
  }, rM = function(n) {
    return Kd.has(n);
  };
} else {
  var f0 = Jce("state");
  eue[f0] = !0, nM = function(n, t) {
    if (uN(n, f0)) throw new YF(u8);
    return t.facade = n, Qce(n, f0, t), t;
  }, j1 = function(n) {
    return uN(n, f0) ? n[f0] : {};
  }, rM = function(n) {
    return uN(n, f0);
  };
}
var EW = {
  set: nM,
  get: j1,
  has: rM,
  enforce: nue,
  getterFor: rue
}, Rz = no, iue = Wa, sue = Ga, Jk = Im, XF = km, oue = Uce.CONFIGURABLE, aue = xW, _W = EW, lue = _W.enforce, cue = _W.get, d8 = String, WI = Object.defineProperty, uue = Rz("".slice), due = Rz("".replace), hue = Rz([].join), fue = XF && !iue(function() {
  return WI(function() {
  }, "length", { value: 8 }).length !== 8;
}), pue = String(String).split("String"), gue = SW.exports = function(n, t, e) {
  uue(d8(t), 0, 7) === "Symbol(" && (t = "[" + due(d8(t), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), e && e.getter && (t = "get " + t), e && e.setter && (t = "set " + t), (!Jk(n, "name") || oue && n.name !== t) && (XF ? WI(n, "name", { value: t, configurable: !0 }) : n.name = t), fue && e && Jk(e, "arity") && n.length !== e.arity && WI(n, "length", { value: e.arity });
  try {
    e && Jk(e, "constructor") && e.constructor ? XF && WI(n, "prototype", { writable: !1 }) : n.prototype && (n.prototype = void 0);
  } catch {
  }
  var r = lue(n);
  return Jk(r, "source") || (r.source = hue(pue, typeof t == "string" ? t : "")), n;
};
Function.prototype.toString = gue(function() {
  return sue(this) && cue(this).source || aue(this);
}, "toString");
var mue = SW.exports, vue = Ga, yue = lw, Sue = mue, bue = _z, TW = function(n, t, e, r) {
  r || (r = {});
  var i = r.enumerable, s = r.name !== void 0 ? r.name : t;
  if (vue(e) && Sue(e, s, r), r.global)
    i ? n[t] = e : bue(t, e);
  else {
    try {
      r.unsafe ? n[t] && (i = !0) : delete n[t];
    } catch {
    }
    i ? n[t] = e : yue.f(n, t, {
      value: e,
      enumerable: !1,
      configurable: !r.nonConfigurable,
      writable: !r.nonWritable
    });
  }
  return n;
}, PW = {}, xue = Math.ceil, wue = Math.floor, Cue = Math.trunc || function(t) {
  var e = +t;
  return (e > 0 ? wue : xue)(e);
}, Eue = Cue, SS = function(n) {
  var t = +n;
  return t !== t || t === 0 ? 0 : Eue(t);
}, _ue = SS, Tue = Math.max, Pue = Math.min, Aue = function(n, t) {
  var e = _ue(n);
  return e < 0 ? Tue(e + t, 0) : Pue(e, t);
}, kue = SS, Iue = Math.min, AW = function(n) {
  var t = kue(n);
  return t > 0 ? Iue(t, 9007199254740991) : 0;
}, Rue = AW, DT = function(n) {
  return Rue(n.length);
}, Mue = b2, Due = Aue, Oue = DT, h8 = function(n) {
  return function(t, e, r) {
    var i = Mue(t), s = Oue(i);
    if (s === 0) return !n && -1;
    var o = Due(r, s), l;
    if (n && e !== e) {
      for (; s > o; )
        if (l = i[o++], l !== l) return !0;
    } else for (; s > o; o++)
      if ((n || o in i) && i[o] === e) return n || o || 0;
    return !n && -1;
  };
}, Lue = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: h8(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: h8(!1)
}, jue = no, hN = Im, Nue = b2, Fue = Lue.indexOf, $ue = Iz, f8 = jue([].push), kW = function(n, t) {
  var e = Nue(n), r = 0, i = [], s;
  for (s in e) !hN($ue, s) && hN(e, s) && f8(i, s);
  for (; t.length > r; ) hN(e, s = t[r++]) && (~Fue(i, s) || f8(i, s));
  return i;
}, Mz = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], zue = kW, Uue = Mz, Bue = Uue.concat("length", "prototype");
PW.f = Object.getOwnPropertyNames || function(t) {
  return zue(t, Bue);
};
var IW = {};
IW.f = Object.getOwnPropertySymbols;
var Hue = x2, Vue = no, Wue = PW, Gue = IW, Kue = yS, Yue = Vue([].concat), Xue = Hue("Reflect", "ownKeys") || function(t) {
  var e = Wue.f(Kue(t)), r = Gue.f;
  return r ? Yue(e, r(t)) : e;
}, p8 = Im, que = Xue, Zue = wz, Que = lw, Jue = function(n, t, e) {
  for (var r = que(t), i = Que.f, s = Zue.f, o = 0; o < r.length; o++) {
    var l = r[o];
    !p8(n, l) && !(e && p8(e, l)) && i(n, l, s(t, l));
  }
}, ede = Wa, tde = Ga, nde = /#|\.prototype\./, OT = function(n, t) {
  var e = ide[rde(n)];
  return e === ode ? !0 : e === sde ? !1 : tde(t) ? ede(t) : !!t;
}, rde = OT.normalize = function(n) {
  return String(n).replace(nde, ".").toLowerCase();
}, ide = OT.data = {}, sde = OT.NATIVE = "N", ode = OT.POLYFILL = "P", ade = OT, eI = Va, lde = wz.f, cde = Az, ude = TW, dde = _z, hde = Jue, fde = ade, cw = function(n, t) {
  var e = n.target, r = n.global, i = n.stat, s, o, l, u, d, f;
  if (r ? o = eI : i ? o = eI[e] || dde(e, {}) : o = eI[e] && eI[e].prototype, o) for (l in t) {
    if (d = t[l], n.dontCallGetSet ? (f = lde(o, l), u = f && f.value) : u = o[l], s = fde(r ? l : e + (i ? "." : "#") + l, n.forced), !s && u !== void 0) {
      if (typeof d == typeof u) continue;
      hde(d, u);
    }
    (n.sham || u && u.sham) && cde(d, "sham", !0), ude(o, l, d, n);
  }
}, RW = {}, pde = kW, gde = Mz, mde = Object.keys || function(t) {
  return pde(t, gde);
}, vde = km, yde = yW, Sde = lw, bde = yS, xde = b2, wde = mde;
RW.f = vde && !yde ? Object.defineProperties : function(t, e) {
  bde(t);
  for (var r = xde(e), i = wde(e), s = i.length, o = 0, l; s > o; ) Sde.f(t, l = i[o++], r[l]);
  return t;
};
var Cde = x2, Ede = Cde("document", "documentElement"), _de = yS, Tde = RW, g8 = Mz, Pde = Iz, Ade = Ede, kde = mW, Ide = wW, m8 = ">", v8 = "<", qF = "prototype", ZF = "script", MW = Ide("IE_PROTO"), fN = function() {
}, DW = function(n) {
  return v8 + ZF + m8 + n + v8 + "/" + ZF + m8;
}, y8 = function(n) {
  n.write(DW("")), n.close();
  var t = n.parentWindow.Object;
  return n = null, t;
}, Rde = function() {
  var n = kde("iframe"), t = "java" + ZF + ":", e;
  return n.style.display = "none", Ade.appendChild(n), n.src = String(t), e = n.contentWindow.document, e.open(), e.write(DW("document.F=Object")), e.close(), e.F;
}, tI, GI = function() {
  try {
    tI = new ActiveXObject("htmlfile");
  } catch {
  }
  GI = typeof document < "u" ? document.domain && tI ? y8(tI) : Rde() : y8(tI);
  for (var n = g8.length; n--; ) delete GI[qF][g8[n]];
  return GI();
};
Pde[MW] = !0;
var OW = Object.create || function(t, e) {
  var r;
  return t !== null ? (fN[qF] = _de(t), r = new fN(), fN[qF] = null, r[MW] = t) : r = GI(), e === void 0 ? r : Tde.f(r, e);
}, Mde = Tp, Dde = OW, Ode = lw.f, QF = Mde("unscopables"), JF = Array.prototype;
JF[QF] === void 0 && Ode(JF, QF, {
  configurable: !0,
  value: Dde(null)
});
var Dz = function(n) {
  JF[QF][n] = !0;
}, Lde = cw, jde = MT, Nde = DT, Fde = SS, $de = Dz;
Lde({ target: "Array", proto: !0 }, {
  at: function(t) {
    var e = jde(this), r = Nde(e), i = Fde(t), s = i >= 0 ? i : r + i;
    return s < 0 || s >= r ? void 0 : e[s];
  }
});
$de("at");
var zde = Va, Ude = no, LT = function(n, t) {
  return Ude(zde[n].prototype[t]);
}, Bde = LT;
Bde("Array", "at");
var Hde = ow, LW = Array.isArray || function(t) {
  return Hde(t) === "Array";
}, Vde = TypeError, Wde = 9007199254740991, Gde = function(n) {
  if (n > Wde) throw Vde("Maximum allowed index exceeded");
  return n;
}, Kde = ow, Yde = no, Xde = function(n) {
  if (Kde(n) === "Function") return Yde(n);
}, S8 = Xde, qde = Cz, Zde = y2, Qde = S8(S8.bind), Jde = function(n, t) {
  return qde(n), t === void 0 ? n : Zde ? Qde(n, t) : function() {
    return n.apply(t, arguments);
  };
}, ehe = LW, the = DT, nhe = Gde, rhe = Jde, jW = function(n, t, e, r, i, s, o, l) {
  for (var u = i, d = 0, f = o ? rhe(o, l) : !1, m, v; d < r; )
    d in e && (m = f ? f(e[d], d, t) : e[d], s > 0 && ehe(m) ? (v = the(m), u = jW(n, t, m, v, u, s - 1) - 1) : (nhe(u + 1), n[u] = m), u++), d++;
  return u;
}, NW = jW, ihe = Tp, she = ihe("toStringTag"), FW = {};
FW[she] = "z";
var ohe = String(FW) === "[object z]", ahe = ohe, lhe = Ga, KI = ow, che = Tp, uhe = che("toStringTag"), dhe = Object, hhe = KI(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", fhe = function(n, t) {
  try {
    return n[t];
  } catch {
  }
}, $W = ahe ? KI : function(n) {
  var t, e, r;
  return n === void 0 ? "Undefined" : n === null ? "Null" : typeof (e = fhe(t = dhe(n), uhe)) == "string" ? e : hhe ? KI(t) : (r = KI(t)) === "Object" && lhe(t.callee) ? "Arguments" : r;
}, phe = no, ghe = Wa, zW = Ga, mhe = $W, vhe = x2, yhe = xW, UW = function() {
}, BW = vhe("Reflect", "construct"), Oz = /^\s*(?:class|function)\b/, She = phe(Oz.exec), bhe = !Oz.test(UW), EE = function(t) {
  if (!zW(t)) return !1;
  try {
    return BW(UW, [], t), !0;
  } catch {
    return !1;
  }
}, HW = function(t) {
  if (!zW(t)) return !1;
  switch (mhe(t)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return bhe || !!She(Oz, yhe(t));
  } catch {
    return !0;
  }
};
HW.sham = !0;
var xhe = !BW || ghe(function() {
  var n;
  return EE(EE.call) || !EE(Object) || !EE(function() {
    n = !0;
  }) || n;
}) ? HW : EE, b8 = LW, whe = xhe, Che = vS, Ehe = Tp, _he = Ehe("species"), x8 = Array, The = function(n) {
  var t;
  return b8(n) && (t = n.constructor, whe(t) && (t === x8 || b8(t.prototype)) ? t = void 0 : Che(t) && (t = t[_he], t === null && (t = void 0))), t === void 0 ? x8 : t;
}, Phe = The, VW = function(n, t) {
  return new (Phe(n))(t === 0 ? 0 : t);
}, Ahe = cw, khe = NW, Ihe = Cz, Rhe = MT, Mhe = DT, Dhe = VW;
Ahe({ target: "Array", proto: !0 }, {
  flatMap: function(t) {
    var e = Rhe(this), r = Mhe(e), i;
    return Ihe(t), i = Dhe(e, 0), i.length = khe(i, e, e, r, 0, 1, t, arguments.length > 1 ? arguments[1] : void 0), i;
  }
});
var Ohe = Dz;
Ohe("flatMap");
var Lhe = LT;
Lhe("Array", "flatMap");
var jhe = cw, Nhe = NW, Fhe = MT, $he = DT, zhe = SS, Uhe = VW;
jhe({ target: "Array", proto: !0 }, {
  flat: function() {
    var t = arguments.length ? arguments[0] : void 0, e = Fhe(this), r = $he(e), i = Uhe(e, 0);
    return i.length = Nhe(i, e, e, r, 0, t === void 0 ? 1 : zhe(t)), i;
  }
});
var Bhe = Dz;
Bhe("flat");
var Hhe = LT;
Hhe("Array", "flat");
var Vhe = $W, Whe = String, jT = function(n) {
  if (Vhe(n) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return Whe(n);
}, Ghe = cw, Khe = no, Yhe = aw, Xhe = SS, qhe = jT, Zhe = Wa, Qhe = Khe("".charAt), Jhe = Zhe(function() {
  return "𠮷".at(-2) !== "\uD842";
});
Ghe({ target: "String", proto: !0, forced: Jhe }, {
  at: function(t) {
    var e = qhe(Yhe(this)), r = e.length, i = Xhe(t), s = i >= 0 ? i : r + i;
    return s < 0 || s >= r ? void 0 : Qhe(e, s);
  }
});
var efe = LT;
efe("String", "at");
var tfe = yS, WW = function() {
  var n = tfe(this), t = "";
  return n.hasIndices && (t += "d"), n.global && (t += "g"), n.ignoreCase && (t += "i"), n.multiline && (t += "m"), n.dotAll && (t += "s"), n.unicode && (t += "u"), n.unicodeSets && (t += "v"), n.sticky && (t += "y"), t;
}, Lz = Wa, nfe = Va, jz = nfe.RegExp, Nz = Lz(function() {
  var n = jz("a", "y");
  return n.lastIndex = 2, n.exec("abcd") !== null;
}), rfe = Nz || Lz(function() {
  return !jz("a", "y").sticky;
}), ife = Nz || Lz(function() {
  var n = jz("^r", "gy");
  return n.lastIndex = 2, n.exec("str") !== null;
}), sfe = {
  BROKEN_CARET: ife,
  MISSED_STICKY: rfe,
  UNSUPPORTED_Y: Nz
}, ofe = Wa, afe = Va, lfe = afe.RegExp, cfe = ofe(function() {
  var n = lfe(".", "s");
  return !(n.dotAll && n.test(`
`) && n.flags === "s");
}), ufe = Wa, dfe = Va, hfe = dfe.RegExp, ffe = ufe(function() {
  var n = hfe("(?<a>b)", "g");
  return n.exec("b").groups.a !== "b" || "b".replace(n, "$<a>c") !== "bc";
}), O0 = _p, w2 = no, pfe = jT, gfe = WW, mfe = sfe, vfe = Pz, yfe = OW, Sfe = EW.get, bfe = cfe, xfe = ffe, wfe = vfe("native-string-replace", String.prototype.replace), iM = RegExp.prototype.exec, e3 = iM, Cfe = w2("".charAt), Efe = w2("".indexOf), _fe = w2("".replace), pN = w2("".slice), t3 = function() {
  var n = /a/, t = /b*/g;
  return O0(iM, n, "a"), O0(iM, t, "a"), n.lastIndex !== 0 || t.lastIndex !== 0;
}(), GW = mfe.BROKEN_CARET, n3 = /()??/.exec("")[1] !== void 0, Tfe = t3 || n3 || GW || bfe || xfe;
Tfe && (e3 = function(t) {
  var e = this, r = Sfe(e), i = pfe(t), s = r.raw, o, l, u, d, f, m, v;
  if (s)
    return s.lastIndex = e.lastIndex, o = O0(e3, s, i), e.lastIndex = s.lastIndex, o;
  var S = r.groups, w = GW && e.sticky, E = O0(gfe, e), A = e.source, P = 0, R = i;
  if (w && (E = _fe(E, "y", ""), Efe(E, "g") === -1 && (E += "g"), R = pN(i, e.lastIndex), e.lastIndex > 0 && (!e.multiline || e.multiline && Cfe(i, e.lastIndex - 1) !== `
`) && (A = "(?: " + A + ")", R = " " + R, P++), l = new RegExp("^(?:" + A + ")", E)), n3 && (l = new RegExp("^" + A + "$(?!\\s)", E)), t3 && (u = e.lastIndex), d = O0(iM, w ? l : e, R), w ? d ? (d.input = pN(d.input, P), d[0] = pN(d[0], P), d.index = e.lastIndex, e.lastIndex += d[0].length) : e.lastIndex = 0 : t3 && d && (e.lastIndex = e.global ? d.index + d[0].length : u), n3 && d && d.length > 1 && O0(wfe, d[0], l, function() {
    for (f = 1; f < arguments.length - 2; f++)
      arguments[f] === void 0 && (d[f] = void 0);
  }), d && S)
    for (d.groups = m = yfe(null), f = 0; f < S.length; f++)
      v = S[f], m[v[0]] = d[v[1]];
  return d;
});
var Fz = e3, Pfe = cw, w8 = Fz;
Pfe({ target: "RegExp", proto: !0, forced: /./.exec !== w8 }, {
  exec: w8
});
var Afe = y2, KW = Function.prototype, C8 = KW.apply, E8 = KW.call, kfe = typeof Reflect == "object" && Reflect.apply || (Afe ? E8.bind(C8) : function() {
  return E8.apply(C8, arguments);
}), _8 = _p, T8 = TW, Ife = Fz, P8 = Wa, YW = Tp, Rfe = Az, Mfe = YW("species"), gN = RegExp.prototype, Dfe = function(n, t, e, r) {
  var i = YW(n), s = !P8(function() {
    var d = {};
    return d[i] = function() {
      return 7;
    }, ""[n](d) !== 7;
  }), o = s && !P8(function() {
    var d = !1, f = /a/;
    return n === "split" && (f = {}, f.constructor = {}, f.constructor[Mfe] = function() {
      return f;
    }, f.flags = "", f[i] = /./[i]), f.exec = function() {
      return d = !0, null;
    }, f[i](""), !d;
  });
  if (!s || !o || e) {
    var l = /./[i], u = t(i, ""[n], function(d, f, m, v, S) {
      var w = f.exec;
      return w === Ife || w === gN.exec ? s && !S ? { done: !0, value: _8(l, f, m, v) } : { done: !0, value: _8(d, m, f, v) } : { done: !1 };
    });
    T8(String.prototype, n, u[0]), T8(gN, i, u[1]);
  }
  r && Rfe(gN[i], "sham", !0);
}, $z = no, Ofe = SS, Lfe = jT, jfe = aw, Nfe = $z("".charAt), A8 = $z("".charCodeAt), Ffe = $z("".slice), k8 = function(n) {
  return function(t, e) {
    var r = Lfe(jfe(t)), i = Ofe(e), s = r.length, o, l;
    return i < 0 || i >= s ? n ? "" : void 0 : (o = A8(r, i), o < 55296 || o > 56319 || i + 1 === s || (l = A8(r, i + 1)) < 56320 || l > 57343 ? n ? Nfe(r, i) : o : n ? Ffe(r, i, i + 2) : (o - 55296 << 10) + (l - 56320) + 65536);
  };
}, $fe = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: k8(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: k8(!0)
}, zfe = $fe.charAt, Ufe = function(n, t, e) {
  return t + (e ? zfe(n, t).length : 1);
}, zz = no, Bfe = MT, Hfe = Math.floor, mN = zz("".charAt), Vfe = zz("".replace), vN = zz("".slice), Wfe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Gfe = /\$([$&'`]|\d{1,2})/g, XW = function(n, t, e, r, i, s) {
  var o = e + n.length, l = r.length, u = Gfe;
  return i !== void 0 && (i = Bfe(i), u = Wfe), Vfe(s, u, function(d, f) {
    var m;
    switch (mN(f, 0)) {
      case "$":
        return "$";
      case "&":
        return n;
      case "`":
        return vN(t, 0, e);
      case "'":
        return vN(t, o);
      case "<":
        m = i[vN(f, 1, -1)];
        break;
      default:
        var v = +f;
        if (v === 0) return d;
        if (v > l) {
          var S = Hfe(v / 10);
          return S === 0 ? d : S <= l ? r[S - 1] === void 0 ? mN(f, 1) : r[S - 1] + mN(f, 1) : d;
        }
        m = r[v - 1];
    }
    return m === void 0 ? "" : m;
  });
}, I8 = _p, Kfe = yS, Yfe = Ga, Xfe = ow, qfe = Fz, Zfe = TypeError, Qfe = function(n, t) {
  var e = n.exec;
  if (Yfe(e)) {
    var r = I8(e, n, t);
    return r !== null && Kfe(r), r;
  }
  if (Xfe(n) === "RegExp") return I8(qfe, n, t);
  throw new Zfe("RegExp#exec called on incompatible receiver");
}, Jfe = kfe, R8 = _p, C2 = no, epe = Dfe, tpe = Wa, npe = yS, rpe = Ga, ipe = S2, spe = SS, ope = AW, p0 = jT, ape = aw, lpe = Ufe, cpe = Ez, upe = XW, dpe = Qfe, hpe = Tp, r3 = hpe("replace"), fpe = Math.max, ppe = Math.min, gpe = C2([].concat), yN = C2([].push), M8 = C2("".indexOf), D8 = C2("".slice), mpe = function(n) {
  return n === void 0 ? n : String(n);
}, vpe = function() {
  return "a".replace(/./, "$0") === "$0";
}(), O8 = function() {
  return /./[r3] ? /./[r3]("a", "$0") === "" : !1;
}(), ype = !tpe(function() {
  var n = /./;
  return n.exec = function() {
    var t = [];
    return t.groups = { a: "7" }, t;
  }, "".replace(n, "$<a>") !== "7";
});
epe("replace", function(n, t, e) {
  var r = O8 ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(s, o) {
      var l = ape(this), u = ipe(s) ? void 0 : cpe(s, r3);
      return u ? R8(u, s, l, o) : R8(t, p0(l), s, o);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, s) {
      var o = npe(this), l = p0(i);
      if (typeof s == "string" && M8(s, r) === -1 && M8(s, "$<") === -1) {
        var u = e(t, o, l, s);
        if (u.done) return u.value;
      }
      var d = rpe(s);
      d || (s = p0(s));
      var f = o.global, m;
      f && (m = o.unicode, o.lastIndex = 0);
      for (var v = [], S; S = dpe(o, l), !(S === null || (yN(v, S), !f)); ) {
        var w = p0(S[0]);
        w === "" && (o.lastIndex = lpe(l, ope(o.lastIndex), m));
      }
      for (var E = "", A = 0, P = 0; P < v.length; P++) {
        S = v[P];
        for (var R = p0(S[0]), M = fpe(ppe(spe(S.index), l.length), 0), j = [], $, U = 1; U < S.length; U++) yN(j, mpe(S[U]));
        var F = S.groups;
        if (d) {
          var B = gpe([R], j, M, l);
          F !== void 0 && yN(B, F), $ = p0(Jfe(s, void 0, B));
        } else
          $ = upe(R, l, M, j, F, s);
        M >= A && (E += D8(l, A, M) + $, A = M + R.length);
      }
      return E + D8(l, A);
    }
  ];
}, !ype || !vpe || O8);
var Spe = vS, bpe = ow, xpe = Tp, wpe = xpe("match"), Cpe = function(n) {
  var t;
  return Spe(n) && ((t = n[wpe]) !== void 0 ? !!t : bpe(n) === "RegExp");
}, Epe = _p, _pe = Im, Tpe = lW, Ppe = WW, L8 = RegExp.prototype, Ape = function(n) {
  var t = n.flags;
  return t === void 0 && !("flags" in L8) && !_pe(n, "flags") && Tpe(L8, n) ? Epe(Ppe, n) : t;
}, kpe = cw, Ipe = _p, Uz = no, j8 = aw, Rpe = Ga, Mpe = S2, Dpe = Cpe, _E = jT, Ope = Ez, Lpe = Ape, jpe = XW, Npe = Tp, Fpe = Npe("replace"), $pe = TypeError, SN = Uz("".indexOf);
Uz("".replace);
var N8 = Uz("".slice), zpe = Math.max;
kpe({ target: "String", proto: !0 }, {
  replaceAll: function(t, e) {
    var r = j8(this), i, s, o, l, u, d, f, m, v, S, w = 0, E = "";
    if (!Mpe(t)) {
      if (i = Dpe(t), i && (s = _E(j8(Lpe(t))), !~SN(s, "g")))
        throw new $pe("`.replaceAll` does not allow non-global regexes");
      if (o = Ope(t, Fpe), o) return Ipe(o, t, r, e);
    }
    for (l = _E(r), u = _E(t), d = Rpe(e), d || (e = _E(e)), f = u.length, m = zpe(1, f), v = SN(l, u); v !== -1; )
      S = d ? _E(e(u, v, l)) : jpe(u, l, v, [], void 0, e), E += N8(l, w, v) + S, w = v + f, v = v + m > l.length ? -1 : SN(l, u, v + m);
    return w < l.length && (E += N8(l, w)), E;
  }
});
var Upe = LT;
Upe("String", "replaceAll");
function qW(n) {
  return n && typeof n == "object" && "parents" in n;
}
function ZW(n) {
  for (let t = 0, e = n.parents.length; t < e; t++)
    if (n.parents[t].__unsafe__getWithoutCapture(!0), n.parents[t].lastChangedEpoch !== n.parentEpochs[t])
      return !0;
  return !1;
}
const sM = (n, t) => {
  if (n.children.remove(t) && n.children.isEmpty && qW(n))
    for (let e = 0, r = n.parents.length; e < r; e++)
      sM(n.parents[e], n);
}, Bz = (n, t) => {
  if (n.children.add(t) && qW(n))
    for (let e = 0, r = n.parents.length; e < r; e++)
      Bz(n.parents[e], n);
};
function QW(n, t) {
  return n === t || Object.is(n, t) || !!(n && t && typeof n.equals == "function" && n.equals(t));
}
function Rm(n, t) {
  const e = Symbol.for(`com.tldraw.state/${n}`), r = globalThis;
  return r[e] ?? (r[e] = t()), r[e];
}
const cp = Rm("empty_array", () => Object.freeze([])), F8 = 8;
class oM {
  constructor() {
    T(this, "arraySize", 0);
    T(this, "array", Array(F8));
    T(this, "set", null);
  }
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array)
      return this.arraySize === 0;
    if (this.set)
      return this.set.size === 0;
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(t) {
    if (this.array)
      return this.array.indexOf(t) !== -1 ? !1 : this.arraySize < F8 ? (this.array[this.arraySize] = t, this.arraySize++, !0) : (this.set = new Set(this.array), this.array = null, this.set.add(t), !0);
    if (this.set)
      return this.set.has(t) ? !1 : (this.set.add(t), !0);
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(t) {
    if (this.array) {
      const e = this.array.indexOf(t);
      return e === -1 ? !1 : (this.array[e] = void 0, this.arraySize--, e !== this.arraySize && (this.array[e] = this.array[this.arraySize], this.array[this.arraySize] = void 0), !0);
    }
    if (this.set)
      return this.set.has(t) ? (this.set.delete(t), !0) : !1;
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor - The callback to run for each element.
   */
  visit(t) {
    if (this.array) {
      for (let e = 0; e < this.arraySize; e++) {
        const r = this.array[e];
        typeof r < "u" && t(r);
      }
      return;
    }
    if (this.set) {
      this.set.forEach(t);
      return;
    }
    throw new Error("no set or array");
  }
  has(t) {
    return this.array ? this.array.indexOf(t) !== -1 : this.set.has(t);
  }
  clear() {
    this.set ? this.set.clear() : (this.arraySize = 0, this.array = []);
  }
  size() {
    return this.set ? this.set.size : this.arraySize;
  }
}
const mc = Symbol.for("com.tldraw.state/RESET_VALUE");
class JW {
  constructor(t) {
    T(this, "index", 0);
    // use a wrap around buffer to store the last N values
    T(this, "buffer");
    this.capacity = t, this.buffer = new Array(t);
  }
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch - The epoch when the diff was computed.
   * @param currentEpoch - The current epoch.
   * @param diff - The diff to add, or else a reset value.
   */
  pushEntry(t, e, r) {
    if (r !== void 0) {
      if (r === mc) {
        this.clear();
        return;
      }
      this.buffer[this.index] = [t, e, r], this.index = (this.index + 1) % this.capacity;
    }
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0, this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param epoch - The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(t) {
    const { index: e, capacity: r, buffer: i } = this;
    for (let s = 0; s < r; s++) {
      const o = (e - 1 + r - s) % r, l = i[o];
      if (!l)
        return mc;
      const [u, d] = l;
      if (s === 0 && t >= d)
        return [];
      if (u <= t && t < d) {
        const f = s + 1, m = new Array(f);
        for (let v = 0; v < f; v++)
          m[v] = i[(o + v) % r][2];
        return m;
      }
    }
    return mc;
  }
}
class Bpe {
  constructor(t, e) {
    T(this, "offset", 0);
    T(this, "maybeRemoved");
    this.below = t, this.child = e;
  }
}
const bi = Rm("capture", () => ({ stack: null }));
function nI(n) {
  const t = bi.stack;
  bi.stack = null;
  try {
    return n();
  } finally {
    bi.stack = t;
  }
}
function eG(n) {
  bi.stack = new Bpe(bi.stack, n), n.parentSet.clear();
}
function tG() {
  const n = bi.stack;
  if (bi.stack = n.below, n.offset < n.child.parents.length) {
    for (let t = n.offset; t < n.child.parents.length; t++) {
      const e = n.child.parents[t];
      n.child.parentSet.has(e) || sM(e, n.child);
    }
    n.child.parents.length = n.offset, n.child.parentEpochs.length = n.offset;
  }
  if (n.maybeRemoved)
    for (let t = 0; t < n.maybeRemoved.length; t++) {
      const e = n.maybeRemoved[t];
      n.child.parentSet.has(e) || sM(e, n.child);
    }
}
function aM(n) {
  if (bi.stack) {
    if (bi.stack.child.parentSet.has(n))
      return;
    if (bi.stack.child.parentSet.add(n), bi.stack.child.isActivelyListening && Bz(n, bi.stack.child), bi.stack.offset < bi.stack.child.parents.length) {
      const e = bi.stack.child.parents[bi.stack.offset];
      e !== n && (bi.stack.maybeRemoved ? bi.stack.maybeRemoved.push(e) : bi.stack.maybeRemoved = [e]);
    }
    bi.stack.child.parents[bi.stack.offset] = n, bi.stack.child.parentEpochs[bi.stack.offset] = n.lastChangedEpoch, bi.stack.offset++;
  }
}
const dm = -1;
class Hpe {
  constructor(t, e, r) {
    T(this, "_isActivelyListening", !1);
    /** @internal */
    T(this, "lastTraversedEpoch", dm);
    T(this, "lastReactedEpoch", dm);
    T(this, "_scheduleCount", 0);
    /** @internal */
    T(this, "parentSet", new oM());
    /** @internal */
    T(this, "parentEpochs", []);
    /** @internal */
    T(this, "parents", []);
    T(this, "_scheduleEffect");
    /** @internal */
    T(this, "maybeExecute", () => {
      this._isActivelyListening && this.execute();
    });
    this.name = t, this.runEffect = e, this._scheduleEffect = r == null ? void 0 : r.scheduleEffect;
  }
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  maybeScheduleEffect() {
    if (this._isActivelyListening && this.lastReactedEpoch !== Al()) {
      if (this.parents.length && !ZW(this)) {
        this.lastReactedEpoch = Al();
        return;
      }
      this.scheduleEffect();
    }
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++, this._scheduleEffect ? this._scheduleEffect(this.maybeExecute) : this.execute();
  }
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].
   * @public
   */
  attach() {
    this._isActivelyListening = !0;
    for (let t = 0, e = this.parents.length; t < e; t++)
      Bz(this.parents[t], this);
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.
   */
  detach() {
    this._isActivelyListening = !1;
    for (let t = 0, e = this.parents.length; t < e; t++)
      sM(this.parents[t], this);
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      eG(this);
      const t = Al(), e = this.runEffect(this.lastReactedEpoch);
      return this.lastReactedEpoch = t, e;
    } finally {
      tG();
    }
  }
}
const uw = Rm(
  "EffectScheduler",
  () => Hpe
);
function bS(n, t, e) {
  const r = new uw(n, t, e);
  return r.attach(), r.scheduleEffect(), () => {
    r.detach();
  };
}
function Vpe(n, t, e) {
  const r = new uw(n, t, e);
  return {
    scheduler: r,
    start: (i) => {
      const s = (i == null ? void 0 : i.force) ?? !1;
      r.attach(), s ? r.scheduleEffect() : r.maybeScheduleEffect();
    },
    stop: () => {
      r.detach();
    }
  };
}
class Wpe {
  constructor(t) {
    T(this, "initialAtomValues", /* @__PURE__ */ new Map());
    this.parent = t;
  }
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    this.isRoot ? nG(this.initialAtomValues.keys()) : this.initialAtomValues.forEach((t, e) => {
      this.parent.initialAtomValues.has(e) || this.parent.initialAtomValues.set(e, t);
    });
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    Dr.globalEpoch++, this.initialAtomValues.forEach((t, e) => {
      var r;
      e.set(t), (r = e.historyBuffer) == null || r.clear();
    }), this.commit();
  }
}
const Dr = Rm("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: dm + 1,
  // Whether any transaction is reacting.
  globalIsReacting: !1,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: dm + 1
}));
function Gpe() {
  return Dr.reactionEpoch;
}
function Al() {
  return Dr.globalEpoch;
}
function Kpe() {
  return Dr.globalIsReacting;
}
function Hz(n, t) {
  t.lastTraversedEpoch !== Dr.globalEpoch && (t.lastTraversedEpoch = Dr.globalEpoch, t instanceof uw ? n.add(t) : t.children.visit((e) => Hz(n, e)));
}
function nG(n) {
  var t;
  if (Dr.globalIsReacting)
    throw new Error("cannot change atoms during reaction cycle");
  try {
    Dr.globalIsReacting = !0, Dr.reactionEpoch = Dr.globalEpoch;
    const e = /* @__PURE__ */ new Set();
    for (const i of n)
      i.children.visit((s) => Hz(e, s));
    for (const i of e)
      i.maybeScheduleEffect();
    let r = 0;
    for (; (t = Dr.cleanupReactors) != null && t.size; ) {
      if (r++ > 1e3)
        throw new Error("Reaction update depth limit exceeded");
      const i = Dr.cleanupReactors;
      Dr.cleanupReactors = null;
      for (const s of i)
        s.maybeScheduleEffect();
    }
  } finally {
    Dr.cleanupReactors = null, Dr.globalIsReacting = !1;
  }
}
function Ype(n, t) {
  if (Dr.globalIsReacting) {
    const e = Dr.cleanupReactors ?? (Dr.cleanupReactors = /* @__PURE__ */ new Set());
    n.children.visit((r) => Hz(e, r));
  } else Dr.currentTransaction ? Dr.currentTransaction.initialAtomValues.has(n) || Dr.currentTransaction.initialAtomValues.set(n, t) : nG([n]);
}
function Xpe() {
  Dr.globalEpoch++;
}
function qpe(n) {
  const t = new Wpe(Dr.currentTransaction);
  Dr.currentTransaction = t;
  try {
    let e, r = !1;
    try {
      e = n(() => r = !0);
    } catch (i) {
      throw t.abort(), i;
    }
    return r ? t.abort() : t.commit(), e;
  } finally {
    Dr.currentTransaction = Dr.currentTransaction.parent;
  }
}
function bh(n) {
  return Dr.currentTransaction ? n() : qpe(n);
}
class Zpe {
  constructor(t, e, r) {
    T(this, "isEqual");
    T(this, "computeDiff");
    T(this, "lastChangedEpoch", Al());
    T(this, "children", new oM());
    T(this, "historyBuffer");
    this.name = t, this.current = e, this.isEqual = (r == null ? void 0 : r.isEqual) ?? null, r && (r.historyLength && (this.historyBuffer = new JW(r.historyLength)), this.computeDiff = r.computeDiff);
  }
  __unsafe__getWithoutCapture(t) {
    return this.current;
  }
  get() {
    return aM(this), this.current;
  }
  set(t, e) {
    var i, s;
    if (((i = this.isEqual) == null ? void 0 : i.call(this, this.current, t)) ?? QW(this.current, t))
      return this.current;
    Xpe(), this.historyBuffer && this.historyBuffer.pushEntry(
      this.lastChangedEpoch,
      Al(),
      e ?? ((s = this.computeDiff) == null ? void 0 : s.call(this, this.current, t, this.lastChangedEpoch, Al())) ?? mc
    ), this.lastChangedEpoch = Al();
    const r = this.current;
    return this.current = t, Ype(this, r), t;
  }
  update(t) {
    return this.set(t(this.current));
  }
  getDiffSince(t) {
    var e;
    return aM(this), t >= this.lastChangedEpoch ? cp : ((e = this.historyBuffer) == null ? void 0 : e.getChangesSince(t)) ?? mc;
  }
}
const Qpe = Rm("Atom", () => Zpe);
function Qs(n, t, e) {
  return new Qpe(n, t, e);
}
let $8 = !1;
function Jpe() {
  $8 || ($8 = !0, console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  ));
}
const GE = Symbol.for("com.tldraw.state/UNINITIALIZED"), Yy = (n) => n === GE, i3 = Rm(
  "WithDiff",
  () => class {
    constructor(t, e) {
      this.value = t, this.diff = e;
    }
  }
);
function KE(n, t) {
  return new i3(n, t);
}
class ege {
  constructor(t, e, r) {
    T(this, "lastChangedEpoch", dm);
    T(this, "lastTraversedEpoch", dm);
    /**
     * The epoch when the reactor was last checked.
     */
    T(this, "lastCheckedEpoch", dm);
    T(this, "parentSet", new oM());
    T(this, "parents", []);
    T(this, "parentEpochs", []);
    T(this, "children", new oM());
    T(this, "historyBuffer");
    // The last-computed value of this signal.
    T(this, "state", GE);
    // If the signal throws an error we stash it so we can rethrow it on the next get()
    T(this, "error", null);
    T(this, "computeDiff");
    T(this, "isEqual");
    this.name = t, this.derive = e, r != null && r.historyLength && (this.historyBuffer = new JW(r.historyLength)), this.computeDiff = r == null ? void 0 : r.computeDiff, this.isEqual = (r == null ? void 0 : r.isEqual) ?? QW;
  }
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  __unsafe__getWithoutCapture(t) {
    var i;
    const e = this.lastChangedEpoch === dm, r = Al();
    if (!e && (this.lastCheckedEpoch === r || this.isActivelyListening && Kpe() && this.lastTraversedEpoch < Gpe() || !ZW(this)))
      if (this.lastCheckedEpoch = r, this.error) {
        if (t)
          return this.state;
        throw this.error.thrownValue;
      } else
        return this.state;
    try {
      eG(this);
      const s = this.derive(this.state, this.lastCheckedEpoch), o = s instanceof i3 ? s.value : s, l = this.state === GE;
      if (l || !this.isEqual(o, this.state)) {
        if (this.historyBuffer && !l) {
          const u = s instanceof i3 ? s.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            Al(),
            u ?? ((i = this.computeDiff) == null ? void 0 : i.call(this, this.state, o, this.lastCheckedEpoch, Al())) ?? mc
          );
        }
        this.lastChangedEpoch = Al(), this.state = o;
      }
      return this.error = null, this.lastCheckedEpoch = Al(), this.state;
    } catch (s) {
      if (this.state !== GE && (this.state = GE, this.lastChangedEpoch = Al()), this.lastCheckedEpoch = Al(), this.historyBuffer && this.historyBuffer.clear(), this.error = { thrownValue: s }, !t) throw s;
      return this.state;
    } finally {
      tG();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      aM(this);
    }
  }
  getDiffSince(t) {
    var e;
    return this.__unsafe__getWithoutCapture(!0), aM(this), t >= this.lastChangedEpoch ? cp : ((e = this.historyBuffer) == null ? void 0 : e.getChangesSince(t)) ?? mc;
  }
}
const Vz = Rm("Computed", () => ege);
function tge(n = {}, t, e, r) {
  const i = r.value, s = Symbol.for("__@tldraw/state__computed__" + e);
  return r.value = function() {
    let o = this[s];
    return o || (o = new Vz(e, i.bind(this), n), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: o
    })), o.get();
  }, r.value[rge] = !0, r;
}
function z8(n = {}, t, e, r) {
  return r.get ? (Jpe(), nge(n, t, e, r)) : tge(n, t, e, r);
}
function nge(n = {}, t, e, r) {
  const i = r.get, s = Symbol.for("__@tldraw/state__computed__" + e);
  return r.get = function() {
    let o = this[s];
    return o || (o = new Vz(e, i.bind(this), n), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: o
    })), o.get();
  }, r;
}
const rge = "@@__isComputedMethod__@@";
function ze() {
  if (arguments.length === 1) {
    const n = arguments[0];
    return (t, e, r) => z8(n, t, e, r);
  } else return typeof arguments[0] == "string" ? new Vz(arguments[0], arguments[1], arguments[2]) : z8(void 0, arguments[0], arguments[1], arguments[2]);
}
const rG = 1, ige = Rm("apiVersion", () => rG);
if (ige !== rG)
  throw new Error(
    "You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package."
  );
var iG = "Expected a function", U8 = NaN, sge = "[object Symbol]", oge = /^\s+|\s+$/g, age = /^[-+]0x[0-9a-f]+$/i, lge = /^0b[01]+$/i, cge = /^0o[0-7]+$/i, uge = parseInt, dge = typeof ga == "object" && ga && ga.Object === Object && ga, hge = typeof self == "object" && self && self.Object === Object && self, fge = dge || hge || Function("return this")(), pge = Object.prototype, gge = pge.toString, mge = Math.max, vge = Math.min, bN = function() {
  return fge.Date.now();
};
function yge(n, t, e) {
  var r, i, s, o, l, u, d = 0, f = !1, m = !1, v = !0;
  if (typeof n != "function")
    throw new TypeError(iG);
  t = B8(t) || 0, lM(e) && (f = !!e.leading, m = "maxWait" in e, s = m ? mge(B8(e.maxWait) || 0, t) : s, v = "trailing" in e ? !!e.trailing : v);
  function S(U) {
    var F = r, B = i;
    return r = i = void 0, d = U, o = n.apply(B, F), o;
  }
  function w(U) {
    return d = U, l = setTimeout(P, t), f ? S(U) : o;
  }
  function E(U) {
    var F = U - u, B = U - d, G = t - F;
    return m ? vge(G, s - B) : G;
  }
  function A(U) {
    var F = U - u, B = U - d;
    return u === void 0 || F >= t || F < 0 || m && B >= s;
  }
  function P() {
    var U = bN();
    if (A(U))
      return R(U);
    l = setTimeout(P, E(U));
  }
  function R(U) {
    return l = void 0, v && r ? S(U) : (r = i = void 0, o);
  }
  function M() {
    l !== void 0 && clearTimeout(l), d = 0, r = u = i = l = void 0;
  }
  function j() {
    return l === void 0 ? o : R(bN());
  }
  function $() {
    var U = bN(), F = A(U);
    if (r = arguments, i = this, u = U, F) {
      if (l === void 0)
        return w(u);
      if (m)
        return l = setTimeout(P, t), S(u);
    }
    return l === void 0 && (l = setTimeout(P, t)), o;
  }
  return $.cancel = M, $.flush = j, $;
}
function Sge(n, t, e) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(iG);
  return lM(e) && (r = "leading" in e ? !!e.leading : r, i = "trailing" in e ? !!e.trailing : i), yge(n, t, {
    leading: r,
    maxWait: t,
    trailing: i
  });
}
function lM(n) {
  var t = typeof n;
  return !!n && (t == "object" || t == "function");
}
function bge(n) {
  return !!n && typeof n == "object";
}
function xge(n) {
  return typeof n == "symbol" || bge(n) && gge.call(n) == sge;
}
function B8(n) {
  if (typeof n == "number")
    return n;
  if (xge(n))
    return U8;
  if (lM(n)) {
    var t = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = lM(t) ? t + "" : t;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = n.replace(oge, "");
  var e = lge.test(n);
  return e || cge.test(n) ? uge(n.slice(2), e ? 2 : 8) : age.test(n) ? U8 : +n;
}
var wge = Sge;
const sG = /* @__PURE__ */ Ep(wge);
var Cge = 200, Wz = "__lodash_hash_undefined__", Ege = 1 / 0, _ge = "[object Function]", Tge = "[object GeneratorFunction]", Pge = /[\\^$.*+?()[\]{}|]/g, Age = /^\[object .+?Constructor\]$/, kge = typeof ga == "object" && ga && ga.Object === Object && ga, Ige = typeof self == "object" && self && self.Object === Object && self, Gz = kge || Ige || Function("return this")();
function Rge(n, t) {
  var e = n ? n.length : 0;
  return !!e && Dge(n, t, 0) > -1;
}
function Mge(n, t, e, r) {
  for (var i = n.length, s = e + -1; ++s < i; )
    if (t(n[s], s, n))
      return s;
  return -1;
}
function Dge(n, t, e) {
  if (t !== t)
    return Mge(n, Oge, e);
  for (var r = e - 1, i = n.length; ++r < i; )
    if (n[r] === t)
      return r;
  return -1;
}
function Oge(n) {
  return n !== n;
}
function Lge(n, t) {
  return n.has(t);
}
function jge(n, t) {
  return n == null ? void 0 : n[t];
}
function Nge(n) {
  var t = !1;
  if (n != null && typeof n.toString != "function")
    try {
      t = !!(n + "");
    } catch {
    }
  return t;
}
function oG(n) {
  var t = -1, e = Array(n.size);
  return n.forEach(function(r) {
    e[++t] = r;
  }), e;
}
var Fge = Array.prototype, $ge = Function.prototype, aG = Object.prototype, xN = Gz["__core-js_shared__"], H8 = function() {
  var n = /[^.]+$/.exec(xN && xN.keys && xN.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}(), lG = $ge.toString, Kz = aG.hasOwnProperty, zge = aG.toString, Uge = RegExp(
  "^" + lG.call(Kz).replace(Pge, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), Bge = Fge.splice, Hge = Yz(Gz, "Map"), wN = Yz(Gz, "Set"), N1 = Yz(Object, "create");
function Zy(n) {
  var t = -1, e = n ? n.length : 0;
  for (this.clear(); ++t < e; ) {
    var r = n[t];
    this.set(r[0], r[1]);
  }
}
function Vge() {
  this.__data__ = N1 ? N1(null) : {};
}
function Wge(n) {
  return this.has(n) && delete this.__data__[n];
}
function Gge(n) {
  var t = this.__data__;
  if (N1) {
    var e = t[n];
    return e === Wz ? void 0 : e;
  }
  return Kz.call(t, n) ? t[n] : void 0;
}
function Kge(n) {
  var t = this.__data__;
  return N1 ? t[n] !== void 0 : Kz.call(t, n);
}
function Yge(n, t) {
  var e = this.__data__;
  return e[n] = N1 && t === void 0 ? Wz : t, this;
}
Zy.prototype.clear = Vge;
Zy.prototype.delete = Wge;
Zy.prototype.get = Gge;
Zy.prototype.has = Kge;
Zy.prototype.set = Yge;
function dw(n) {
  var t = -1, e = n ? n.length : 0;
  for (this.clear(); ++t < e; ) {
    var r = n[t];
    this.set(r[0], r[1]);
  }
}
function Xge() {
  this.__data__ = [];
}
function qge(n) {
  var t = this.__data__, e = E2(t, n);
  if (e < 0)
    return !1;
  var r = t.length - 1;
  return e == r ? t.pop() : Bge.call(t, e, 1), !0;
}
function Zge(n) {
  var t = this.__data__, e = E2(t, n);
  return e < 0 ? void 0 : t[e][1];
}
function Qge(n) {
  return E2(this.__data__, n) > -1;
}
function Jge(n, t) {
  var e = this.__data__, r = E2(e, n);
  return r < 0 ? e.push([n, t]) : e[r][1] = t, this;
}
dw.prototype.clear = Xge;
dw.prototype.delete = qge;
dw.prototype.get = Zge;
dw.prototype.has = Qge;
dw.prototype.set = Jge;
function hw(n) {
  var t = -1, e = n ? n.length : 0;
  for (this.clear(); ++t < e; ) {
    var r = n[t];
    this.set(r[0], r[1]);
  }
}
function eme() {
  this.__data__ = {
    hash: new Zy(),
    map: new (Hge || dw)(),
    string: new Zy()
  };
}
function tme(n) {
  return _2(this, n).delete(n);
}
function nme(n) {
  return _2(this, n).get(n);
}
function rme(n) {
  return _2(this, n).has(n);
}
function ime(n, t) {
  return _2(this, n).set(n, t), this;
}
hw.prototype.clear = eme;
hw.prototype.delete = tme;
hw.prototype.get = nme;
hw.prototype.has = rme;
hw.prototype.set = ime;
function cM(n) {
  var t = -1, e = n ? n.length : 0;
  for (this.__data__ = new hw(); ++t < e; )
    this.add(n[t]);
}
function sme(n) {
  return this.__data__.set(n, Wz), this;
}
function ome(n) {
  return this.__data__.has(n);
}
cM.prototype.add = cM.prototype.push = sme;
cM.prototype.has = ome;
function E2(n, t) {
  for (var e = n.length; e--; )
    if (pme(n[e][0], t))
      return e;
  return -1;
}
function ame(n) {
  if (!cG(n) || dme(n))
    return !1;
  var t = gme(n) || Nge(n) ? Uge : Age;
  return t.test(hme(n));
}
function lme(n, t, e) {
  var r = -1, i = Rge, s = n.length, o = !0, l = [], u = l;
  if (s >= Cge) {
    var d = cme(n);
    if (d)
      return oG(d);
    o = !1, i = Lge, u = new cM();
  } else
    u = l;
  e:
    for (; ++r < s; ) {
      var f = n[r], m = f;
      if (f = f !== 0 ? f : 0, o && m === m) {
        for (var v = u.length; v--; )
          if (u[v] === m)
            continue e;
        l.push(f);
      } else i(u, m, e) || (u !== l && u.push(m), l.push(f));
    }
  return l;
}
var cme = wN && 1 / oG(new wN([, -0]))[1] == Ege ? function(n) {
  return new wN(n);
} : mme;
function _2(n, t) {
  var e = n.__data__;
  return ume(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function Yz(n, t) {
  var e = jge(n, t);
  return ame(e) ? e : void 0;
}
function ume(n) {
  var t = typeof n;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? n !== "__proto__" : n === null;
}
function dme(n) {
  return !!H8 && H8 in n;
}
function hme(n) {
  if (n != null) {
    try {
      return lG.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
function fme(n) {
  return n && n.length ? lme(n) : [];
}
function pme(n, t) {
  return n === t || n !== n && t !== t;
}
function gme(n) {
  var t = cG(n) ? zge.call(n) : "";
  return t == _ge || t == Tge;
}
function cG(n) {
  var t = typeof n;
  return !!n && (t == "object" || t == "function");
}
function mme() {
}
var vme = fme;
const yme = /* @__PURE__ */ Ep(vme), YE = {
  Good: "#40C057",
  Mid: "#FFC078",
  Poor: "#E03131"
}, Sme = YE.Good;
class uG {
  constructor() {
    T(this, "startTime", 0);
    T(this, "name", "");
    T(this, "frames", 0);
    T(this, "started", !1);
    T(this, "frame", null);
    T(this, "recordFrame", () => {
      this.frames++, this.started && (this.frame = requestAnimationFrame(this.recordFrame));
    });
  }
  start(t) {
    this.name = t, this.frames = 0, this.started = !0, this.frame !== null && cancelAnimationFrame(this.frame), this.frame = requestAnimationFrame(this.recordFrame), this.startTime = performance.now();
  }
  stop() {
    this.started = !1, this.frame !== null && cancelAnimationFrame(this.frame);
    const t = (performance.now() - this.startTime) / 1e3, e = t === 0 ? 0 : Math.floor(this.frames / t), r = e > 55 ? YE.Good : e > 30 ? YE.Mid : YE.Poor, i = r === YE.Mid ? "black" : "white", s = this.name[0].toUpperCase() + this.name.slice(1);
    console.debug(
      `%cPerf%c ${s} %c${e}%c fps`,
      `color: white; background: ${Sme};padding: 2px;border-radius: 3px;`,
      "font-weight: normal",
      `font-weight: bold; padding: 2px; background: ${r};color: ${i};`,
      "font-weight: normal"
    );
  }
  isStarted() {
    return this.started;
  }
}
function Xz(n, t) {
  const e = [];
  e: for (const r of n) {
    for (const i of e)
      if (t ? t(r, i) : r === i)
        continue e;
    e.push(r);
  }
  return e;
}
function xn(n) {
  return n.filter((t) => t != null);
}
function Io(n) {
  return n[n.length - 1];
}
function bme(n, t) {
  let e, r = 1 / 0;
  for (const i of n) {
    const s = t(i);
    s < r && (e = i, r = s);
  }
  return e;
}
function xme(n, t) {
  if (n === t) return !0;
  if (n.length !== t.length) return !1;
  for (let e = 0; e < n.length; e++)
    if (!Object.is(n[e], t[e]))
      return !1;
  return !0;
}
class vp {
  constructor() {
    /** The map of items to their cached values. */
    T(this, "items", /* @__PURE__ */ new WeakMap());
  }
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(t, e) {
    return this.items.has(t) || this.items.set(t, e(t)), this.items.get(t);
  }
}
function dG(n) {
  const t = (...e) => {
    try {
      return n(...e);
    } catch (r) {
      throw r instanceof Error && Error.captureStackTrace && Error.captureStackTrace(r, t), r;
    }
  };
  return t;
}
const F1 = () => {
}, gm = {
  ok(n) {
    return { ok: !0, value: n };
  },
  err(n) {
    return { ok: !1, error: n };
  }
};
function ma(n, t) {
  const e = t && n && typeof n == "object" && t in n ? n[t] : n;
  throw new Error(`Unknown switch case ${e}`);
}
const ii = dG(
  (n, t) => {
    if (!n)
      throw new Error(t || "Assertion Error");
  }
), nu = dG((n, t) => {
  if (n == null)
    throw new Error(t ?? "value must be defined");
  return n;
});
function hG(n, t) {
  let e;
  const r = (...i) => (e || (e = {}, e.promise = new Promise((s, o) => {
    e.resolve = s, e.reject = o;
  })), clearTimeout(e.timeout), e.latestArgs = i, e.timeout = setTimeout(() => {
    const s = e;
    e = void 0;
    try {
      s.resolve(n(...s.latestArgs));
    } catch (o) {
      s.reject(o);
    }
  }, t), e.promise);
  return r.cancel = () => {
    e && clearTimeout(e.timeout);
  }, r;
}
const V8 = /* @__PURE__ */ new WeakMap();
function qz(n, t) {
  if (typeof n != "object" || n === null) return;
  let e = V8.get(n);
  e || (e = { tags: {}, extras: {} }, V8.set(n, e)), t.tags && (e.tags = {
    ...e.tags,
    ...t.tags
  }), t.extras && (e.extras = {
    ...e.extras,
    ...t.extras
  });
}
async function Th(n, t) {
  return window.fetch(n, {
    // We want to make sure that the referrer is not sent to other domains.
    referrerPolicy: "strict-origin-when-cross-origin",
    ...t
  });
}
const Xx = (n, t) => {
  const e = new window.Image(n, t);
  return e.referrerPolicy = "strict-origin-when-cross-origin", e;
};
class Xy {
  /**
   * @param dataURL - The file as a string.
   *
   * from https://stackoverflow.com/a/53817185
   */
  static async dataUrlToArrayBuffer(t) {
    return Th(t).then(function(e) {
      return e.arrayBuffer();
    });
  }
  /**
   * Convert a file to a base64 encoded data url.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.toDataUrl(myImageFile)
   * ```
   *
   * @param value - The file as a blob.
   */
  static async blobToDataUrl(t) {
    return await new Promise((e, r) => {
      if (t) {
        const i = new FileReader();
        i.onload = () => e(i.result), i.onerror = (s) => r(s), i.onabort = (s) => r(s), i.readAsDataURL(t);
      }
    });
  }
  /**
   * Convert a file to a unicode text string.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.fileToDataUrl(myTextFile)
   * ```
   *
   * @param value - The file as a blob.
   */
  static async blobToText(t) {
    return await new Promise((e, r) => {
      if (t) {
        const i = new FileReader();
        i.onload = () => e(i.result), i.onerror = (s) => r(s), i.onabort = (s) => r(s), i.readAsText(t);
      }
    });
  }
}
function s3(n) {
  let t = 0;
  for (let e = 0; e < n.length; e++)
    t = (t << 5) - t + n.charCodeAt(e), t |= 0;
  return t + "";
}
function wme(n) {
  const t = new DataView(n);
  let e = 0;
  for (let r = 0; r < t.byteLength; r++)
    e = (e << 5) - e + t.getUint8(r), e |= 0;
  return e + "";
}
/*!
 * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license
 * Copyright (c) Philip van Heemstra
 */
function Cme(n) {
  const t = new Uint8Array(n);
  if (!t || !(typeof Buffer < "u" && Buffer.isBuffer(t) || t instanceof Uint8Array) || t.length < 16 || !(t[0] === 137 && t[1] === 80 && t[2] === 78 && t[3] === 71 && t[4] === 13 && t[5] === 10 && t[6] === 26 && t[7] === 10))
    return !1;
  function r(s, o, l, u, d = 1024) {
    if (!o)
      return -1;
    o = new RegExp(o, "g");
    const f = o.source.length, m = new TextDecoder(), v = s.length;
    if (typeof u > "u" && (u = v), l >= v || u <= 0 || l >= u)
      return -1;
    s = s.subarray(l, u);
    let S = -1, w = 0, E = 0, A = "";
    e: for (; w < s.length; ) {
      const P = w + d, R = s.subarray(w, P), M = m.decode(R, { stream: !0 }), j = A + M;
      let $, U = -1;
      for (; ($ = o.exec(j)) !== null; ) {
        U = $.index - A.length, S = E + U;
        break e;
      }
      w = P, E += M.length;
      const F = U > -1 ? U + f : M.length - f;
      A = M.slice(F);
    }
    return S >= 0 && (S += l >= 0 ? l : v + l), S;
  }
  const i = r(t, "IDAT", 12);
  return i >= 12 ? r(t, "acTL", 8, i) >= 8 : !1;
}
const Eme = (n) => new Uint8Array(n)[3] === 44;
/*!
 * MIT License
 * Modified code originally from <https://github.com/qzb/is-animated>
 * Copyright (c) 2016 Józef Sokołowski <j.k.sokolowski@gmail.com>
 */
function W8(n, t) {
  let e = 0;
  for (; n[t + e]; )
    e += n[t + e] + 1;
  return e + 1;
}
function _me(n) {
  return new TextDecoder("ascii").decode(n.slice(0, 3)) === "GIF";
}
function Tme(n) {
  const t = new Uint8Array(n);
  let e, r, i = 0, s = 0;
  if (!_me(n))
    return !1;
  for (e = t[10] & 128, r = t[10] & 7, i += 6, i += 7, i += e ? 3 * Math.pow(2, r + 1) : 0; s < 2 && i < t.length; )
    switch (t[i]) {
      case 44:
        s += 1, e = t[i + 9] & 128, r = t[i + 9] & 7, i += 10, i += e ? 3 * Math.pow(2, r + 1) : 0, i += W8(t, i + 1) + 1;
        break;
      case 33:
        i += 2, i += W8(t, i);
        break;
      case 59:
        i = t.length;
        break;
      default:
        i = t.length;
        break;
    }
  return s > 1;
}
let o3 = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
typeof Int32Array < "u" && (o3 = new Int32Array(o3));
/*!
 * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE
 * Copyright: 2014 Alex Gorbatchev
 * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts
 */
const Pme = (n, t) => {
  let e = ~~t ^ -1;
  for (let r = 0; r < n.length; r++)
    e = o3[(e ^ n[r]) & 255] ^ e >>> 8;
  return e ^ -1;
}, G8 = 4, K8 = 4;
class ph {
  static isPng(t, e) {
    return t.getUint8(e + 0) === 137 && t.getUint8(e + 1) === 80 && t.getUint8(e + 2) === 78 && t.getUint8(e + 3) === 71 && t.getUint8(e + 4) === 13 && t.getUint8(e + 5) === 10 && t.getUint8(e + 6) === 26 && t.getUint8(e + 7) === 10;
  }
  static getChunkType(t, e) {
    return [
      String.fromCharCode(t.getUint8(e)),
      String.fromCharCode(t.getUint8(e + 1)),
      String.fromCharCode(t.getUint8(e + 2)),
      String.fromCharCode(t.getUint8(e + 3))
    ].join("");
  }
  static readChunks(t, e = 0) {
    const r = {};
    if (!ph.isPng(t, e))
      throw new Error("Not a PNG");
    for (e += 8; e <= t.buffer.byteLength; ) {
      const i = e, s = t.getInt32(e);
      e += 4;
      const o = ph.getChunkType(t, e);
      if (o === "IDAT" && r[o]) {
        e += s + G8 + K8;
        continue;
      }
      if (o === "IEND")
        break;
      r[o] = {
        start: i,
        dataOffset: e + 4,
        size: s
      }, e += s + G8 + K8;
    }
    return r;
  }
  static parsePhys(t, e) {
    return {
      ppux: t.getUint32(e),
      ppuy: t.getUint32(e + 4),
      unit: t.getUint8(e + 4)
    };
  }
  static findChunk(t, e) {
    return ph.readChunks(t)[e];
  }
  static setPhysChunk(t, e = 1, r) {
    let i = 46, s = 0;
    const o = ph.findChunk(t, "pHYs");
    o && (i = o.start, s = o.size);
    const l = ph.findChunk(t, "IDAT");
    l && (i = l.start, s = 0);
    const u = new ArrayBuffer(21), d = new DataView(u);
    d.setUint32(0, 9), d.setUint8(4, 112), d.setUint8(5, 72), d.setUint8(6, 89), d.setUint8(7, 115);
    const f = 2835.5;
    d.setInt32(8, f * e), d.setInt32(12, f * e), d.setInt8(16, 1);
    const m = new Uint8Array(u.slice(4, 17));
    d.setInt32(17, Pme(m));
    const v = t.buffer.slice(0, i), S = t.buffer.slice(i + s);
    return new Blob([v, u, S], r);
  }
}
/*!
 * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
 */
function Ame(n) {
  return !n || n.length < 12 ? !1 : n[8] === 87 && n[9] === 69 && n[10] === 66 && n[11] === 80;
}
function kme(n) {
  const t = new Uint8Array(n);
  return !Ame(t) || !t || t.length < 21 ? !1 : (t[20] >> 1 & 1) === 1;
}
const fG = Object.freeze(["image/svg+xml"]), pG = Object.freeze([
  "image/jpeg",
  "image/png",
  "image/webp"
]), gG = Object.freeze([
  "image/gif",
  "image/apng",
  "image/avif"
]), Zz = Object.freeze([
  ...pG,
  ...fG,
  ...gG
]), mG = Object.freeze([
  "video/mp4",
  "video/webm",
  "video/quicktime"
]), Ime = [
  ...Zz,
  ...mG
].join(",");
class mh {
  /**
   * Load a video from a url.
   * @public
   */
  static loadVideo(t) {
    return new Promise((e, r) => {
      const i = document.createElement("video");
      i.onloadeddata = () => e(i), i.onerror = (s) => {
        console.error(s), r(new Error("Could not load video"));
      }, i.crossOrigin = "anonymous", i.src = t;
    });
  }
  /**
   * Load an image from a url.
   * @public
   */
  static loadImage(t) {
    return new Promise((e, r) => {
      const i = Xx();
      i.onload = () => e(i), i.onerror = (s) => {
        console.error(s), r(new Error("Could not load image"));
      }, i.crossOrigin = "anonymous", i.referrerPolicy = "strict-origin-when-cross-origin", i.src = t;
    });
  }
  /**
   * Get the size of a video blob
   *
   * @param src - A SharedBlob containing the video
   * @public
   */
  static async getVideoSize(t) {
    return mh.usingObjectURL(t, async (e) => {
      const r = await mh.loadVideo(e);
      return { w: r.videoWidth, h: r.videoHeight };
    });
  }
  /**
   * Get the size of an image blob
   *
   * @param dataURL - A Blob containing the image.
   * @public
   */
  static async getImageSize(t) {
    const e = await mh.usingObjectURL(t, mh.loadImage);
    try {
      if (t.type === "image/png") {
        const r = new DataView(await t.arrayBuffer());
        if (ph.isPng(r, 0)) {
          const i = ph.findChunk(r, "pHYs");
          if (i) {
            const s = ph.parsePhys(r, i.dataOffset);
            if (s.unit === 0 && s.ppux === s.ppuy) {
              const o = Math.max(s.ppux / 2834.5, 1);
              return {
                w: Math.round(e.naturalWidth / o),
                h: Math.round(e.naturalHeight / o)
              };
            }
          }
        }
      }
    } catch (r) {
      return console.error(r), { w: e.naturalWidth, h: e.naturalHeight };
    }
    return { w: e.naturalWidth, h: e.naturalHeight };
  }
  static async isAnimated(t) {
    return t.type === "image/gif" ? Tme(await t.arrayBuffer()) : t.type === "image/avif" ? Eme(await t.arrayBuffer()) : t.type === "image/webp" ? kme(await t.arrayBuffer()) : t.type === "image/apng" ? Cme(await t.arrayBuffer()) : !1;
  }
  static isAnimatedImageType(t) {
    return gG.includes(t || "");
  }
  static isStaticImageType(t) {
    return pG.includes(t || "");
  }
  static isVectorImageType(t) {
    return fG.includes(t || "");
  }
  static isImageType(t) {
    return Zz.includes(t);
  }
  static async usingObjectURL(t, e) {
    const r = URL.createObjectURL(t);
    try {
      return await e(r);
    } finally {
      URL.revokeObjectURL(r);
    }
  }
}
function Il(n, t, e) {
  return n + (t - n) * e;
}
function dd(n = "") {
  let t = 0, e = 0, r = 0, i = 0;
  function s() {
    const o = t ^ t << 11;
    return t = e, e = r, r = i, i ^= (i >>> 19 ^ o ^ o >>> 8) >>> 0, i / 4294967296 * 2;
  }
  for (let o = 0; o < n.length + 64; o++)
    t ^= n.charCodeAt(o) | 0, s();
  return s;
}
function qx(n, t, e, r = !1) {
  const [i, s] = t, [o, l] = e, u = o + (n - i) / (s - i) * (l - o);
  return r ? o < l ? Math.max(Math.min(u, l), o) : Math.max(Math.min(u, o), l) : u;
}
function xh(n, t) {
  return Object.prototype.hasOwnProperty.call(n, t);
}
function Dl(n, t) {
  if (xh(n, t))
    return n[t];
}
function Y8(n) {
  return Object.keys(n);
}
function zi(n) {
  return Object.values(n);
}
function Fl(n) {
  return Object.entries(n);
}
function vG(n) {
  return Object.fromEntries(n);
}
function _1(n, t) {
  const e = {};
  let r = !1;
  for (const [i, s] of Fl(n))
    t(i, s) ? e[i] = s : r = !0;
  return r ? e : n;
}
function NT(n, t) {
  const e = {};
  for (const [r, i] of Fl(n)) {
    const s = t(r, i);
    e[r] = s;
  }
  return e;
}
function yG(n, t) {
  if (n === t) return !0;
  const e = new Set(Object.keys(n)), r = new Set(Object.keys(t));
  if (e.size !== r.size) return !1;
  for (const i of e)
    if (!r.has(i) || !Object.is(n[i], t[i])) return !1;
  return !0;
}
const gc = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", SG = "a0", bG = "A00000000000000000000000000";
function xG(n) {
  if (n >= "a" && n <= "z")
    return n.charCodeAt(0) - 97 + 2;
  if (n >= "A" && n <= "Z")
    return 90 - n.charCodeAt(0) + 2;
  throw new Error("Invalid index key head: " + n);
}
function wG(n) {
  if (n.length !== xG(n.charAt(0)))
    throw new Error("invalid integer part of index key: " + n);
}
function X8(n) {
  if (n === void 0) throw Error("n is undefined");
}
function q8(n) {
  wG(n);
  const [t, ...e] = n.split("");
  let r = !0;
  for (let i = e.length - 1; r && i >= 0; i--) {
    const s = gc.indexOf(e[i]) + 1;
    s === gc.length ? e[i] = "0" : (e[i] = gc.charAt(s), r = !1);
  }
  if (r) {
    if (t === "Z") return "a0";
    if (t === "z") return;
    const i = String.fromCharCode(t.charCodeAt(0) + 1);
    return i > "a" ? e.push("0") : e.pop(), i + e.join("");
  } else
    return t + e.join("");
}
function Rme(n) {
  wG(n);
  const [t, ...e] = n.split("");
  let r = !0;
  for (let i = e.length - 1; r && i >= 0; i--) {
    const s = gc.indexOf(e[i]) - 1;
    s === -1 ? e[i] = gc.slice(-1) : (e[i] = gc.charAt(s), r = !1);
  }
  if (r) {
    if (t === "a") return "Z" + gc.slice(-1);
    if (t === "A") return;
    const i = String.fromCharCode(t.charCodeAt(0) - 1);
    return i < "Z" ? e.push(gc.slice(-1)) : e.pop(), i + e.join("");
  } else
    return t + e.join("");
}
function L0(n, t) {
  if (t !== void 0 && n >= t)
    throw new Error(n + " >= " + t);
  if (n.slice(-1) === "0" || t && t.slice(-1) === "0")
    throw new Error("trailing zero");
  if (t) {
    let i = 0;
    for (; (n.charAt(i) || "0") === t.charAt(i); )
      i++;
    if (i > 0)
      return t.slice(0, i) + L0(n.slice(i), t.slice(i));
  }
  const e = n ? gc.indexOf(n.charAt(0)) : 0, r = t !== void 0 ? gc.indexOf(t.charAt(0)) : gc.length;
  if (r - e > 1) {
    const i = Math.round(0.5 * (e + r));
    return gc.charAt(i);
  } else
    return t && t.length > 1 ? t.slice(0, 1) : gc.charAt(e) + L0(n.slice(1), void 0);
}
function XE(n) {
  const t = xG(n.charAt(0));
  if (t > n.length)
    throw new Error("invalid index: " + n);
  return n.slice(0, t);
}
function a3(n) {
  if (n === bG)
    throw new Error("invalid index: " + n);
  const t = XE(n);
  if (n.slice(t.length).slice(-1) === "0")
    throw new Error("invalid index: " + n);
}
function g0(n, t) {
  if (n !== void 0 && a3(n), t !== void 0 && a3(t), n !== void 0 && t !== void 0 && n >= t)
    throw new Error(n + " >= " + t);
  if (n === void 0 && t === void 0)
    return SG;
  if (n === void 0) {
    if (t === void 0) throw Error("b is undefined");
    const l = XE(t), u = t.slice(l.length);
    if (l === bG)
      return l + L0("", u);
    if (l < t)
      return l;
    const d = Rme(l);
    return X8(d), d;
  }
  if (t === void 0) {
    const l = XE(n), u = n.slice(l.length), d = q8(l);
    return d === void 0 ? l + L0(u, void 0) : d;
  }
  const e = XE(n), r = n.slice(e.length), i = XE(t), s = t.slice(i.length);
  if (e === i)
    return e + L0(r, s);
  const o = q8(e);
  return X8(o), o < t ? o : e + L0(r, void 0);
}
function Sm(n, t, e) {
  if (e === 0) return [];
  if (e === 1) return [g0(n, t)];
  if (t === void 0) {
    let s = g0(n, t);
    const o = [s];
    for (let l = 0; l < e - 1; l++)
      s = g0(s, t), o.push(s);
    return o;
  }
  if (n === void 0) {
    let s = g0(n, t);
    const o = [s];
    for (let l = 0; l < e - 1; l++)
      s = g0(n, s), o.push(s);
    return o.reverse(), o;
  }
  const r = Math.floor(e / 2), i = g0(n, t);
  return [...Sm(n, i, r), i, ...Sm(i, t, e - r - 1)];
}
const CG = SG;
function Mme(n) {
  a3(n);
}
function Zx(n, t, e) {
  return Sm(n, t, e);
}
function CN(n, t) {
  return Sm(n, void 0, t);
}
function $1(n, t) {
  return Sm(n, t, 1)[0];
}
function id(n) {
  return Sm(n, void 0, 1)[0];
}
function Dme(n) {
  return Sm(void 0, n, 1)[0];
}
function z1(n, t = "a1") {
  return [t, ...Sm(t, void 0, n)];
}
function fa(n, t) {
  return n.index < t.index ? -1 : n.index > t.index ? 1 : 0;
}
function Ome(n, t) {
  return n.id > t.id ? 1 : -1;
}
function Qz(n) {
  try {
    return localStorage.getItem(n);
  } catch {
    return null;
  }
}
function Jz(n, t) {
  try {
    localStorage.setItem(n, t);
  } catch {
  }
}
function Lme() {
  try {
    localStorage.clear();
  } catch {
  }
}
function EG(n) {
  try {
    return sessionStorage.getItem(n);
  } catch {
    return null;
  }
}
function e5(n, t) {
  try {
    sessionStorage.setItem(n, t);
  } catch {
  }
}
function _G(n) {
  try {
    sessionStorage.removeItem(n);
  } catch {
  }
}
function jme() {
  try {
    sessionStorage.clear();
  } catch {
  }
}
const Nme = () => typeof process < "u" && process.env.NODE_ENV === "test" && // @ts-expect-error
!globalThis.__FORCE_RAF_IN_TESTS__, j0 = [], Fme = 60, YI = Math.ceil(1e3 / Fme);
let TE, EN = 0, l3 = 0;
const $me = () => {
  const n = j0.splice(0, j0.length);
  for (const t of n)
    t();
};
function TG() {
  if (TE)
    return;
  const n = Date.now(), t = n - l3;
  if (EN + t < YI) {
    TE = requestAnimationFrame(() => {
      TE = void 0, TG();
    });
    return;
  }
  TE = requestAnimationFrame(() => {
    TE = void 0, l3 = n, EN = Math.min(EN + t - YI, YI * 10), $me();
  });
}
let Z8 = !1;
function PG(n) {
  return Nme() ? (n(), () => {
  }) : (j0.includes(n) || (j0.push(n), Z8 || (Z8 = !0, l3 = Date.now() - YI - 1), TG()), () => {
    const t = j0.indexOf(n);
    t > -1 && j0.splice(t, 1);
  });
}
class zme {
  constructor() {
    T(this, "timeouts", []);
    T(this, "intervals", []);
    T(this, "rafs", []);
  }
  /** @public */
  setTimeout(t, e, ...r) {
    const i = window.setTimeout(t, e, r);
    return this.timeouts.push(i), i;
  }
  /** @public */
  setInterval(t, e, ...r) {
    const i = window.setInterval(t, e, r);
    return this.intervals.push(i), i;
  }
  /** @public */
  requestAnimationFrame(t) {
    const e = window.requestAnimationFrame(t);
    return this.rafs.push(e), e;
  }
  /** @public */
  dispose() {
    this.timeouts.forEach((t) => clearTimeout(t)), this.intervals.forEach((t) => clearInterval(t)), this.rafs.forEach((t) => cancelAnimationFrame(t)), this.timeouts.length = 0, this.intervals.length = 0, this.rafs.length = 0;
  }
}
function Ume(n) {
  return n !== null;
}
function Bme() {
  return typeof globalThis < "u" && globalThis.structuredClone ? [globalThis.structuredClone, !0] : typeof global < "u" && global.structuredClone ? [global.structuredClone, !0] : typeof window < "u" && window.structuredClone ? [window.structuredClone, !0] : [(n) => n && JSON.parse(JSON.stringify(n)), !1];
}
const AG = Bme(), ni = AG[0];
AG[1];
const kG = Object.getPrototypeOf(ni({})), t5 = {
  enableLicensing: Hme("enableLicensing", {
    defaults: { all: !0, production: !1 }
  })
}, IG = Cl(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: !1
  }
), qi = {
  // --- DEBUG VALUES ---
  logPreventDefaults: Cl("logPreventDefaults", {
    defaults: { all: !1 }
  }),
  logPointerCaptures: Cl("logPointerCaptures", {
    defaults: { all: !1 }
  }),
  logElementRemoves: Cl("logElementRemoves", {
    defaults: { all: !1 }
  }),
  debugSvg: Cl("debugSvg", {
    defaults: { all: !1 }
  }),
  showFps: Cl("showFps", {
    defaults: { all: !1 }
  }),
  measurePerformance: Cl("measurePerformance", { defaults: { all: !1 } }),
  throwToBlob: Cl("throwToBlob", {
    defaults: { all: !1 }
  }),
  reconnectOnPing: Cl("reconnectOnPing", {
    defaults: { all: !1 }
  }),
  debugCursors: Cl("debugCursors", {
    defaults: { all: !1 }
  }),
  forceSrgb: Cl("forceSrgbColors", { defaults: { all: !1 } }),
  debugGeometry: Cl("debugGeometry", { defaults: { all: !1 } }),
  hideShapes: Cl("hideShapes", { defaults: { all: !1 } }),
  editOnType: Cl("editOnType", { defaults: { all: !1 } })
};
if (typeof Element < "u") {
  const n = Element.prototype.removeChild;
  bS("element removal logging", () => {
    qi.logElementRemoves.get() ? Element.prototype.removeChild = function(t) {
      return console.warn("[tldraw] removing child:", t), n.call(this, t);
    } : Element.prototype.removeChild = n;
  });
}
function Cl(n, {
  defaults: t,
  shouldStoreForSession: e = !0
}) {
  return RG({
    name: n,
    defaults: t,
    shouldStoreForSession: e
  });
}
function Hme(n, {
  defaults: t,
  shouldStoreForSession: e = !0
}) {
  return RG({
    name: n,
    defaults: t,
    shouldStoreForSession: e
  });
}
function RG(n) {
  const t = Wme(n), e = n.shouldStoreForSession ? Vme(n.name) : null, r = Qs(`debug:${n.name}`, e ?? t);
  return typeof window < "u" && (n.shouldStoreForSession && bS(`debug:${n.name}`, () => {
    const i = r.get();
    i === t ? _G(`tldraw_debug:${n.name}`) : e5(`tldraw_debug:${n.name}`, JSON.stringify(i));
  }), Object.defineProperty(window, `tldraw${n.name.replace(/^[a-z]/, (i) => i.toUpperCase())}`, {
    get() {
      return r.get();
    },
    set(i) {
      r.set(i);
    },
    configurable: !0
  })), Object.assign(r, n);
}
function Vme(n) {
  try {
    return JSON.parse(EG(`tldraw_debug:${n}`) ?? "null");
  } catch {
    return null;
  }
}
function _N(n) {
  try {
    return n();
  } catch {
    return null;
  }
}
function Wme(n) {
  switch (_N(() => process.env.TLDRAW_ENV) ?? _N(() => process.env.VERCEL_PUBLIC_TLDRAW_ENV) ?? _N(() => process.env.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production") {
    case "production":
      return n.defaults.production ?? n.defaults.all;
    case "preview":
    case "staging":
      return n.defaults.staging ?? n.defaults.all;
    default:
      return n.defaults.development ?? n.defaults.all;
  }
}
class XI {
  constructor(t) {
    /**
     * The next value of the set.
     *
     * @internal
     */
    T(this, "nextValue");
    /**
     * The diff of the set.
     *
     * @internal
     */
    T(this, "diff");
    this.previousValue = t;
  }
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    var r, i, s, o;
    const t = ((i = (r = this.diff) == null ? void 0 : r.removed) == null ? void 0 : i.size) ?? 0, e = ((o = (s = this.diff) == null ? void 0 : s.added) == null ? void 0 : o.size) ?? 0;
    if (!(t === 0 && e === 0))
      return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(t, e) {
    var r, i;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.add(t), this.diff ?? (this.diff = {}), e ? (r = this.diff.removed) == null || r.delete(t) : ((i = this.diff).added ?? (i.added = /* @__PURE__ */ new Set()), this.diff.added.add(t));
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @public
   */
  add(t) {
    var i, s, o;
    const e = this.previousValue.has(t);
    if (e)
      return ((s = (i = this.diff) == null ? void 0 : i.removed) == null ? void 0 : s.has(t)) ? this._add(t, e) : void 0;
    (o = this.nextValue) != null && o.has(t) || this._add(t, e);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(t, e) {
    var r, i;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.delete(t), this.diff ?? (this.diff = {}), e ? ((r = this.diff).removed ?? (r.removed = /* @__PURE__ */ new Set()), this.diff.removed.add(t)) : (i = this.diff.added) == null || i.delete(t);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @public
   */
  remove(t) {
    var i, s, o, l;
    const e = this.previousValue.has(t);
    if (!e)
      return ((s = (i = this.diff) == null ? void 0 : i.added) == null ? void 0 : s.has(t)) ? this._remove(t, e) : void 0;
    (l = (o = this.diff) == null ? void 0 : o.removed) != null && l.has(t) || this._remove(t, e);
  }
}
let FT = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((t, e) => (e &= 63, e < 36 ? t += e.toString(36) : e < 62 ? t += (e - 26).toString(36).toUpperCase() : e > 62 ? t += "-" : t += "_", t), "");
class T2 {
  constructor(t, e) {
    T(this, "createDefaultProperties");
    T(this, "validator");
    T(this, "ephemeralKeys");
    T(this, "ephemeralKeySet");
    T(this, "scope");
    /**
     * Check whether a record is an instance of this record type.
     *
     * @example
     *
     * ```ts
     * const result = recordType.isInstance(someRecord)
     * ```
     *
     * @param record - The record to check.
     * @returns Whether the record is an instance of this record type.
     */
    T(this, "isInstance", (t) => (t == null ? void 0 : t.typeName) === this.typeName);
    this.typeName = t, this.createDefaultProperties = e.createDefaultProperties, this.validator = e.validator ?? { validate: (i) => i }, this.scope = e.scope ?? "document", this.ephemeralKeys = e.ephemeralKeys;
    const r = /* @__PURE__ */ new Set();
    if (e.ephemeralKeys)
      for (const [i, s] of Fl(e.ephemeralKeys))
        s && r.add(i);
    this.ephemeralKeySet = r;
  }
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   * @returns The new record.
   */
  create(t) {
    const e = { ...this.createDefaultProperties(), id: this.createId() };
    for (const [r, i] of Object.entries(t))
      i !== void 0 && (e[r] = i);
    return e.typeName = this.typeName, e;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @returns The cloned record.
   * @public
   */
  clone(t) {
    return { ...ni(t), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(t) {
    return this.typeName + ":" + (t ?? FT());
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createCustomId('myId')
   * ```
   *
   * @deprecated - Use `createId` instead.
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(t) {
    return this.typeName + ":" + t;
  }
  /**
   * Takes an id like `user:123` and returns the part after the colon `123`
   *
   * @param id - The id
   * @returns
   */
  parseId(t) {
    if (!this.isId(t))
      throw new Error(`ID "${t}" is not a valid ID for type "${this.typeName}"`);
    return t.slice(this.typeName.length + 1);
  }
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isIn('someId')
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(t) {
    if (!t) return !1;
    for (let e = 0; e < this.typeName.length; e++)
      if (t[e] !== this.typeName[e]) return !1;
    return t[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param fn - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(t) {
    return new T2(this.typeName, {
      createDefaultProperties: t,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Check that the passed in record passes the validations for this type. Returns its input
   * correctly typed if it does, but throws an error otherwise.
   */
  validate(t, e) {
    return e && this.validator.validateUsingKnownGoodVersion ? this.validator.validateUsingKnownGoodVersion(e, t) : this.validator.validate(t);
  }
}
function Oh(n, t) {
  return new T2(n, {
    createDefaultProperties: () => ({}),
    validator: t.validator,
    scope: t.scope,
    ephemeralKeys: t.ephemeralKeys
  });
}
function uM() {
  return { added: {}, updated: {}, removed: {} };
}
function c3(n) {
  const t = { added: n.removed, removed: n.added, updated: {} };
  for (const [e, r] of Object.values(n.updated))
    t.updated[e.id] = [r, e];
  return t;
}
function MG(n) {
  return Object.keys(n.added).length === 0 && Object.keys(n.updated).length === 0 && Object.keys(n.removed).length === 0;
}
function n5(n) {
  const t = { added: {}, removed: {}, updated: {} };
  return T1(t, n), t;
}
function T1(n, t) {
  for (const e of t) {
    for (const [r, i] of Fl(e.added))
      if (n.removed[r]) {
        const s = n.removed[r];
        delete n.removed[r], s !== i && (n.updated[r] = [s, i]);
      } else
        n.added[r] = i;
    for (const [r, [i, s]] of Fl(e.updated)) {
      if (n.added[r]) {
        n.added[r] = s, delete n.updated[r], delete n.removed[r];
        continue;
      }
      if (n.updated[r]) {
        n.updated[r] = [n.updated[r][0], s], delete n.removed[r];
        continue;
      }
      n.updated[r] = e.updated[r], delete n.removed[r];
    }
    for (const [r, i] of Fl(e.removed))
      n.added[r] ? delete n.added[r] : n.updated[r] ? (n.removed[r] = n.updated[r][0], delete n.updated[r]) : n.removed[r] = i;
  }
}
var dM = { exports: {} };
dM.exports;
(function(n, t) {
  var e = 200, r = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, l = "[object Arguments]", u = "[object Array]", d = "[object AsyncFunction]", f = "[object Boolean]", m = "[object Date]", v = "[object Error]", S = "[object Function]", w = "[object GeneratorFunction]", E = "[object Map]", A = "[object Number]", P = "[object Null]", R = "[object Object]", M = "[object Promise]", j = "[object Proxy]", $ = "[object RegExp]", U = "[object Set]", F = "[object String]", B = "[object Symbol]", G = "[object Undefined]", X = "[object WeakMap]", te = "[object ArrayBuffer]", ne = "[object DataView]", K = "[object Float32Array]", Z = "[object Float64Array]", oe = "[object Int8Array]", fe = "[object Int16Array]", ie = "[object Int32Array]", ue = "[object Uint8Array]", Se = "[object Uint8ClampedArray]", ke = "[object Uint16Array]", ce = "[object Uint32Array]", ye = /[\\^$.*+?()[\]{}|]/g, Fe = /^\[object .+?Constructor\]$/, Xe = /^(?:0|[1-9]\d*)$/, je = {};
  je[K] = je[Z] = je[oe] = je[fe] = je[ie] = je[ue] = je[Se] = je[ke] = je[ce] = !0, je[l] = je[u] = je[te] = je[f] = je[ne] = je[m] = je[v] = je[S] = je[E] = je[A] = je[R] = je[$] = je[U] = je[F] = je[X] = !1;
  var nt = typeof ga == "object" && ga && ga.Object === Object && ga, Ze = typeof self == "object" && self && self.Object === Object && self, tt = nt || Ze || Function("return this")(), et = t && !t.nodeType && t, at = et && !0 && n && !n.nodeType && n, Yt = at && at.exports === et, Un = Yt && nt.process, pt = function() {
    try {
      return Un && Un.binding && Un.binding("util");
    } catch {
    }
  }(), Ut = pt && pt.isTypedArray;
  function jt(se, ve) {
    for (var $e = -1, st = se == null ? 0 : se.length, Vn = 0, Zt = []; ++$e < st; ) {
      var pr = se[$e];
      ve(pr, $e, se) && (Zt[Vn++] = pr);
    }
    return Zt;
  }
  function $t(se, ve) {
    for (var $e = -1, st = ve.length, Vn = se.length; ++$e < st; )
      se[Vn + $e] = ve[$e];
    return se;
  }
  function yn(se, ve) {
    for (var $e = -1, st = se == null ? 0 : se.length; ++$e < st; )
      if (ve(se[$e], $e, se))
        return !0;
    return !1;
  }
  function hi(se, ve) {
    for (var $e = -1, st = Array(se); ++$e < se; )
      st[$e] = ve($e);
    return st;
  }
  function Nr(se) {
    return function(ve) {
      return se(ve);
    };
  }
  function fi(se, ve) {
    return se.has(ve);
  }
  function oi(se, ve) {
    return se == null ? void 0 : se[ve];
  }
  function es(se) {
    var ve = -1, $e = Array(se.size);
    return se.forEach(function(st, Vn) {
      $e[++ve] = [Vn, st];
    }), $e;
  }
  function Di(se, ve) {
    return function($e) {
      return se(ve($e));
    };
  }
  function Ss(se) {
    var ve = -1, $e = Array(se.size);
    return se.forEach(function(st) {
      $e[++ve] = st;
    }), $e;
  }
  var wi = Array.prototype, ts = Function.prototype, On = Object.prototype, Kr = tt["__core-js_shared__"], ns = ts.toString, vr = On.hasOwnProperty, Je = function() {
    var se = /[^.]+$/.exec(Kr && Kr.keys && Kr.keys.IE_PROTO || "");
    return se ? "Symbol(src)_1." + se : "";
  }(), It = On.toString, hn = RegExp(
    "^" + ns.call(vr).replace(ye, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Bn = Yt ? tt.Buffer : void 0, Ln = tt.Symbol, Yr = tt.Uint8Array, kr = On.propertyIsEnumerable, rs = wi.splice, wn = Ln ? Ln.toStringTag : void 0, is = Object.getOwnPropertySymbols, Zn = Bn ? Bn.isBuffer : void 0, Qn = Di(Object.keys, Object), so = Ca(tt, "DataView"), ss = Ca(tt, "Map"), Za = Ca(tt, "Promise"), Hl = Ca(tt, "Set"), Ec = Ca(tt, "WeakMap"), oo = Ca(Object, "create"), _c = gi(so), ao = gi(ss), Qa = gi(Za), lo = gi(Hl), xa = gi(Ec), os = Ln ? Ln.prototype : void 0, bs = os ? os.valueOf : void 0;
  function as(se) {
    var ve = -1, $e = se == null ? 0 : se.length;
    for (this.clear(); ++ve < $e; ) {
      var st = se[ve];
      this.set(st[0], st[1]);
    }
  }
  function Ja() {
    this.__data__ = oo ? oo(null) : {}, this.size = 0;
  }
  function de(se) {
    var ve = this.has(se) && delete this.__data__[se];
    return this.size -= ve ? 1 : 0, ve;
  }
  function Be(se) {
    var ve = this.__data__;
    if (oo) {
      var $e = ve[se];
      return $e === r ? void 0 : $e;
    }
    return vr.call(ve, se) ? ve[se] : void 0;
  }
  function Ke(se) {
    var ve = this.__data__;
    return oo ? ve[se] !== void 0 : vr.call(ve, se);
  }
  function Pt(se, ve) {
    var $e = this.__data__;
    return this.size += this.has(se) ? 0 : 1, $e[se] = oo && ve === void 0 ? r : ve, this;
  }
  as.prototype.clear = Ja, as.prototype.delete = de, as.prototype.get = Be, as.prototype.has = Ke, as.prototype.set = Pt;
  function en(se) {
    var ve = -1, $e = se == null ? 0 : se.length;
    for (this.clear(); ++ve < $e; ) {
      var st = se[ve];
      this.set(st[0], st[1]);
    }
  }
  function bn() {
    this.__data__ = [], this.size = 0;
  }
  function Bt(se) {
    var ve = this.__data__, $e = du(ve, se);
    if ($e < 0)
      return !1;
    var st = ve.length - 1;
    return $e == st ? ve.pop() : rs.call(ve, $e, 1), --this.size, !0;
  }
  function fn(se) {
    var ve = this.__data__, $e = du(ve, se);
    return $e < 0 ? void 0 : ve[$e][1];
  }
  function pi(se) {
    return du(this.__data__, se) > -1;
  }
  function fr(se, ve) {
    var $e = this.__data__, st = du($e, se);
    return st < 0 ? (++this.size, $e.push([se, ve])) : $e[st][1] = ve, this;
  }
  en.prototype.clear = bn, en.prototype.delete = Bt, en.prototype.get = fn, en.prototype.has = pi, en.prototype.set = fr;
  function Yn(se) {
    var ve = -1, $e = se == null ? 0 : se.length;
    for (this.clear(); ++ve < $e; ) {
      var st = se[ve];
      this.set(st[0], st[1]);
    }
  }
  function ls() {
    this.size = 0, this.__data__ = {
      hash: new as(),
      map: new (ss || en)(),
      string: new as()
    };
  }
  function el(se) {
    var ve = Cn(this, se).delete(se);
    return this.size -= ve ? 1 : 0, ve;
  }
  function Hn(se) {
    return Cn(this, se).get(se);
  }
  function Oi(se) {
    return Cn(this, se).has(se);
  }
  function xs(se, ve) {
    var $e = Cn(this, se), st = $e.size;
    return $e.set(se, ve), this.size += $e.size == st ? 0 : 1, this;
  }
  Yn.prototype.clear = ls, Yn.prototype.delete = el, Yn.prototype.get = Hn, Yn.prototype.has = Oi, Yn.prototype.set = xs;
  function on(se) {
    var ve = -1, $e = se == null ? 0 : se.length;
    for (this.__data__ = new Yn(); ++ve < $e; )
      this.add(se[ve]);
  }
  function $o(se) {
    return this.__data__.set(se, r), this;
  }
  function Tc(se) {
    return this.__data__.has(se);
  }
  on.prototype.add = on.prototype.push = $o, on.prototype.has = Tc;
  function co(se) {
    var ve = this.__data__ = new en(se);
    this.size = ve.size;
  }
  function Pc() {
    this.__data__ = new en(), this.size = 0;
  }
  function Us(se) {
    var ve = this.__data__, $e = ve.delete(se);
    return this.size = ve.size, $e;
  }
  function Nh(se) {
    return this.__data__.get(se);
  }
  function ws(se) {
    return this.__data__.has(se);
  }
  function Fh(se, ve) {
    var $e = this.__data__;
    if ($e instanceof en) {
      var st = $e.__data__;
      if (!ss || st.length < e - 1)
        return st.push([se, ve]), this.size = ++$e.size, this;
      $e = this.__data__ = new Yn(st);
    }
    return $e.set(se, ve), this.size = $e.size, this;
  }
  co.prototype.clear = Pc, co.prototype.delete = Us, co.prototype.get = Nh, co.prototype.has = ws, co.prototype.set = Fh;
  function $h(se, ve) {
    var $e = Cr(se), st = !$e && Rc(se), Vn = !$e && !st && xd(se), Zt = !$e && !st && !Vn && Wl(se), pr = $e || st || Vn || Zt, Xr = pr ? hi(se.length, String) : [], gr = Xr.length;
    for (var W in se)
      vr.call(se, W) && !(pr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (W == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Vn && (W == "offset" || W == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Zt && (W == "buffer" || W == "byteLength" || W == "byteOffset") || // Skip index properties.
      Sd(W, gr))) && Xr.push(W);
    return Xr;
  }
  function du(se, ve) {
    for (var $e = se.length; $e--; )
      if (us(se[$e][0], ve))
        return $e;
    return -1;
  }
  function md(se, ve, $e) {
    var st = ve(se);
    return Cr(se) ? st : $t(st, $e(se));
  }
  function zo(se) {
    return se == null ? se === void 0 ? G : P : wn && wn in Object(se) ? fu(se) : Fr(se);
  }
  function Uo(se) {
    return uo(se) && zo(se) == l;
  }
  function cs(se, ve, $e, st, Vn) {
    return se === ve ? !0 : se == null || ve == null || !uo(se) && !uo(ve) ? se !== se && ve !== ve : Ac(se, ve, $e, st, cs, Vn);
  }
  function Ac(se, ve, $e, st, Vn, Zt) {
    var pr = Cr(se), Xr = Cr(ve), gr = pr ? u : ln(se), W = Xr ? u : ln(ve);
    gr = gr == l ? R : gr, W = W == l ? R : W;
    var le = gr == R, Ce = W == R, Pe = gr == W;
    if (Pe && xd(se)) {
      if (!xd(ve))
        return !1;
      pr = !0, le = !1;
    }
    if (Pe && !le)
      return Zt || (Zt = new co()), pr || Wl(se) ? hu(se, ve, $e, st, Vn, Zt) : Vl(se, ve, gr, $e, st, Vn, Zt);
    if (!($e & i)) {
      var He = le && vr.call(se, "__wrapped__"), yt = Ce && vr.call(ve, "__wrapped__");
      if (He || yt) {
        var Qe = He ? se.value() : se, Ct = yt ? ve.value() : ve;
        return Zt || (Zt = new co()), Vn(Qe, Ct, $e, st, Zt);
      }
    }
    return Pe ? (Zt || (Zt = new co()), $m(se, ve, $e, st, Vn, Zt)) : !1;
  }
  function kc(se) {
    if (!zh(se) || tn(se))
      return !1;
    var ve = Ci(se) ? hn : Fe;
    return ve.test(gi(se));
  }
  function Ic(se) {
    return uo(se) && Ea(se.length) && !!je[zo(se)];
  }
  function vd(se) {
    if (!pu(se))
      return Qn(se);
    var ve = [];
    for (var $e in Object(se))
      vr.call(se, $e) && $e != "constructor" && ve.push($e);
    return ve;
  }
  function hu(se, ve, $e, st, Vn, Zt) {
    var pr = $e & i, Xr = se.length, gr = ve.length;
    if (Xr != gr && !(pr && gr > Xr))
      return !1;
    var W = Zt.get(se);
    if (W && Zt.get(ve))
      return W == ve;
    var le = -1, Ce = !0, Pe = $e & s ? new on() : void 0;
    for (Zt.set(se, ve), Zt.set(ve, se); ++le < Xr; ) {
      var He = se[le], yt = ve[le];
      if (st)
        var Qe = pr ? st(yt, He, le, ve, se, Zt) : st(He, yt, le, se, ve, Zt);
      if (Qe !== void 0) {
        if (Qe)
          continue;
        Ce = !1;
        break;
      }
      if (Pe) {
        if (!yn(ve, function(Ct, sn) {
          if (!fi(Pe, sn) && (He === Ct || Vn(He, Ct, $e, st, Zt)))
            return Pe.push(sn);
        })) {
          Ce = !1;
          break;
        }
      } else if (!(He === yt || Vn(He, yt, $e, st, Zt))) {
        Ce = !1;
        break;
      }
    }
    return Zt.delete(se), Zt.delete(ve), Ce;
  }
  function Vl(se, ve, $e, st, Vn, Zt, pr) {
    switch ($e) {
      case ne:
        if (se.byteLength != ve.byteLength || se.byteOffset != ve.byteOffset)
          return !1;
        se = se.buffer, ve = ve.buffer;
      case te:
        return !(se.byteLength != ve.byteLength || !Zt(new Yr(se), new Yr(ve)));
      case f:
      case m:
      case A:
        return us(+se, +ve);
      case v:
        return se.name == ve.name && se.message == ve.message;
      case $:
      case F:
        return se == ve + "";
      case E:
        var Xr = es;
      case U:
        var gr = st & i;
        if (Xr || (Xr = Ss), se.size != ve.size && !gr)
          return !1;
        var W = pr.get(se);
        if (W)
          return W == ve;
        st |= s, pr.set(se, ve);
        var le = hu(Xr(se), Xr(ve), st, Vn, Zt, pr);
        return pr.delete(se), le;
      case B:
        if (bs)
          return bs.call(se) == bs.call(ve);
    }
    return !1;
  }
  function $m(se, ve, $e, st, Vn, Zt) {
    var pr = $e & i, Xr = wa(se), gr = Xr.length, W = wa(ve), le = W.length;
    if (gr != le && !pr)
      return !1;
    for (var Ce = gr; Ce--; ) {
      var Pe = Xr[Ce];
      if (!(pr ? Pe in ve : vr.call(ve, Pe)))
        return !1;
    }
    var He = Zt.get(se);
    if (He && Zt.get(ve))
      return He == ve;
    var yt = !0;
    Zt.set(se, ve), Zt.set(ve, se);
    for (var Qe = pr; ++Ce < gr; ) {
      Pe = Xr[Ce];
      var Ct = se[Pe], sn = ve[Pe];
      if (st)
        var En = pr ? st(sn, Ct, Pe, ve, se, Zt) : st(Ct, sn, Pe, se, ve, Zt);
      if (!(En === void 0 ? Ct === sn || Vn(Ct, sn, $e, st, Zt) : En)) {
        yt = !1;
        break;
      }
      Qe || (Qe = Pe == "constructor");
    }
    if (yt && !Qe) {
      var er = se.constructor, Wn = ve.constructor;
      er != Wn && "constructor" in se && "constructor" in ve && !(typeof er == "function" && er instanceof er && typeof Wn == "function" && Wn instanceof Wn) && (yt = !1);
    }
    return Zt.delete(se), Zt.delete(ve), yt;
  }
  function wa(se) {
    return md(se, Dp, yd);
  }
  function Cn(se, ve) {
    var $e = se.__data__;
    return bd(ve) ? $e[typeof ve == "string" ? "string" : "hash"] : $e.map;
  }
  function Ca(se, ve) {
    var $e = oi(se, ve);
    return kc($e) ? $e : void 0;
  }
  function fu(se) {
    var ve = vr.call(se, wn), $e = se[wn];
    try {
      se[wn] = void 0;
      var st = !0;
    } catch {
    }
    var Vn = It.call(se);
    return st && (ve ? se[wn] = $e : delete se[wn]), Vn;
  }
  var yd = is ? function(se) {
    return se == null ? [] : (se = Object(se), jt(is(se), function(ve) {
      return kr.call(se, ve);
    }));
  } : Bo, ln = zo;
  (so && ln(new so(new ArrayBuffer(1))) != ne || ss && ln(new ss()) != E || Za && ln(Za.resolve()) != M || Hl && ln(new Hl()) != U || Ec && ln(new Ec()) != X) && (ln = function(se) {
    var ve = zo(se), $e = ve == R ? se.constructor : void 0, st = $e ? gi($e) : "";
    if (st)
      switch (st) {
        case _c:
          return ne;
        case ao:
          return E;
        case Qa:
          return M;
        case lo:
          return U;
        case xa:
          return X;
      }
    return ve;
  });
  function Sd(se, ve) {
    return ve = ve ?? o, !!ve && (typeof se == "number" || Xe.test(se)) && se > -1 && se % 1 == 0 && se < ve;
  }
  function bd(se) {
    var ve = typeof se;
    return ve == "string" || ve == "number" || ve == "symbol" || ve == "boolean" ? se !== "__proto__" : se === null;
  }
  function tn(se) {
    return !!Je && Je in se;
  }
  function pu(se) {
    var ve = se && se.constructor, $e = typeof ve == "function" && ve.prototype || On;
    return se === $e;
  }
  function Fr(se) {
    return It.call(se);
  }
  function gi(se) {
    if (se != null) {
      try {
        return ns.call(se);
      } catch {
      }
      try {
        return se + "";
      } catch {
      }
    }
    return "";
  }
  function us(se, ve) {
    return se === ve || se !== se && ve !== ve;
  }
  var Rc = Uo(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Uo : function(se) {
    return uo(se) && vr.call(se, "callee") && !kr.call(se, "callee");
  }, Cr = Array.isArray;
  function Jn(se) {
    return se != null && Ea(se.length) && !Ci(se);
  }
  var xd = Zn || Mc;
  function Bs(se, ve) {
    return cs(se, ve);
  }
  function Ci(se) {
    if (!zh(se))
      return !1;
    var ve = zo(se);
    return ve == S || ve == w || ve == d || ve == j;
  }
  function Ea(se) {
    return typeof se == "number" && se > -1 && se % 1 == 0 && se <= o;
  }
  function zh(se) {
    var ve = typeof se;
    return se != null && (ve == "object" || ve == "function");
  }
  function uo(se) {
    return se != null && typeof se == "object";
  }
  var Wl = Ut ? Nr(Ut) : Ic;
  function Dp(se) {
    return Jn(se) ? $h(se) : vd(se);
  }
  function Bo() {
    return [];
  }
  function Mc() {
    return !1;
  }
  n.exports = Bs;
})(dM, dM.exports);
var Gme = dM.exports;
const Kme = /* @__PURE__ */ Ep(Gme);
function Yme(n) {
  if (n.length === 0) return /* @__PURE__ */ new Set();
  const t = n[0], e = n.slice(1), r = /* @__PURE__ */ new Set();
  for (const i of t)
    e.every((s) => s.has(i)) && r.add(i);
  return r;
}
function Xme(n, t) {
  const e = {};
  for (const r of t)
    n.has(r) || (e.added ?? (e.added = /* @__PURE__ */ new Set()), e.added.add(r));
  for (const r of n)
    t.has(r) || (e.removed ?? (e.removed = /* @__PURE__ */ new Set()), e.removed.add(r));
  return e.added || e.removed ? e : void 0;
}
function Q8(n, t) {
  for (const [e, r] of Object.entries(n)) {
    const i = r, s = t[e];
    if ("eq" in i && s !== i.eq || "neq" in i && s === i.neq || "gt" in i && (typeof s != "number" || s <= i.gt)) return !1;
  }
  return !0;
}
function J8(n, t, e) {
  const r = Object.fromEntries(Object.keys(e).map((i) => [i, /* @__PURE__ */ new Set()]));
  for (const [i, s] of Object.entries(e))
    if ("eq" in s) {
      const l = n.index(t, i).get().get(s.eq);
      if (l)
        for (const u of l)
          r[i].add(u);
    } else if ("neq" in s) {
      const o = n.index(t, i);
      for (const [l, u] of o.get())
        if (l !== s.neq)
          for (const d of u)
            r[i].add(d);
    } else if ("gt" in s) {
      const o = n.index(t, i);
      for (const [l, u] of o.get())
        if (l > s.gt)
          for (const d of u)
            r[i].add(d);
    }
  return Yme(Object.values(r));
}
class qme {
  constructor(t, e) {
    /**
     * A cache of derivations (indexes).
     *
     * @internal
     */
    T(this, "indexCache", /* @__PURE__ */ new Map());
    /**
     * A cache of derivations (filtered histories).
     *
     * @internal
     */
    T(this, "historyCache", /* @__PURE__ */ new Map());
    this.atoms = t, this.history = e;
  }
  /**
   * Create a derivation that contains the history for a given type
   *
   * @param typeName - The name of the type to filter by.
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(t) {
    if (this.historyCache.has(t))
      return this.historyCache.get(t);
    const e = ze(
      "filterHistory:" + t,
      (r, i) => {
        if (Yy(r))
          return this.history.get();
        const s = this.history.getDiffSince(i);
        if (s === mc) return this.history.get();
        const o = { added: {}, removed: {}, updated: {} };
        let l = 0, u = 0, d = 0;
        for (const f of s) {
          for (const m of zi(f.added))
            if (m.typeName === t)
              if (o.removed[m.id]) {
                const v = o.removed[m.id];
                delete o.removed[m.id], u--, v !== m && (o.updated[m.id] = [v, m], d++);
              } else
                o.added[m.id] = m, l++;
          for (const [m, v] of zi(f.updated))
            v.typeName === t && (o.added[v.id] ? o.added[v.id] = v : o.updated[v.id] ? o.updated[v.id] = [o.updated[v.id][0], v] : (o.updated[v.id] = [m, v], d++));
          for (const m of zi(f.removed))
            m.typeName === t && (o.added[m.id] ? (delete o.added[m.id], l--) : o.updated[m.id] ? (o.removed[m.id] = o.updated[m.id][0], delete o.updated[m.id], d--, u++) : (o.removed[m.id] = m, u++));
        }
        return l || u || d ? KE(this.history.get(), o) : r;
      },
      { historyLength: 100 }
    );
    return this.historyCache.set(t, e), e;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   * @public
   */
  index(t, e) {
    const r = t + ":" + e;
    if (this.indexCache.has(r))
      return this.indexCache.get(r);
    const i = this.__uncached_createIndex(t, e);
    return this.indexCache.set(r, i), i;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   * @internal
   */
  __uncached_createIndex(t, e) {
    const r = this.filterHistory(t), i = () => {
      r.get();
      const s = /* @__PURE__ */ new Map();
      for (const o of zi(this.atoms.get())) {
        const l = o.get();
        if (l.typeName === t) {
          const u = l[e];
          s.has(u) || s.set(u, /* @__PURE__ */ new Set()), s.get(u).add(l.id);
        }
      }
      return s;
    };
    return ze(
      "index:" + t + ":" + e,
      (s, o) => {
        if (Yy(s)) return i();
        const l = r.getDiffSince(o);
        if (l === mc)
          return i();
        const u = /* @__PURE__ */ new Map(), d = (S, w) => {
          let E = u.get(S);
          E || (E = new XI(
            s.get(S) ?? /* @__PURE__ */ new Set()
          )), E.add(w), u.set(S, E);
        }, f = (S, w) => {
          let E = u.get(S);
          E || (E = new XI(s.get(S) ?? /* @__PURE__ */ new Set())), E.remove(w), u.set(S, E);
        };
        for (const S of l) {
          for (const w of zi(S.added))
            if (w.typeName === t) {
              const E = w[e];
              d(E, w.id);
            }
          for (const [w, E] of zi(S.updated))
            if (E.typeName === t) {
              const A = w[e], P = E[e];
              A !== P && (f(A, E.id), d(P, E.id));
            }
          for (const w of zi(S.removed))
            if (w.typeName === t) {
              const E = w[e];
              f(E, w.id);
            }
        }
        let m, v;
        for (const [S, w] of u) {
          const E = w.get();
          E && (m || (m = new Map(s)), v || (v = /* @__PURE__ */ new Map()), E.value.size === 0 ? m.delete(S) : m.set(S, E.value), v.set(S, E.diff));
        }
        return m && v ? KE(m, v) : s;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  record(t, e = () => ({}), r = "record:" + t + (e ? ":" + e.toString() : "")) {
    const i = this.ids(t, e, r);
    return ze(r, () => {
      var s;
      for (const o of i.get())
        return (s = this.atoms.get()[o]) == null ? void 0 : s.get();
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(t, e = () => ({}), r = "records:" + t + (e ? ":" + e.toString() : "")) {
    const i = this.ids(t, e, "ids:" + r);
    return ze(r, () => [...i.get()].map((s) => {
      const o = this.atoms.get()[s];
      if (!o)
        throw new Error("no atom found for record id: " + s);
      return o.get();
    }));
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(t, e = () => ({}), r = "ids:" + t + (e ? ":" + e.toString() : "")) {
    const i = this.filterHistory(t), s = () => {
      i.get();
      const u = e();
      return Object.keys(u).length === 0 ? new Set(
        zi(this.atoms.get()).flatMap((d) => {
          const f = d.get();
          return f.typeName === t ? f.id : [];
        })
      ) : J8(this, t, u);
    }, o = (u) => {
      const d = s(), f = Xme(u, d);
      return f ? KE(d, f) : u;
    }, l = ze("ids_query:" + r, e, {
      isEqual: Kme
    });
    return ze(
      "query:" + r,
      (u, d) => {
        const f = l.get();
        if (Yy(u))
          return s();
        if (d < l.lastChangedEpoch)
          return o(u);
        const m = i.getDiffSince(d);
        if (m === mc)
          return o(u);
        const v = new XI(
          u
        );
        for (const w of m) {
          for (const E of zi(w.added))
            E.typeName === t && Q8(f, E) && v.add(E.id);
          for (const [E, A] of zi(w.updated))
            A.typeName === t && (Q8(f, A) ? v.add(A.id) : v.remove(A.id));
          for (const E of zi(w.removed))
            E.typeName === t && v.remove(E.id);
        }
        const S = v.get();
        return S ? KE(S.value, S.diff) : u;
      },
      { historyLength: 50 }
    );
  }
  exec(t, e) {
    const r = J8(this, t, e);
    if (r.size === 0)
      return cp;
    const i = this.atoms.get();
    return [...r].map((s) => i[s].get());
  }
}
class Zme {
  constructor(t) {
    T(this, "_beforeCreateHandlers", {});
    T(this, "_afterCreateHandlers", {});
    T(this, "_beforeChangeHandlers", {});
    T(this, "_afterChangeHandlers", {});
    T(this, "_beforeDeleteHandlers", {});
    T(this, "_afterDeleteHandlers", {});
    T(this, "_operationCompleteHandlers", []);
    T(this, "_isEnabled", !0);
    this.store = t;
  }
  /** @internal */
  isEnabled() {
    return this._isEnabled;
  }
  /** @internal */
  setIsEnabled(t) {
    this._isEnabled = t;
  }
  /** @internal */
  handleBeforeCreate(t, e) {
    if (!this._isEnabled) return t;
    const r = this._beforeCreateHandlers[t.typeName];
    if (r) {
      let i = t;
      for (const s of r)
        i = s(i, e);
      return i;
    }
    return t;
  }
  /** @internal */
  handleAfterCreate(t, e) {
    if (!this._isEnabled) return;
    const r = this._afterCreateHandlers[t.typeName];
    if (r)
      for (const i of r)
        i(t, e);
  }
  /** @internal */
  handleBeforeChange(t, e, r) {
    if (!this._isEnabled) return e;
    const i = this._beforeChangeHandlers[e.typeName];
    if (i) {
      let s = e;
      for (const o of i)
        s = o(t, s, r);
      return s;
    }
    return e;
  }
  /** @internal */
  handleAfterChange(t, e, r) {
    if (!this._isEnabled) return;
    const i = this._afterChangeHandlers[e.typeName];
    if (i)
      for (const s of i)
        s(t, e, r);
  }
  /** @internal */
  handleBeforeDelete(t, e) {
    if (!this._isEnabled) return !0;
    const r = this._beforeDeleteHandlers[t.typeName];
    if (r) {
      for (const i of r)
        if (i(t, e) === !1)
          return !1;
    }
    return !0;
  }
  /** @internal */
  handleAfterDelete(t, e) {
    if (!this._isEnabled) return;
    const r = this._afterDeleteHandlers[t.typeName];
    if (r)
      for (const i of r)
        i(t, e);
  }
  /** @internal */
  handleOperationComplete(t) {
    if (this._isEnabled)
      for (const e of this._operationCompleteHandlers)
        e(t);
  }
  /**
   * Internal helper for registering a bunch of side effects at once and keeping them organized.
   * @internal
   */
  register(t) {
    const e = [];
    for (const [r, i] of Object.entries(t))
      i != null && i.beforeCreate && e.push(this.registerBeforeCreateHandler(r, i.beforeCreate)), i != null && i.afterCreate && e.push(this.registerAfterCreateHandler(r, i.afterCreate)), i != null && i.beforeChange && e.push(this.registerBeforeChangeHandler(r, i.beforeChange)), i != null && i.afterChange && e.push(this.registerAfterChangeHandler(r, i.afterChange)), i != null && i.beforeDelete && e.push(this.registerBeforeDeleteHandler(r, i.beforeDelete)), i != null && i.afterDelete && e.push(this.registerAfterDeleteHandler(r, i.afterDelete));
    return () => {
      for (const r of e) r();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(t, e) {
    return this._beforeCreateHandlers[t] || (this._beforeCreateHandlers[t] = []), this._beforeCreateHandlers[t].push(e), () => Bv(this._beforeCreateHandlers[t], e);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { text: page.name },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(t, e) {
    return this._afterCreateHandlers[t] || (this._afterCreateHandlers[t] = []), this._afterCreateHandlers[t].push(e), () => Bv(this._afterCreateHandlers[t], e);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(t, e) {
    return this._beforeChangeHandlers[t] || (this._beforeChangeHandlers[t] = []), this._beforeChangeHandlers[t].push(e), () => Bv(this._beforeChangeHandlers[t], e);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(t, e) {
    return this._afterChangeHandlers[t] || (this._afterChangeHandlers[t] = []), this._afterChangeHandlers[t].push(e), () => Bv(this._afterChangeHandlers[t], e);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(t, e) {
    return this._beforeDeleteHandlers[t] || (this._beforeDeleteHandlers[t] = []), this._beforeDeleteHandlers[t].push(e), () => Bv(this._beforeDeleteHandlers[t], e);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(t, e) {
    return this._afterDeleteHandlers[t] || (this._afterDeleteHandlers[t] = []), this._afterDeleteHandlers[t].push(e), () => Bv(this._afterDeleteHandlers[t], e);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(t) {
    return this._operationCompleteHandlers.push(t), () => Bv(this._operationCompleteHandlers, t);
  }
}
function Bv(n, t) {
  const e = n.indexOf(t);
  e >= 0 && n.splice(e, 1);
}
function hM(n) {
  if (process.env.NODE_ENV === "production")
    return n;
  const t = Object.getPrototypeOf(n);
  if (t && !(Array.isArray(n) || t === Object.prototype || t === null || t === kG))
    throw console.error("cannot include non-js data in a record", n), new Error("cannot include non-js data in a record");
  const e = Object.getOwnPropertyNames(n);
  for (const r of e) {
    const i = n[r];
    i && typeof i == "object" && hM(i);
  }
  return Object.freeze(n);
}
class r5 {
  constructor(t) {
    /**
     * The random id of the store.
     */
    T(this, "id");
    /**
     * An atom containing the store's atoms.
     *
     * @internal
     * @readonly
     */
    T(this, "atoms", Qs("store_atoms", {}));
    /**
     * An atom containing the store's history.
     *
     * @public
     * @readonly
     */
    T(this, "history", Qs("history", 0, {
      historyLength: 1e3
    }));
    /**
     * A StoreQueries instance for this store.
     *
     * @public
     * @readonly
     */
    T(this, "query", new qme(this.atoms, this.history));
    /**
     * A set containing listeners that have been added to this store.
     *
     * @internal
     */
    T(this, "listeners", /* @__PURE__ */ new Set());
    /**
     * An array of history entries that have not yet been flushed.
     *
     * @internal
     */
    T(this, "historyAccumulator", new Jme());
    /**
     * A reactor that responds to changes to the history by squashing the accumulated history and
     * notifying listeners of the changes.
     *
     * @internal
     */
    T(this, "historyReactor");
    /**
     * Function to dispose of any in-flight timeouts.
     *
     * @internal
     */
    T(this, "cancelHistoryReactor", () => {
    });
    T(this, "schema");
    T(this, "props");
    T(this, "scopedTypes");
    T(this, "sideEffects", new Zme(this));
    /**
     * Add some records to the store. It's an error if they already exist.
     *
     * @param records - The records to add.
     * @public
     */
    T(this, "put", (t, e) => {
      this.atomic(() => {
        const r = {}, i = {}, s = this.atoms.__unsafe__getWithoutCapture();
        let o = null, l, u = !1;
        const d = this.isMergingRemoteChanges ? "remote" : "user";
        for (let f = 0, m = t.length; f < m; f++) {
          l = t[f];
          const v = (o ?? s)[l.id];
          if (v) {
            const S = v.__unsafe__getWithoutCapture();
            if (l = this.sideEffects.handleBeforeChange(S, l, d), this.schema.validateRecord(
              this,
              l,
              e ?? "updateRecord",
              S
            ) === S) continue;
            v.set(hM(l)), u = !0;
            const E = v.__unsafe__getWithoutCapture();
            r[l.id] = [S, E], this.addDiffForAfterEvent(S, E);
          } else
            l = this.sideEffects.handleBeforeCreate(l, d), u = !0, l = this.schema.validateRecord(
              this,
              l,
              e ?? "createRecord",
              null
            ), i[l.id] = l, this.addDiffForAfterEvent(null, l), o || (o = { ...s }), o[l.id] = Qs("atom:" + l.id, l);
        }
        o && this.atoms.set(o), u && this.updateHistory({
          added: i,
          updated: r,
          removed: {}
        });
      });
    });
    /**
     * Remove some records from the store via their ids.
     *
     * @param ids - The ids of the records to remove.
     * @public
     */
    T(this, "remove", (t) => {
      this.atomic(() => {
        const e = /* @__PURE__ */ new Set(), r = this.isMergingRemoteChanges ? "remote" : "user";
        if (this.sideEffects.isEnabled())
          for (const s of t) {
            const o = this.atoms.__unsafe__getWithoutCapture()[s];
            o && this.sideEffects.handleBeforeDelete(o.get(), r) === !1 && e.add(s);
          }
        let i;
        this.atoms.update((s) => {
          let o;
          for (const l of t) {
            if (e.has(l) || !(l in s)) continue;
            o || (o = { ...s }), i || (i = {}), delete o[l];
            const u = s[l].get();
            i[l] = u, this.addDiffForAfterEvent(u, null);
          }
          return o ?? s;
        }), i && this.updateHistory({ added: {}, updated: {}, removed: i });
      });
    });
    /**
     * Get the value of a store record by its id.
     *
     * @param id - The id of the record to get.
     * @public
     */
    T(this, "get", (t) => {
      var e;
      return (e = this.atoms.get()[t]) == null ? void 0 : e.get();
    });
    /**
     * Get the value of a store record by its id without updating its epoch.
     *
     * @param id - The id of the record to get.
     * @public
     */
    T(this, "unsafeGetWithoutCapture", (t) => {
      var e;
      return (e = this.atoms.get()[t]) == null ? void 0 : e.__unsafe__getWithoutCapture();
    });
    /**
     * Creates a JSON payload from the record store.
     *
     * @param scope - The scope of records to serialize. Defaults to 'document'.
     * @returns The record store snapshot as a JSON payload.
     */
    T(this, "serialize", (t = "document") => {
      const e = {};
      for (const [r, i] of Fl(this.atoms.get())) {
        const s = i.get();
        (t === "all" || this.scopedTypes[t].has(s.typeName)) && (e[r] = s);
      }
      return e;
    });
    /**
     * Get an array of all values in the store.
     *
     * @returns An array of all values in the store.
     * @public
     */
    T(this, "allRecords", () => zi(this.atoms.get()).map((t) => t.get()));
    /**
     * Removes all records from the store.
     *
     * @public
     */
    T(this, "clear", () => {
      this.remove(Y8(this.atoms.get()));
    });
    /**
     * Update a record. To update multiple records at once, use the `update` method of the
     * `TypedStore` class.
     *
     * @param id - The id of the record to update.
     * @param updater - A function that updates the record.
     */
    T(this, "update", (t, e) => {
      const r = this.atoms.get()[t];
      if (!r) {
        console.error(`Record ${t} not found. This is probably an error`);
        return;
      }
      this.put([e(r.__unsafe__getWithoutCapture())]);
    });
    /**
     * Get whether the record store has a id.
     *
     * @param id - The id of the record to check.
     * @public
     */
    T(this, "has", (t) => !!this.atoms.get()[t]);
    /**
     * Add a new listener to the store.
     *
     * @param onHistory - The listener to call when the store updates.
     * @param filters - Filters to apply to the listener.
     * @returns A function to remove the listener.
     */
    T(this, "listen", (t, e) => {
      this._flushHistory();
      const r = {
        onHistory: t,
        filters: {
          source: (e == null ? void 0 : e.source) ?? "all",
          scope: (e == null ? void 0 : e.scope) ?? "all"
        }
      };
      return this.listeners.add(r), this.historyReactor.scheduler.isActivelyListening || this.historyReactor.start(), () => {
        this.listeners.delete(r), this.listeners.size === 0 && this.historyReactor.stop();
      };
    });
    T(this, "isMergingRemoteChanges", !1);
    /**
     * Merge changes from a remote source without triggering listeners.
     *
     * @param fn - A function that merges the external changes.
     * @public
     */
    T(this, "mergeRemoteChanges", (t) => {
      if (this.isMergingRemoteChanges)
        return t();
      if (this._isInAtomicOp)
        throw new Error("Cannot merge remote changes while in atomic operation");
      try {
        this.isMergingRemoteChanges = !0, bh(t);
      } finally {
        this.isMergingRemoteChanges = !1;
      }
    });
    /**
     * Create a computed cache.
     *
     * @param name - The name of the derivation cache.
     * @param derive - A function used to derive the value of the cache.
     * @public
     */
    T(this, "createComputedCache", (t, e, r) => {
      const i = new vp();
      return {
        get: (s) => {
          const o = this.atoms.get()[s];
          if (o)
            return i.get(o, () => {
              const l = r ? ze(o.name + ":equals", () => o.get(), { isEqual: r }) : o;
              return ze(t + ":" + s, () => e(l.get()));
            }).get();
        }
      };
    });
    /**
     * Create a computed cache from a selector
     *
     * @param name - The name of the derivation cache.
     * @param selector - A function that returns a subset of the original shape
     * @param derive - A function used to derive the value of the cache.
     * @public
     */
    T(this, "createSelectedComputedCache", (t, e, r) => {
      const i = new vp();
      return {
        get: (s) => {
          const o = this.atoms.get()[s];
          if (o)
            return i.get(o, () => {
              const l = ze(
                t + ":" + s + ":selector",
                () => e(o.get())
              );
              return ze(t + ":" + s, () => r(l.get()));
            }).get();
        }
      };
    });
    T(this, "_integrityChecker");
    T(this, "_isPossiblyCorrupted", !1);
    T(this, "pendingAfterEvents", null);
    T(this, "_isInAtomicOp", !1);
    const { initialData: e, schema: r, id: i } = t;
    this.id = i ?? FT(), this.schema = r, this.props = t.props, e && this.atoms.set(
      vG(
        Fl(e).map(([s, o]) => [
          s,
          Qs(
            "atom:" + s,
            hM(this.schema.validateRecord(this, o, "initialize", null))
          )
        ])
      )
    ), this.historyReactor = Vpe(
      "Store.historyReactor",
      () => {
        this.history.get(), this._flushHistory();
      },
      { scheduleEffect: (s) => this.cancelHistoryReactor = PG(s) }
    ), this.scopedTypes = {
      document: new Set(
        zi(this.schema.types).filter((s) => s.scope === "document").map((s) => s.typeName)
      ),
      session: new Set(
        zi(this.schema.types).filter((s) => s.scope === "session").map((s) => s.typeName)
      ),
      presence: new Set(
        zi(this.schema.types).filter((s) => s.scope === "presence").map((s) => s.typeName)
      )
    };
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const t = this.historyAccumulator.flush();
      for (const { changes: e, source: r } of t) {
        let i = null, s = null, o = null;
        for (const { onHistory: l, filters: u } of this.listeners)
          if (!(u.source !== "all" && u.source !== r))
            if (u.scope !== "all")
              if (u.scope === "document") {
                if (s ?? (s = this.filterChangesByScope(e, "document")), !s) continue;
                l({ changes: s, source: r });
              } else if (u.scope === "session") {
                if (i ?? (i = this.filterChangesByScope(e, "session")), !i) continue;
                l({ changes: i, source: r });
              } else {
                if (o ?? (o = this.filterChangesByScope(e, "presence")), !o) continue;
                l({ changes: o, source: r });
              }
            else
              l({ changes: e, source: r });
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @returns
   */
  filterChangesByScope(t, e) {
    const r = {
      added: _1(t.added, (i, s) => this.scopedTypes[e].has(s.typeName)),
      updated: _1(t.updated, (i, s) => this.scopedTypes[e].has(s[1].typeName)),
      removed: _1(t.removed, (i, s) => this.scopedTypes[e].has(s.typeName))
    };
    return Object.keys(r.added).length === 0 && Object.keys(r.updated).length === 0 && Object.keys(r.removed).length === 0 ? null : r;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(t) {
    this.historyAccumulator.add({
      changes: t,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    }), this.listeners.size === 0 && this.historyAccumulator.clear(), this.history.set(this.history.get() + 1, t);
  }
  validate(t) {
    this.allRecords().forEach((e) => this.schema.validateRecord(this, e, t, null));
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   *
   * @public
   */
  getStoreSnapshot(t = "document") {
    return {
      store: this.serialize(t),
      schema: this.schema.serialize()
    };
  }
  /**
   * @deprecated use `getSnapshot` from the 'tldraw' package instead.
   */
  getSnapshot(t = "document") {
    return console.warn(
      "[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead."
    ), this.getStoreSnapshot(t);
  }
  /**
   * Migrate a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getSnapshot()
   * store.migrateSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  migrateSnapshot(t) {
    const e = this.schema.migrateStoreSnapshot(t);
    if (e.type === "error")
      throw new Error(`Failed to migrate snapshot: ${e.reason}`);
    return {
      store: e.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  loadStoreSnapshot(t) {
    const e = this.schema.migrateStoreSnapshot(t);
    if (e.type === "error")
      throw new Error(`Failed to migrate snapshot: ${e.reason}`);
    const r = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(!1), this.atomic(() => {
        this.clear(), this.put(Object.values(e.value)), this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(r);
    }
  }
  /**
   * @public
   * @deprecated use `loadSnapshot` from the 'tldraw' package instead.
   */
  loadSnapshot(t) {
    console.warn(
      "[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead."
    ), this.loadStoreSnapshot(t);
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(t) {
    const e = [], r = this.historyAccumulator.addInterceptor((i) => e.push(i.changes));
    try {
      return bh(t), n5(e);
    } finally {
      r();
    }
  }
  applyDiff(t, {
    runCallbacks: e = !0,
    ignoreEphemeralKeys: r = !1
  } = {}) {
    this.atomic(() => {
      const i = zi(t.added);
      for (const [o, l] of zi(t.updated)) {
        const u = this.schema.getType(l.typeName);
        if (r && u.ephemeralKeySet.size) {
          const d = this.get(l.id);
          if (!d) {
            i.push(l);
            continue;
          }
          let f = null;
          for (const [m, v] of Object.entries(l))
            u.ephemeralKeySet.has(m) || Object.is(v, Dl(d, m)) || (f || (f = { ...d }), f[m] = v);
          f && i.push(f);
        } else
          i.push(l);
      }
      const s = Y8(t.removed);
      i.length && this.put(i), s.length && this.remove(s);
    }, e);
  }
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      var t;
      this._integrityChecker ?? (this._integrityChecker = this.schema.createIntegrityChecker(this)), (t = this._integrityChecker) == null || t.call(this);
    });
  }
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = !0;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  addDiffForAfterEvent(t, e) {
    if (ii(this.pendingAfterEvents, "must be in event operation"), t === e || (t && e && ii(t.id === e.id), !t && !e)) return;
    const r = (t || e).id, i = this.pendingAfterEvents.get(r);
    i ? i.after = e : this.pendingAfterEvents.set(r, { before: t, after: e });
  }
  flushAtomicCallbacks() {
    let t = 0;
    const e = this.isMergingRemoteChanges ? "remote" : "user";
    for (; this.pendingAfterEvents; ) {
      const r = this.pendingAfterEvents;
      if (this.pendingAfterEvents = null, !!this.sideEffects.isEnabled()) {
        if (t++, t > 100)
          throw new Error("Maximum store update depth exceeded, bailing out");
        for (const { before: i, after: s } of r.values())
          i && s ? this.sideEffects.handleAfterChange(i, s, e) : i && !s ? this.sideEffects.handleAfterDelete(i, e) : !i && s && this.sideEffects.handleAfterCreate(s, e);
        this.pendingAfterEvents || this.sideEffects.handleOperationComplete(e);
      }
    }
  }
  /** @internal */
  atomic(t, e = !0) {
    return bh(() => {
      if (this._isInAtomicOp)
        return this.pendingAfterEvents || (this.pendingAfterEvents = /* @__PURE__ */ new Map()), t();
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const r = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(e ?? r), this._isInAtomicOp = !0;
      try {
        const i = t();
        return this.flushAtomicCallbacks(), i;
      } finally {
        this.pendingAfterEvents = null, this.sideEffects.setIsEnabled(r), this._isInAtomicOp = !1;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(t) {
    return this.historyAccumulator.addInterceptor(
      (e) => t(e, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
}
function Qme(n) {
  if (n.length === 0) return [];
  const t = [];
  let e = [n[0]], r;
  for (let i = 1, s = n.length; i < s; i++)
    r = n[i], e[0].source !== r.source && (t.push(e), e = []), e.push(r);
  return t.push(e), hM(
    t.map((i) => ({
      source: i[0].source,
      changes: n5(i.map((s) => s.changes))
    }))
  );
}
class Jme {
  constructor() {
    T(this, "_history", []);
    T(this, "_interceptors", /* @__PURE__ */ new Set());
  }
  addInterceptor(t) {
    return this._interceptors.add(t), () => {
      this._interceptors.delete(t);
    };
  }
  add(t) {
    this._history.push(t);
    for (const e of this._interceptors)
      e(t);
  }
  flush() {
    const t = Qme(this._history);
    return this._history = [], t;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
}
function eve(n, t, e) {
  const r = new vp();
  return {
    get(i, s) {
      return r.get(i, () => (i instanceof r5 ? i : i.store).createComputedCache(n, (u) => t(i, u), e)).get(s);
    }
  };
}
function tve(n) {
  const t = [];
  for (let e = n.length - 1; e >= 0; e--) {
    const r = n[e];
    if ("id" in r)
      t.unshift(r);
    else {
      const i = r.dependsOn, s = t[0];
      s && (t[0] = {
        ...s,
        dependsOn: i.concat(s.dependsOn ?? [])
      });
    }
  }
  return t;
}
function V0({
  sequence: n,
  sequenceId: t,
  retroactive: e = !0
}) {
  const r = {
    sequenceId: t,
    retroactive: e,
    sequence: tve(n)
  };
  return DG(r), r;
}
function Ul(n, t) {
  return Object.fromEntries(
    Fl(t).map(([e, r]) => [e, `${n}/${r}`])
  );
}
function wc(n) {
  const t = n.sequenceId;
  return V0({
    sequenceId: t,
    retroactive: n.retroactive ?? !0,
    sequence: n.sequence.map(
      (e) => "id" in e ? {
        ...e,
        scope: "record",
        filter: (r) => {
          var i, s;
          return r.typeName === n.recordType && (((i = e.filter) == null ? void 0 : i.call(e, r)) ?? !0) && (((s = n.filter) == null ? void 0 : s.call(n, r)) ?? !0);
        }
      } : e
    )
  });
}
function nve(n) {
  const t = new Map(n.map((s) => [s.id, s])), e = /* @__PURE__ */ new Set(), r = [];
  function i(s) {
    ii(!e.has(s.id), `Circular dependency in migrations: ${s.id}`), e.add(s.id);
    const { version: o, sequenceId: l } = fM(s.id), u = t.get(`${l}/${o - 1}`);
    if (u && i(u), s.dependsOn)
      for (const d of s.dependsOn) {
        const f = t.get(d);
        f && i(f);
      }
    t.delete(s.id), r.push(s);
  }
  for (const s of t.values())
    i(s);
  return r;
}
function fM(n) {
  const [t, e] = n.split("/");
  return { sequenceId: t, version: parseInt(e) };
}
function e9(n, t) {
  t && ii(
    n.startsWith(t + "/"),
    `Every migration in sequence '${t}' must have an id starting with '${t}/'. Got invalid id: '${n}'`
  ), ii(n.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${n}'`);
}
function DG(n) {
  if (ii(
    !n.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${n.sequenceId}`
  ), ii(n.sequenceId.length, "sequenceId must be a non-empty string"), n.sequence.length === 0)
    return;
  e9(n.sequence[0].id, n.sequenceId);
  let t = fM(n.sequence[0].id).version;
  ii(
    t === 1,
    `Expected the first migrationId to be '${n.sequenceId}/1' but got '${n.sequence[0].id}'`
  );
  for (let e = 1; e < n.sequence.length; e++) {
    const r = n.sequence[e].id;
    e9(r, n.sequenceId);
    const i = fM(r).version;
    ii(
      i === t + 1,
      `Migration id numbers must increase in increments of 1, expected ${n.sequenceId}/${t + 1} but got '${n.sequence[e].id}'`
    ), t = i;
  }
}
var Ng = /* @__PURE__ */ ((n) => (n.IncompatibleSubtype = "incompatible-subtype", n.UnknownType = "unknown-type", n.TargetVersionTooNew = "target-version-too-new", n.TargetVersionTooOld = "target-version-too-old", n.MigrationError = "migration-error", n.UnrecognizedSubtype = "unrecognized-subtype", n))(Ng || {});
function rve(n) {
  if (n.schemaVersion > 2 || n.schemaVersion < 1) return gm.err("Bad schema version");
  if (n.schemaVersion === 2) return gm.ok(n);
  const t = {
    schemaVersion: 2,
    sequences: {}
  };
  for (const [e, r] of Object.entries(n.recordVersions))
    if (t.sequences[`com.tldraw.${e}`] = r.version, "subTypeKey" in r)
      for (const [i, s] of Object.entries(r.subTypeVersions))
        t.sequences[`com.tldraw.${e}.${i}`] = s;
  return gm.ok(t);
}
class i5 {
  constructor(t, e) {
    T(this, "migrations", {});
    T(this, "sortedMigrations");
    var i;
    this.types = t, this.options = e;
    for (const s of e.migrations ?? [])
      ii(!this.migrations[s.sequenceId], `Duplicate migration sequenceId ${s.sequenceId}`), DG(s), this.migrations[s.sequenceId] = s;
    const r = Object.values(this.migrations).flatMap((s) => s.sequence);
    this.sortedMigrations = nve(r);
    for (const s of this.sortedMigrations)
      if ((i = s.dependsOn) != null && i.length)
        for (const o of s.dependsOn) {
          const l = r.find((u) => u.id === o);
          ii(l, `Migration '${s.id}' depends on missing migration '${o}'`);
        }
  }
  static create(t, e) {
    return new i5(t, e ?? {});
  }
  validateRecord(t, e, r, i) {
    try {
      const s = Dl(this.types, e.typeName);
      if (!s)
        throw new Error(`Missing definition for record type ${e.typeName}`);
      return s.validate(e, i ?? void 0);
    } catch (s) {
      if (this.options.onValidationFailure)
        return this.options.onValidationFailure({
          store: t,
          record: e,
          phase: r,
          recordBefore: i,
          error: s
        });
      throw s;
    }
  }
  // TODO: use a weakmap to store the result of this function
  getMigrationsSince(t) {
    const e = rve(t);
    if (!e.ok)
      return e;
    const r = e.value, i = new Set(
      // start with any shared sequences
      Object.keys(r.sequences).filter((o) => this.migrations[o])
    );
    for (const o in this.migrations)
      r.sequences[o] === void 0 && this.migrations[o].retroactive && i.add(o);
    if (i.size === 0)
      return gm.ok([]);
    const s = /* @__PURE__ */ new Set();
    for (const o of i) {
      const l = r.sequences[o];
      if (typeof l != "number" && this.migrations[o].retroactive || l === 0) {
        for (const f of this.migrations[o].sequence)
          s.add(f.id);
        continue;
      }
      const u = `${o}/${l}`, d = this.migrations[o].sequence.findIndex((f) => f.id === u);
      if (d === -1)
        return gm.err("Incompatible schema?");
      for (const f of this.migrations[o].sequence.slice(d + 1))
        s.add(f.id);
    }
    return gm.ok(this.sortedMigrations.filter(({ id: o }) => s.has(o)));
  }
  migratePersistedRecord(t, e, r = "up") {
    const i = this.getMigrationsSince(e);
    if (!i.ok)
      return console.error("Error migrating record", i.error), { type: "error", reason: Ng.MigrationError };
    let s = i.value;
    if (s.length === 0)
      return { type: "success", value: t };
    if (s.some((o) => o.scope === "store"))
      return {
        type: "error",
        reason: r === "down" ? Ng.TargetVersionTooOld : Ng.TargetVersionTooNew
      };
    if (r === "down") {
      if (!s.every((o) => o.down))
        return {
          type: "error",
          reason: Ng.TargetVersionTooOld
        };
      s = s.slice().reverse();
    }
    t = ni(t);
    try {
      for (const o of s) {
        if (o.scope === "store") throw new Error(
          /* won't happen, just for TS */
        );
        if (!(o.filter ? o.filter(t) : !0)) continue;
        const u = o[r](t);
        u && (t = ni(u));
      }
    } catch (o) {
      return console.error("Error migrating record", o), { type: "error", reason: Ng.MigrationError };
    }
    return { type: "success", value: t };
  }
  migrateStoreSnapshot(t) {
    let { store: e } = t;
    const r = this.getMigrationsSince(t.schema);
    if (!r.ok)
      return console.error("Error migrating store", r.error), { type: "error", reason: Ng.MigrationError };
    const i = r.value;
    if (i.length === 0)
      return { type: "success", value: e };
    e = ni(e);
    try {
      for (const s of i)
        if (s.scope === "record")
          for (const [o, l] of Object.entries(e)) {
            if (!(s.filter ? s.filter(l) : !0)) continue;
            const d = s.up(l);
            d && (e[o] = ni(d));
          }
        else if (s.scope === "store") {
          const o = s.up(e);
          o && (e = ni(o));
        } else
          ma(s);
    } catch (s) {
      return console.error("Error migrating store", s), { type: "error", reason: Ng.MigrationError };
    }
    return { type: "success", value: e };
  }
  /** @internal */
  createIntegrityChecker(t) {
    var e, r;
    return ((r = (e = this.options).createIntegrityChecker) == null ? void 0 : r.call(e, t)) ?? void 0;
  }
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId: t, sequence: e }) => [
          t,
          e.length ? fM(e.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId: t }) => [t, 0])
      )
    };
  }
  /** @internal */
  getType(t) {
    const e = Dl(this.types, t);
    return ii(e, "record type does not exists"), e;
  }
}
function ive(n) {
  if (!n.length)
    return null;
  let t = "";
  for (const e of n)
    typeof e == "number" ? t += `.${e}` : e.startsWith("(") ? t.endsWith(")") ? t = `${t.slice(0, -1)}, ${e.slice(1)}` : t += e : t += `.${e}`;
  return t = t.replace(/id = [^,]+, /, "").replace(/id = [^)]+/, ""), t.startsWith(".") ? t.slice(1) : t;
}
class Kn extends Error {
  constructor(e, r = []) {
    const i = ive(r), s = e.split(`
`).map((o, l) => l === 0 ? o : `  ${o}`).join(`
`);
    super(r ? `At ${i}: ${s}` : s);
    T(this, "name", "ValidationError");
    this.rawMessage = e, this.path = r;
  }
}
function $l(n, t) {
  try {
    return t();
  } catch (e) {
    throw e instanceof Kn ? new Kn(e.rawMessage, [n, ...e.path]) : new Kn(e.toString(), [n]);
  }
}
function bm(n) {
  if (n === null) return "null";
  if (Array.isArray(n)) return "an array";
  const t = typeof n;
  switch (t) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${t}`;
    case "object":
      return `an ${t}`;
    case "undefined":
      return "undefined";
    default:
      ma(t);
  }
}
class Ka {
  constructor(t, e) {
    this.validationFn = t, this.validateUsingKnownGoodVersionFn = e;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The returned value is
   * guaranteed to be referentially equal to the passed value.
   */
  validate(t) {
    const e = this.validationFn(t);
    if (process.env.NODE_ENV !== "production" && !Object.is(t, e))
      throw new Kn("Validator functions must return the same value they were passed");
    return e;
  }
  validateUsingKnownGoodVersion(t, e) {
    return Object.is(t, e) ? t : this.validateUsingKnownGoodVersionFn ? this.validateUsingKnownGoodVersionFn(t, e) : this.validate(e);
  }
  /** Checks that the passed value is of the correct type. */
  isValid(t) {
    try {
      return this.validate(t), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  nullable() {
    return uve(this);
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  optional() {
    return LG(this);
  }
  /**
   * Refine this validation to a new type. The passed-in validation function should throw an error
   * if the value can't be converted to the new type, or return the new type otherwise.
   */
  refine(t) {
    return new Ka(
      (e) => t(this.validate(e)),
      (e, r) => {
        const i = this.validateUsingKnownGoodVersion(e, r);
        return Object.is(e, i) ? e : t(i);
      }
    );
  }
  check(t, e) {
    return typeof t == "string" ? this.refine((r) => ($l(`(check ${t})`, () => e(r)), r)) : this.refine((r) => (t(r), r));
  }
}
class sve extends Ka {
  constructor(t) {
    super(
      (e) => {
        const r = t9.validate(e);
        for (let i = 0; i < r.length; i++)
          $l(i, () => t.validate(r[i]));
        return r;
      },
      (e, r) => {
        if (!t.validateUsingKnownGoodVersion) return this.validate(r);
        const i = t9.validate(r);
        let s = e.length !== i.length;
        for (let o = 0; o < i.length; o++) {
          const l = i[o];
          if (o >= e.length) {
            s = !0, $l(o, () => t.validate(l));
            continue;
          }
          if (Object.is(e[o], l))
            continue;
          const u = $l(
            o,
            () => t.validateUsingKnownGoodVersion(e[o], l)
          );
          Object.is(u, e[o]) || (s = !0);
        }
        return s ? r : e;
      }
    ), this.itemValidator = t;
  }
  nonEmpty() {
    return this.check((t) => {
      if (t.length === 0)
        throw new Kn("Expected a non-empty array");
    });
  }
  lengthGreaterThan1() {
    return this.check((t) => {
      if (t.length <= 1)
        throw new Kn("Expected an array with length greater than 1");
    });
  }
}
class pM extends Ka {
  constructor(t, e = !1) {
    super(
      (r) => {
        if (typeof r != "object" || r === null)
          throw new Kn(`Expected object, got ${bm(r)}`);
        for (const [i, s] of Object.entries(t))
          $l(i, () => {
            s.validate(Dl(r, i));
          });
        if (!e) {
          for (const i of Object.keys(r))
            if (!xh(t, i))
              throw new Kn("Unexpected property", [i]);
        }
        return r;
      },
      (r, i) => {
        if (typeof i != "object" || i === null)
          throw new Kn(`Expected object, got ${bm(i)}`);
        let s = !1;
        for (const [o, l] of Object.entries(t)) {
          const u = Dl(r, o), d = Dl(i, o);
          if (Object.is(u, d))
            continue;
          const f = $l(o, () => {
            const m = l;
            return m.validateUsingKnownGoodVersion ? m.validateUsingKnownGoodVersion(u, d) : m.validate(d);
          });
          Object.is(f, u) || (s = !0);
        }
        if (!e) {
          for (const o of Object.keys(i))
            if (!xh(t, o))
              throw new Kn("Unexpected property", [o]);
        }
        for (const o of Object.keys(r))
          if (!xh(i, o)) {
            s = !0;
            break;
          }
        return s ? i : r;
      }
    ), this.config = t, this.shouldAllowUnknownProperties = e;
  }
  allowUnknownProperties() {
    return new pM(this.config, !0);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   *
   * ```ts
   * const animalValidator = T.object({
   * 	name: T.string,
   * })
   * const catValidator = animalValidator.extend({
   * 	meowVolume: T.number,
   * })
   * ```
   */
  extend(t) {
    return new pM({ ...this.config, ...t });
  }
}
class P2 extends Ka {
  constructor(t, e, r, i) {
    super(
      (s) => {
        this.expectObject(s);
        const { matchingSchema: o, variant: l } = this.getMatchingSchemaAndVariant(s);
        return o === void 0 ? this.unknownValueValidation(s, l) : $l(`(${t} = ${l})`, () => o.validate(s));
      },
      (s, o) => {
        this.expectObject(o), this.expectObject(s);
        const { matchingSchema: l, variant: u } = this.getMatchingSchemaAndVariant(o);
        return l === void 0 ? this.unknownValueValidation(o, u) : Dl(s, t) !== Dl(o, t) ? $l(`(${t} = ${u})`, () => l.validate(o)) : $l(`(${t} = ${u})`, () => l.validateUsingKnownGoodVersion ? l.validateUsingKnownGoodVersion(s, o) : l.validate(o));
      }
    ), this.key = t, this.config = e, this.unknownValueValidation = r, this.useNumberKeys = i;
  }
  expectObject(t) {
    if (typeof t != "object" || t === null)
      throw new Kn(`Expected an object, got ${bm(t)}`, []);
  }
  getMatchingSchemaAndVariant(t) {
    const e = Dl(t, this.key);
    if (!this.useNumberKeys && typeof e != "string")
      throw new Kn(
        `Expected a string for key "${this.key}", got ${bm(e)}`
      );
    if (this.useNumberKeys && !Number.isFinite(Number(e)))
      throw new Kn(`Expected a number for key "${this.key}", got "${e}"`);
    return { matchingSchema: xh(this.config, e) ? this.config[e] : void 0, variant: e };
  }
  validateUnknownVariants(t) {
    return new P2(this.key, this.config, t, this.useNumberKeys);
  }
}
class ove extends Ka {
  constructor(t, e) {
    super(
      (r) => {
        if (typeof r != "object" || r === null)
          throw new Kn(`Expected object, got ${bm(r)}`);
        for (const [i, s] of Object.entries(r))
          $l(i, () => {
            t.validate(i), e.validate(s);
          });
        return r;
      },
      (r, i) => {
        if (typeof i != "object" || i === null)
          throw new Kn(`Expected object, got ${bm(i)}`);
        let s = !1;
        for (const [o, l] of Object.entries(i)) {
          if (!xh(r, o)) {
            s = !0, $l(o, () => {
              t.validate(o), e.validate(l);
            });
            continue;
          }
          const u = Dl(r, o), d = l;
          if (Object.is(u, d))
            continue;
          const f = $l(o, () => e.validateUsingKnownGoodVersion ? e.validateUsingKnownGoodVersion(u, d) : e.validate(d));
          Object.is(f, u) || (s = !0);
        }
        for (const o of Object.keys(r))
          if (!xh(i, o)) {
            s = !0;
            break;
          }
        return s ? i : r;
      }
    ), this.keyValidator = t, this.valueValidator = e;
  }
}
function s5(n) {
  return new Ka((t) => {
    if (typeof t !== n)
      throw new Kn(`Expected ${n}, got ${bm(t)}`);
    return t;
  });
}
const ave = new Ka((n) => n), vn = s5("string"), Jt = s5("number").check((n) => {
  if (Number.isNaN(n))
    throw new Kn("Expected a number, got NaN");
  if (!Number.isFinite(n))
    throw new Kn(`Expected a finite number, got ${n}`);
}), gM = Jt.check((n) => {
  if (n < 0) throw new Kn(`Expected a positive number, got ${n}`);
}), Qi = Jt.check((n) => {
  if (n <= 0) throw new Kn(`Expected a non-zero positive number, got ${n}`);
}), OG = Jt.check((n) => {
  if (!Number.isInteger(n)) throw new Kn(`Expected an integer, got ${n}`);
}), qI = OG.check((n) => {
  if (n < 0) throw new Kn(`Expected a positive integer, got ${n}`);
}), lve = OG.check((n) => {
  if (n <= 0) throw new Kn(`Expected a non-zero positive integer, got ${n}`);
}), kn = s5("boolean");
function ya(n) {
  return new Ka((t) => {
    if (t !== n)
      throw new Kn(`Expected ${n}, got ${JSON.stringify(t)}`);
    return n;
  });
}
const t9 = new Ka((n) => {
  if (!Array.isArray(n))
    throw new Kn(`Expected an array, got ${bm(n)}`);
  return n;
});
function Ro(n) {
  return new sve(n);
}
function Mn(n) {
  return new pM(n);
}
function u3(n) {
  return typeof n == "object" && n !== null && (Object.getPrototypeOf(n) === Object.prototype || Object.getPrototypeOf(n) === null || Object.getPrototypeOf(n) === kG);
}
function d3(n) {
  return n === null || typeof n == "number" || typeof n == "string" || typeof n == "boolean" ? !0 : Array.isArray(n) ? n.every(d3) : u3(n) ? Object.values(n).every(d3) : !1;
}
const Mo = new Ka(
  (n) => {
    if (d3(n))
      return n;
    throw new Kn(`Expected json serializable value, got ${typeof n}`);
  },
  (n, t) => {
    if (Array.isArray(n) && Array.isArray(t)) {
      let e = n.length !== t.length;
      for (let r = 0; r < t.length; r++) {
        if (r >= n.length) {
          e = !0, Mo.validate(t[r]);
          continue;
        }
        const i = n[r], s = t[r];
        if (Object.is(i, s))
          continue;
        const o = Mo.validateUsingKnownGoodVersion(i, s);
        Object.is(o, i) || (e = !0);
      }
      return e ? t : n;
    } else if (u3(n) && u3(t)) {
      let e = !1;
      for (const r of Object.keys(t)) {
        if (!xh(n, r)) {
          e = !0, Mo.validate(t[r]);
          continue;
        }
        const i = n[r], s = t[r];
        if (Object.is(i, s))
          continue;
        const o = Mo.validateUsingKnownGoodVersion(i, s);
        Object.is(o, i) || (e = !0);
      }
      for (const r of Object.keys(n))
        if (!xh(t, r)) {
          e = !0;
          break;
        }
      return e ? t : n;
    } else
      return Mo.validate(t);
  }
);
function mM(n, t) {
  return new ove(n, t);
}
function o5(n, t) {
  return new P2(
    n,
    t,
    (e, r) => {
      throw new Kn(
        `Expected one of ${Object.keys(t).map((i) => JSON.stringify(i)).join(" or ")}, got ${JSON.stringify(r)}`,
        [n]
      );
    },
    !1
  );
}
function cve(n, t) {
  return new P2(
    n,
    t,
    (e, r) => {
      throw new Kn(
        `Expected one of ${Object.keys(t).map((i) => JSON.stringify(i)).join(" or ")}, got ${JSON.stringify(r)}`,
        [n]
      );
    },
    !0
  );
}
function Lh(n, t) {
  return new Ka(
    (e) => $l(n, () => t.validate(e)),
    (e, r) => $l(n, () => t.validateUsingKnownGoodVersion ? t.validateUsingKnownGoodVersion(e, r) : t.validate(r))
  );
}
function A2(n) {
  return new Ka((t) => {
    if (!n.has(t)) {
      const e = Array.from(n, (r) => JSON.stringify(r)).join(" or ");
      throw new Kn(`Expected ${e}, got ${t}`);
    }
    return t;
  });
}
function LG(n) {
  return new Ka(
    (t) => {
      if (t !== void 0)
        return n.validate(t);
    },
    (t, e) => {
      if (!(t === void 0 && e === void 0) && e !== void 0)
        return n.validateUsingKnownGoodVersion && t !== void 0 ? n.validateUsingKnownGoodVersion(t, e) : n.validate(e);
    }
  );
}
function uve(n) {
  return new Ka(
    (t) => t === null ? null : n.validate(t),
    (t, e) => e === null ? null : n.validateUsingKnownGoodVersion && t !== null ? n.validateUsingKnownGoodVersion(t, e) : n.validate(e)
  );
}
function k2(...n) {
  return A2(new Set(n));
}
function a5(n) {
  try {
    return new URL(n);
  } catch {
    if (n.startsWith("/") || n.startsWith("./"))
      try {
        return new URL(n, "http://example.com");
      } catch {
        throw new Kn(`Expected a valid url, got ${JSON.stringify(n)}`);
      }
    throw new Kn(`Expected a valid url, got ${JSON.stringify(n)}`);
  }
}
const dve = /* @__PURE__ */ new Set(["http:", "https:", "mailto:"]), bc = vn.check((n) => {
  if (n === "") return;
  const t = a5(n);
  if (!dve.has(t.protocol.toLowerCase()))
    throw new Kn(
      `Expected a valid url, got ${JSON.stringify(n)} (invalid protocol)`
    );
}), hve = /* @__PURE__ */ new Set(["http:", "https:", "data:", "asset:"]), Qy = vn.check((n) => {
  if (n === "") return;
  const t = a5(n);
  if (!hve.has(t.protocol.toLowerCase()))
    throw new Kn(
      `Expected a valid url, got ${JSON.stringify(n)} (invalid protocol)`
    );
});
vn.check((n) => {
  if (n === "") return;
  if (!a5(n).protocol.toLowerCase().match(/^https?:$/))
    throw new Kn(
      `Expected a valid url, got ${JSON.stringify(n)} (invalid protocol)`
    );
});
const l5 = vn.refine((n) => {
  try {
    return Mme(n), n;
  } catch {
    throw new Kn(`Expected an index key, got ${JSON.stringify(n)}`);
  }
});
function vc(n) {
  return vn.refine((t) => {
    if (!t.startsWith(`${n}:`))
      throw new Error(`${n} ID must start with "${n}:"`);
    return t;
  });
}
const I2 = vc("asset");
function c5(n, t) {
  return Mn({
    id: I2,
    typeName: ya("asset"),
    type: ya(n),
    props: t,
    meta: Mo
  });
}
const Jy = Mn({
  x: Jt,
  y: Jt,
  z: Jt.optional()
}), P1 = Mn({
  x: Jt,
  y: Jt,
  w: Jt,
  h: Jt
}), jG = Jt.check((n) => {
  if (n < 0 || n > 1)
    throw new Kn("Opacity must be between 0 and 1");
}), fve = vn.refine((n) => {
  if (!n.startsWith("page:") && !n.startsWith("shape:"))
    throw new Error('Parent ID must start with "page:" or "shape:"');
  return n;
}), eu = vc("shape");
function pve(n, t, e) {
  return Mn({
    id: eu,
    typeName: ya("shape"),
    x: Jt,
    y: Jt,
    rotation: Jt,
    index: l5,
    parentId: fve,
    type: ya(n),
    isLocked: kn,
    opacity: jG,
    props: t ? Mn(t) : Mo,
    meta: e ? Mn(e) : Mo
  });
}
const gve = vc("binding");
function mve(n, t, e) {
  return Mn({
    id: gve,
    typeName: ya("binding"),
    type: ya(n),
    fromId: eu,
    toId: eu,
    props: t ? Mn(t) : Mo,
    meta: e ? Mn(e) : Mo
  });
}
Ul("com.tldraw.binding", {});
wc({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function qy(n) {
  return `binding:${FT()}`;
}
function vve(n) {
  return Oh("binding", {
    scope: "document",
    validator: Lh(
      "binding",
      o5(
        "type",
        NT(
          n,
          (t, { props: e, meta: r }) => mve(t, e, r)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}
class No {
  /** @internal */
  constructor(t, e, r) {
    this.id = t, this.defaultValue = e, this.type = r;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(t, e) {
    const { defaultValue: r, type: i = ave } = e;
    return new No(t, r, i);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(t, e) {
    const { defaultValue: r, values: i } = e;
    return new yve(t, r, i);
  }
  setDefaultValue(t) {
    this.defaultValue = t;
  }
  validate(t) {
    return this.type.validate(t);
  }
  validateUsingKnownGoodVersion(t, e) {
    return this.type.validateUsingKnownGoodVersion ? this.type.validateUsingKnownGoodVersion(t, e) : this.validate(e);
  }
}
class yve extends No {
  /** @internal */
  constructor(t, e, r) {
    super(t, e, k2(...r)), this.values = r;
  }
}
const rI = Ul("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
}), Sve = wc({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: rI.AddIsLocked,
      up: (n) => {
        n.isLocked = !1;
      },
      down: (n) => {
        delete n.isLocked;
      }
    },
    {
      id: rI.HoistOpacity,
      up: (n) => {
        n.opacity = Number(n.props.opacity ?? "1"), delete n.props.opacity;
      },
      down: (n) => {
        const t = n.opacity;
        delete n.opacity, n.props.opacity = t < 0.175 ? "0.1" : t < 0.375 ? "0.25" : t < 0.625 ? "0.5" : t < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: rI.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    },
    {
      id: rI.AddWhite,
      up: (n) => {
      },
      down: (n) => {
        n.props.color === "white" && (n.props.color = "black");
      }
    }
  ]
});
function N0(n) {
  return n ? n.typeName === "shape" : !1;
}
function kl(n) {
  return n ? n.startsWith("shape:") : !1;
}
function Ar(n) {
  return `shape:${n ?? FT()}`;
}
function NG(n) {
  const t = /* @__PURE__ */ new Map();
  for (const [e, r] of Object.entries(n))
    if (r instanceof No) {
      if (t.has(r))
        throw new Error(
          `Duplicate style prop ${r.id}. Each style prop can only be used once within a shape.`
        );
      t.set(r, e);
    }
  return t;
}
function hd(n, t) {
  return NT(t, (e, r) => `com.tldraw.shape.${n}/${r}`);
}
function bve(n) {
  return Oh("shape", {
    scope: "document",
    validator: Lh(
      "shape",
      o5(
        "type",
        NT(
          n,
          (t, { props: e, meta: r }) => pve(t, e, r)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: !1,
    opacity: 1,
    meta: {}
  }));
}
function n9(n, t) {
  const e = [];
  for (const [r, { migrations: i }] of Object.entries(t)) {
    const s = `com.tldraw.${n}.${r}`;
    i ? "sequenceId" in i ? (ii(
      s === i.sequenceId,
      `sequenceId mismatch for ${r} ${T2} migrations. Expected '${s}', got '${i.sequenceId}'`
    ), e.push(i)) : "sequence" in i ? e.push(
      V0({
        sequenceId: s,
        retroactive: !1,
        sequence: i.sequence.map(
          (o) => "id" in o ? FG(n, r, o) : o
        )
      })
    ) : e.push(
      V0({
        sequenceId: s,
        retroactive: !1,
        sequence: Object.keys(i.migrators).map((o) => Number(o)).sort((o, l) => o - l).map(
          (o) => ({
            id: `${s}/${o}`,
            scope: "record",
            filter: (l) => l.typeName === n && l.type === r,
            up: (l) => {
              const u = i.migrators[o].up(l);
              if (u)
                return u;
            },
            down: (l) => {
              const u = i.migrators[o].down(l);
              if (u)
                return u;
            }
          })
        )
      })
    ) : e.push(
      V0({
        sequenceId: s,
        retroactive: !1,
        sequence: []
      })
    );
  }
  return e;
}
function FG(n, t, e) {
  return {
    id: e.id,
    dependsOn: e.dependsOn,
    scope: "record",
    filter: (r) => r.typeName === n && r.type === t,
    up: (r) => {
      const i = e.up(r.props);
      i && (r.props = i);
    },
    down: typeof e.down == "function" ? (r) => {
      const i = e.down(r.props);
      i && (r.props = i);
    } : void 0
  };
}
const $G = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
], vM = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "rgb(249, 250, 251)",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      note: {
        fill: "#FCE19C",
        text: "#000000"
      },
      semi: "#e8e8e8",
      pattern: "#494949",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      note: {
        fill: "#8AA3FF",
        text: "#000000"
      },
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlight: {
        srgb: "#10acff",
        p3: "color(display-p3 0.308 0.6632 0.9996)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      note: {
        fill: "#6FC896",
        text: "#000000"
      },
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlight: {
        srgb: "#00ffc8",
        p3: "color(display-p3 0.2536 0.984 0.7981)"
      }
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      note: {
        fill: "#C0CAD3",
        text: "#000000"
      },
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlight: {
        srgb: "#cbe7f1",
        p3: "color(display-p3 0.8163 0.9023 0.9416)"
      }
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      note: {
        fill: "#9BC4FD",
        text: "#000000"
      },
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlight: {
        srgb: "#00f4ff",
        p3: "color(display-p3 0.1512 0.9414 0.9996)"
      }
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      note: {
        fill: "#98D08A",
        text: "#000000"
      },
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlight: {
        srgb: "#65f641",
        p3: "color(display-p3 0.563 0.9495 0.3857)"
      }
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      note: {
        fill: "#F7A5A1",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlight: {
        srgb: "#ff7fa3",
        p3: "color(display-p3 0.9988 0.5301 0.6397)"
      }
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      note: {
        fill: "#DFB0F9",
        text: "#000000"
      },
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlight: {
        srgb: "#ff88ff",
        p3: "color(display-p3 0.9676 0.5652 0.9999)"
      }
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      note: {
        fill: "#FAA475",
        text: "#000000"
      },
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlight: {
        srgb: "#ffa500",
        p3: "color(display-p3 0.9988 0.6905 0.266)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      note: {
        fill: "#FC8282",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#e55959",
      highlight: {
        srgb: "#ff636e",
        p3: "color(display-p3 0.9992 0.4376 0.45)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      note: {
        fill: "#DB91FD",
        text: "#000000"
      },
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlight: {
        srgb: "#c77cff",
        p3: "color(display-p3 0.7469 0.5089 0.9995)"
      }
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      note: {
        fill: "#FED49A",
        text: "#000000"
      },
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      note: {
        fill: "#FFFFFF",
        text: "#000000"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      note: {
        fill: "#2c2c2c",
        text: "#f2f2f2"
      },
      semi: "#2c3036",
      pattern: "#989898",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      note: {
        fill: "#2A3F98",
        text: "#f2f2f2"
      },
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlight: {
        srgb: "#0079d2",
        p3: "color(display-p3 0.0032 0.4655 0.7991)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      note: {
        fill: "#014429",
        text: "#f2f2f2"
      },
      semi: "#253231",
      pattern: "#366a53",
      highlight: {
        srgb: "#009774",
        p3: "color(display-p3 0.0085 0.582 0.4604)"
      }
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      note: {
        fill: "#56595F",
        text: "#f2f2f2"
      },
      semi: "#33373c",
      pattern: "#7c8187",
      highlight: {
        srgb: "#9cb4cb",
        p3: "color(display-p3 0.6299 0.7012 0.7856)"
      }
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      note: {
        fill: "#1F5495",
        text: "#f2f2f2"
      },
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlight: {
        srgb: "#00bdc8",
        p3: "color(display-p3 0.0023 0.7259 0.7735)"
      }
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      note: {
        fill: "#21581D",
        text: "#f2f2f2"
      },
      semi: "#2a3830",
      pattern: "#4e874e",
      highlight: {
        srgb: "#00a000",
        p3: "color(display-p3 0.2711 0.6172 0.0195)"
      }
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      note: {
        fill: "#923632",
        text: "#f2f2f2"
      },
      semi: "#3b3235",
      pattern: "#a56767",
      highlight: {
        srgb: "#db005b",
        p3: "color(display-p3 0.7849 0.0585 0.3589)"
      }
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      note: {
        fill: "#762F8E",
        text: "#f2f2f2"
      },
      semi: "#383442",
      pattern: "#9770a9",
      highlight: {
        srgb: "#c400c7",
        p3: "color(display-p3 0.7024 0.0403 0.753)"
      }
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      note: {
        fill: "#843906",
        text: "#f2f2f2"
      },
      semi: "#3a2e2a",
      pattern: "#9f552d",
      highlight: {
        srgb: "#d07a00",
        p3: "color(display-p3 0.7699 0.4937 0.0085)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      note: {
        fill: "#89231A",
        text: "#f2f2f2"
      },
      semi: "#36292b",
      pattern: "#8f3734",
      highlight: {
        srgb: "#de002c",
        p3: "color(display-p3 0.7978 0.0509 0.2035)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      note: {
        fill: "#681683",
        text: "#f2f2f2"
      },
      semi: "#31293c",
      pattern: "#763a8b",
      highlight: {
        srgb: "#9e00ee",
        p3: "color(display-p3 0.5651 0.0079 0.8986)"
      }
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      note: {
        fill: "#98571B",
        text: "#f2f2f2"
      },
      semi: "#3c3934",
      pattern: "#fecb92",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      note: {
        fill: "#eaeaea",
        text: "#1d1d1d"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  }
};
function Pp(n) {
  return n.isDarkMode ? vM.darkMode : vM.lightMode;
}
const xc = No.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: $G
}), zG = No.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: $G
}), eS = No.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
}), tS = No.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill"]
}), Ph = No.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
}), UG = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
}, Ah = No.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
}), BG = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
], yM = No.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: BG
}), SM = No.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: BG
}), HG = {
  labelColor: zG,
  color: xc,
  fill: tS,
  dash: eS,
  size: Ah,
  arrowheadStart: yM,
  arrowheadEnd: SM,
  font: Ph,
  start: Jy,
  end: Jy,
  bend: Jt,
  text: vn,
  labelPosition: Jt,
  scale: Qi
}, E0 = hd("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5
});
function iI(n) {
  return FG("shape", "arrow", n);
}
const VG = V0({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: !1,
  sequence: [
    iI({
      id: E0.AddLabelColor,
      up: (n) => {
        n.labelColor = "black";
      },
      down: "retired"
    }),
    iI({
      id: E0.AddIsPrecise,
      up: ({ start: n, end: t }) => {
        n.type === "binding" && (n.isPrecise = !(n.normalizedAnchor.x === 0.5 && n.normalizedAnchor.y === 0.5)), t.type === "binding" && (t.isPrecise = !(t.normalizedAnchor.x === 0.5 && t.normalizedAnchor.y === 0.5));
      },
      down: ({ start: n, end: t }) => {
        n.type === "binding" && (n.isPrecise || (n.normalizedAnchor = { x: 0.5, y: 0.5 }), delete n.isPrecise), t.type === "binding" && (t.isPrecise || (t.normalizedAnchor = { x: 0.5, y: 0.5 }), delete t.isPrecise);
      }
    }),
    iI({
      id: E0.AddLabelPosition,
      up: (n) => {
        n.labelPosition = 0.5;
      },
      down: (n) => {
        delete n.labelPosition;
      }
    }),
    {
      id: E0.ExtractBindings,
      scope: "store",
      up: (n) => {
        const t = Object.values(n).filter(
          (e) => e.typeName === "shape" && e.type === "arrow"
        );
        for (const e of t) {
          const { start: r, end: i } = e.props;
          if (r.type === "binding") {
            const s = qy(), o = {
              typeName: "binding",
              id: s,
              type: "arrow",
              fromId: e.id,
              toId: r.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: r.normalizedAnchor,
                isExact: r.isExact,
                isPrecise: r.isPrecise
              }
            };
            n[s] = o, e.props.start = { x: 0, y: 0 };
          } else
            delete e.props.start.type;
          if (i.type === "binding") {
            const s = qy(), o = {
              typeName: "binding",
              id: s,
              type: "arrow",
              fromId: e.id,
              toId: i.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: i.normalizedAnchor,
                isExact: i.isExact,
                isPrecise: i.isPrecise
              }
            };
            n[s] = o, e.props.end = { x: 0, y: 0 };
          } else
            delete e.props.end.type;
        }
      }
    },
    iI({
      id: E0.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    })
  ]
}), WG = {
  terminal: k2("start", "end"),
  normalizedAnchor: Jy,
  isExact: kn,
  isPrecise: kn
}, GG = {
  sequence: [{ dependsOn: [E0.ExtractBindings] }]
}, xve = Lh(
  "camera",
  Mn({
    typeName: ya("camera"),
    id: vc("camera"),
    x: Jt,
    y: Jt,
    z: Jt,
    meta: Mo
  })
), wve = Ul("com.tldraw.camera", {
  AddMeta: 1
}), Cve = wc({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: wve.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), vh = Oh("camera", {
  validator: xve,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
), Eve = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]), KG = A2(Eve), _ve = Mn({
  type: KG,
  rotation: Jt
}), Tve = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]), Pve = A2(Tve), Ave = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]), YG = Mn({
  id: vn,
  points: Ro(Jy),
  size: gM,
  color: Pve,
  opacity: Jt,
  state: A2(Ave),
  delay: Jt,
  shrink: Jt,
  taper: kn
}), U1 = vc("page"), kve = Lh(
  "page",
  Mn({
    typeName: ya("page"),
    id: U1,
    name: vn,
    index: l5,
    meta: Mo
  })
), Ive = Ul("com.tldraw.page", {
  AddMeta: 1
}), Rve = wc({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: Ive.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), yp = Oh("page", {
  validator: kve,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function El(n) {
  return yp.isId(n);
}
const Mve = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: !1,
  // meta
  typeName: !1,
  // meta
  currentPageId: !1,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: !1,
  // does not preserve because it's a temporary state
  stylesForNextShape: !1,
  // does not preserve because it's a temporary state
  followingUserId: !1,
  // does not preserve because it's a temporary state
  highlightedUserIds: !1,
  // does not preserve because it's a temporary state
  brush: !1,
  // does not preserve because it's a temporary state
  cursor: !1,
  // does not preserve because it's a temporary state
  scribbles: !1,
  // does not preserve because it's a temporary state
  isFocusMode: !0,
  // preserves because it's a user preference
  isDebugMode: !0,
  // preserves because it's a user preference
  isToolLocked: !0,
  // preserves because it's a user preference
  exportBackground: !0,
  // preserves because it's a user preference
  screenBounds: !0,
  // preserves because it's capturing the user's screen state
  insets: !0,
  // preserves because it's capturing the user's screen state
  zoomBrush: !1,
  // does not preserve because it's a temporary state
  chatMessage: !1,
  // does not preserve because it's a temporary state
  isChatting: !1,
  // does not preserve because it's a temporary state
  isPenMode: !1,
  // does not preserve because it's a temporary state
  isGridMode: !0,
  // preserves because it's a user preference
  isFocused: !0,
  // preserves because obviously
  devicePixelRatio: !0,
  // preserves because it captures the user's screen state
  isCoarsePointer: !0,
  // preserves because it captures the user's screen state
  isHoveringCanvas: !1,
  // does not preserve because it's a temporary state
  openMenus: !1,
  // does not preserve because it's a temporary state
  isChangingStyle: !1,
  // does not preserve because it's a temporary state
  isReadonly: !0,
  // preserves because it's a config option
  meta: !1,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: !1
  //
}, XG = (n) => n ? _1(n, (t) => Mve[t]) : null;
vc("instance");
function Dve(n) {
  const t = {};
  for (const [r, i] of n)
    t[r] = LG(i);
  const e = Lh(
    "instance",
    Mn({
      typeName: ya("instance"),
      id: vc("instance"),
      currentPageId: U1,
      followingUserId: vn.nullable(),
      brush: P1.nullable(),
      opacityForNextShape: jG,
      stylesForNextShape: Mn(t),
      cursor: _ve,
      scribbles: Ro(YG),
      isFocusMode: kn,
      isDebugMode: kn,
      isToolLocked: kn,
      exportBackground: kn,
      screenBounds: P1,
      insets: Ro(kn),
      zoomBrush: P1.nullable(),
      isPenMode: kn,
      isGridMode: kn,
      chatMessage: vn,
      isChatting: kn,
      highlightedUserIds: Ro(vn),
      isFocused: kn,
      devicePixelRatio: Jt,
      isCoarsePointer: kn,
      isHoveringCanvas: kn.nullable(),
      openMenus: Ro(vn),
      isChangingStyle: kn,
      isReadonly: kn,
      meta: Mo,
      duplicateProps: Mn({
        shapeIds: Ro(vc("shape")),
        offset: Mn({
          x: Jt,
          y: Jt
        })
      }).nullable()
    })
  );
  return Oh("instance", {
    validator: e,
    scope: "session",
    ephemeralKeys: {
      currentPageId: !1,
      meta: !1,
      followingUserId: !0,
      opacityForNextShape: !0,
      stylesForNextShape: !0,
      brush: !0,
      cursor: !0,
      scribbles: !0,
      isFocusMode: !0,
      isDebugMode: !0,
      isToolLocked: !0,
      exportBackground: !0,
      screenBounds: !0,
      insets: !0,
      zoomBrush: !0,
      isPenMode: !0,
      isGridMode: !0,
      chatMessage: !0,
      isChatting: !0,
      highlightedUserIds: !0,
      isFocused: !0,
      devicePixelRatio: !0,
      isCoarsePointer: !0,
      isHoveringCanvas: !0,
      openMenus: !0,
      isChangingStyle: !0,
      isReadonly: !0,
      duplicateProps: !0
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: !1,
      exportBackground: !1,
      isDebugMode: process.env.NODE_ENV === "development",
      isToolLocked: !1,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [!1, !1, !1, !1],
      zoomBrush: null,
      isGridMode: !1,
      isPenMode: !1,
      chatMessage: "",
      isChatting: !1,
      highlightedUserIds: [],
      isFocused: !1,
      devicePixelRatio: typeof window > "u" ? 1 : window.devicePixelRatio,
      isCoarsePointer: !1,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: !1,
      isReadonly: !1,
      meta: {},
      duplicateProps: null
    })
  );
}
const ui = Ul("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
}), Ove = wc({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: ui.AddTransparentExportBgs,
      up: (n) => ({ ...n, exportBackground: !0 })
    },
    {
      id: ui.RemoveDialog,
      up: ({ dialog: n, ...t }) => t
    },
    {
      id: ui.AddToolLockMode,
      up: (n) => ({ ...n, isToolLocked: !1 })
    },
    {
      id: ui.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape: n, ...t }) => ({
        ...t,
        propsForNextShape: Object.fromEntries(
          Object.entries(n).filter(
            ([e]) => [
              "color",
              "labelColor",
              "dash",
              "fill",
              "size",
              "font",
              "align",
              "verticalAlign",
              "icon",
              "geo",
              "arrowheadStart",
              "arrowheadEnd",
              "spline"
            ].includes(e)
          )
        )
      })
    },
    {
      id: ui.AddLabelColor,
      up: ({ propsForNextShape: n, ...t }) => ({
        ...t,
        propsForNextShape: {
          ...n,
          labelColor: "black"
        }
      })
    },
    {
      id: ui.AddFollowingUserId,
      up: (n) => ({ ...n, followingUserId: null })
    },
    {
      id: ui.RemoveAlignJustify,
      up: (n) => {
        let t = n.propsForNextShape.align;
        return t === "justify" && (t = "start"), {
          ...n,
          propsForNextShape: {
            ...n.propsForNextShape,
            align: t
          }
        };
      }
    },
    {
      id: ui.AddZoom,
      up: (n) => ({ ...n, zoomBrush: null })
    },
    {
      id: ui.AddVerticalAlign,
      up: (n) => ({
        ...n,
        propsForNextShape: {
          ...n.propsForNextShape,
          verticalAlign: "middle"
        }
      })
    },
    {
      id: ui.AddScribbleDelay,
      up: (n) => n.scribble !== null ? { ...n, scribble: { ...n.scribble, delay: 0 } } : { ...n }
    },
    {
      id: ui.RemoveUserId,
      up: ({ userId: n, ...t }) => t
    },
    {
      id: ui.AddIsPenModeAndIsGridMode,
      up: (n) => ({ ...n, isPenMode: !1, isGridMode: !1 })
    },
    {
      id: ui.HoistOpacity,
      up: ({ propsForNextShape: { opacity: n, ...t }, ...e }) => ({ ...e, opacityForNextShape: Number(n ?? "1"), propsForNextShape: t })
    },
    {
      id: ui.AddChat,
      up: (n) => ({ ...n, chatMessage: "", isChatting: !1 })
    },
    {
      id: ui.AddHighlightedUserIds,
      up: (n) => ({ ...n, highlightedUserIds: [] })
    },
    {
      id: ui.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: n, ...t }) => ({ ...t, stylesForNextShape: {} })
    },
    {
      id: ui.AddMeta,
      up: (n) => ({
        ...n,
        meta: {}
      })
    },
    {
      id: ui.RemoveCursorColor,
      up: (n) => {
        const { color: t, ...e } = n.cursor;
        return {
          ...n,
          cursor: e
        };
      }
    },
    {
      id: ui.AddLonelyProperties,
      up: (n) => ({
        ...n,
        canMoveCamera: !0,
        isFocused: !1,
        devicePixelRatio: 1,
        isCoarsePointer: !1,
        openMenus: [],
        isChangingStyle: !1,
        isReadOnly: !1
      })
    },
    {
      id: ui.ReadOnlyReadonly,
      up: ({ isReadOnly: n, ...t }) => ({
        ...t,
        isReadonly: n
      })
    },
    {
      id: ui.AddHoveringCanvas,
      up: (n) => ({
        ...n,
        isHoveringCanvas: null
      })
    },
    {
      id: ui.AddScribbles,
      up: ({ scribble: n, ...t }) => ({
        ...t,
        scribbles: []
      })
    },
    {
      id: ui.AddInset,
      up: (n) => ({
        ...n,
        insets: [!1, !1, !1, !1]
      }),
      down: ({ insets: n, ...t }) => ({
        ...t
      })
    },
    {
      id: ui.AddDuplicateProps,
      up: (n) => ({
        ...n,
        duplicateProps: null
      }),
      down: ({ duplicateProps: n, ...t }) => ({
        ...t
      })
    },
    {
      id: ui.RemoveCanMoveCamera,
      up: ({ canMoveCamera: n, ...t }) => ({
        ...t
      }),
      down: (n) => ({ ...n, canMoveCamera: !0 })
    }
  ]
}), za = "instance:instance", Lve = Lh(
  "instance_page_state",
  Mn({
    typeName: ya("instance_page_state"),
    id: vc("instance_page_state"),
    pageId: U1,
    selectedShapeIds: Ro(eu),
    hintingShapeIds: Ro(eu),
    erasingShapeIds: Ro(eu),
    hoveredShapeId: eu.nullable(),
    editingShapeId: eu.nullable(),
    croppingShapeId: eu.nullable(),
    focusedGroupId: eu.nullable(),
    meta: Mo
  })
), PE = Ul("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
}), jve = wc({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: PE.AddCroppingId,
      up(n) {
        n.croppingShapeId = null;
      }
    },
    {
      id: PE.RemoveInstanceIdAndCameraId,
      up(n) {
        delete n.instanceId, delete n.cameraId;
      }
    },
    {
      id: PE.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    },
    {
      id: PE.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (n) => {
      },
      down: (n) => {
      }
    },
    {
      id: PE.RenamePropertiesAgain,
      up: (n) => {
        n.selectedShapeIds = n.selectedIds, delete n.selectedIds, n.hintingShapeIds = n.hintingIds, delete n.hintingIds, n.erasingShapeIds = n.erasingIds, delete n.erasingIds, n.hoveredShapeId = n.hoveredId, delete n.hoveredId, n.editingShapeId = n.editingId, delete n.editingId, n.croppingShapeId = n.croppingShapeId ?? n.croppingId ?? null, delete n.croppingId, n.focusedGroupId = n.focusLayerId, delete n.focusLayerId;
      },
      down: (n) => {
        n.selectedIds = n.selectedShapeIds, delete n.selectedShapeIds, n.hintingIds = n.hintingShapeIds, delete n.hintingShapeIds, n.erasingIds = n.erasingShapeIds, delete n.erasingShapeIds, n.hoveredId = n.hoveredShapeId, delete n.hoveredShapeId, n.editingId = n.editingShapeId, delete n.editingShapeId, n.croppingId = n.croppingShapeId, delete n.croppingShapeId, n.focusLayerId = n.focusedGroupId, delete n.focusedGroupId;
      }
    }
  ]
}), sd = Oh(
  "instance_page_state",
  {
    validator: Lve,
    scope: "session",
    ephemeralKeys: {
      pageId: !1,
      selectedShapeIds: !1,
      editingShapeId: !1,
      croppingShapeId: !1,
      meta: !1,
      hintingShapeIds: !0,
      erasingShapeIds: !0,
      hoveredShapeId: !0,
      focusedGroupId: !0
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
), Nve = Lh(
  "pointer",
  Mn({
    typeName: ya("pointer"),
    id: vc("pointer"),
    x: Jt,
    y: Jt,
    lastActivityTimestamp: Jt,
    meta: Mo
  })
), Fve = Ul("com.tldraw.pointer", {
  AddMeta: 1
}), $ve = wc({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: Fve.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), u5 = Oh("pointer", {
  validator: Nve,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
), bM = u5.createId("pointer"), zve = Lh(
  "instance_presence",
  Mn({
    typeName: ya("instance_presence"),
    id: vc("instance_presence"),
    userId: vn,
    userName: vn,
    lastActivityTimestamp: Jt,
    followingUserId: vn.nullable(),
    cursor: Mn({
      x: Jt,
      y: Jt,
      type: KG,
      rotation: Jt
    }),
    color: vn,
    camera: Mn({
      x: Jt,
      y: Jt,
      z: Jt
    }),
    screenBounds: P1,
    selectedShapeIds: Ro(vc("shape")),
    currentPageId: vc("page"),
    brush: P1.nullable(),
    scribbles: Ro(YG),
    chatMessage: vn,
    meta: Mo
  })
), AE = Ul("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5
}), Uve = wc({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: AE.AddScribbleDelay,
      up: (n) => {
        n.scribble !== null && (n.scribble.delay = 0);
      }
    },
    {
      id: AE.RemoveInstanceId,
      up: (n) => {
        delete n.instanceId;
      }
    },
    {
      id: AE.AddChatMessage,
      up: (n) => {
        n.chatMessage = "";
      }
    },
    {
      id: AE.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    },
    {
      id: AE.RenameSelectedShapeIds,
      up: (n) => {
      }
    }
  ]
}), Bve = Oh(
  "instance_presence",
  {
    validator: zve,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: 0,
  followingUserId: null,
  color: "#FF0000",
  camera: {
    x: 0,
    y: 0,
    z: 1
  },
  cursor: {
    x: 0,
    y: 0,
    type: "default",
    rotation: 0
  },
  screenBounds: {
    x: 0,
    y: 0,
    w: 1,
    h: 1
  },
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
})), Hve = Lh(
  "document",
  Mn({
    typeName: ya("document"),
    id: ya("document:document"),
    gridSize: Jt,
    name: vn,
    meta: Mo
  })
), r9 = Ul("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
}), Vve = wc({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: r9.AddName,
      up: (n) => {
        n.name = "";
      },
      down: (n) => {
        delete n.name;
      }
    },
    {
      id: r9.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), d5 = Oh("document", {
  validator: Hve,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
), h3 = d5.createId("document");
function Wve(n, t) {
  return n.index < t.index ? -1 : n.index > t.index ? 1 : 0;
}
function i9(n) {
  n.typeName === "asset" && ("src" in n && (n.src = "<redacted>"), "src" in n.props && (n.props.src = "<redacted>"));
}
const Gve = ({ error: n, phase: t, record: e, recordBefore: r }) => {
  throw qz(n, {
    tags: {
      origin: "store.validateRecord",
      storePhase: t,
      isExistingValidationIssue: (
        // if we're initializing the store for the first time, we should
        // allow invalid records so people can load old buggy data:
        t === "initialize"
      )
    },
    extras: {
      recordBefore: r ? i9(ni(r)) : void 0,
      recordAfter: i9(ni(e))
    }
  }), n;
};
function Kve() {
  return [
    yp.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function Yve(n) {
  const t = n.query.ids("page"), e = () => {
    if (!n.has(h3))
      return n.put([d5.create({ id: h3, name: n.props.defaultName })]), e();
    if (!n.has(bM))
      return n.put([u5.create({ id: bM })]), e();
    const r = t.get();
    if (r.size === 0)
      return n.put(Kve()), e();
    const i = () => [...r].map((u) => n.get(u)).sort(Wve)[0].id, s = n.get(za);
    if (s) {
      if (!r.has(s.currentPageId))
        return n.put([{ ...s, currentPageId: i() }]), e();
    } else return n.put([
      n.schema.types.instance.create({
        id: za,
        currentPageId: i(),
        exportBackground: !0
      })
    ]), e();
    const o = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
    for (const u of r) {
      const d = sd.createId(u);
      n.has(d) || o.add(d);
      const f = vh.createId(u);
      n.has(f) || l.add(f);
    }
    o.size > 0 && n.put(
      [...o].map(
        (u) => sd.create({
          id: u,
          pageId: sd.parseId(u)
        })
      )
    ), l.size > 0 && n.put([...l].map((u) => vh.create({ id: u })));
  };
  return e;
}
const Xve = c5(
  "bookmark",
  Mn({
    title: vn,
    description: vn,
    image: vn,
    favicon: vn,
    src: Qy.nullable()
  })
), s9 = Ul("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
}), qve = wc({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (n) => n.type === "bookmark",
  sequence: [
    {
      id: s9.MakeUrlsValid,
      up: (n) => {
        Qy.isValid(n.props.src) || (n.props.src = "");
      },
      down: (n) => {
      }
    },
    {
      id: s9.AddFavicon,
      up: (n) => {
        Qy.isValid(n.props.favicon) || (n.props.favicon = "");
      },
      down: (n) => {
        delete n.props.favicon;
      }
    }
  ]
}), Zve = c5(
  "image",
  Mn({
    w: Jt,
    h: Jt,
    name: vn,
    isAnimated: kn,
    mimeType: vn.nullable(),
    src: Qy.nullable(),
    fileSize: Qi.optional()
  })
), kE = Ul("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
}), Qve = wc({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (n) => n.type === "image",
  sequence: [
    {
      id: kE.AddIsAnimated,
      up: (n) => {
        n.props.isAnimated = !1;
      },
      down: (n) => {
        delete n.props.isAnimated;
      }
    },
    {
      id: kE.RenameWidthHeight,
      up: (n) => {
        n.props.w = n.props.width, n.props.h = n.props.height, delete n.props.width, delete n.props.height;
      },
      down: (n) => {
        n.props.width = n.props.w, n.props.height = n.props.h, delete n.props.w, delete n.props.h;
      }
    },
    {
      id: kE.MakeUrlsValid,
      up: (n) => {
        Qy.isValid(n.props.src) || (n.props.src = "");
      },
      down: (n) => {
      }
    },
    {
      id: kE.AddFileSize,
      up: (n) => {
        n.props.fileSize = -1;
      },
      down: (n) => {
        delete n.props.fileSize;
      }
    },
    {
      id: kE.MakeFileSizeOptional,
      up: (n) => {
        n.props.fileSize === -1 && (n.props.fileSize = void 0);
      },
      down: (n) => {
        n.props.fileSize === void 0 && (n.props.fileSize = -1);
      }
    }
  ]
}), Jve = c5(
  "video",
  Mn({
    w: Jt,
    h: Jt,
    name: vn,
    isAnimated: kn,
    mimeType: vn.nullable(),
    src: Qy.nullable(),
    fileSize: Jt.optional()
  })
), IE = Ul("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
}), eye = wc({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (n) => n.type === "video",
  sequence: [
    {
      id: IE.AddIsAnimated,
      up: (n) => {
        n.props.isAnimated = !1;
      },
      down: (n) => {
        delete n.props.isAnimated;
      }
    },
    {
      id: IE.RenameWidthHeight,
      up: (n) => {
        n.props.w = n.props.width, n.props.h = n.props.height, delete n.props.width, delete n.props.height;
      },
      down: (n) => {
        n.props.width = n.props.w, n.props.height = n.props.h, delete n.props.w, delete n.props.h;
      }
    },
    {
      id: IE.MakeUrlsValid,
      up: (n) => {
        Qy.isValid(n.props.src) || (n.props.src = "");
      },
      down: (n) => {
      }
    },
    {
      id: IE.AddFileSize,
      up: (n) => {
        n.props.fileSize = -1;
      },
      down: (n) => {
        delete n.props.fileSize;
      }
    },
    {
      id: IE.MakeFileSizeOptional,
      up: (n) => {
        n.props.fileSize === -1 && (n.props.fileSize = void 0);
      },
      down: (n) => {
        n.props.fileSize === void 0 && (n.props.fileSize = -1);
      }
    }
  ]
}), tye = Lh(
  "asset",
  o5("type", {
    image: Zve,
    video: Jve,
    bookmark: Xve
  })
), nye = Ul("com.tldraw.asset", {
  AddMeta: 1
}), rye = wc({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: nye.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), Zv = Oh("asset", {
  validator: tye,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
})), qG = {
  w: Qi,
  h: Qi,
  assetId: I2.nullable(),
  url: bc
}, o9 = hd("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
}), ZG = {
  sequence: [
    {
      id: o9.NullAssetId,
      up: (n) => {
        n.assetId === void 0 && (n.assetId = null);
      },
      down: "retired"
    },
    {
      id: o9.MakeUrlsValid,
      up: (n) => {
        bc.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    }
  ]
}, QG = Mn({
  type: k2("free", "straight"),
  points: Ro(Jy)
}), JG = {
  color: xc,
  fill: tS,
  dash: eS,
  size: Ah,
  segments: Ro(QG),
  isComplete: kn,
  isClosed: kn,
  isPen: kn,
  scale: Qi
}, a9 = hd("draw", {
  AddInPen: 1,
  AddScale: 2
}), eK = {
  sequence: [
    {
      id: a9.AddInPen,
      up: (n) => {
        const { points: t } = n.segments[0];
        if (t.length === 0) {
          n.isPen = !1;
          return;
        }
        let e = !(t[0].z === 0 || t[0].z === 0.5);
        t[1] && (e = e && !(t[1].z === 0 || t[1].z === 0.5)), n.isPen = e;
      },
      down: "retired"
    },
    {
      id: a9.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, l9 = /(^\/r\/[^/]+\/?$)/, br = (n) => {
  try {
    return new URL(n);
  } catch {
    return;
  }
}, $T = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    overridePermissions: {
      "allow-top-navigation": !0
    },
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(l9))
        return n;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(l9))
        return n;
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      if (n.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !n.includes("figma.com/embed"))
        return `https://www.figma.com/embed?embed_host=share&url=${n}`;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/embed\/?$/)) {
        const e = t.searchParams.get("url");
        if (e)
          return e;
      }
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0
    },
    toEmbedUrl: (n) => {
      if (n.includes("/maps/")) {
        const t = n.match(/@(.*),(.*),(.*)z/);
        let e;
        if (t) {
          const [, r, i, s] = t;
          e = `https://${new URL(n).host.replace("www.", "")}/maps/embed/v1/view?key=${process.env.NEXT_PUBLIC_GC_API_KEY}&center=${r},${i}&zoom=${s}`;
        } else
          e = "";
        return e;
      }
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (!t) return;
      if (t.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && t.searchParams.has("center") && t.searchParams.get("zoom")) {
        const r = t.searchParams.get("zoom"), [i, s] = t.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${i},${s},${r}z`;
      }
    }
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n), e = t && t.pathname.match(/\/v\/(.+)\/?/);
      if (e)
        return `https://www.val.town/embed/${e[1]}`;
    },
    fromEmbedUrl: (n) => {
      const t = br(n), e = t && t.pathname.match(/\/embed\/(.+)\/?/);
      if (e)
        return `https://www.val.town/v/${e[1]}`;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n), e = t && t.pathname.match(/\/s\/([^/]+)\/?/);
      if (e)
        return `https://codesandbox.io/embed/${e[1]}`;
    },
    fromEmbedUrl: (n) => {
      const t = br(n), e = t && t.pathname.match(/\/embed\/([^/]+)\/?/);
      if (e)
        return `https://codesandbox.io/s/${e[1]}`;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/, e = n.match(t);
      if (e) {
        const [r, i, s] = e;
        return `https://codepen.io/${i}/embed/${s}`;
      }
    },
    fromEmbedUrl: (n) => {
      const t = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, e = n.match(t);
      if (e) {
        const [r, i, s] = e;
        return `https://codepen.io/${i}/pen/${s}`;
      }
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: !1,
    toEmbedUrl: (n) => {
      const t = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/, e = n.match(t);
      if (e) {
        const [r, i] = e;
        return `https://scratch.mit.edu/projects/embed/${i}`;
      }
    },
    fromEmbedUrl: (n) => {
      const t = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, e = n.match(t);
      if (e) {
        const [r, i] = e;
        return `https://scratch.mit.edu/projects/${i}`;
      }
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0,
      "allow-popups-to-escape-sandbox": !0
    },
    isAspectRatioLocked: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (!t) return;
      const e = t.hostname.replace(/^www./, "");
      if (e === "youtu.be")
        return `https://www.youtube.com/embed/${t.pathname.split("/").filter(Boolean)[0]}`;
      if ((e === "youtube.com" || e === "m.youtube.com") && t.pathname.match(/^\/watch/))
        return `https://www.youtube.com/embed/${t.searchParams.get("v")}`;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (!t) return;
      if (t.hostname.replace(/^www./, "") === "youtube.com") {
        const r = t.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r)
          return `https://www.youtube.com/watch?v=${r[1]}`;
      }
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": !0
    },
    toEmbedUrl: (n) => {
      const t = br(n), e = t == null ? void 0 : t.searchParams.get("cid");
      if (t != null && t.pathname.match(/\/calendar\/u\/0/) && e) {
        t.pathname = "/calendar/embed";
        const r = Array.from(t.searchParams.keys());
        for (const i of r)
          t.searchParams.delete(i);
        return t.searchParams.set("src", e), t.href;
      }
    },
    fromEmbedUrl: (n) => {
      const t = br(n), e = t == null ? void 0 : t.searchParams.get("src");
      if (t != null && t.pathname.match(/\/calendar\/embed/) && e) {
        t.pathname = "/calendar/u/0";
        const r = Array.from(t.searchParams.keys());
        for (const i of r)
          t.searchParams.delete(i);
        return t.searchParams.set("cid", e), t.href;
      }
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": !0
    },
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t != null && t.pathname.match(/^\/presentation/) && (t != null && t.pathname.match(/\/pub\/?$/))) {
        t.pathname = t.pathname.replace(/\/pub$/, "/embed");
        const e = Array.from(t.searchParams.keys());
        for (const r of e)
          t.searchParams.delete(r);
        return t.href;
      }
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t != null && t.pathname.match(/^\/presentation/) && (t != null && t.pathname.match(/\/embed\/?$/))) {
        t.pathname = t.pathname.replace(/\/embed$/, "/pub");
        const e = Array.from(t.searchParams.keys());
        for (const r of e)
          t.searchParams.delete(r);
        return t.href;
      }
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/\/([^/]+)\/([^/]+)/))
        return n.split("/").pop() ? n : void 0;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/\/([^/]+)\/([^/]+)/))
        return n.split("/").pop() ? n : void 0;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/\/@([^/]+)\/([^/]+)/))
        return `${n}?embed=true`;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/\/@([^/]+)\/([^/]+)/) && t.searchParams.has("embed"))
        return t.searchParams.delete("embed"), t.href;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/map\//))
        return t.origin + "/embed" + t.pathname;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/embed\/map\//))
        return t.pathname = t.pathname.replace(/^\/embed/, ""), t.href;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/(artist|album)\//))
        return t.origin + "/embed" + t.pathname;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/embed\/(artist|album)\//))
        return t.origin + t.pathname.replace(/^\/embed/, "");
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.hostname === "vimeo.com" && t.pathname.match(/^\/[0-9]+/))
        return "https://player.vimeo.com/video/" + t.pathname.split("/")[1] + "?title=0&byline=0";
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.hostname === "player.vimeo.com") {
        const e = t.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (e)
          return "https://vimeo.com/" + e[1];
      }
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.hash.match(/#room=/))
        return n;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.hash.match(/#room=/))
        return n;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !1,
    backgroundColor: "#fff",
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/))
        return `${t.origin}/embed${t.pathname}?cell=*`;
      if (t && t.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const e = t.pathname.replace(/^\/d/, "");
        return `${t.origin}/embed${e}?cell=*`;
      }
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${t.origin}${t.pathname.replace("/embed", "")}#cell-*`;
      if (t && t.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${t.origin}${t.pathname.replace("/embed", "/d")}#cell-*`;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.hostname === "www.desmos.com" && t.pathname.match(/^\/calculator\/([^/]+)\/?$/) && t.search === "" && t.hash === "")
        return `${n}?embed`;
    },
    fromEmbedUrl: (n) => {
      const t = br(n);
      if (t && t.hostname === "www.desmos.com" && t.pathname.match(/^\/calculator\/([^/]+)\/?$/) && t.search === "?embed" && t.hash === "")
        return n.replace("?embed", "");
    }
  }
], iye = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": !1,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": !1,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": !1,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": !1,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": !1,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": !0,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": !1,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": !1,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": !1,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": !0,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": !0,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": !0
}, tK = {
  w: Qi,
  h: Qi,
  url: vn
}, sI = hd("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
}), nK = {
  sequence: [
    {
      id: sI.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (n) => {
        try {
          const t = n.url, e = new URL(t).host.replace("www.", "");
          let r;
          for (const i of $T)
            if (i.hostnames.includes(e))
              try {
                r = i.fromEmbedUrl(t);
              } catch (s) {
                console.warn(s);
              }
          n.tmpOldUrl = n.url, n.url = r ?? "";
        } catch {
          n.url = "", n.tmpOldUrl = n.url;
        }
      },
      down: "retired"
    },
    {
      id: sI.RemoveDoesResize,
      up: (n) => {
        delete n.doesResize;
      },
      down: "retired"
    },
    {
      id: sI.RemoveTmpOldUrl,
      up: (n) => {
        delete n.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: sI.RemovePermissionOverrides,
      up: (n) => {
        delete n.overridePermissions;
      },
      down: "retired"
    }
  ]
}, rK = {
  w: Qi,
  h: Qi,
  name: vn
}, iK = {
  sequence: []
}, xM = No.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
}), wM = No.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
}), od = No.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
}), sK = {
  geo: od,
  labelColor: zG,
  color: xc,
  fill: tS,
  dash: eS,
  size: Ah,
  font: Ph,
  align: xM,
  verticalAlign: wM,
  url: bc,
  w: Qi,
  h: Qi,
  growY: gM,
  text: vn,
  scale: Qi
}, Ef = hd("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9
}), oK = {
  sequence: [
    {
      id: Ef.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: Ef.AddLabelColor,
      up: (n) => {
        n.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: Ef.RemoveJustify,
      up: (n) => {
        n.align === "justify" && (n.align = "start");
      },
      down: "retired"
    },
    {
      id: Ef.AddCheckBox,
      up: (n) => {
      },
      down: "retired"
    },
    {
      id: Ef.AddVerticalAlign,
      up: (n) => {
        n.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Ef.MigrateLegacyAlign,
      up: (n) => {
        let t;
        switch (n.align) {
          case "start":
            t = "start-legacy";
            break;
          case "end":
            t = "end-legacy";
            break;
          default:
            t = "middle-legacy";
            break;
        }
        n.align = t;
      },
      down: "retired"
    },
    {
      id: Ef.AddCloud,
      up: (n) => {
      },
      down: "retired"
    },
    {
      id: Ef.MakeUrlsValid,
      up: (n) => {
        bc.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    },
    {
      id: Ef.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, aK = {}, lK = { sequence: [] }, cK = {
  color: xc,
  size: Ah,
  segments: Ro(QG),
  isComplete: kn,
  isPen: kn,
  scale: Qi
}, sye = hd("highlight", {
  AddScale: 1
}), uK = {
  sequence: [
    {
      id: sye.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, oye = Mn({
  topLeft: Jy,
  bottomRight: Jy
}), dK = {
  w: Qi,
  h: Qi,
  playing: kn,
  url: bc,
  assetId: I2.nullable(),
  crop: oye.nullable(),
  flipX: kn,
  flipY: kn
}, oI = hd("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4
}), hK = {
  sequence: [
    {
      id: oI.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: oI.AddCropProp,
      up: (n) => {
        n.crop = null;
      },
      down: (n) => {
        delete n.crop;
      }
    },
    {
      id: oI.MakeUrlsValid,
      up: (n) => {
        bc.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    },
    {
      id: oI.AddFlipProps,
      up: (n) => {
        n.flipX = !1, n.flipY = !1;
      },
      down: (n) => {
        delete n.flipX, delete n.flipY;
      }
    }
  ]
}, CM = No.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
}), aye = Mn({
  id: vn,
  index: l5,
  x: Jt,
  y: Jt
}), fK = {
  color: xc,
  dash: eS,
  size: Ah,
  spline: CM,
  points: mM(vn, aye),
  scale: Qi
}, RE = hd("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
}), pK = {
  sequence: [
    {
      id: RE.AddSnapHandles,
      up: (n) => {
        for (const t of Object.values(n.handles))
          t.canSnap = !0;
      },
      down: "retired"
    },
    {
      id: RE.RemoveExtraHandleProps,
      up: (n) => {
        n.handles = vG(
          Object.values(n.handles).map((t) => [
            t.index,
            {
              x: t.x,
              y: t.y
            }
          ])
        );
      },
      down: (n) => {
        const t = Object.entries(n.handles).map(([e, r]) => ({ index: e, ...r })).sort(fa);
        n.handles = Object.fromEntries(
          t.map((e, r) => {
            const i = r === 0 ? "start" : r === t.length - 1 ? "end" : `handle:${e.index}`;
            return [
              i,
              {
                id: i,
                type: "vertex",
                canBind: !1,
                canSnap: !0,
                index: e.index,
                x: e.x,
                y: e.y
              }
            ];
          })
        );
      }
    },
    {
      id: RE.HandlesToPoints,
      up: (n) => {
        const t = Object.entries(n.handles).map(([e, { x: r, y: i }]) => ({ x: r, y: i, index: e })).sort(fa);
        n.points = t.map(({ x: e, y: r }) => ({ x: e, y: r })), delete n.handles;
      },
      down: (n) => {
        const t = z1(n.points.length);
        n.handles = Object.fromEntries(
          n.points.map((e, r) => [
            t[r],
            {
              x: e.x,
              y: e.y
            }
          ])
        ), delete n.points;
      }
    },
    {
      id: RE.PointIndexIds,
      up: (n) => {
        const t = z1(n.points.length);
        n.points = Object.fromEntries(
          n.points.map((e, r) => {
            const i = t[r];
            return [
              i,
              {
                id: i,
                index: i,
                x: e.x,
                y: e.y
              }
            ];
          })
        );
      },
      down: (n) => {
        const t = Object.values(n.points).sort(fa);
        n.points = t.map(({ x: e, y: r }) => ({ x: e, y: r }));
      }
    },
    {
      id: RE.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, gK = {
  color: xc,
  size: Ah,
  font: Ph,
  fontSizeAdjustment: gM,
  align: xM,
  verticalAlign: wM,
  growY: gM,
  url: bc,
  text: vn,
  scale: Qi
}, Hv = hd("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7
}), mK = {
  sequence: [
    {
      id: Hv.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: Hv.RemoveJustify,
      up: (n) => {
        n.align === "justify" && (n.align = "start");
      },
      down: "retired"
    },
    {
      id: Hv.MigrateLegacyAlign,
      up: (n) => {
        switch (n.align) {
          case "start":
            n.align = "start-legacy";
            return;
          case "end":
            n.align = "end-legacy";
            return;
          default:
            n.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: Hv.AddVerticalAlign,
      up: (n) => {
        n.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Hv.MakeUrlsValid,
      up: (n) => {
        bc.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    },
    {
      id: Hv.AddFontSizeAdjustment,
      up: (n) => {
        n.fontSizeAdjustment = 0;
      },
      down: (n) => {
        delete n.fontSizeAdjustment;
      }
    },
    {
      id: Hv.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, f3 = No.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
}), vK = {
  color: xc,
  size: Ah,
  font: Ph,
  textAlign: f3,
  w: Qi,
  text: vn,
  scale: Qi,
  autoSize: kn
}, c9 = hd("text", {
  RemoveJustify: 1,
  AddTextAlign: 2
}), yK = {
  sequence: [
    {
      id: c9.RemoveJustify,
      up: (n) => {
        n.align === "justify" && (n.align = "start");
      },
      down: "retired"
    },
    {
      id: c9.AddTextAlign,
      up: (n) => {
        n.textAlign = n.align, delete n.align;
      },
      down: (n) => {
        n.align = n.textAlign, delete n.textAlign;
      }
    }
  ]
}, SK = {
  w: Qi,
  h: Qi,
  time: Jt,
  playing: kn,
  url: bc,
  assetId: I2.nullable()
}, u9 = hd("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2
}), bK = {
  sequence: [
    {
      id: u9.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: u9.MakeUrlsValid,
      up: (n) => {
        bc.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    }
  ]
}, aI = Ul("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4
}), lye = V0({
  sequenceId: "com.tldraw.store",
  retroactive: !1,
  sequence: [
    {
      id: aI.RemoveCodeAndIconShapeTypes,
      scope: "store",
      up: (n) => {
        for (const [t, e] of Fl(n))
          e.typeName === "shape" && (e.type === "icon" || e.type === "code") && delete n[t];
      }
    },
    {
      id: aI.AddInstancePresenceType,
      scope: "store",
      up(n) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: aI.RemoveTLUserAndPresenceAndAddPointer,
      scope: "store",
      up: (n) => {
        for (const [t, e] of Fl(n))
          e.typeName.match(/^(user|user_presence)$/) && delete n[t];
      }
    },
    {
      // remove user document records
      id: aI.RemoveUserDocument,
      scope: "store",
      up: (n) => {
        for (const [t, e] of Fl(n))
          e.typeName.match("user_document") && delete n[t];
      }
    }
  ]
}), cye = {
  arrow: { migrations: VG, props: HG },
  bookmark: { migrations: ZG, props: qG },
  draw: { migrations: eK, props: JG },
  embed: { migrations: nK, props: tK },
  frame: { migrations: iK, props: rK },
  geo: { migrations: oK, props: sK },
  group: { migrations: lK, props: aK },
  highlight: { migrations: uK, props: cK },
  image: { migrations: hK, props: dK },
  line: { migrations: pK, props: fK },
  note: { migrations: mK, props: gK },
  text: { migrations: yK, props: vK },
  video: { migrations: bK, props: SK }
}, uye = {
  arrow: { migrations: GG, props: WG }
};
function dye({
  shapes: n = cye,
  bindings: t = uye,
  migrations: e
} = {}) {
  const r = /* @__PURE__ */ new Map();
  for (const l of zi(n))
    for (const u of NG(l.props ?? {}).keys()) {
      if (r.has(u.id) && r.get(u.id) !== u)
        throw new Error(`Multiple StyleProp instances with the same id: ${u.id}`);
      r.set(u.id, u);
    }
  const i = bve(n), s = vve(t), o = Dve(r);
  return i5.create(
    {
      asset: Zv,
      binding: s,
      camera: vh,
      document: d5,
      instance: o,
      instance_page_state: sd,
      page: yp,
      instance_presence: Bve,
      pointer: u5,
      shape: i
    },
    {
      migrations: [
        lye,
        rye,
        Cve,
        Vve,
        Ove,
        jve,
        Rve,
        Uve,
        $ve,
        Sve,
        qve,
        Qve,
        eye,
        ...n9("shape", n),
        ...n9("binding", t),
        ...e ?? []
      ],
      onValidationFailure: Gve,
      createIntegrityChecker: Yve
    }
  );
}
const B1 = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ca", label: "Català" },
  { locale: "cs", label: "Čeština" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "ru", label: "Russian" },
  { locale: "sl", label: "Slovenščina" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "tr", label: "Türkçe" },
  { locale: "uk", label: "Ukrainian" },
  { locale: "he", label: "עברית" },
  { locale: "ar", label: "عربي" },
  { locale: "fa", label: "فارسی" },
  { locale: "ku", label: "کوردی" },
  { locale: "ne", label: "नेपाली" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "te", label: "తెలుగు" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "my", label: "မြန်မာစာ" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ja", label: "日本語" },
  { locale: "zh-cn", label: "简体中文" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
];
function hye() {
  const n = typeof window < "u" ? window.navigator.languages ?? ["en"] : ["en"];
  return fye(n);
}
function fye(n) {
  for (const t of n) {
    const e = pye(t);
    if (e)
      return e;
  }
  return "en";
}
const d9 = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function pye(n) {
  const t = B1.find((i) => i.locale === n.toLowerCase());
  if (t)
    return t.locale;
  const [e, r] = n.split(/[-_]/).map((i) => i.toLowerCase());
  if (r) {
    const i = B1.find((s) => s.locale === e);
    if (i)
      return i.locale;
  }
  return e in d9 ? d9[e] : null;
}
function R2(n, t) {
  const e = Gn.useRef(t);
  e.current = t;
  const [r, i, s] = Gn.useMemo(() => {
    let o = null;
    const l = (f) => (o = f, () => {
      o = null;
    }), u = new uw(
      `useStateTracking(${n})`,
      // this is what `scheduler.execute()` will call
      () => {
        var f;
        return (f = e.current) == null ? void 0 : f.call(e);
      },
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          o == null || o();
        }
      }
    );
    return [u, l, () => u.scheduleCount];
  }, [n]);
  return Gn.useSyncExternalStore(i, s, s), Gn.useEffect(() => (r.attach(), r.maybeScheduleEffect(), () => {
    r.detach();
  }), [r]), r.execute();
}
const h9 = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(n, t, e) {
    return R2(
      n.displayName ?? n.name ?? "tracked(???)",
      () => n.apply(t, e)
    );
  }
}, gye = Symbol.for("react.memo"), mye = Symbol.for("react.forward_ref");
function ro(n) {
  let t = null;
  const e = n.$$typeof;
  return e === gye && (n = n.type, t = n.compare), e === mye ? D.memo(D.forwardRef(new Proxy(n.render, h9))) : D.memo(new Proxy(n, h9), t);
}
function vye() {
  const n = arguments[0], t = arguments[1], e = arguments.length === 3 ? void 0 : arguments[2], r = arguments.length === 3 ? arguments[2] : arguments[3];
  return D.useMemo(() => ze(`useComputed(${n})`, t, e), r);
}
function mm(n, t, e = cp) {
  D.useEffect(() => {
    const r = new uw(n, t);
    return r.attach(), r.execute(), () => {
      r.detach();
    };
  }, e);
}
function De() {
  const n = arguments, t = n.length === 3 ? n[2] : [n[0]], e = n.length === 3 ? n[0] : `useValue(${n[0].name})`, r = D.useRef(!0);
  r.current = !0;
  const i = D.useMemo(() => n.length === 1 ? n[0] : ze(e, () => {
    if (r.current)
      return n[1]();
    try {
      return n[1]();
    } catch {
      return {};
    }
  }), t);
  try {
    const { subscribe: s, getSnapshot: o } = D.useMemo(() => ({
      subscribe: (l) => bS(`useValue(${e})`, () => {
        i.get(), l();
      }),
      getSnapshot: () => i.get()
    }), [i]);
    return D.useSyncExternalStore(s, o, o);
  } finally {
    r.current = !1;
  }
}
var xK = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
  (function() {
    var t = {}.hasOwnProperty;
    function e() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var l = arguments[o];
        l && (s = i(s, r(l)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return e.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var o = "";
      for (var l in s)
        t.call(s, l) && s[l] && (o = i(o, l));
      return o;
    }
    function i(s, o) {
      return o ? s ? s + " " + o : s + o : s;
    }
    n.exports ? (e.default = e, n.exports = e) : window.classNames = e;
  })();
})(xK);
var yye = xK.exports;
const Vt = /* @__PURE__ */ Ep(yye), wK = "2.4.4", f9 = {
  major: "2024-06-28T10:56:07.893Z",
  minor: "2024-07-22T16:42:50.301Z",
  patch: "2024-08-05T17:56:04.722Z"
}, Sye = { error: null };
class CK extends D.Component {
  constructor() {
    super(...arguments);
    T(this, "state", Sye);
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  componentDidCatch(e) {
    var r, i;
    (i = (r = this.props).onError) == null || i.call(r, e);
  }
  render() {
    const { error: e } = this.state;
    if (e !== null) {
      const { fallback: r } = this.props;
      return /* @__PURE__ */ y.jsx(r, { error: e });
    }
    return this.props.children;
  }
}
function H1({
  children: n,
  fallback: t,
  ...e
}) {
  return t === null ? n : /* @__PURE__ */ y.jsx(CK, { fallback: t, ...e, children: n });
}
const M2 = D.createContext(null);
function we() {
  const n = Gn.useContext(M2);
  if (!n)
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  return n;
}
function bye() {
  return /* @__PURE__ */ y.jsx("div", { className: "tl-background" });
}
function fw(n, t, e, r, i, s) {
  D.useLayoutEffect(() => {
    const o = n.current;
    if (!o || t === void 0) return;
    let l = `translate(${t}px, ${e}px)`;
    r !== void 0 && (l += ` scale(${r})`), i !== void 0 && (l += ` rotate(${i}rad)`), s && (l += ` translate(${s.x}px, ${s.y}px)`), o.style.transform = l;
  });
}
const Js = {
  linear: (n) => n,
  easeInQuad: (n) => n * n,
  easeOutQuad: (n) => n * (2 - n),
  easeInOutQuad: (n) => n < 0.5 ? 2 * n * n : -1 + (4 - 2 * n) * n,
  easeInCubic: (n) => n * n * n,
  easeOutCubic: (n) => --n * n * n + 1,
  easeInOutCubic: (n) => n < 0.5 ? 4 * n * n * n : (n - 1) * (2 * n - 2) * (2 * n - 2) + 1,
  easeInQuart: (n) => n * n * n * n,
  easeOutQuart: (n) => 1 - --n * n * n * n,
  easeInOutQuart: (n) => n < 0.5 ? 8 * n * n * n * n : 1 - 8 * --n * n * n * n,
  easeInQuint: (n) => n * n * n * n * n,
  easeOutQuint: (n) => 1 + --n * n * n * n * n,
  easeInOutQuint: (n) => n < 0.5 ? 16 * n * n * n * n * n : 1 + 16 * --n * n * n * n * n,
  easeInSine: (n) => 1 - Math.cos(n * Math.PI / 2),
  easeOutSine: (n) => Math.sin(n * Math.PI / 2),
  easeInOutSine: (n) => -(Math.cos(Math.PI * n) - 1) / 2,
  easeInExpo: (n) => n <= 0 ? 0 : Math.pow(2, 10 * n - 10),
  easeOutExpo: (n) => n >= 1 ? 1 : 1 - Math.pow(2, -10 * n),
  easeInOutExpo: (n) => n <= 0 ? 0 : n >= 1 ? 1 : n < 0.5 ? Math.pow(2, 20 * n - 10) / 2 : (2 - Math.pow(2, -20 * n + 10)) / 2
};
class O {
  constructor(t = 0, e = 0, r = 1) {
    this.x = t, this.y = e, this.z = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(t = this.x, e = this.y, r = this.z) {
    return this.x = t, this.y = e, this.z = r, this;
  }
  setTo({ x: t = 0, y: e = 0, z: r = 1 }) {
    return this.x = t, this.y = e, this.z = r, this;
  }
  rot(t) {
    if (t === 0) return this;
    const { x: e, y: r } = this, i = Math.sin(t), s = Math.cos(t);
    return this.x = e * s - r * i, this.y = e * i + r * s, this;
  }
  rotWith(t, e) {
    if (e === 0) return this;
    const r = this.x - t.x, i = this.y - t.y, s = Math.sin(e), o = Math.cos(e);
    return this.x = t.x + (r * o - i * s), this.y = t.y + (r * s + i * o), this;
  }
  clone() {
    const { x: t, y: e, z: r } = this;
    return new O(t, e, r);
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subXY(t, e) {
    return this.x -= t, this.y -= e, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addXY(t, e) {
    return this.x += t, this.y += e, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  clamp(t, e) {
    return this.x = Math.max(this.x, t), this.y = Math.max(this.y, t), e !== void 0 && (this.x = Math.min(this.x, e), this.y = Math.min(this.y, e)), this;
  }
  div(t) {
    return this.x /= t, this.y /= t, this;
  }
  divV(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  mul(t) {
    return this.x *= t, this.y *= t, this;
  }
  mulV(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(t, e) {
    const r = O.Tan(t, this);
    return this.add(r.mul(e));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(t) {
    return this.x = this.y * t.z - this.z * t.y, this.y = this.z * t.x - this.x * t.z, this;
  }
  dpr(t) {
    return O.Dpr(this, t);
  }
  cpr(t) {
    return O.Cpr(this, t);
  }
  len2() {
    return O.Len2(this);
  }
  len() {
    return O.Len(this);
  }
  pry(t) {
    return O.Pry(this, t);
  }
  per() {
    const { x: t, y: e } = this;
    return this.x = e, this.y = -t, this;
  }
  uni() {
    return O.Uni(this);
  }
  tan(t) {
    return O.Tan(this, t);
  }
  dist(t) {
    return O.Dist(this, t);
  }
  distanceToLineSegment(t, e) {
    return O.DistanceToLineSegment(t, e, this);
  }
  slope(t) {
    return O.Slope(this, t);
  }
  snapToGrid(t) {
    return this.x = Math.round(this.x / t) * t, this.y = Math.round(this.y / t) * t, this;
  }
  angle(t) {
    return O.Angle(this, t);
  }
  toAngle() {
    return O.ToAngle(this);
  }
  lrp(t, e) {
    return this.x = this.x + (t.x - this.x) * e, this.y = this.y + (t.y - this.y) * e, this;
  }
  equals(t) {
    return O.Equals(this, t);
  }
  equalsXY(t, e) {
    return O.EqualsXY(this, t, e);
  }
  norm() {
    const t = this.len();
    return this.x = t === 0 ? 0 : this.x / t, this.y = t === 0 ? 0 : this.y / t, this;
  }
  toFixed() {
    return O.ToFixed(this);
  }
  toString() {
    return O.ToString(O.ToFixed(this));
  }
  toJson() {
    return O.ToJson(this);
  }
  toArray() {
    return O.ToArray(this);
  }
  static Add(t, e) {
    return new O(t.x + e.x, t.y + e.y);
  }
  static AddXY(t, e, r) {
    return new O(t.x + e, t.y + r);
  }
  static Sub(t, e) {
    return new O(t.x - e.x, t.y - e.y);
  }
  static SubXY(t, e, r) {
    return new O(t.x - e, t.y - r);
  }
  static AddScalar(t, e) {
    return new O(t.x + e, t.y + e);
  }
  static SubScalar(t, e) {
    return new O(t.x - e, t.y - e);
  }
  static Div(t, e) {
    return new O(t.x / e, t.y / e);
  }
  static Mul(t, e) {
    return new O(t.x * e, t.y * e);
  }
  static DivV(t, e) {
    return new O(t.x / e.x, t.y / e.y);
  }
  static MulV(t, e) {
    return new O(t.x * e.x, t.y * e.y);
  }
  static Neg(t) {
    return new O(-t.x, -t.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(t) {
    return new O(t.y, -t.x);
  }
  static Abs(t) {
    return new O(Math.abs(t.x), Math.abs(t.y));
  }
  // Get the distance between two points.
  static Dist(t, e) {
    return ((t.y - e.y) ** 2 + (t.x - e.x) ** 2) ** 0.5;
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(t, e, r) {
    return (t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y) < r ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(t, e) {
    return (t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(t, e) {
    return t.x * e.x + t.y * e.y;
  }
  static Cross(t, e) {
    return new O(
      t.y * e.z - t.z * e.y,
      t.z * e.x - t.x * e.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(t, e) {
    return t.x * e.y - e.x * t.y;
  }
  static Len2(t) {
    return t.x * t.x + t.y * t.y;
  }
  static Len(t) {
    return (t.x * t.x + t.y * t.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(t, e) {
    return O.Dpr(t, e) / O.Len(e);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(t) {
    return O.Div(t, O.Len(t));
  }
  static Tan(t, e) {
    return O.Uni(O.Sub(t, e));
  }
  static Min(t, e) {
    return new O(Math.min(t.x, e.x), Math.min(t.y, e.y));
  }
  static Max(t, e) {
    return new O(Math.max(t.x, e.x), Math.max(t.y, e.y));
  }
  static From({ x: t, y: e, z: r = 1 }) {
    return new O(t, e, r);
  }
  static FromArray(t) {
    return new O(t[0], t[1]);
  }
  static Rot(t, e = 0) {
    const r = Math.sin(e), i = Math.cos(e);
    return new O(t.x * i - t.y * r, t.x * r + t.y * i);
  }
  static RotWith(t, e, r) {
    const i = t.x - e.x, s = t.y - e.y, o = Math.sin(r), l = Math.cos(r);
    return new O(e.x + (i * l - s * o), e.y + (i * o + s * l));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(t, e, r) {
    return O.Mul(e, O.Sub(r, t).pry(e)).add(t);
  }
  static NearestPointOnLineSegment(t, e, r, i = !0) {
    if (O.Equals(t, r) || O.Equals(e, r)) return O.From(r);
    const s = O.Tan(e, t), o = O.Add(t, O.Mul(s, O.Sub(r, t).pry(s)));
    if (i) {
      if (o.x < Math.min(t.x, e.x)) return O.Cast(t.x < e.x ? t : e);
      if (o.x > Math.max(t.x, e.x)) return O.Cast(t.x > e.x ? t : e);
      if (o.y < Math.min(t.y, e.y)) return O.Cast(t.y < e.y ? t : e);
      if (o.y > Math.max(t.y, e.y)) return O.Cast(t.y > e.y ? t : e);
    }
    return o;
  }
  static DistanceToLineThroughPoint(t, e, r) {
    return O.Dist(r, O.NearestPointOnLineThroughPoint(t, e, r));
  }
  static DistanceToLineSegment(t, e, r, i = !0) {
    return O.Dist(r, O.NearestPointOnLineSegment(t, e, r, i));
  }
  static Snap(t, e = 1) {
    return new O(Math.round(t.x / e) * e, Math.round(t.y / e) * e);
  }
  static Cast(t) {
    return t instanceof O ? t : O.From(t);
  }
  static Slope(t, e) {
    return t.x === e.y ? NaN : (t.y - e.y) / (t.x - e.x);
  }
  static IsNaN(t) {
    return isNaN(t.x) || isNaN(t.y);
  }
  static Angle(t, e) {
    return Math.atan2(e.y - t.y, e.x - t.x);
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(t, e, r) {
    return O.Sub(e, t).mul(r).add(t);
  }
  static Med(t, e) {
    return new O((t.x + e.x) / 2, (t.y + e.y) / 2);
  }
  static Equals(t, e) {
    return Math.abs(t.x - e.x) < 1e-4 && Math.abs(t.y - e.y) < 1e-4;
  }
  static EqualsXY(t, e, r) {
    return t.x === e && t.y === r;
  }
  static Clockwise(t, e, r) {
    return (r.x - t.x) * (e.y - t.y) - (e.x - t.x) * (r.y - t.y) < 0;
  }
  static Rescale(t, e) {
    const r = O.Len(t);
    return new O(e * t.x / r, e * t.y / r);
  }
  static ScaleWithOrigin(t, e, r) {
    return O.Sub(t, r).mul(e).add(r);
  }
  static ToFixed(t) {
    return new O(op(t.x), op(t.y));
  }
  static ToInt(t) {
    return new O(
      parseInt(t.x.toFixed(0)),
      parseInt(t.y.toFixed(0)),
      parseInt((t.z ?? 0).toFixed(0))
    );
  }
  static ToCss(t) {
    return `${t.x},${t.y}`;
  }
  static Nudge(t, e, r) {
    return O.Add(t, O.Tan(e, t).mul(r));
  }
  static ToString(t) {
    return `${t.x}, ${t.y}`;
  }
  static ToAngle(t) {
    let e = Math.atan2(t.y, t.x);
    return e < 0 && (e += Math.PI * 2), e;
  }
  static FromAngle(t, e = 1) {
    return new O(Math.cos(t) * e, Math.sin(t) * e);
  }
  static ToArray(t) {
    return [t.x, t.y, t.z];
  }
  static ToJson(t) {
    const { x: e, y: r, z: i } = t;
    return { x: e, y: r, z: i };
  }
  static Average(t) {
    const e = t.length, r = new O(0, 0);
    if (e === 0)
      return r;
    for (let i = 0; i < e; i++)
      r.add(t[i]);
    return r.div(e);
  }
  static Clamp(t, e, r) {
    return r === void 0 ? new O(Math.min(Math.max(t.x, e)), Math.min(Math.max(t.y, e))) : new O(Math.min(Math.max(t.x, e), r), Math.min(Math.max(t.y, e), r));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(t, e, r = 6) {
    const i = [];
    for (let s = 0; s < r; s++) {
      const o = Js.easeInQuad(s / (r - 1)), l = O.Lrp(t, e, o);
      l.z = Math.min(1, 0.5 + Math.abs(0.5 - xye(o)) * 0.65), i.push(l);
    }
    return i;
  }
  static SnapToGrid(t, e = 8) {
    return new O(Math.round(t.x / e) * e, Math.round(t.y / e) * e);
  }
}
const xye = (n) => n < 0.5 ? 2 * n * n : -1 + (4 - 2 * n) * n;
function ar(n) {
  return `${be(n.x)},${be(n.y)} `;
}
function Rl(n, t) {
  return `${be((n.x + t.x) / 2)},${be((n.y + t.y) / 2)} `;
}
const cr = Math.PI, ri = cr / 2, wr = cr * 2, wye = Math.sin;
function Zs(n, t, e) {
  return Math.max(t, typeof e < "u" ? Math.min(n, e) : n);
}
function lI(n, t = 1e10) {
  return n ? Math.round(n * t) / t : 0;
}
function vm(n, t, e = 1e-6) {
  return Math.abs(n - t) <= e;
}
function EK(n, t) {
  const e = Math.pow(n - t, 2) / Math.pow(n + t, 2);
  return cr * (n + t) * (1 + 3 * e / (10 + Math.sqrt(4 - 3 * e)));
}
function ym(n) {
  return n = n % wr, n < 0 ? n = n + wr : n === 0 && (n = 0), n;
}
function zT(n, t) {
  return n = ym(n), t = ym(t), n > t && (t += wr), t - n;
}
function _K(n, t) {
  return wr - zT(n, t);
}
function ZI(n, t) {
  const e = (t - n) % wr;
  return 2 * e % wr - e;
}
function p3(n) {
  return (wr + n) % wr;
}
function EM(n, t) {
  const e = wr / t;
  let r = Math.floor((p3(n) + e / 2) / e) * e % wr;
  return r < cr && (r += wr), r > cr && (r -= wr), r;
}
function TK(n, t) {
  return n === t || vm(n % (Math.PI / 2) - t % (Math.PI / 2), 0);
}
function Cye(n) {
  return n * cr / 180;
}
function Eye(n) {
  return n * 180 / cr;
}
function nS(n, t, e) {
  return new O(n.x, n.y).add(O.FromAngle(e, t));
}
function TN(n, t, e) {
  const r = n / 2, i = t / 2, s = [];
  let o = 1 / 0, l = -1 / 0, u = 1 / 0, d = -1 / 0;
  for (let w = 0; w < e; w++) {
    const E = wr / e, A = -ri + w * E, P = r + r * Math.cos(A), R = i + i * Math.sin(A);
    P < o && (o = P), R < u && (u = R), P > l && (l = P), R > d && (d = R), s.push(new O(P, R));
  }
  const f = l - o, m = d - u, v = n - f, S = t - m;
  if (v !== 0 || S !== 0)
    for (let w = 0; w < s.length; w++) {
      const E = s[w];
      E.x = (E.x - o) / f * n, E.y = (E.y - u) / m * t;
    }
  return s;
}
function ME(n, t, e, r) {
  return n < r && e < t;
}
function nd(n, t, e, r) {
  const i = Math.max(n, e), s = Math.min(t, r);
  return i <= s ? [i, s] : null;
}
function p9(n, t, e) {
  return (t.x - n.x) * (e.y - n.y) - (e.x - n.x) * (t.y - n.y);
}
function yc(n, t) {
  let e = 0, r, i;
  for (let s = 0; s < t.length; s++) {
    if (r = t[s], r.x === n.x && r.y === n.y || (i = t[(s + 1) % t.length], O.Dist(n, r) + O.Dist(n, i) === O.Dist(r, i))) return !0;
    r.y <= n.y ? i.y > n.y && p9(r, i, n) > 0 && (e += 1) : i.y <= n.y && p9(r, i, n) < 0 && (e -= 1);
  }
  return e !== 0;
}
function be(n) {
  return Math.round(n * 1e4) / 1e4;
}
function op(n) {
  return Math.round(n * 100) / 100;
}
const g9 = (n) => Math.abs(n) < Number.MAX_SAFE_INTEGER;
function Bg(n, t, e) {
  return e < 0 ? zT(n, t) : _K(n, t);
}
function g3(n, t, e, r) {
  let i;
  if (Math.abs(n) > cr) {
    i = ZI(t, r);
    const s = ZI(r, e);
    return Math.abs(i) < Math.abs(s) ? i / n : (n - s) / n;
  } else {
    i = ZI(t, r);
    const s = i / n;
    return Math.sign(i) !== Math.sign(n) ? Math.abs(s) > 0.5 ? 1 : 0 : s;
  }
}
function _ye(n, t, e, r) {
  const i = 2 * ((t - n) % wr) % wr - (t - n) % wr;
  return r ? (wr - Math.abs(i)) * (e ? 1 : -1) : i;
}
function h5(n, t, e) {
  const r = -2 * (n.x * (t.y - e.y) - n.y * (t.x - e.x) + t.x * e.y - e.x * t.y);
  return new O(
    ((n.x * n.x + n.y * n.y) * (e.y - t.y) + (t.x * t.x + t.y * t.y) * (n.y - e.y) + (e.x * e.x + e.y * e.y) * (t.y - n.y)) / r,
    ((n.x * n.x + n.y * n.y) * (t.x - e.x) + (t.x * t.x + t.y * t.y) * (e.x - n.x) + (e.x * e.x + e.y * e.y) * (n.x - t.x)) / r
  );
}
function Tye(n, t, e, r, i) {
  if (e === null)
    return [O.From(n), O.From(t)];
  const s = [], o = O.Angle(e, n), l = O.Angle(e, t), u = zT(o, l);
  for (let d = 0; d < i; d++) {
    const f = d / (i - 1), m = o + u * f, v = nS(e, r, m);
    s.push(v);
  }
  return s;
}
const PN = ({ brush: n, color: t, opacity: e, className: r }) => {
  const i = D.useRef(null);
  fw(i, n.x, n.y);
  const s = be(Math.max(1, n.w)), o = be(Math.max(1, n.h));
  return /* @__PURE__ */ y.jsx("svg", { className: "tl-overlays__item", ref: i, children: t ? /* @__PURE__ */ y.jsxs("g", { className: "tl-brush", opacity: e, children: [
    /* @__PURE__ */ y.jsx("rect", { width: s, height: o, fill: t, opacity: 0.75 }),
    /* @__PURE__ */ y.jsx("rect", { width: s, height: o, fill: "none", stroke: t, opacity: 0.1 })
  ] }) : /* @__PURE__ */ y.jsx("rect", { className: `tl-brush tl-brush__default ${r}`, width: s, height: o }) });
}, m9 = {
  isLocked: !1,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.1, 0.25, 0.5, 1, 2, 4, 8]
}, AN = {
  duration: 0,
  easing: Js.easeInOutCubic
}, v9 = {
  CAMERA_MOVE: -10
}, Pye = ["top", "right", "bottom", "left"], y9 = 0, f5 = 2, cI = 1, S9 = 5, Aye = 128;
function _M(n) {
  if (n instanceof HTMLElement) return n;
  if (n.parentElement) return _M(n.parentElement);
  throw Error("Could not find a parent element of an HTML type!");
}
function qn(n) {
  n.preventDefault(), qi.logPreventDefaults.get() && console.warn("preventDefault called on event:", n);
}
function UT(n, t) {
  if (n.setPointerCapture(t.pointerId), qi.logPointerCaptures.get()) {
    const e = IG.get();
    e.set(n, (e.get(n) ?? 0) + 1), console.warn("setPointerCapture called on element:", n, t);
  }
}
function BT(n, t) {
  if (n.hasPointerCapture(t.pointerId) && (n.releasePointerCapture(t.pointerId), qi.logPointerCaptures.get())) {
    const e = IG.get();
    e.get(n) === 1 ? e.delete(n) : e.has(n) ? e.set(n, e.get(n) - 1) : console.warn("Release without capture"), console.warn("releasePointerCapture called on element:", n, t);
  }
}
const to = (n) => n.stopPropagation(), aa = (n, t, e) => {
  n && n.style.setProperty(t, e);
};
function Ol(n) {
  return n.isKilled = !0, {
    point: {
      x: n.clientX,
      y: n.clientY,
      z: n.pressure
    },
    shiftKey: n.shiftKey,
    altKey: n.altKey,
    ctrlKey: n.metaKey || n.ctrlKey,
    pointerId: n.pointerId,
    button: n.button,
    isPen: n.pointerType === "pen"
  };
}
function PK() {
  const n = we();
  return D.useMemo(
    function() {
      let r, i;
      function s(E) {
        if (!E.isKilled) {
          if (E.button === f5) {
            n.dispatch({
              type: "pointer",
              target: "canvas",
              name: "right_click",
              ...Ol(E)
            });
            return;
          }
          E.button !== 0 && E.button !== 1 && E.button !== 5 || (UT(E.currentTarget, E), n.dispatch({
            type: "pointer",
            target: "canvas",
            name: "pointer_down",
            ...Ol(E)
          }));
        }
      }
      function o(E) {
        E.isKilled || E.clientX === r && E.clientY === i || (r = E.clientX, i = E.clientY, n.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...Ol(E)
        }));
      }
      function l(E) {
        E.isKilled || E.button !== 0 && E.button !== 1 && E.button !== 2 && E.button !== 5 || (r = E.clientX, i = E.clientY, BT(E.currentTarget, E), n.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...Ol(E)
        }));
      }
      function u(E) {
        if (E.isKilled || n.getInstanceState().isPenMode && E.pointerType !== "pen") return;
        const A = E.pointerType === "mouse" || E.pointerType === "pen";
        n.updateInstanceState({ isHoveringCanvas: A ? !0 : null });
      }
      function d(E) {
        if (E.isKilled || n.getInstanceState().isPenMode && E.pointerType !== "pen") return;
        const A = E.pointerType === "mouse" || E.pointerType === "pen";
        n.updateInstanceState({ isHoveringCanvas: A ? !1 : null });
      }
      function f(E) {
        E.isKilled = !0, qn(E);
      }
      function m(E) {
        E.isKilled = !0, E.target instanceof HTMLElement && E.target.tagName !== "A" && E.target.tagName !== "TEXTAREA" && // When in EditingShape state, we are actually clicking on a 'DIV'
        // not A/TEXTAREA element yet. So, to preserve cursor position
        // for edit mode on mobile we need to not preventDefault.
        // TODO: Find out if we still need this preventDefault in general though.
        !(n.getEditingShape() && E.target.className.includes("tl-text-content")) && qn(E);
      }
      function v(E) {
        qn(E);
      }
      async function S(E) {
        var P, R;
        if (qn(E), !((R = (P = E.dataTransfer) == null ? void 0 : P.files) != null && R.length)) return;
        const A = Array.from(E.dataTransfer.files);
        await n.putExternalContent({
          type: "files",
          files: A,
          point: n.screenToPage({ x: E.clientX, y: E.clientY }),
          ignoreParent: !1
        });
      }
      function w(E) {
        to(E);
      }
      return {
        onPointerDown: s,
        onPointerMove: o,
        onPointerUp: l,
        onPointerEnter: u,
        onPointerLeave: d,
        onDragOver: v,
        onDrop: S,
        onTouchStart: f,
        onTouchEnd: m,
        onClick: w
      };
    },
    [n]
  );
}
function kye() {
  const n = we();
  D.useEffect(() => {
    let t = n.getInstanceState().isCoarsePointer;
    const e = (o) => {
      const l = o.pointerType !== "mouse";
      t !== l && (t = l, n.updateInstanceState({ isCoarsePointer: l }));
    };
    window.addEventListener("pointerdown", e, { capture: !0 });
    const r = window.matchMedia && window.matchMedia("(any-pointer: coarse)"), i = n.environment.isFirefox && !n.environment.isAndroid && !n.environment.isIos, s = () => {
      const o = i ? !1 : r.matches;
      t === o && (t = o, n.updateInstanceState({ isCoarsePointer: o }));
    };
    return r && (r.addEventListener("change", s), s()), () => {
      window.removeEventListener("pointerdown", e, { capture: !0 }), r && r.removeEventListener("change", s);
    };
  }, [n]);
}
const AK = D.createContext(null);
function Iye({
  container: n,
  children: t
}) {
  return /* @__PURE__ */ y.jsx(AK.Provider, { value: n, children: t });
}
function io() {
  return nu(D.useContext(AK), "useContainer used outside of <Tldraw />");
}
function Rye() {
  const n = we(), t = io(), e = De("isFocused", () => n.getIsFocused(), [n]);
  D.useEffect(() => {
    if (typeof window > "u" || !("matchMedia" in window)) return;
    let r = null;
    const i = () => {
      r != null && r();
      const s = `(resolution: ${window.devicePixelRatio}dppx)`, o = matchMedia(s), l = (u) => {
        u.type === "change" && i();
      };
      o.addEventListener ? o.addEventListener("change", i) : o.addListener && o.addListener(l), r = () => {
        o.removeEventListener ? o.removeEventListener("change", i) : o.removeListener && o.removeListener(l);
      }, n.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    return i(), () => {
      r == null || r();
    };
  }, [n]), D.useEffect(() => {
    if (!e) return;
    const r = (l) => {
      if (l.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (n.isIn("zoom") || !n.getPath().endsWith(".idle")) && !uI() && qn(l), l.isKilled) return;
      switch (l.isKilled = !0, l.key) {
        case "=":
        case "-":
        case "0": {
          if (l.metaKey || l.ctrlKey) {
            qn(l);
            return;
          }
          break;
        }
        case "Tab": {
          if (uI() || n.getIsMenuOpen())
            return;
          break;
        }
        case ",":
          return;
        case "Escape": {
          if ((n.getEditingShape() || n.getSelectedShapeIds().length > 0) && l.preventDefault(), n.getOpenMenus().length > 0) return;
          n.inputs.keys.has("Escape") || (n.inputs.keys.add("Escape"), n.cancel(), n.focus());
          return;
        }
        default:
          if (uI() || n.getIsMenuOpen())
            return;
      }
      const u = {
        type: "keyboard",
        name: l.repeat ? "key_repeat" : "key_down",
        key: l.key,
        code: l.code,
        shiftKey: l.shiftKey,
        altKey: l.altKey,
        ctrlKey: l.metaKey || l.ctrlKey
      };
      n.dispatch(u);
    }, i = (l) => {
      if (l.isKilled || (l.isKilled = !0, uI() || n.getIsMenuOpen()) || l.key === ",")
        return;
      const u = {
        type: "keyboard",
        name: "key_up",
        key: l.key,
        code: l.code,
        shiftKey: l.shiftKey,
        altKey: l.altKey,
        ctrlKey: l.metaKey || l.ctrlKey
      };
      n.dispatch(u);
    };
    function s(l) {
      var u, d;
      if (t.contains(l.target)) {
        const f = l.touches[0].pageX, m = l.touches[0].radiusX || 0;
        (f - m < 10 || f + m > n.getViewportScreenBounds().width - 10) && (((u = l.target) == null ? void 0 : u.tagName) === "BUTTON" && ((d = l.target) == null || d.click()), qn(l));
      }
    }
    const o = (l) => {
      t.contains(l.target) && (l.ctrlKey || l.metaKey) && qn(l);
    };
    return t.addEventListener("touchstart", s, { passive: !1 }), t.addEventListener("wheel", o, { passive: !1 }), document.addEventListener("gesturestart", qn), document.addEventListener("gesturechange", qn), document.addEventListener("gestureend", qn), t.addEventListener("keydown", r), t.addEventListener("keyup", i), () => {
      t.removeEventListener("touchstart", s), t.removeEventListener("wheel", o), document.removeEventListener("gesturestart", qn), document.removeEventListener("gesturechange", qn), document.removeEventListener("gestureend", qn), t.removeEventListener("keydown", r), t.removeEventListener("keyup", i);
    };
  }, [n, t, e]);
}
const Mye = ["input", "select", "button", "textarea"];
function uI() {
  const { activeElement: n } = document;
  return !!(n && (n.getAttribute("contenteditable") || Mye.indexOf(n.tagName.toLowerCase()) > -1));
}
const Dye = ["textarea", "input"];
function Oye(n) {
  const t = we();
  D.useEffect(() => {
    const e = n.current;
    if (!e) return;
    const r = (i) => {
      var s;
      if (i instanceof PointerEvent && i.pointerType === "pen") {
        i.isKilled = !0;
        const { target: o } = i;
        if (Dye.includes((s = o.tagName) == null ? void 0 : s.toLocaleLowerCase()) || t.isIn("select.editing_shape"))
          return;
        qn(i);
      }
    };
    return e.addEventListener("touchstart", r), e.addEventListener("touchend", r), () => {
      e.removeEventListener("touchstart", r), e.removeEventListener("touchend", r);
    };
  }, [t, n]);
}
function Lye(n, t, e) {
  return Math.max(t, Math.min(n, e));
}
const Do = {
  toVector(n, t) {
    return n === void 0 && (n = t), Array.isArray(n) ? n : [n, n];
  },
  add(n, t) {
    return [n[0] + t[0], n[1] + t[1]];
  },
  sub(n, t) {
    return [n[0] - t[0], n[1] - t[1]];
  },
  addTo(n, t) {
    n[0] += t[0], n[1] += t[1];
  },
  subTo(n, t) {
    n[0] -= t[0], n[1] -= t[1];
  }
};
function b9(n, t, e) {
  return t === 0 || Math.abs(t) === 1 / 0 ? Math.pow(n, e * 5) : n * t * e / (t + e * n);
}
function x9(n, t, e, r = 0.15) {
  return r === 0 ? Lye(n, t, e) : n < t ? -b9(t - n, e - t, r) + t : n > e ? +b9(n - e, e - t, r) + e : n;
}
function jye(n, [t, e], [r, i]) {
  const [[s, o], [l, u]] = n;
  return [x9(t, s, o, r), x9(e, l, u, i)];
}
function Nye(n, t) {
  if (typeof n != "object" || n === null) return n;
  var e = n[Symbol.toPrimitive];
  if (e !== void 0) {
    var r = e.call(n, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(n);
}
function Fye(n) {
  var t = Nye(n, "string");
  return typeof t == "symbol" ? t : String(t);
}
function da(n, t, e) {
  return t = Fye(t), t in n ? Object.defineProperty(n, t, {
    value: e,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[t] = e, n;
}
function w9(n, t) {
  var e = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), e.push.apply(e, r);
  }
  return e;
}
function Ri(n) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w9(Object(e), !0).forEach(function(r) {
      da(n, r, e[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(e)) : w9(Object(e)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(e, r));
    });
  }
  return n;
}
const kK = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function C9(n) {
  return n ? n[0].toUpperCase() + n.slice(1) : "";
}
const $ye = ["enter", "leave"];
function zye(n = !1, t) {
  return n && !$ye.includes(t);
}
function Uye(n, t = "", e = !1) {
  const r = kK[n], i = r && r[t] || t;
  return "on" + C9(n) + C9(i) + (zye(e, i) ? "Capture" : "");
}
const Bye = ["gotpointercapture", "lostpointercapture"];
function Hye(n) {
  let t = n.substring(2).toLowerCase();
  const e = !!~t.indexOf("passive");
  e && (t = t.replace("passive", ""));
  const r = Bye.includes(t) ? "capturecapture" : "capture", i = !!~t.indexOf(r);
  return i && (t = t.replace("capture", "")), {
    device: t,
    capture: i,
    passive: e
  };
}
function Vye(n, t = "") {
  const e = kK[n], r = e && e[t] || t;
  return n + r;
}
function IK(n) {
  return "touches" in n;
}
function Wye(n) {
  return IK(n) ? "touch" : "pointerType" in n ? n.pointerType : "mouse";
}
function Gye(n) {
  return Array.from(n.touches).filter((t) => {
    var e, r;
    return t.target === n.currentTarget || ((e = n.currentTarget) === null || e === void 0 || (r = e.contains) === null || r === void 0 ? void 0 : r.call(e, t.target));
  });
}
function m3(n, t) {
  try {
    const e = t.clientX - n.clientX, r = t.clientY - n.clientY, i = (t.clientX + n.clientX) / 2, s = (t.clientY + n.clientY) / 2, o = Math.hypot(e, r);
    return {
      angle: -(Math.atan2(e, r) * 180) / Math.PI,
      distance: o,
      origin: [i, s]
    };
  } catch {
  }
  return null;
}
function Kye(n) {
  return Gye(n).map((t) => t.identifier);
}
function E9(n, t) {
  const [e, r] = Array.from(n.touches).filter((i) => t.includes(i.identifier));
  return m3(e, r);
}
const _9 = 40, T9 = 800;
function RK(n) {
  let {
    deltaX: t,
    deltaY: e,
    deltaMode: r
  } = n;
  return r === 1 ? (t *= _9, e *= _9) : r === 2 && (t *= T9, e *= T9), [t, e];
}
function Yye(n) {
  const t = {};
  if ("buttons" in n && (t.buttons = n.buttons), "shiftKey" in n) {
    const {
      shiftKey: e,
      altKey: r,
      metaKey: i,
      ctrlKey: s
    } = n;
    Object.assign(t, {
      shiftKey: e,
      altKey: r,
      metaKey: i,
      ctrlKey: s
    });
  }
  return t;
}
function TM(n, ...t) {
  return typeof n == "function" ? n(...t) : n;
}
function Xye() {
}
function qye(...n) {
  return n.length === 0 ? Xye : n.length === 1 ? n[0] : function() {
    let t;
    for (const e of n)
      t = e.apply(this, arguments) || t;
    return t;
  };
}
function P9(n, t) {
  return Object.assign({}, t, n || {});
}
const Zye = 32;
class MK {
  constructor(t, e, r) {
    this.ctrl = t, this.args = e, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(t) {
    this.ctrl.state[this.key] = t;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: t,
      shared: e,
      ingKey: r,
      args: i
    } = this;
    e[r] = t._active = t.active = t._blocked = t._force = !1, t._step = [!1, !1], t.intentional = !1, t._movement = [0, 0], t._distance = [0, 0], t._direction = [0, 0], t._delta = [0, 0], t._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], t.args = i, t.axis = void 0, t.memo = void 0, t.elapsedTime = t.timeDelta = 0, t.direction = [0, 0], t.distance = [0, 0], t.overflow = [0, 0], t._movementBound = [!1, !1], t.velocity = [0, 0], t.movement = [0, 0], t.delta = [0, 0], t.timeStamp = 0;
  }
  start(t) {
    const e = this.state, r = this.config;
    e._active || (this.reset(), this.computeInitial(), e._active = !0, e.target = t.target, e.currentTarget = t.currentTarget, e.lastOffset = r.from ? TM(r.from, e) : e.offset, e.offset = e.lastOffset, e.startTime = e.timeStamp = t.timeStamp);
  }
  computeValues(t) {
    const e = this.state;
    e._values = t, e.values = this.config.transform(t);
  }
  computeInitial() {
    const t = this.state;
    t._initial = t._values, t.initial = t.values;
  }
  compute(t) {
    const {
      state: e,
      config: r,
      shared: i
    } = this;
    e.args = this.args;
    let s = 0;
    if (t && (e.event = t, r.preventDefault && t.cancelable && e.event.preventDefault(), e.type = t.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, Yye(t)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, s = t.timeStamp - e.timeStamp, e.timeStamp = t.timeStamp, e.elapsedTime = e.timeStamp - e.startTime), e._active) {
      const U = e._delta.map(Math.abs);
      Do.addTo(e._distance, U);
    }
    this.axisIntent && this.axisIntent(t);
    const [o, l] = e._movement, [u, d] = r.threshold, {
      _step: f,
      values: m
    } = e;
    if (r.hasCustomTransform ? (f[0] === !1 && (f[0] = Math.abs(o) >= u && m[0]), f[1] === !1 && (f[1] = Math.abs(l) >= d && m[1])) : (f[0] === !1 && (f[0] = Math.abs(o) >= u && Math.sign(o) * u), f[1] === !1 && (f[1] = Math.abs(l) >= d && Math.sign(l) * d)), e.intentional = f[0] !== !1 || f[1] !== !1, !e.intentional) return;
    const v = [0, 0];
    if (r.hasCustomTransform) {
      const [U, F] = m;
      v[0] = f[0] !== !1 ? U - f[0] : 0, v[1] = f[1] !== !1 ? F - f[1] : 0;
    } else
      v[0] = f[0] !== !1 ? o - f[0] : 0, v[1] = f[1] !== !1 ? l - f[1] : 0;
    this.restrictToAxis && !e._blocked && this.restrictToAxis(v);
    const S = e.offset, w = e._active && !e._blocked || e.active;
    w && (e.first = e._active && !e.active, e.last = !e._active && e.active, e.active = i[this.ingKey] = e._active, t && (e.first && ("bounds" in r && (e._bounds = TM(r.bounds, e)), this.setup && this.setup()), e.movement = v, this.computeOffset()));
    const [E, A] = e.offset, [[P, R], [M, j]] = e._bounds;
    e.overflow = [E < P ? -1 : E > R ? 1 : 0, A < M ? -1 : A > j ? 1 : 0], e._movementBound[0] = e.overflow[0] ? e._movementBound[0] === !1 ? e._movement[0] : e._movementBound[0] : !1, e._movementBound[1] = e.overflow[1] ? e._movementBound[1] === !1 ? e._movement[1] : e._movementBound[1] : !1;
    const $ = e._active ? r.rubberband || [0, 0] : [0, 0];
    if (e.offset = jye(e._bounds, e.offset, $), e.delta = Do.sub(e.offset, S), this.computeMovement(), w && (!e.last || s > Zye)) {
      e.delta = Do.sub(e.offset, S);
      const U = e.delta.map(Math.abs);
      Do.addTo(e.distance, U), e.direction = e.delta.map(Math.sign), e._direction = e._delta.map(Math.sign), !e.first && s > 0 && (e.velocity = [U[0] / s, U[1] / s], e.timeDelta = s);
    }
  }
  emit() {
    const t = this.state, e = this.shared, r = this.config;
    if (t._active || this.clean(), (t._blocked || !t.intentional) && !t._force && !r.triggerAllEvents) return;
    const i = this.handler(Ri(Ri(Ri({}, e), t), {}, {
      [this.aliasKey]: t.values
    }));
    i !== void 0 && (t.memo = i);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function Qye([n, t], e) {
  const r = Math.abs(n), i = Math.abs(t);
  if (r > i && r > e)
    return "x";
  if (i > r && i > e)
    return "y";
}
class Jye extends MK {
  constructor(...t) {
    super(...t), da(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = Do.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = Do.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(t) {
    const e = this.state, r = this.config;
    if (!e.axis && t) {
      const i = typeof r.axisThreshold == "object" ? r.axisThreshold[Wye(t)] : r.axisThreshold;
      e.axis = Qye(e._movement, i);
    }
    e._blocked = (r.lockDirection || !!r.axis) && !e.axis || !!r.axis && r.axis !== e.axis;
  }
  restrictToAxis(t) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          t[1] = 0;
          break;
        case "y":
          t[0] = 0;
          break;
      }
  }
}
const A9 = (n) => n, k9 = 0.15, p5 = {
  enabled(n = !0) {
    return n;
  },
  eventOptions(n, t, e) {
    return Ri(Ri({}, e.shared.eventOptions), n);
  },
  preventDefault(n = !1) {
    return n;
  },
  triggerAllEvents(n = !1) {
    return n;
  },
  rubberband(n = 0) {
    switch (n) {
      case !0:
        return [k9, k9];
      case !1:
        return [0, 0];
      default:
        return Do.toVector(n);
    }
  },
  from(n) {
    if (typeof n == "function") return n;
    if (n != null) return Do.toVector(n);
  },
  transform(n, t, e) {
    const r = n || e.shared.transform;
    if (this.hasCustomTransform = !!r, process.env.NODE_ENV === "development") {
      const i = r || A9;
      return (s) => {
        const o = i(s);
        return (!isFinite(o[0]) || !isFinite(o[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${o[0]},${[1]}]`), o;
      };
    }
    return r || A9;
  },
  threshold(n) {
    return Do.toVector(n, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(p5, {
  domTarget(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const eSe = 0, HT = Ri(Ri({}, p5), {}, {
  axis(n, t, {
    axis: e
  }) {
    if (this.lockDirection = e === "lock", !this.lockDirection) return e;
  },
  axisThreshold(n = eSe) {
    return n;
  },
  bounds(n = {}) {
    if (typeof n == "function")
      return (s) => HT.bounds(n(s));
    if ("current" in n)
      return () => n.current;
    if (typeof HTMLElement == "function" && n instanceof HTMLElement)
      return n;
    const {
      left: t = -1 / 0,
      right: e = 1 / 0,
      top: r = -1 / 0,
      bottom: i = 1 / 0
    } = n;
    return [[t, e], [r, i]];
  }
}), VT = typeof window < "u" && window.document && window.document.createElement;
function DK() {
  return VT && "ontouchstart" in window;
}
function tSe() {
  return DK() || VT && window.navigator.maxTouchPoints > 1;
}
function nSe() {
  return VT && "onpointerdown" in window;
}
function rSe() {
  return VT && "exitPointerLock" in window.document;
}
function iSe() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const ru = {
  isBrowser: VT,
  gesture: iSe(),
  touch: DK(),
  touchscreen: tSe(),
  pointer: nSe(),
  pointerLock: rSe()
}, sSe = 250, oSe = 180, aSe = 0.5, lSe = 50, cSe = 250, uSe = 10, I9 = {
  mouse: 0,
  touch: 0,
  pen: 8
}, dSe = Ri(Ri({}, HT), {}, {
  device(n, t, {
    pointer: {
      touch: e = !1,
      lock: r = !1,
      mouse: i = !1
    } = {}
  }) {
    return this.pointerLock = r && ru.pointerLock, ru.touch && e ? "touch" : this.pointerLock ? "mouse" : ru.pointer && !i ? "pointer" : ru.touch ? "touch" : "mouse";
  },
  preventScrollAxis(n, t, {
    preventScroll: e
  }) {
    if (this.preventScrollDelay = typeof e == "number" ? e : e || e === void 0 && n ? sSe : void 0, !(!ru.touchscreen || e === !1))
      return n || (e !== void 0 ? "y" : void 0);
  },
  pointerCapture(n, t, {
    pointer: {
      capture: e = !0,
      buttons: r = 1,
      keys: i = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = i, !this.pointerLock && this.device === "pointer" && e;
  },
  threshold(n, t, {
    filterTaps: e = !1,
    tapsThreshold: r = 3,
    axis: i = void 0
  }) {
    const s = Do.toVector(n, e ? r : i ? 1 : 0);
    return this.filterTaps = e, this.tapsThreshold = r, s;
  },
  swipe({
    velocity: n = aSe,
    distance: t = lSe,
    duration: e = cSe
  } = {}) {
    return {
      velocity: this.transform(Do.toVector(n)),
      distance: this.transform(Do.toVector(t)),
      duration: e
    };
  },
  delay(n = 0) {
    switch (n) {
      case !0:
        return oSe;
      case !1:
        return 0;
      default:
        return n;
    }
  },
  axisThreshold(n) {
    return n ? Ri(Ri({}, I9), n) : I9;
  },
  keyboardDisplacement(n = uSe) {
    return n;
  }
});
process.env.NODE_ENV === "development" && Object.assign(dSe, {
  useTouch(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function OK(n) {
  const [t, e] = n.overflow, [r, i] = n._delta, [s, o] = n._direction;
  (t < 0 && r > 0 && s < 0 || t > 0 && r < 0 && s > 0) && (n._movement[0] = n._movementBound[0]), (e < 0 && i > 0 && o < 0 || e > 0 && i < 0 && o > 0) && (n._movement[1] = n._movementBound[1]);
}
const hSe = 30, fSe = 100;
class pSe extends MK {
  constructor(...t) {
    super(...t), da(this, "ingKey", "pinching"), da(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const t = this.state;
    t._touchIds = [], t.canceled = !1, t.cancel = this.cancel.bind(this), t.turns = 0;
  }
  computeOffset() {
    const {
      type: t,
      movement: e,
      lastOffset: r
    } = this.state;
    t === "wheel" ? this.state.offset = Do.add(e, r) : this.state.offset = [(1 + e[0]) * r[0], e[1] + r[1]];
  }
  computeMovement() {
    const {
      offset: t,
      lastOffset: e
    } = this.state;
    this.state.movement = [t[0] / e[0], t[1] - e[1]];
  }
  axisIntent() {
    const t = this.state, [e, r] = t._movement;
    if (!t.axis) {
      const i = Math.abs(e) * hSe - Math.abs(r);
      i < 0 ? t.axis = "angle" : i > 0 && (t.axis = "scale");
    }
  }
  restrictToAxis(t) {
    this.config.lockDirection && (this.state.axis === "scale" ? t[1] = 0 : this.state.axis === "angle" && (t[0] = 0));
  }
  cancel() {
    const t = this.state;
    t.canceled || setTimeout(() => {
      t.canceled = !0, t._active = !1, this.compute(), this.emit();
    }, 0);
  }
  touchStart(t) {
    this.ctrl.setEventIds(t);
    const e = this.state, r = this.ctrl.touchIds;
    if (e._active && e._touchIds.every((s) => r.has(s)) || r.size < 2) return;
    this.start(t), e._touchIds = Array.from(r).slice(0, 2);
    const i = E9(t, e._touchIds);
    i && this.pinchStart(t, i);
  }
  pointerStart(t) {
    if (t.buttons != null && t.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(t), t.target.setPointerCapture(t.pointerId);
    const e = this.state, r = e._pointerEvents, i = this.ctrl.pointerIds;
    if (e._active && Array.from(r.keys()).every((o) => i.has(o)) || (r.size < 2 && r.set(t.pointerId, t), e._pointerEvents.size < 2)) return;
    this.start(t);
    const s = m3(...Array.from(r.values()));
    s && this.pinchStart(t, s);
  }
  pinchStart(t, e) {
    const r = this.state;
    r.origin = e.origin, this.computeValues([e.distance, e.angle]), this.computeInitial(), this.compute(t), this.emit();
  }
  touchMove(t) {
    if (!this.state._active) return;
    const e = E9(t, this.state._touchIds);
    e && this.pinchMove(t, e);
  }
  pointerMove(t) {
    const e = this.state._pointerEvents;
    if (e.has(t.pointerId) && e.set(t.pointerId, t), !this.state._active) return;
    const r = m3(...Array.from(e.values()));
    r && this.pinchMove(t, r);
  }
  pinchMove(t, e) {
    const r = this.state, i = r._values[1], s = e.angle - i;
    let o = 0;
    Math.abs(s) > 270 && (o += Math.sign(s)), this.computeValues([e.distance, e.angle - 360 * o]), r.origin = e.origin, r.turns = o, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(t), this.emit();
  }
  touchEnd(t) {
    this.ctrl.setEventIds(t), this.state._active && this.state._touchIds.some((e) => !this.ctrl.touchIds.has(e)) && (this.state._active = !1, this.compute(t), this.emit());
  }
  pointerEnd(t) {
    const e = this.state;
    this.ctrl.setEventIds(t);
    try {
      t.target.releasePointerCapture(t.pointerId);
    } catch {
    }
    e._pointerEvents.has(t.pointerId) && e._pointerEvents.delete(t.pointerId), e._active && e._pointerEvents.size < 2 && (e._active = !1, this.compute(t), this.emit());
  }
  gestureStart(t) {
    t.cancelable && t.preventDefault();
    const e = this.state;
    e._active || (this.start(t), this.computeValues([t.scale, t.rotation]), e.origin = [t.clientX, t.clientY], this.compute(t), this.emit());
  }
  gestureMove(t) {
    if (t.cancelable && t.preventDefault(), !this.state._active) return;
    const e = this.state;
    this.computeValues([t.scale, t.rotation]), e.origin = [t.clientX, t.clientY];
    const r = e._movement;
    e._movement = [t.scale - 1, t.rotation], e._delta = Do.sub(e._movement, r), this.compute(t), this.emit();
  }
  gestureEnd(t) {
    this.state._active && (this.state._active = !1, this.compute(t), this.emit());
  }
  wheel(t) {
    const e = this.config.modifierKey;
    e && (Array.isArray(e) ? !e.find((r) => t[r]) : !t[e]) || (this.state._active ? this.wheelChange(t) : this.wheelStart(t), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)));
  }
  wheelStart(t) {
    this.start(t), this.wheelChange(t);
  }
  wheelChange(t) {
    "uv" in t || (t.cancelable && t.preventDefault(), process.env.NODE_ENV === "development" && !t.defaultPrevented && console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
    const r = this.state;
    r._delta = [-RK(t)[1] / fSe * r.offset[0], 0], Do.addTo(r._movement, r._delta), OK(r), this.state.origin = [t.clientX, t.clientY], this.compute(t), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(t) {
    const e = this.config.device;
    e && (t(e, "start", this[e + "Start"].bind(this)), t(e, "change", this[e + "Move"].bind(this)), t(e, "end", this[e + "End"].bind(this)), t(e, "cancel", this[e + "End"].bind(this)), t("lostPointerCapture", "", this[e + "End"].bind(this))), this.config.pinchOnWheel && t("wheel", "", this.wheel.bind(this), {
      passive: !1
    });
  }
}
const gSe = Ri(Ri({}, p5), {}, {
  device(n, t, {
    shared: e,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (e.target && !ru.touch && ru.gesture) return "gesture";
    if (ru.touch && r) return "touch";
    if (ru.touchscreen) {
      if (ru.pointer) return "pointer";
      if (ru.touch) return "touch";
    }
  },
  bounds(n, t, {
    scaleBounds: e = {},
    angleBounds: r = {}
  }) {
    const i = (o) => {
      const l = P9(TM(e, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [l.min, l.max];
    }, s = (o) => {
      const l = P9(TM(r, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [l.min, l.max];
    };
    return typeof e != "function" && typeof r != "function" ? [i(), s()] : (o) => [i(o), s(o)];
  },
  threshold(n, t, e) {
    return this.lockDirection = e.axis === "lock", Do.toVector(n, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(n) {
    return n === void 0 ? "ctrlKey" : n;
  },
  pinchOnWheel(n = !0) {
    return n;
  }
});
Ri(Ri({}, HT), {}, {
  mouseOnly: (n = !0) => n
});
class mSe extends Jye {
  constructor(...t) {
    super(...t), da(this, "ingKey", "wheeling");
  }
  wheel(t) {
    this.state._active || this.start(t), this.wheelChange(t), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(t) {
    const e = this.state;
    e._delta = RK(t), Do.addTo(e._movement, e._delta), OK(e), this.compute(t), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(t) {
    t("wheel", "", this.wheel.bind(this));
  }
}
const vSe = HT;
Ri(Ri({}, HT), {}, {
  mouseOnly: (n = !0) => n
});
const g5 = /* @__PURE__ */ new Map(), v3 = /* @__PURE__ */ new Map();
function ySe(n) {
  g5.set(n.key, n.engine), v3.set(n.key, n.resolver);
}
const SSe = {
  key: "pinch",
  engine: pSe,
  resolver: gSe
}, bSe = {
  key: "wheel",
  engine: mSe,
  resolver: vSe
};
function xSe(n, t) {
  if (n == null) return {};
  var e = {}, r = Object.keys(n), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(t.indexOf(i) >= 0) && (e[i] = n[i]);
  return e;
}
function wSe(n, t) {
  if (n == null) return {};
  var e = xSe(n, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (i = 0; i < s.length; i++)
      r = s[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (e[r] = n[r]);
  }
  return e;
}
const CSe = {
  target(n) {
    if (n)
      return () => "current" in n ? n.current : n;
  },
  enabled(n = !0) {
    return n;
  },
  window(n = ru.isBrowser ? window : void 0) {
    return n;
  },
  eventOptions({
    passive: n = !0,
    capture: t = !1
  } = {}) {
    return {
      passive: n,
      capture: t
    };
  },
  transform(n) {
    return n;
  }
}, ESe = ["target", "eventOptions", "window", "enabled", "transform"];
function QI(n = {}, t) {
  const e = {};
  for (const [r, i] of Object.entries(t))
    switch (typeof i) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const s = i.call(e, n[r], r, n);
          Number.isNaN(s) || (e[r] = s);
        } else
          e[r] = i.call(e, n[r], r, n);
        break;
      case "object":
        e[r] = QI(n[r], i);
        break;
      case "boolean":
        i && (e[r] = n[r]);
        break;
    }
  return e;
}
function _Se(n, t, e = {}) {
  const r = n, {
    target: i,
    eventOptions: s,
    window: o,
    enabled: l,
    transform: u
  } = r, d = wSe(r, ESe);
  if (e.shared = QI({
    target: i,
    eventOptions: s,
    window: o,
    enabled: l,
    transform: u
  }, CSe), t) {
    const f = v3.get(t);
    e[t] = QI(Ri({
      shared: e.shared
    }, d), f);
  } else
    for (const f in d) {
      const m = v3.get(f);
      if (m)
        e[f] = QI(Ri({
          shared: e.shared
        }, d[f]), m);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(f)) {
        if (f === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${f}\` was used. Please read the documentation for further information.`);
      }
    }
  return e;
}
class LK {
  constructor(t, e) {
    da(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = t, this._gestureKey = e;
  }
  add(t, e, r, i, s) {
    const o = this._listeners, l = Vye(e, r), u = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, d = Ri(Ri({}, u), s);
    t.addEventListener(l, i, d);
    const f = () => {
      t.removeEventListener(l, i, d), o.delete(f);
    };
    return o.add(f), f;
  }
  clean() {
    this._listeners.forEach((t) => t()), this._listeners.clear();
  }
}
class TSe {
  constructor() {
    da(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(t, e, r = 140, ...i) {
    this.remove(t), this._timeouts.set(t, window.setTimeout(e, r, ...i));
  }
  remove(t) {
    const e = this._timeouts.get(t);
    e && window.clearTimeout(e);
  }
  clean() {
    this._timeouts.forEach((t) => void window.clearTimeout(t)), this._timeouts.clear();
  }
}
class PSe {
  constructor(t) {
    da(this, "gestures", /* @__PURE__ */ new Set()), da(this, "_targetEventStore", new LK(this)), da(this, "gestureEventStores", {}), da(this, "gestureTimeoutStores", {}), da(this, "handlers", {}), da(this, "config", {}), da(this, "pointerIds", /* @__PURE__ */ new Set()), da(this, "touchIds", /* @__PURE__ */ new Set()), da(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), ASe(this, t);
  }
  setEventIds(t) {
    if (IK(t))
      return this.touchIds = new Set(Kye(t)), this.touchIds;
    if ("pointerId" in t)
      return t.type === "pointerup" || t.type === "pointercancel" ? this.pointerIds.delete(t.pointerId) : t.type === "pointerdown" && this.pointerIds.add(t.pointerId), this.pointerIds;
  }
  applyHandlers(t, e) {
    this.handlers = t, this.nativeHandlers = e;
  }
  applyConfig(t, e) {
    this.config = _Se(t, e, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const t of this.gestures)
      this.gestureEventStores[t].clean(), this.gestureTimeoutStores[t].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...t) {
    const e = this.config.shared, r = {};
    let i;
    if (!(e.target && (i = e.target(), !i))) {
      if (e.enabled) {
        for (const o of this.gestures) {
          const l = this.config[o], u = R9(r, l.eventOptions, !!i);
          if (l.enabled) {
            const d = g5.get(o);
            new d(this, t, o).bind(u);
          }
        }
        const s = R9(r, e.eventOptions, !!i);
        for (const o in this.nativeHandlers)
          s(o, "", (l) => this.nativeHandlers[o](Ri(Ri({}, this.state.shared), {}, {
            event: l,
            args: t
          })), void 0, !0);
      }
      for (const s in r)
        r[s] = qye(...r[s]);
      if (!i) return r;
      for (const s in r) {
        const {
          device: o,
          capture: l,
          passive: u
        } = Hye(s);
        this._targetEventStore.add(i, o, "", r[s], {
          capture: l,
          passive: u
        });
      }
    }
  }
}
function m0(n, t) {
  n.gestures.add(t), n.gestureEventStores[t] = new LK(n, t), n.gestureTimeoutStores[t] = new TSe();
}
function ASe(n, t) {
  t.drag && m0(n, "drag"), t.wheel && m0(n, "wheel"), t.scroll && m0(n, "scroll"), t.move && m0(n, "move"), t.pinch && m0(n, "pinch"), t.hover && m0(n, "hover");
}
const R9 = (n, t, e) => (r, i, s, o = {}, l = !1) => {
  var u, d;
  const f = (u = o.capture) !== null && u !== void 0 ? u : t.capture, m = (d = o.passive) !== null && d !== void 0 ? d : t.passive;
  let v = l ? r : Uye(r, i, f);
  e && m && (v += "Passive"), n[v] = n[v] || [], n[v].push(s);
}, kSe = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function ISe(n) {
  const t = {}, e = {}, r = /* @__PURE__ */ new Set();
  for (let i in n)
    kSe.test(i) ? (r.add(RegExp.lastMatch), e[i] = n[i]) : t[i] = n[i];
  return [e, t, r];
}
function v0(n, t, e, r, i, s) {
  if (!n.has(e)) return;
  if (!g5.has(r)) {
    process.env.NODE_ENV === "development" && console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${r}\` gesture but isn't properly configured.

Please add \`${r}Action\` when creating your handler.`);
    return;
  }
  const o = e + "Start", l = e + "End", u = (d) => {
    let f;
    return d.first && o in t && t[o](d), e in t && (f = t[e](d)), d.last && l in t && t[l](d), f;
  };
  i[r] = u, s[r] = s[r] || {};
}
function RSe(n, t) {
  const [e, r, i] = ISe(n), s = {};
  return v0(i, e, "onDrag", "drag", s, t), v0(i, e, "onWheel", "wheel", s, t), v0(i, e, "onScroll", "scroll", s, t), v0(i, e, "onPinch", "pinch", s, t), v0(i, e, "onMove", "move", s, t), v0(i, e, "onHover", "hover", s, t), {
    handlers: s,
    config: t,
    nativeHandlers: r
  };
}
function MSe(n, t = {}, e, r) {
  const i = Gn.useMemo(() => new PSe(n), []);
  if (i.applyHandlers(n, r), i.applyConfig(t, e), Gn.useEffect(i.effect.bind(i)), Gn.useEffect(() => i.clean.bind(i), []), t.target === void 0)
    return i.bind.bind(i);
}
function DSe(n) {
  return n.forEach(ySe), function(e, r) {
    const {
      handlers: i,
      nativeHandlers: s,
      config: o
    } = RSe(e, r || {});
    return MSe(i, o, void 0, s);
  };
}
const M9 = 10, OSe = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line deprecation/deprecation
  typeof window > "u" ? "node" : window.navigator.platform
);
function jK(n) {
  let { deltaY: t, deltaX: e } = n, r = 0;
  return n.ctrlKey || n.altKey || n.metaKey ? r = (Math.abs(t) > M9 ? M9 * Math.sign(t) : t) / 100 : n.shiftKey && !OSe && (e = t, t = 0), { x: -e, y: -t, z: -r };
}
const LSe = DSe([bSe, SSe]);
let y0;
const jSe = (n) => y0 === void 0 ? (y0 = n, !1) : n - y0 > 120 && n - y0 < 160 ? (y0 = n, !0) : (y0 = n, !1);
function NSe(n) {
  const t = we(), e = D.useMemo(() => {
    let r = "not sure";
    const i = ({ event: E }) => {
      if (!t.getInstanceState().isFocused || (r = "not sure", jSe(Date.now())))
        return;
      const A = t.getEditingShapeId();
      if (A) {
        const M = t.getShape(A);
        if (M && t.getShapeUtil(M).canScroll(M)) {
          const $ = t.getShapePageBounds(A);
          if ($ != null && $.containsPoint(t.inputs.currentPagePoint))
            return;
        }
      }
      qn(E), to(E);
      const P = jK(E);
      if (P.x === 0 && P.y === 0) return;
      const R = {
        type: "wheel",
        name: "wheel",
        delta: P,
        point: new O(E.clientX, E.clientY),
        shiftKey: E.shiftKey,
        altKey: E.altKey,
        ctrlKey: E.metaKey || E.ctrlKey
      };
      t.dispatch(R);
    };
    let s = 1, o = 1, l = 1, u = 0;
    const d = new O(), f = new O(), m = (E) => {
      const A = n.current;
      r = "not sure";
      const { event: P, origin: R, da: M } = E;
      P instanceof WheelEvent || (P.target === A || A != null && A.contains(P.target)) && (f.x = R[0], f.y = R[1], d.x = R[0], d.y = R[1], s = M[0], o = t.getZoomLevel(), t.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: R[0], y: R[1], z: t.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: P.shiftKey,
        altKey: P.altKey,
        ctrlKey: P.metaKey || P.ctrlKey
      }));
    }, v = (E) => {
      if (E && (r = "zooming"), r === "zooming")
        return;
      const A = Math.abs(u - s), P = O.Dist(d, f);
      switch (r) {
        case "not sure": {
          A > 24 ? r = "zooming" : P > 16 && (r = "panning");
          break;
        }
        case "panning": {
          A > 64 && (r = "zooming");
          break;
        }
      }
    };
    return {
      onWheel: i,
      onPinchStart: m,
      onPinchEnd: (E) => {
        const A = n.current, { event: P, origin: R, offset: M } = E;
        if (P instanceof WheelEvent || !(P.target === A || A != null && A.contains(P.target))) return;
        const j = M[0];
        r = "not sure", t.timers.requestAnimationFrame(() => {
          t.dispatch({
            type: "pinch",
            name: "pinch_end",
            point: { x: R[0], y: R[1], z: j },
            delta: { x: R[0], y: R[1] },
            shiftKey: P.shiftKey,
            altKey: P.altKey,
            ctrlKey: P.metaKey || P.ctrlKey
          });
        });
      },
      onPinch: (E) => {
        const A = n.current, { event: P, origin: R, offset: M, da: j } = E;
        if (P instanceof WheelEvent || !(P.target === A || A != null && A.contains(P.target))) return;
        const $ = E.type === "gesturechange" || E.type === "gestureend";
        u = j[0];
        const U = R[0] - f.x, F = R[1] - f.y;
        switch (f.x = R[0], f.y = R[1], v($), r) {
          case "zooming": {
            l = M[0], t.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: R[0], y: R[1], z: l },
              delta: { x: U, y: F },
              shiftKey: P.shiftKey,
              altKey: P.altKey,
              ctrlKey: P.metaKey || P.ctrlKey
            });
            break;
          }
          case "panning": {
            t.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: R[0], y: R[1], z: o },
              delta: { x: U, y: F },
              shiftKey: P.shiftKey,
              altKey: P.altKey,
              ctrlKey: P.metaKey || P.ctrlKey
            });
            break;
          }
        }
      }
    };
  }, [t, n]);
  LSe(e, {
    target: n,
    eventOptions: { passive: !1 },
    pinch: {
      from: () => [t.getZoomLevel(), 0],
      // Return the camera z to use when pinch starts
      scaleBounds: () => ({ from: t.getZoomLevel(), max: 8, min: 0.05 })
    }
  });
}
function kN(n, t, e) {
  const r = n.getShape(t), i = n.getShapeHandles(r);
  return { shape: r, handle: i.find((s) => s.id === e) };
}
function FSe(n, t) {
  const e = we();
  return D.useMemo(() => {
    const r = (u) => {
      if (u.isKilled) return;
      const d = _M(u.currentTarget);
      UT(d, u);
      const { shape: f, handle: m } = kN(e, n, t);
      m && e.dispatch({
        type: "pointer",
        target: "handle",
        handle: m,
        shape: f,
        name: "pointer_down",
        ...Ol(u)
      });
    };
    let i, s;
    return {
      onPointerDown: r,
      onPointerMove: (u) => {
        if (u.isKilled || u.clientX === i && u.clientY === s) return;
        i = u.clientX, s = u.clientY;
        const { shape: d, handle: f } = kN(e, n, t);
        f && e.dispatch({
          type: "pointer",
          target: "handle",
          handle: f,
          shape: d,
          name: "pointer_move",
          ...Ol(u)
        });
      },
      onPointerUp: (u) => {
        if (u.isKilled) return;
        const d = _M(u.currentTarget);
        BT(d, u);
        const { shape: f, handle: m } = kN(e, n, t);
        m && e.dispatch({
          type: "pointer",
          target: "handle",
          handle: m,
          shape: f,
          name: "pointer_up",
          ...Ol(u)
        });
      }
    };
  }, [e, n, t]);
}
const di = class di {
  constructor(t = 0, e = 0, r = 0, i = 0) {
    T(this, "x", 0);
    T(this, "y", 0);
    T(this, "w", 0);
    T(this, "h", 0);
    this.x = t, this.y = e, this.w = r, this.h = i;
  }
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new O(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(t) {
    this.x = t.x, this.y = t.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(t) {
    this.x = t;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(t) {
    this.y = t;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(t) {
    this.w = t;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(t) {
    this.h = t;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new O(this.midX, this.midY);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(t) {
    this.minX = t.x - this.width / 2, this.minY = t.y - this.height / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new O(this.minX, this.minY),
      new O(this.maxX, this.minY),
      new O(this.maxX, this.maxY),
      new O(this.minX, this.maxY)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new O(this.minX, this.minY),
      new O(this.maxX, this.minY),
      new O(this.maxX, this.maxY),
      new O(this.minX, this.maxY),
      this.center
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners: t } = this;
    return [
      [t[0], t[1]],
      [t[1], t[2]],
      [t[2], t[3]],
      [t[3], t[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new O(this.w, this.h);
  }
  toFixed() {
    return this.x = lI(this.x), this.y = lI(this.y), this.w = lI(this.w), this.h = lI(this.h), this;
  }
  setTo(t) {
    return this.x = t.x, this.y = t.y, this.w = t.w, this.h = t.h, this;
  }
  set(t = 0, e = 0, r = 0, i = 0) {
    return this.x = t, this.y = e, this.w = r, this.h = i, this;
  }
  expand(t) {
    const e = Math.min(this.minX, t.minX), r = Math.min(this.minY, t.minY), i = Math.max(this.maxX, t.maxX), s = Math.max(this.maxY, t.maxY);
    return this.x = e, this.y = r, this.w = i - e, this.h = s - r, this;
  }
  expandBy(t) {
    return this.x -= t, this.y -= t, this.w += t * 2, this.h += t * 2, this;
  }
  scale(t) {
    return this.x /= t, this.y /= t, this.w /= t, this.h /= t, this;
  }
  clone() {
    const { x: t, y: e, w: r, h: i } = this;
    return new di(t, e, r, i);
  }
  translate(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  snapToGrid(t) {
    const e = Math.round(this.minX / t) * t, r = Math.round(this.minY / t) * t, i = Math.round(this.maxX / t) * t, s = Math.round(this.maxY / t) * t;
    this.minX = e, this.minY = r, this.width = Math.max(1, i - e), this.height = Math.max(1, s - r);
  }
  collides(t) {
    return di.Collides(this, t);
  }
  contains(t) {
    return di.Contains(this, t);
  }
  includes(t) {
    return di.Includes(this, t);
  }
  containsPoint(t, e = 0) {
    return di.ContainsPoint(this, t, e);
  }
  getHandlePoint(t) {
    switch (t) {
      case "top_left":
        return new O(this.minX, this.minY);
      case "top_right":
        return new O(this.maxX, this.minY);
      case "bottom_left":
        return new O(this.minX, this.maxY);
      case "bottom_right":
        return new O(this.maxX, this.maxY);
      case "top":
        return new O(this.midX, this.minY);
      case "right":
        return new O(this.maxX, this.midY);
      case "bottom":
        return new O(this.midX, this.maxY);
      case "left":
        return new O(this.minX, this.midY);
    }
  }
  toJson() {
    return { x: this.minX, y: this.minY, w: this.w, h: this.h };
  }
  resize(t, e, r) {
    const { minX: i, minY: s, maxX: o, maxY: l } = this;
    let { minX: u, minY: d, maxX: f, maxY: m } = this;
    switch (t) {
      case "left":
      case "top_left":
      case "bottom_left": {
        u += e;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        f += e;
        break;
      }
    }
    switch (t) {
      case "top":
      case "top_left":
      case "top_right": {
        d += r;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        m += r;
        break;
      }
    }
    const v = (f - u) / (o - i), S = (m - d) / (l - s), w = v < 0, E = S < 0;
    if (w) {
      const A = f;
      f = u, u = A;
    }
    if (E) {
      const A = m;
      m = d, d = A;
    }
    this.minX = u, this.minY = d, this.width = Math.abs(f - u), this.height = Math.abs(m - d);
  }
  union(t) {
    const e = Math.min(this.minX, t.x), r = Math.min(this.minY, t.y), i = Math.max(this.maxX, t.w + t.x), s = Math.max(this.maxY, t.h + t.y);
    return this.x = e, this.y = r, this.width = i - e, this.height = s - r, this;
  }
  static From(t) {
    return new di(t.x, t.y, t.w, t.h);
  }
  static FromCenter(t, e) {
    return new di(t.x - e.x / 2, t.y - e.y / 2, e.x, e.y);
  }
  static FromPoints(t) {
    if (t.length === 0) return new di();
    let e = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0, o;
    for (let l = 0, u = t.length; l < u; l++)
      o = t[l], e = Math.min(o.x, e), r = Math.min(o.y, r), i = Math.max(o.x, i), s = Math.max(o.y, s);
    return new di(e, r, i - e, s - r);
  }
  static Expand(t, e) {
    const r = Math.min(e.minX, t.minX), i = Math.min(e.minY, t.minY), s = Math.max(e.maxX, t.maxX), o = Math.max(e.maxY, t.maxY);
    return new di(r, i, s - r, o - i);
  }
  static ExpandBy(t, e) {
    return new di(t.minX - e, t.minY - e, t.width + e * 2, t.height + e * 2);
  }
  static Resize(t, e, r, i, s = !1) {
    const { minX: o, minY: l, maxX: u, maxY: d } = t;
    let { minX: f, minY: m, maxX: v, maxY: S } = t;
    switch (e) {
      case "left":
      case "top_left":
      case "bottom_left": {
        f += r;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        v += r;
        break;
      }
    }
    switch (e) {
      case "top":
      case "top_left":
      case "top_right": {
        m += i;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        S += i;
        break;
      }
    }
    const w = (v - f) / (u - o), E = (S - m) / (d - l), A = w < 0, P = E < 0;
    if (s) {
      const M = (u - o) / (d - l), j = Math.abs(v - f), $ = Math.abs(S - m), U = j * (E < 0 ? 1 : -1) * (1 / M), F = $ * (w < 0 ? 1 : -1) * M, B = M < j / $;
      switch (e) {
        case "top_left": {
          B ? m = S + U : f = v + F;
          break;
        }
        case "top_right": {
          B ? m = S + U : v = f - F;
          break;
        }
        case "bottom_right": {
          B ? S = m - U : v = f - F;
          break;
        }
        case "bottom_left": {
          B ? S = m - U : f = v + F;
          break;
        }
        case "bottom":
        case "top": {
          const G = (f + v) / 2, X = $ * M;
          f = G - X / 2, v = G + X / 2;
          break;
        }
        case "left":
        case "right": {
          const G = (m + S) / 2, X = j / M;
          m = G - X / 2, S = G + X / 2;
          break;
        }
      }
    }
    if (A) {
      const M = v;
      v = f, f = M;
    }
    if (P) {
      const M = S;
      S = m, m = M;
    }
    const R = new di(f, m, Math.abs(v - f), Math.abs(S - m));
    return {
      box: R,
      scaleX: +(R.width / t.width * (w > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(R.height / t.height * (E > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(t) {
    return di.Equals(this, t);
  }
  static Equals(t, e) {
    return e.x === t.x && e.y === t.y && e.w === t.w && e.h === t.h;
  }
  zeroFix() {
    return this.w = Math.max(1, this.w), this.h = Math.max(1, this.h), this;
  }
  static ZeroFix(t) {
    return new di(t.x, t.y, Math.max(1, t.w), Math.max(1, t.h));
  }
};
T(di, "Collides", (t, e) => !(t.maxX < e.minX || t.minX > e.maxX || t.maxY < e.minY || t.minY > e.maxY)), T(di, "Contains", (t, e) => t.minX < e.minX && t.minY < e.minY && t.maxY > e.maxY && t.maxX > e.maxX), T(di, "Includes", (t, e) => di.Collides(t, e) || di.Contains(t, e)), T(di, "ContainsPoint", (t, e, r = 0) => !(e.x < t.minX - r || e.y < t.minY - r || e.x > t.maxX + r || e.y > t.maxY + r)), T(di, "Common", (t) => {
  let e = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0;
  for (let o = 0; o < t.length; o++) {
    const l = t[o];
    e = Math.min(e, l.minX), r = Math.min(r, l.minY), i = Math.max(i, l.maxX), s = Math.max(s, l.maxY);
  }
  return new di(e, r, i - e, s - r);
}), T(di, "Sides", (t, e = 0) => {
  const { corners: r } = t;
  return [
    [r[0], r[1]],
    [r[1], r[2]],
    [r[2], r[3]],
    [r[3], r[0]]
  ];
});
let vt = di;
function $Se(n) {
  switch (n) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return n;
  }
}
function zSe(n) {
  switch (n) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return n;
  }
}
function USe(n) {
  return n === "top_left" || n === "top_right" || n === "bottom_right" || n === "bottom_left";
}
function BSe(n) {
  const t = we();
  D.useLayoutEffect(() => {
    let e = new vt();
    function r() {
      const d = n.current;
      if (!d) return null;
      const f = d.getBoundingClientRect(), m = new vt(
        f.left || f.x,
        f.top || f.y,
        Math.max(f.width, 1),
        Math.max(f.height, 1)
      );
      e.equals(m) || (t.updateViewportScreenBounds(m), e = m);
    }
    r();
    const i = sG(r, 200, {
      trailing: !0
    }), s = t.timers.setInterval(i, 1e3);
    window.addEventListener("resize", i);
    const o = new ResizeObserver((d) => {
      d[0].contentRect && i();
    }), l = n.current;
    let u = null;
    return l && (o.observe(l), u = HSe(l), u.addEventListener("scroll", i)), () => {
      clearInterval(s), window.removeEventListener("resize", i), o.disconnect(), u == null || u.removeEventListener("scroll", i), i.cancel();
    };
  }, [t, n]);
}
/*!
 * Author: excalidraw
 * MIT License: https://github.com/excalidraw/excalidraw/blob/master/LICENSE
 * https://github.com/excalidraw/excalidraw/blob/48c3465b19f10ec755b3eb84e21a01a468e96e43/packages/excalidraw/utils.ts#L600
 */
const HSe = (n) => {
  let t = n.parentElement;
  for (; t; ) {
    if (t === document.body)
      return document;
    const { overflowY: e } = window.getComputedStyle(t);
    if (t.scrollHeight > t.clientHeight && (e === "auto" || e === "scroll" || e === "overlay"))
      return t;
    t = t.parentElement;
  }
  return document;
}, xr = class xr {
  constructor(t, e, r, i, s, o) {
    T(this, "a", 1);
    T(this, "b", 0);
    T(this, "c", 0);
    T(this, "d", 1);
    T(this, "e", 0);
    T(this, "f", 0);
    this.a = t, this.b = e, this.c = r, this.d = i, this.e = s, this.f = o;
  }
  equals(t) {
    return this === t || this.a === t.a && this.b === t.b && this.c === t.c && this.d === t.d && this.e === t.e && this.f === t.f;
  }
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  multiply(t) {
    const e = t, { a: r, b: i, c: s, d: o, e: l, f: u } = this;
    return this.a = r * e.a + s * e.b, this.c = r * e.c + s * e.d, this.e = r * e.e + s * e.f + l, this.b = i * e.a + o * e.b, this.d = i * e.c + o * e.d, this.f = i * e.e + o * e.f + u, this;
  }
  rotate(t, e, r) {
    return t === 0 ? this : e === void 0 ? this.multiply(xr.Rotate(t)) : this.translate(e, r).multiply(xr.Rotate(t)).translate(-e, -r);
  }
  translate(t, e) {
    return this.multiply(xr.Translate(t, e));
  }
  scale(t, e) {
    return this.multiply(xr.Scale(t, e));
  }
  invert() {
    const { a: t, b: e, c: r, d: i, e: s, f: o } = this, l = t * i - e * r;
    return this.a = i / l, this.b = e / -l, this.c = r / -l, this.d = t / l, this.e = (i * s - r * o) / -l, this.f = (e * s - t * o) / l, this;
  }
  applyToPoint(t) {
    return xr.applyToPoint(this, t);
  }
  applyToPoints(t) {
    return xr.applyToPoints(this, t);
  }
  rotation() {
    return xr.Rotation(this);
  }
  point() {
    return xr.Point(this);
  }
  decomposed() {
    return xr.Decompose(this);
  }
  toCssString() {
    return xr.toCssString(this);
  }
  setTo(t) {
    return Object.assign(this, t), this;
  }
  decompose() {
    return xr.Decompose(this);
  }
  clone() {
    return new xr(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new xr(1, 0, 0, 1, 0, 0);
  }
  static Translate(t, e) {
    return new xr(1, 0, 0, 1, t, e);
  }
  static Rotate(t, e, r) {
    if (t === 0) return xr.Identity();
    const i = Math.cos(t), s = Math.sin(t), o = new xr(i, s, -s, i, 0, 0);
    return e === void 0 ? o : xr.Compose(xr.Translate(e, r), o, xr.Translate(-e, -r));
  }
  static Multiply(t, e) {
    return {
      a: t.a * e.a + t.c * e.b,
      c: t.a * e.c + t.c * e.d,
      e: t.a * e.e + t.c * e.f + t.e,
      b: t.b * e.a + t.d * e.b,
      d: t.b * e.c + t.d * e.d,
      f: t.b * e.e + t.d * e.f + t.f
    };
  }
  static Inverse(t) {
    const e = t.a * t.d - t.b * t.c;
    return {
      a: t.d / e,
      b: t.b / -e,
      c: t.c / -e,
      d: t.a / e,
      e: (t.d * t.e - t.c * t.f) / -e,
      f: (t.b * t.e - t.a * t.f) / e
    };
  }
  static Absolute(t) {
    const e = t.a * t.d - t.b * t.c;
    return {
      a: t.d / e,
      b: t.b / -e,
      c: t.c / -e,
      d: t.a / e,
      e: (t.d * t.e - t.c * t.f) / e,
      f: (t.b * t.e - t.a * t.f) / -e
    };
  }
  static Compose(...t) {
    const e = xr.Identity();
    for (let r = 0, i = t.length; r < i; r++)
      e.multiply(t[r]);
    return e;
  }
  static Point(t) {
    return new O(t.e, t.f);
  }
  static Rotation(t) {
    let e;
    if (t.a !== 0 || t.c !== 0) {
      const r = (t.a * t.a + t.c * t.c) ** 0.5;
      e = Math.acos(t.a / r) * (t.c > 0 ? -1 : 1);
    } else if (t.b !== 0 || t.d !== 0) {
      const r = (t.b * t.b + t.d * t.d) ** 0.5;
      e = ri + Math.acos(t.b / r) * (t.d > 0 ? -1 : 1);
    } else
      e = 0;
    return p3(e);
  }
  static Decompose(t) {
    let e, r, i;
    if (t.a !== 0 || t.c !== 0) {
      const s = (t.a * t.a + t.c * t.c) ** 0.5;
      e = s, r = (t.a * t.d - t.b * t.c) / s, i = Math.acos(t.a / s) * (t.c > 0 ? -1 : 1);
    } else if (t.b !== 0 || t.d !== 0) {
      const s = (t.b * t.b + t.d * t.d) ** 0.5;
      e = (t.a * t.d - t.b * t.c) / s, r = s, i = ri + Math.acos(t.b / s) * (t.d > 0 ? -1 : 1);
    } else
      e = 0, r = 0, i = 0;
    return {
      x: t.e,
      y: t.f,
      scaleX: e,
      scaleY: r,
      rotation: p3(i)
    };
  }
  static Smooth(t, e = 1e10) {
    return t.a = Math.round(t.a * e) / e, t.b = Math.round(t.b * e) / e, t.c = Math.round(t.c * e) / e, t.d = Math.round(t.d * e) / e, t.e = Math.round(t.e * e) / e, t.f = Math.round(t.f * e) / e, t;
  }
  static toCssString(t) {
    return `matrix(${be(t.a)}, ${be(t.b)}, ${be(
      t.c
    )}, ${be(t.d)}, ${be(t.e)}, ${be(t.f)})`;
  }
  static applyToPoint(t, e) {
    return new O(
      t.a * e.x + t.c * e.y + t.e,
      t.b * e.x + t.d * e.y + t.f,
      e.z
    );
  }
  static applyToXY(t, e, r) {
    return [t.a * e + t.c * r + t.e, t.b * e + t.d * r + t.f];
  }
  static applyToPoints(t, e) {
    return e.map(
      (r) => new O(t.a * r.x + t.c * r.y + t.e, t.b * r.x + t.d * r.y + t.f, r.z)
    );
  }
  static applyToBounds(t, e) {
    return new vt(t.e + e.minX, t.f + e.minY, e.width, e.height);
  }
  static From(t) {
    return new xr(t.a, t.b, t.c, t.d, t.e, t.f);
  }
  static Cast(t) {
    return t instanceof xr ? t : xr.From(t);
  }
};
T(xr, "Scale", (t, e, r, i) => {
  const s = new xr(t, 0, 0, e, 0, 0);
  return r === void 0 ? s : xr.Compose(xr.Translate(r, i), s, xr.Translate(-r, -i));
});
let At = xr;
function NK(n, t) {
  return t === 0 ? n : NK(t, n % t);
}
function FK(n) {
  const t = n.toString().split(".")[1];
  if (!t) return 1;
  const e = Math.pow(10, t.length), r = parseInt(t, 10);
  return e / NK(r, e);
}
class Mm {
  constructor(t) {
    T(this, "isFilled", !1);
    T(this, "isClosed", !0);
    T(this, "isLabel", !1);
    T(this, "debugColor");
    T(this, "ignore");
    T(this, "_vertices");
    T(this, "_bounds");
    T(this, "_area");
    T(this, "_length");
    this.isFilled = t.isFilled, this.isClosed = t.isClosed, this.isLabel = t.isLabel ?? !1, this.debugColor = t.debugColor, this.ignore = t.ignore;
  }
  // hitTestPoint(point: Vec, margin = 0, hitInside = false) {
  // 	// We've removed the broad phase here; that should be done outside of the call
  // 	return this.distanceToPoint(point, hitInside) <= margin
  // }
  hitTestPoint(t, e = 0, r = !1) {
    return this.isClosed && (this.isFilled || r) && yc(t, this.vertices) ? !0 : O.Dist2(t, this.nearestPoint(t)) <= e * e;
  }
  distanceToPoint(t, e = !1) {
    return t.dist(this.nearestPoint(t)) * (this.isClosed && (this.isFilled || e) && yc(t, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(t, e) {
    if (t.equals(e)) return this.distanceToPoint(t);
    const { vertices: r } = this;
    let i, s = 1 / 0, o, l, u;
    for (let d = 0; d < r.length; d++)
      l = r[d], u = O.NearestPointOnLineSegment(t, e, l, !0), o = O.Dist2(l, u), o < s && (s = o, i = u);
    if (!i) throw Error("nearest point not found");
    return this.isClosed && this.isFilled && yc(i, this.vertices) ? -s : s;
  }
  hitTestLineSegment(t, e, r = 0) {
    return this.distanceToLineSegment(t, e) <= r;
  }
  nearestPointOnLineSegment(t, e) {
    const { vertices: r } = this;
    let i, s = 1 / 0, o, l, u;
    for (let d = 0; d < r.length; d++)
      l = r[d], u = O.NearestPointOnLineSegment(t, e, l, !0), o = O.Dist2(l, u), o < s && (s = o, i = u);
    if (!i) throw Error("nearest point not found");
    return i;
  }
  isPointInBounds(t, e = 0) {
    const { bounds: r } = this;
    return !(t.x < r.minX - e || t.y < r.minY - e || t.x > r.maxX + e || t.y > r.maxY + e);
  }
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    return this._vertices || (this._vertices = this.getVertices()), this._vertices;
  }
  getBounds() {
    return vt.FromPoints(this.vertices);
  }
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    return this._bounds || (this._bounds = this.getBounds()), this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    return this._area || (this._area = this.getArea()), this._area;
  }
  getArea() {
    if (!this.isClosed)
      return 0;
    const { vertices: t } = this;
    let e = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r], o = t[(r + 1) % i];
      e += s.x * o.y - o.x * s.y;
    }
    return e / 2;
  }
  toSimpleSvgPath() {
    let t = "";
    const { vertices: e } = this, r = e.length;
    if (r === 0) return t;
    t += `M${e[0].x},${e[0].y}`;
    for (let i = 1; i < r; i++)
      t += `L${e[i].x},${e[i].y}`;
    return this.isClosed && (t += "Z"), t;
  }
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    return this._length ? this._length : (this._length = this.getLength(), this._length);
  }
  getLength() {
    const { vertices: t } = this;
    let e, r = t[0], i = 0;
    for (let s = 1; s < t.length; s++)
      e = t[s], i += O.Dist2(r, e), r = e;
    return Math.sqrt(i);
  }
}
class ld extends Mm {
  constructor(e) {
    super({ ...e, isClosed: !0, isFilled: !1 });
    T(this, "children", []);
    T(this, "ignoredChildren", []);
    for (const r of e.children)
      r.ignore ? this.ignoredChildren.push(r) : this.children.push(r);
    if (this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices() {
    return this.children.filter((e) => !e.isLabel).flatMap((e) => e.vertices);
  }
  nearestPoint(e) {
    let r = 1 / 0, i;
    const { children: s } = this;
    if (s.length === 0)
      throw Error("no children");
    let o, l;
    for (const u of s)
      o = u.nearestPoint(e), l = O.Dist2(o, e), l < r && (r = l, i = o);
    if (!i) throw Error("nearest point not found");
    return i;
  }
  distanceToPoint(e, r = !1) {
    return Math.min(...this.children.map((i, s) => i.distanceToPoint(e, r || s > 0)));
  }
  hitTestPoint(e, r, i) {
    return !!this.children.filter((s) => !s.isLabel).find((s) => s.hitTestPoint(e, r, i));
  }
  hitTestLineSegment(e, r, i) {
    return !!this.children.filter((s) => !s.isLabel).find((s) => s.hitTestLineSegment(e, r, i));
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let e = "";
    for (const i of this.children)
      e += i.toSimpleSvgPath();
    const r = vt.FromPoints(this.vertices).corners;
    for (let i = 0, s = r.length; i < s; i++) {
      const o = r[i], l = r[(i - 1 + s) % s], u = o.dist(l), d = r[(i + 1) % s], f = o.dist(d), m = o.clone().lrp(l, 4 / u), v = o, S = o.clone().lrp(d, 4 / f);
      e += `M${m.x},${m.y} L${v.x},${v.y} L${S.x},${S.y} `;
    }
    return e;
  }
  getLength() {
    return this.children.reduce((e, r) => r.isLabel ? e : e + r.length, 0);
  }
  getSvgPathData() {
    return this.children.map((e, r) => e.isLabel ? "" : e.getSvgPathData(r === 0)).join(" ");
  }
}
function VSe(n = !0) {
  const [t, e] = D.useState(0), r = we();
  D.useEffect(() => {
    if (!n) return;
    const i = () => e((s) => s + 1);
    return r.on("tick", i), () => {
      r.off("tick", i);
    };
  }, [r, n]);
}
const WSe = ro(function({
  showStroke: t = !0,
  showVertices: e = !0,
  showClosestPointOnOutline: r = !0
}) {
  const i = we();
  VSe(r);
  const s = i.getZoomLevel(), o = i.getRenderingShapes(), {
    inputs: { currentPagePoint: l }
  } = i;
  return /* @__PURE__ */ y.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: o.map((u) => {
        const d = i.getShape(u.id);
        if (d.type === "group") return null;
        const f = i.getShapeGeometry(d), m = i.getShapePageTransform(d), v = i.getPointInShapeSpace(d, l), S = f.nearestPoint(v), w = f.distanceToPoint(v, !0), E = Math.abs(w) * s, A = w < 0, { vertices: P } = f;
        return /* @__PURE__ */ y.jsxs(
          "g",
          {
            transform: m.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              t && /* @__PURE__ */ y.jsx(
                "g",
                {
                  stroke: f.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / s,
                  fill: "none",
                  children: /* @__PURE__ */ y.jsx($K, { geometry: f })
                }
              ),
              e && P.map((R, M) => /* @__PURE__ */ y.jsx(
                "circle",
                {
                  cx: R.x,
                  cy: R.y,
                  r: 2 / s,
                  fill: `hsl(${qx(M, [0, P.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / s
                },
                `v${M}`
              )),
              r && E < 150 && /* @__PURE__ */ y.jsx(
                "line",
                {
                  x1: S.x,
                  y1: S.y,
                  x2: v.x,
                  y2: v.y,
                  opacity: 1 - E / 150,
                  stroke: A ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / s
                }
              )
            ]
          },
          u.id + "_outline"
        );
      })
    }
  );
});
function $K({ geometry: n }) {
  return n instanceof ld ? /* @__PURE__ */ y.jsx(y.Fragment, { children: [...n.children, ...n.ignoredChildren].map((t, e) => /* @__PURE__ */ y.jsx($K, { geometry: t }, e)) }) : /* @__PURE__ */ y.jsx("path", { d: n.toSimpleSvgPath() });
}
function zK(n) {
  return yme(n);
}
function UK() {
  const n = we(), t = vye(
    "userIds",
    () => zK(n.getCollaborators().map((e) => e.userId)).sort(),
    { isEqual: (e, r) => {
      var i;
      return e.join(",") === ((i = r.join) == null ? void 0 : i.call(r, ","));
    } },
    [n]
  );
  return De(t);
}
function D2(n) {
  const t = we();
  return De(
    `latestPresence:${n}`,
    () => t.getCollaborators().find((r) => r.userId === n),
    [t, n]
  ) ?? null;
}
const GSe = ro(function() {
  return UK().map((e) => /* @__PURE__ */ y.jsx(KSe, { collaboratorId: e }, e));
}), KSe = ro(function({
  collaboratorId: t
}) {
  const e = we(), r = D2(t), i = XSe(e, r);
  if (!(r && r.currentPageId === e.getCurrentPageId()))
    return null;
  switch (i) {
    case "inactive": {
      const { followingUserId: s, highlightedUserIds: o } = e.getInstanceState();
      if (!(s === r.userId || o.includes(r.userId)))
        return null;
      break;
    }
    case "idle": {
      const { highlightedUserIds: s } = e.getInstanceState();
      if (r.followingUserId === e.user.getId() && !(r.chatMessage || s.includes(r.userId)))
        return null;
      break;
    }
  }
  return /* @__PURE__ */ y.jsx(YSe, { latestPresence: r });
}), YSe = ro(function({
  latestPresence: t
}) {
  const e = we(), {
    CollaboratorBrush: r,
    CollaboratorScribble: i,
    CollaboratorCursor: s,
    CollaboratorHint: o,
    CollaboratorShapeIndicator: l
  } = xi(), u = e.getZoomLevel(), d = e.getViewportPageBounds(), { userId: f, chatMessage: m, brush: v, scribbles: S, selectedShapeIds: w, userName: E, cursor: A, color: P } = t, R = !(A.x < d.minX - 12 / u || A.y < d.minY - 16 / u || A.x > d.maxX - 12 / u || A.y > d.maxY - 16 / u);
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    v && r ? /* @__PURE__ */ y.jsx(
      r,
      {
        className: "tl-collaborator__brush",
        brush: v,
        color: P,
        opacity: 0.1
      },
      f + "_brush"
    ) : null,
    R && s ? /* @__PURE__ */ y.jsx(
      s,
      {
        className: "tl-collaborator__cursor",
        point: A,
        color: P,
        zoom: u,
        name: E !== "New User" ? E : null,
        chatMessage: m
      },
      f + "_cursor"
    ) : o ? /* @__PURE__ */ y.jsx(
      o,
      {
        className: "tl-collaborator__cursor-hint",
        point: A,
        color: P,
        zoom: u,
        viewport: d
      },
      f + "_cursor_hint"
    ) : null,
    i && S.length ? /* @__PURE__ */ y.jsx(y.Fragment, { children: S.map((M) => /* @__PURE__ */ y.jsx(
      i,
      {
        className: "tl-collaborator__scribble",
        scribble: M,
        color: P,
        zoom: u,
        opacity: M.color === "laser" ? 0.5 : 0.1
      },
      f + "_scribble_" + M.id
    )) }) : null,
    l && w.map((M) => /* @__PURE__ */ y.jsx(
      l,
      {
        className: "tl-collaborator__shape-indicator",
        shapeId: M,
        color: P,
        opacity: 0.5
      },
      f + "_" + M
    ))
  ] });
});
function D9(n, t) {
  return t > n.options.collaboratorInactiveTimeoutMs ? "inactive" : t > n.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function XSe(n, t) {
  const e = D.useRef((t == null ? void 0 : t.lastActivityTimestamp) ?? -1), [r, i] = D.useState(
    () => D9(n, Date.now() - e.current)
  );
  return D.useEffect(() => {
    const s = n.timers.setInterval(() => {
      i(D9(n, Date.now() - e.current));
    }, n.options.collaboratorCheckIntervalMs);
    return () => clearInterval(s);
  }, [n]), t && (e.current = t.lastActivityTimestamp), r;
}
const BK = D.memo(function({
  id: t,
  shape: e,
  util: r,
  index: i,
  backgroundIndex: s,
  opacity: o,
  dprMultiple: l
}) {
  const u = we(), { ShapeErrorFallback: d } = xi(), f = D.useRef(null), m = D.useRef(null), v = D.useRef({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: !1
  });
  mm(
    "set shape stuff",
    () => {
      const E = u.getShape(t);
      if (!E) return;
      const A = v.current, P = u.getShapeClipPath(t) ?? "none";
      P !== A.clipPath && (aa(f.current, "clip-path", P), aa(m.current, "clip-path", P), A.clipPath = P);
      const R = u.getShapePageTransform(t), M = At.toCssString(R), j = u.getShapeGeometry(E).bounds;
      M !== A.transform && (aa(f.current, "transform", M), aa(m.current, "transform", M), A.transform = M);
      const $ = j.w % l, U = j.h % l, F = $ === 0 ? j.w : j.w + (l - $), B = U === 0 ? j.h : j.h + (l - U);
      (F !== A.width || B !== A.height) && (aa(f.current, "width", Math.max(F, l) + "px"), aa(f.current, "height", Math.max(B, l) + "px"), aa(m.current, "width", Math.max(F, l) + "px"), aa(m.current, "height", Math.max(B, l) + "px"), A.width = F, A.height = B);
    },
    [u]
  ), mm(
    "set opacity and z-index",
    () => {
      const E = f.current, A = m.current;
      aa(E, "opacity", o), aa(A, "opacity", o), aa(E, "z-index", i), aa(A, "z-index", s);
    },
    [o, i, s]
  ), mm(
    "set display",
    () => {
      if (!u.getShape(t)) return;
      const P = u.getCulledShapes().has(t);
      P !== v.current.isCulled && (aa(f.current, "display", P ? "none" : "block"), aa(m.current, "display", P ? "none" : "block"), v.current.isCulled = P);
    },
    [u]
  );
  const S = D.useCallback(
    (E) => u.annotateError(E, { origin: "shape", willCrashApp: !1 }),
    [u]
  );
  if (!e) return null;
  const w = "fill" in e.props && e.props.fill !== "none";
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    r.backgroundComponent && /* @__PURE__ */ y.jsx(
      "div",
      {
        ref: m,
        className: "tl-shape tl-shape-background",
        "data-shape-type": e.type,
        draggable: !1,
        children: /* @__PURE__ */ y.jsx(H1, { fallback: d, onError: S, children: /* @__PURE__ */ y.jsx(ZSe, { shape: e, util: r }) })
      }
    ),
    /* @__PURE__ */ y.jsx(
      "div",
      {
        ref: f,
        className: "tl-shape",
        "data-shape-type": e.type,
        "data-shape-is-filled": w,
        draggable: !1,
        children: /* @__PURE__ */ y.jsx(H1, { fallback: d, onError: S, children: /* @__PURE__ */ y.jsx(qSe, { shape: e, util: r }) })
      }
    )
  ] });
}), qSe = D.memo(
  function({ shape: t, util: e }) {
    return R2(
      "InnerShape:" + t.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        e.component(e.editor.store.unsafeGetWithoutCapture(t.id))
      )
    );
  },
  (n, t) => n.shape.props === t.shape.props && n.shape.meta === t.shape.meta
), ZSe = D.memo(
  function({
    shape: t,
    util: e
  }) {
    return R2(
      "InnerShape:" + t.type,
      () => {
        var r;
        return (
          // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
          // calling the render method with stale data.
          (r = e.backgroundComponent) == null ? void 0 : r.call(e, e.editor.store.unsafeGetWithoutCapture(t.id))
        );
      }
    );
  },
  (n, t) => n.shape.props === t.shape.props && n.shape.meta === t.shape.meta
);
function QSe({ className: n }) {
  const t = we(), { Background: e, SvgDefs: r, ShapeIndicators: i } = xi(), s = D.useRef(null), o = D.useRef(null), l = D.useRef(null), u = io();
  BSe(s), Rye(), kye(), NSe(s), Oye(s);
  const d = D.useRef({ lodDisableTextOutline: !1, allowTextOutline: !0 });
  mm(
    "position layers",
    function() {
      const { x: R, y: M, z: j } = t.getCamera();
      if (d.current.allowTextOutline && t.environment.isSafari && (u.style.setProperty("--tl-text-outline", "none"), d.current.allowTextOutline = !1), d.current.allowTextOutline && j < t.options.textShadowLod !== d.current.lodDisableTextOutline) {
        const F = j < t.options.textShadowLod;
        u.style.setProperty(
          "--tl-text-outline",
          F ? "none" : "var(--tl-text-outline-reference)"
        ), d.current.lodDisableTextOutline = F;
      }
      const $ = j >= 1 ? qx(j, [1, 8], [0.125, 0.5], !0) : qx(j, [0.1, 1], [-2, 0.125], !0), U = `scale(${be(j)}) translate(${be(
        R + $
      )}px,${be(M + $)}px)`;
      aa(o.current, "transform", U), aa(l.current, "transform", U);
    },
    [t, u]
  );
  const f = PK(), m = De(
    "shapeSvgDefs",
    () => {
      const P = /* @__PURE__ */ new Map();
      for (const R of zi(t.shapeUtils)) {
        if (!R) return;
        const M = R.getCanvasSvgDefs();
        for (const { key: j, component: $ } of M)
          P.has(j) || P.set(j, /* @__PURE__ */ y.jsx($, {}, j));
      }
      return [...P.values()];
    },
    [t]
  ), v = De("debug_shapes", () => qi.hideShapes.get(), [qi]), S = De("debug_svg", () => qi.debugSvg.get(), [qi]), w = De("debug_geometry", () => qi.debugGeometry.get(), [
    qi
  ]), E = De(
    "isEditingAnything",
    () => t.getEditingShapeId() !== null,
    [t]
  ), A = De(
    "isSelectingAnything",
    () => !!t.getSelectedShapeIds().length,
    [t]
  );
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(
      "div",
      {
        ref: s,
        draggable: !1,
        "data-iseditinganything": E,
        "data-isselectinganything": A,
        className: Vt("tl-canvas", n),
        "data-testid": "canvas",
        ...f,
        children: [
          /* @__PURE__ */ y.jsx("svg", { className: "tl-svg-context", children: /* @__PURE__ */ y.jsxs("defs", { children: [
            m,
            /* @__PURE__ */ y.jsx(hbe, {}),
            /* @__PURE__ */ y.jsx(fbe, {}),
            r && /* @__PURE__ */ y.jsx(r, {})
          ] }) }),
          e && /* @__PURE__ */ y.jsx("div", { className: "tl-background__wrapper", children: /* @__PURE__ */ y.jsx(e, {}) }),
          /* @__PURE__ */ y.jsx(ebe, {}),
          /* @__PURE__ */ y.jsxs("div", { ref: o, className: "tl-html-layer tl-shapes", draggable: !1, children: [
            /* @__PURE__ */ y.jsx(vbe, {}),
            /* @__PURE__ */ y.jsx(mbe, {}),
            v ? null : S ? /* @__PURE__ */ y.jsx(lbe, {}) : /* @__PURE__ */ y.jsx(ube, {})
          ] }),
          /* @__PURE__ */ y.jsx("div", { className: "tl-overlays", children: /* @__PURE__ */ y.jsxs("div", { ref: l, className: "tl-html-layer", children: [
            w ? /* @__PURE__ */ y.jsx(WSe, {}) : null,
            /* @__PURE__ */ y.jsx(sbe, {}),
            /* @__PURE__ */ y.jsx(nbe, {}),
            /* @__PURE__ */ y.jsx(tbe, {}),
            /* @__PURE__ */ y.jsx(rbe, {}),
            i && /* @__PURE__ */ y.jsx(i, {}),
            /* @__PURE__ */ y.jsx(dbe, {}),
            /* @__PURE__ */ y.jsx(ibe, {}),
            /* @__PURE__ */ y.jsx(gbe, {}),
            /* @__PURE__ */ y.jsx(GSe, {})
          ] }) }),
          /* @__PURE__ */ y.jsx(ybe, {})
        ]
      }
    ),
    /* @__PURE__ */ y.jsx(JSe, {})
  ] });
}
function JSe() {
  const { InFrontOfTheCanvas: n } = xi();
  return n ? /* @__PURE__ */ y.jsx(n, {}) : null;
}
function ebe() {
  const n = we(), t = De("gridSize", () => n.getDocumentSettings().gridSize, [n]), { x: e, y: r, z: i } = De("camera", () => n.getCamera(), [n]), s = De("isGridMode", () => n.getInstanceState().isGridMode, [n]), { Grid: o } = xi();
  return o && s ? /* @__PURE__ */ y.jsx(o, { x: e, y: r, z: i, size: t }) : null;
}
function tbe() {
  const n = we(), t = De("scribbles", () => n.getInstanceState().scribbles, [n]), e = De("zoomLevel", () => n.getZoomLevel(), [n]), { Scribble: r } = xi();
  return r && t.length ? t.map((i) => /* @__PURE__ */ y.jsx(r, { className: "tl-user-scribble", scribble: i, zoom: e }, i.id)) : null;
}
function nbe() {
  const n = we(), t = De("brush", () => n.getInstanceState().brush, [n]), { Brush: e } = xi();
  return e && t ? /* @__PURE__ */ y.jsx(e, { className: "tl-user-brush", brush: t }) : null;
}
function rbe() {
  const n = we(), t = De("zoomBrush", () => n.getInstanceState().zoomBrush, [n]), { ZoomBrush: e } = xi();
  return e && t ? /* @__PURE__ */ y.jsx(e, { className: "tl-user-brush tl-zoom-brush", brush: t }) : null;
}
function ibe() {
  const n = we(), t = De("snapLines", () => n.snaps.getIndicators(), [n]), e = De("zoomLevel", () => n.getZoomLevel(), [n]), { SnapIndicator: r } = xi();
  return r && t.length > 0 ? t.map((i) => /* @__PURE__ */ y.jsx(r, { className: "tl-user-snapline", line: i, zoom: e }, i.id)) : null;
}
function sbe() {
  const n = we(), t = De(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly: e, isChangingStyle: r } = n.getInstanceState();
      if (e || r) return !1;
      const i = n.getOnlySelectedShape();
      return !i || !n.getShapeHandles(i) ? !1 : i.id;
    },
    [n]
  );
  return t ? /* @__PURE__ */ y.jsx(obe, { shapeId: t }) : null;
}
function obe({ shapeId: n }) {
  const t = we(), { Handles: e } = xi(), r = De("zoomLevel", () => t.getZoomLevel(), [t]), i = De("coarse pointer", () => t.getInstanceState().isCoarsePointer, [
    t
  ]), s = De("handles transform", () => t.getShapePageTransform(n), [
    t,
    n
  ]), o = De(
    "handles",
    () => {
      const l = t.getShapeHandles(n);
      if (!l) return null;
      const u = (i ? t.options.coarseHandleRadius : t.options.handleRadius) / r * 2;
      return l.filter(
        (d) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          d.type !== "virtual" || !l.some(
            (f) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              f !== d && // only check against vertex handles
              f.type === "vertex" && O.Dist(d, f) < u
            )
          )
        )
      ).sort((d) => d.type === "vertex" ? 1 : -1);
    },
    [t, r, i, n]
  );
  return !e || !o || !s ? null : /* @__PURE__ */ y.jsx(e, { children: /* @__PURE__ */ y.jsx("g", { transform: At.toCssString(s), children: o.map((l) => /* @__PURE__ */ y.jsx(
    abe,
    {
      shapeId: n,
      handle: l,
      zoom: r,
      isCoarse: i
    },
    l.id
  )) }) });
}
function abe({
  shapeId: n,
  handle: t,
  zoom: e,
  isCoarse: r
}) {
  const i = FSe(n, t.id), { Handle: s } = xi();
  return s ? /* @__PURE__ */ y.jsx("g", { "aria-label": "handle", transform: `translate(${t.x}, ${t.y})`, ...i, children: /* @__PURE__ */ y.jsx(s, { shapeId: n, handle: t, zoom: e, isCoarse: r }) }) : null;
}
function lbe() {
  const n = we(), t = De("rendering shapes", () => n.getRenderingShapes(), [n]), e = De(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      FK(Math.floor(n.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [n]
  );
  return t.map((r) => /* @__PURE__ */ y.jsxs(D.Fragment, { children: [
    /* @__PURE__ */ y.jsx(BK, { ...r, dprMultiple: e }),
    /* @__PURE__ */ y.jsx(pbe, { id: r.id })
  ] }, r.id + "_fragment"));
}
function cbe() {
  const n = we(), t = D.useRef(/* @__PURE__ */ new Set());
  return mm(
    "reflow for culled shapes",
    () => {
      const e = n.getCulledShapes();
      if (t.current.size === e.size && [...e].every((i) => t.current.has(i)))
        return;
      t.current = e;
      const r = document.getElementsByClassName("tl-canvas");
      r.length !== 0 && r[0].offsetHeight;
    },
    [n]
  ), null;
}
function ube() {
  const n = we(), t = De("rendering shapes", () => n.getRenderingShapes(), [n]), e = De(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      FK(Math.floor(n.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [n]
  );
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    t.map((r) => /* @__PURE__ */ y.jsx(BK, { ...r, dprMultiple: e }, r.id + "_shape")),
    n.environment.isSafari && /* @__PURE__ */ y.jsx(cbe, {})
  ] });
}
function dbe() {
  const n = we(), { ShapeIndicator: t } = xi(), e = De("hinting shape ids", () => Xz(n.getHintingShapeIds()), [n]);
  return !e.length || !t ? null : e.map((r) => /* @__PURE__ */ y.jsx(t, { className: "tl-user-indicator__hint", shapeId: r }, r + "_hinting"));
}
function hbe() {
  return /* @__PURE__ */ y.jsxs("g", { id: "cursor", children: [
    /* @__PURE__ */ y.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ y.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ y.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ y.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ y.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ y.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ y.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ y.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ y.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function fbe() {
  return /* @__PURE__ */ y.jsx("path", { id: "cursor_hint", fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function pbe({ id: n }) {
  const t = we(), [e, r] = D.useState(null), i = De(
    "is in root",
    () => {
      const s = t.getShape(n);
      return (s == null ? void 0 : s.parentId) === t.getCurrentPageId();
    },
    [t, n]
  );
  return D.useEffect(() => {
    if (!i) return;
    let s = null;
    const o = bS("shape to svg", async () => {
      const l = Math.random();
      s = l;
      const d = t.isShapeOfType(n, "frame") ? 0 : 10;
      let f = t.getShapePageBounds(n);
      if (!f) return;
      f = f.clone().expandBy(d);
      const m = await t.getSvgString([n], {
        padding: d,
        background: t.getInstanceState().exportBackground
      });
      if (s !== l || !m) return;
      const v = `data:image/svg+xml;utf8,${encodeURIComponent(m.svg)}`;
      r({ src: v, bounds: f });
    });
    return () => {
      s = null, o();
    };
  }, [t, n, i]), !i || !e ? null : /* @__PURE__ */ y.jsx(
    "img",
    {
      src: e.src,
      width: e.bounds.width,
      height: e.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${e.bounds.x}px, ${e.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function gbe() {
  const n = we(), t = De("selection rotation", () => n.getSelectionRotation(), [
    n
  ]), e = De(
    "selection bounds",
    () => n.getSelectionRotatedPageBounds(),
    [n]
  ), { SelectionForeground: r } = xi();
  return !e || !r ? null : /* @__PURE__ */ y.jsx(r, { bounds: e, rotation: t });
}
function mbe() {
  const n = we(), t = De("selection rotation", () => n.getSelectionRotation(), [
    n
  ]), e = De(
    "selection bounds",
    () => n.getSelectionRotatedPageBounds(),
    [n]
  ), { SelectionBackground: r } = xi();
  return !e || !r ? null : /* @__PURE__ */ y.jsx(r, { bounds: e, rotation: t });
}
function vbe() {
  const { OnTheCanvas: n } = xi();
  return n ? /* @__PURE__ */ y.jsx(n, {}) : null;
}
function ybe() {
  const n = we(), t = De("camera state", () => n.getCameraState(), [n]);
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      className: Vt("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": t === "idle"
      })
    }
  );
}
function Sbe({
  className: n,
  zoom: t,
  point: e,
  color: r,
  viewport: i,
  opacity: s = 1
}) {
  const o = D.useRef(null);
  return fw(
    o,
    Zs(e.x, i.minX + 5 / t, i.maxX - 5 / t),
    Zs(e.y, i.minY + 5 / t, i.maxY - 5 / t),
    1 / t,
    O.Angle(i.center, e)
  ), /* @__PURE__ */ y.jsxs("svg", { ref: o, className: Vt("tl-overlays__item", n), children: [
    /* @__PURE__ */ y.jsx("use", { href: "#cursor_hint", color: r, strokeWidth: 3, stroke: "var(--color-background)" }),
    /* @__PURE__ */ y.jsx("use", { href: "#cursor_hint", color: r, opacity: s })
  ] });
}
const O9 = D.memo(function({
  className: t,
  zoom: e,
  point: r,
  color: i,
  name: s,
  chatMessage: o
}) {
  const l = D.useRef(null);
  return fw(l, r == null ? void 0 : r.x, r == null ? void 0 : r.y, 1 / e), r ? /* @__PURE__ */ y.jsxs("div", { ref: l, className: Vt("tl-overlays__item", t), children: [
    /* @__PURE__ */ y.jsx("svg", { className: "tl-cursor", children: /* @__PURE__ */ y.jsx("use", { href: "#cursor", color: i }) }),
    o ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      s && /* @__PURE__ */ y.jsx("div", { className: "tl-nametag-title", style: { color: i }, children: s }),
      /* @__PURE__ */ y.jsx("div", { className: "tl-nametag-chat", style: { backgroundColor: i }, children: o })
    ] }) : s && /* @__PURE__ */ y.jsx("div", { className: "tl-nametag", style: { backgroundColor: i }, children: s })
  ] }) : null;
});
function HK() {
  return D.useId().replace(/:/g, "_");
}
function bbe({ x: n, y: t, z: e, size: r }) {
  const i = `grid_${HK()}`, s = we(), { gridSteps: o } = s.options;
  return /* @__PURE__ */ y.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ y.jsx("defs", { children: o.map(({ min: l, mid: u, step: d }, f) => {
      const m = d * r * e, v = 0.5 + n * e, S = 0.5 + t * e, w = v > 0 ? v % m : m + v % m, E = S > 0 ? S % m : m + S % m, A = e < u ? qx(e, [l, u], [0, 1]) : 1;
      return /* @__PURE__ */ y.jsx(
        "pattern",
        {
          id: `${i}_${d}`,
          width: m,
          height: m,
          patternUnits: "userSpaceOnUse",
          children: /* @__PURE__ */ y.jsx("circle", { className: "tl-grid-dot", cx: w, cy: E, r: 1, opacity: A })
        },
        f
      );
    }) }),
    o.map(({ step: l }, u) => /* @__PURE__ */ y.jsx("rect", { width: "100%", height: "100%", fill: `url(#${i}_${l})` }, u))
  ] });
}
function xbe({ handle: n, isCoarse: t, className: e, zoom: r }) {
  const i = we(), s = (t ? i.options.coarseHandleRadius : i.options.handleRadius) / r;
  if (n.type === "clone") {
    const l = 3 / r, u = `M0,${-l} A${l},${l} 0 0,1 0,${l}`, d = Pye.indexOf(n.id);
    return /* @__PURE__ */ y.jsxs("g", { className: Vt(`tl-handle tl-handle__${n.type}`, e), children: [
      /* @__PURE__ */ y.jsx("circle", { className: "tl-handle__bg", r: s }),
      /* @__PURE__ */ y.jsx("path", { className: "tl-handle__fg", d: u, transform: `rotate(${-90 + 90 * d})` })
    ] });
  }
  const o = (n.type === "create" && t ? 3 : 4) / Math.max(r, 0.25);
  return /* @__PURE__ */ y.jsxs("g", { className: Vt(`tl-handle tl-handle__${n.type}`, e), children: [
    /* @__PURE__ */ y.jsx("circle", { className: "tl-handle__bg", r: s }),
    /* @__PURE__ */ y.jsx("circle", { className: "tl-handle__fg", r: o })
  ] });
}
const wbe = ({ children: n }) => /* @__PURE__ */ y.jsx("svg", { className: "tl-user-handles tl-overlays__item", children: n }), Cbe = () => {
  const { Spinner: n } = xi();
  return /* @__PURE__ */ y.jsx(A5, { children: n ? /* @__PURE__ */ y.jsx(n, {}) : null });
};
function m5(n, t = !0) {
  const e = n.length;
  if (e < 2)
    return "";
  let r = n[0], i = n[1];
  if (e === 2)
    return `M${ar(r)}L${ar(i)}`;
  let s = "";
  for (let o = 2, l = e - 1; o < l; o++)
    r = n[o], i = n[o + 1], s += Rl(r, i);
  return t ? `M${Rl(n[0], n[1])}Q${ar(n[1])}${Rl(
    n[1],
    n[2]
  )}T${s}${Rl(n[e - 1], n[0])}${Rl(n[0], n[1])}Z` : `M${ar(n[0])}Q${ar(n[1])}${Rl(n[1], n[2])}${n.length > 3 ? "T" : ""}${s}L${ar(n[e - 1])}`;
}
function L9({ scribble: n, zoom: t, color: e, opacity: r, className: i }) {
  return n.points.length ? /* @__PURE__ */ y.jsx("svg", { className: i && Vt("tl-overlays__item", i), children: /* @__PURE__ */ y.jsx(
    "path",
    {
      className: "tl-scribble",
      d: m5(n.points, !1),
      stroke: e ?? `var(--color-${n.color})`,
      fill: "none",
      strokeWidth: 8 / t,
      opacity: r ?? n.opacity
    }
  ) }) : null;
}
function VK({ bounds: n, rotation: t }) {
  const e = D.useRef(null);
  return fw(e, n.x, n.y, 1, t), D.useLayoutEffect(() => {
    const r = e.current;
    r && (r.style.width = be(Math.max(1, n.width)) + "px", r.style.height = be(Math.max(1, n.height)) + "px");
  }, [n.width, n.height]), /* @__PURE__ */ y.jsx("div", { ref: e, className: "tl-selection__bg", draggable: !1 });
}
function Ebe({ bounds: n, rotation: t }) {
  const e = we(), r = D.useRef(null), i = De("only selected shape", () => e.getOnlySelectedShape(), [e]), s = i ? e.getShapeUtil(i).expandSelectionOutlinePx(i) : 0;
  return fw(r, n == null ? void 0 : n.x, n == null ? void 0 : n.y, 1, t, {
    x: -s,
    y: -s
  }), n = n.clone().expandBy(s).zeroFix(), /* @__PURE__ */ y.jsx(
    "svg",
    {
      ref: r,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: /* @__PURE__ */ y.jsx(
        "rect",
        {
          className: Vt("tl-selection__fg__outline"),
          width: be(n.width),
          height: be(n.height)
        }
      )
    }
  );
}
const _be = () => /* @__PURE__ */ y.jsx("div", { className: "tl-shape-error-boundary" }), Tbe = ({ shape: n, util: t }) => R2(
  "Indicator: " + n.type,
  () => (
    // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
    // calling the render method with stale data.
    t.indicator(t.editor.store.unsafeGetWithoutCapture(n.id))
  )
), Pbe = ({ editor: n, id: t }) => {
  const e = De("shape for indicator", () => n.store.get(t), [n, t]), { ShapeIndicatorErrorFallback: r } = xi();
  return !e || e.isLocked ? null : /* @__PURE__ */ y.jsx(
    H1,
    {
      fallback: r,
      onError: (i) => n.annotateError(i, { origin: "react.shapeIndicator", willCrashApp: !1 }),
      children: /* @__PURE__ */ y.jsx(Tbe, { shape: e, util: n.getShapeUtil(e) }, e.id)
    }
  );
}, j9 = D.memo(function({
  shapeId: t,
  className: e,
  color: r,
  hidden: i,
  opacity: s
}) {
  const o = we(), l = D.useRef(null);
  return mm(
    "indicator transform",
    () => {
      const u = l.current;
      if (!u) return;
      const d = o.getShapePageTransform(t);
      d && u.style.setProperty("transform", d.toCssString());
    },
    [o, t]
  ), D.useLayoutEffect(() => {
    const u = l.current;
    u && u.style.setProperty("display", i ? "none" : "block");
  }, [i]), /* @__PURE__ */ y.jsx("svg", { ref: l, className: Vt("tl-overlays__item", e), children: /* @__PURE__ */ y.jsx("g", { className: "tl-shape-indicator", stroke: r ?? "var(--color-selected)", opacity: s, children: /* @__PURE__ */ y.jsx(Pbe, { editor: o, id: t }) }) });
}), Abe = () => /* @__PURE__ */ y.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" }), WK = D.memo(function() {
  const t = we(), e = D.useRef(/* @__PURE__ */ new Set()), r = De(
    "should display selected ids",
    () => {
      const o = e.current, l = /* @__PURE__ */ new Set();
      if (
        // We only show indicators when in the following states...
        t.isInAny(
          "select.idle",
          "select.brushing",
          "select.scribble_brushing",
          "select.editing_shape",
          "select.pointing_shape",
          "select.pointing_selection",
          "select.pointing_handle"
        ) && // ...but we hide indicators when we've just changed a style (so that the user can see the change)
        !t.getInstanceState().isChangingStyle
      ) {
        const u = t.getSelectedShapeIds();
        for (const d of u)
          l.add(d);
        if (t.isInAny("select.idle", "select.editing_shape")) {
          const d = t.getInstanceState();
          if (d.isHoveringCanvas && !d.isCoarsePointer) {
            const f = t.getHoveredShapeId();
            f && l.add(f);
          }
        }
      }
      if (o.size !== l.size)
        return e.current = l, l;
      for (const u of l)
        if (!o.has(u))
          return e.current = l, l;
      return o;
    },
    [t]
  ), i = De("rendering shapes", () => t.getRenderingShapes(), [t]), { ShapeIndicator: s } = xi();
  return s ? i.map(({ id: o }) => /* @__PURE__ */ y.jsx(s, { shapeId: o, hidden: !r.has(o) }, o + "_indicator")) : null;
});
function kbe({ points: n, zoom: t }) {
  const e = 2.5 / t, r = n.reduce((v, S) => Math.min(v, S.x), 1 / 0), i = n.reduce((v, S) => Math.max(v, S.x), -1 / 0), s = n.reduce((v, S) => Math.min(v, S.y), 1 / 0), o = n.reduce((v, S) => Math.max(v, S.y), -1 / 0), l = n.some((v) => v.x === r && v.y === s);
  let u, d, f, m;
  return l ? (u = r, d = s, f = i, m = o) : (u = r, d = o, f = i, m = s), /* @__PURE__ */ y.jsxs("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    /* @__PURE__ */ y.jsx("line", { x1: u, y1: d, x2: f, y2: m }),
    n.map((v, S) => /* @__PURE__ */ y.jsx("g", { transform: `translate(${v.x},${v.y})`, children: /* @__PURE__ */ y.jsx(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-e},${-e} L ${e},${e} M ${-e},${e} L ${e},${-e}`
      }
    ) }, S))
  ] });
}
function Ibe({ gaps: n, direction: t, zoom: e }) {
  const r = 3.5 / e;
  let i = [-1 / 0, 1 / 0], s = null;
  const o = t === "horizontal";
  for (const u of n) {
    if (s = nd(
      i[0],
      i[1],
      o ? u.startEdge[0].y : u.startEdge[0].x,
      o ? u.startEdge[1].y : u.startEdge[1].x
    ), s)
      i = s;
    else
      continue;
    if (s = nd(
      i[0],
      i[1],
      o ? u.endEdge[0].y : u.endEdge[0].x,
      o ? u.endEdge[1].y : u.endEdge[1].x
    ), s)
      i = s;
    else
      continue;
  }
  if (i === null)
    return null;
  const l = (i[0] + i[1]) / 2;
  return /* @__PURE__ */ y.jsx("g", { className: "tl-snap-indicator", stroke: "cyan", children: n.map(({ startEdge: u, endEdge: d }, f) => /* @__PURE__ */ y.jsx(D.Fragment, { children: o ? (
    // horizontal gap
    /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "line",
        {
          x1: u[0].x,
          y1: l - 2 * r,
          x2: u[1].x,
          y2: l + 2 * r
        }
      ),
      /* @__PURE__ */ y.jsx(
        "line",
        {
          x1: d[0].x,
          y1: l - 2 * r,
          x2: d[1].x,
          y2: l + 2 * r
        }
      ),
      /* @__PURE__ */ y.jsx("line", { x1: u[0].x, y1: l, x2: d[0].x, y2: l }),
      /* @__PURE__ */ y.jsx(
        "line",
        {
          x1: (u[0].x + d[0].x) / 2,
          y1: l - r,
          x2: (u[0].x + d[0].x) / 2,
          y2: l + r
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "line",
        {
          x1: l - 2 * r,
          y1: u[0].y,
          x2: l + 2 * r,
          y2: u[1].y
        }
      ),
      /* @__PURE__ */ y.jsx(
        "line",
        {
          x1: l - 2 * r,
          y1: d[0].y,
          x2: l + 2 * r,
          y2: d[1].y
        }
      ),
      /* @__PURE__ */ y.jsx("line", { x1: l, y1: u[0].y, x2: l, y2: d[0].y }),
      /* @__PURE__ */ y.jsx(
        "line",
        {
          x1: l - r,
          y1: (u[0].y + d[0].y) / 2,
          x2: l + r,
          y2: (u[0].y + d[0].y) / 2
        }
      )
    ] })
  ) }, f)) });
}
function Rbe({ className: n, line: t, zoom: e }) {
  return /* @__PURE__ */ y.jsx("svg", { className: Vt("tl-overlays__item", n), children: t.type === "points" ? /* @__PURE__ */ y.jsx(kbe, { ...t, zoom: e }) : t.type === "gaps" ? /* @__PURE__ */ y.jsx(Ibe, { ...t, zoom: e }) : null });
}
function v5() {
  return /* @__PURE__ */ y.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", children: /* @__PURE__ */ y.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ y.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ y.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ y.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const Mbe = () => null;
function GK(n, t) {
  const e = D.useRef(n);
  return t(n, e.current) ? e.current : (e.current = n, n);
}
function A1(n) {
  return GK(n, xme);
}
const Dbe = (n, t) => (n ?? (n = null), t ?? (t = null), n === t ? !0 : !n || !t ? !1 : yG(n, t));
function O2(n) {
  return GK(n, Dbe);
}
const KK = D.createContext(null);
function Obe({
  overrides: n = {},
  children: t
}) {
  const e = O2(n), r = D.useMemo(
    () => ({
      Background: bye,
      SvgDefs: Mbe,
      Brush: PN,
      ZoomBrush: PN,
      CollaboratorBrush: PN,
      Cursor: O9,
      CollaboratorCursor: O9,
      CollaboratorHint: Sbe,
      CollaboratorShapeIndicator: j9,
      Grid: bbe,
      Scribble: L9,
      SnapIndicator: Rbe,
      Handles: wbe,
      Handle: xbe,
      CollaboratorScribble: L9,
      ErrorFallback: XK,
      ShapeErrorFallback: _be,
      ShapeIndicatorErrorFallback: Abe,
      Spinner: v5,
      SelectionBackground: VK,
      SelectionForeground: Ebe,
      ShapeIndicators: WK,
      ShapeIndicator: j9,
      OnTheCanvas: null,
      InFrontOfTheCanvas: null,
      Canvas: QSe,
      LoadingScreen: Cbe,
      ...e
    }),
    [e]
  );
  return /* @__PURE__ */ y.jsx(KK.Provider, { value: r, children: t });
}
function xi() {
  const n = D.useContext(KK);
  if (!n)
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  return n;
}
const y5 = {
  openWindow: (n, t) => window.open(n, t, "noopener noreferrer"),
  refreshPage: () => window.location.reload(),
  hardReset: async () => {
    var n;
    return await ((n = window.__tldraw__hardReset) == null ? void 0 : n.call(window));
  }
};
function YK() {
  y5.hardReset();
}
function Lbe() {
  y5.refreshPage();
}
const jbe = "https://github.com/tldraw/tldraw/issues/new", XK = ({ error: n, editor: t }) => {
  const e = D.useRef(null), [r, i] = D.useState(process.env.NODE_ENV === "development"), [s, o] = D.useState(!1), [l, u] = D.useState(!1);
  let d = null;
  try {
    d = xi().Canvas ?? null;
  } catch {
  }
  const f = n instanceof Error ? n.message : String(n), m = n instanceof Error ? n.stack : null, v = De(
    "isDarkMode",
    () => {
      try {
        if (t)
          return t.user.getIsDarkMode();
      } catch {
      }
      return null;
    },
    [t]
  ), [S, w] = D.useState(null);
  D.useLayoutEffect(() => {
    var $;
    v !== null && w(v);
    let M = ($ = e.current) == null ? void 0 : $.parentElement, j = !1;
    for (; M; ) {
      if (M.classList.contains("tl-theme__dark") || M.classList.contains("tl-theme__light")) {
        j = !0;
        break;
      }
      M = M.parentElement;
    }
    if (j) {
      w(null);
      return;
    }
    typeof window < "u" && "matchMedia" in window && w(window.matchMedia("(prefers-color-scheme: dark)").matches);
  }, [v]), D.useEffect(() => {
    if (s) {
      const M = t == null ? void 0 : t.timers.setTimeout(() => {
        o(!1);
      }, 2e3);
      return () => clearTimeout(M);
    }
  }, [s, t]);
  const E = () => {
    const M = document.createElement("textarea");
    M.value = m ?? f, document.body.appendChild(M), M.select(), document.execCommand("copy"), M.remove(), o(!0);
  }, A = () => {
    Lbe();
  }, P = async () => {
    YK();
  }, R = new URL(jbe);
  return R.searchParams.set("title", f), R.searchParams.set("labels", "bug"), R.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${m ?? f}
\`\`\`

My browser: ${navigator.userAgent}`
  ), /* @__PURE__ */ y.jsxs(
    "div",
    {
      ref: e,
      className: Vt(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        S === null ? "" : S ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        /* @__PURE__ */ y.jsx("div", { className: "tl-error-boundary__overlay" }),
        t && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ y.jsx(CK, { onError: F1, fallback: () => null, children: /* @__PURE__ */ y.jsx(M2.Provider, { value: t, children: /* @__PURE__ */ y.jsx("div", { className: "tl-overlay tl-error-boundary__canvas", children: d ? /* @__PURE__ */ y.jsx(d, {}) : null }) }) }),
        /* @__PURE__ */ y.jsx(
          "div",
          {
            className: Vt("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": r && !l
            }),
            children: l ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
              /* @__PURE__ */ y.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ y.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ y.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ y.jsx("button", { onClick: () => u(!1), children: "Cancel" }),
                /* @__PURE__ */ y.jsx("button", { className: "tl-error-boundary__reset", onClick: P, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
              /* @__PURE__ */ y.jsx("h2", { children: "Something's gone wrong." }),
              /* @__PURE__ */ y.jsxs("p", { children: [
                "Sorry, we encountered an error. Please refresh the page to continue. If you keep seeing this error, you can ",
                /* @__PURE__ */ y.jsx("a", { href: R.toString(), children: "create a GitHub issue" }),
                " or",
                " ",
                /* @__PURE__ */ y.jsx("a", { href: "https://discord.gg/Cq6cPsTfNy", children: "ask for help on Discord" }),
                "."
              ] }),
              r && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
                "Message:",
                /* @__PURE__ */ y.jsx("h4", { children: /* @__PURE__ */ y.jsx("code", { children: f }) }),
                "Stack trace:",
                /* @__PURE__ */ y.jsxs("div", { className: "tl-error-boundary__content__error", children: [
                  /* @__PURE__ */ y.jsx("pre", { children: /* @__PURE__ */ y.jsx("code", { children: m ?? f }) }),
                  /* @__PURE__ */ y.jsx("button", { onClick: E, children: s ? "Copied!" : "Copy" })
                ] })
              ] }),
              /* @__PURE__ */ y.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ y.jsx("button", { onClick: () => i(!r), children: r ? "Hide details" : "Show details" }),
                /* @__PURE__ */ y.jsxs("div", { className: "tl-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ y.jsx(
                    "button",
                    {
                      className: "tl-error-boundary__reset",
                      onClick: () => u(!0),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ y.jsx("button", { className: "tl-error-boundary__refresh", onClick: A, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};
function Ii() {
  return FT();
}
const qK = "TLDRAW_USER_DATA_v3", ZK = Mn({
  id: vn,
  name: vn.nullable().optional(),
  locale: vn.nullable().optional(),
  color: vn.nullable().optional(),
  colorScheme: k2("light", "dark", "system").optional(),
  animationSpeed: Jt.nullable().optional(),
  edgeScrollSpeed: Jt.nullable().optional(),
  isSnapMode: kn.nullable().optional(),
  isWrapMode: kn.nullable().optional(),
  isDynamicSizeMode: kn.nullable().optional(),
  isPasteAtCursorMode: kn.nullable().optional()
}), Af = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8
}, S5 = Math.max(...Object.values(Af));
function Nbe(n) {
  n.version < Af.AddAnimationSpeed && (n.user.animationSpeed = 1), n.version < Af.AddIsSnapMode && (n.user.isSnapMode = !1), n.version < Af.MakeFieldsNullable, n.version < Af.AddEdgeScrollSpeed && (n.user.edgeScrollSpeed = 1), n.version < Af.AddExcalidrawSelectMode && (n.user.isWrapMode = !1), n.version < Af.AllowSystemColorScheme && (n.user.isDarkMode === !0 ? n.user.colorScheme = "dark" : n.user.isDarkMode === !1 && (n.user.colorScheme = "light"), delete n.user.isDarkMode), n.version < Af.AddDynamicSizeMode && (n.user.isDynamicSizeMode = !1), n.version < Af.AddPasteAtCursor && (n.user.isPasteAtCursorMode = !1), n.version = S5;
}
const y3 = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function QK() {
  return y3[Math.floor(Math.random() * y3.length)];
}
function Fbe() {
  var n, t;
  return typeof window < "u" && "matchMedia" in window ? ((t = (n = window.matchMedia) == null ? void 0 : n.call(window, "(prefers-reduced-motion: reduce)")) == null ? void 0 : t.matches) ?? !1 : !1;
}
const _f = Object.freeze({
  name: "New User",
  locale: hye(),
  color: QK(),
  edgeScrollSpeed: 1,
  animationSpeed: Fbe() ? 0 : 1,
  isSnapMode: !1,
  isWrapMode: !1,
  isDynamicSizeMode: !1,
  isPasteAtCursorMode: !1,
  colorScheme: "system"
});
function IN() {
  return {
    id: Ii(),
    color: QK()
  };
}
function JK(n) {
  if (n === null || typeof n != "object" || !("version" in n) || !("user" in n) || typeof n.version != "number")
    return IN();
  const t = ni(n);
  Nbe(t);
  try {
    return ZK.validate(t.user);
  } catch {
    return IN();
  }
}
function $be() {
  const n = JSON.parse(Qz(qK) || "null") ?? null;
  return JK(n);
}
const L2 = Qs("globalUserData", null);
function zbe() {
  Jz(
    qK,
    JSON.stringify({
      version: S5,
      user: L2.get()
    })
  );
}
function eY(n) {
  ZK.validate(n), L2.set(n), zbe(), Bbe();
}
const Ube = typeof process < "u" && process.env.NODE_ENV === "test", W0 = typeof BroadcastChannel < "u" && !Ube ? new BroadcastChannel("tldraw-user-sync") : null;
W0 == null || W0.addEventListener("message", (n) => {
  const t = n.data;
  (t == null ? void 0 : t.type) === nY && (t == null ? void 0 : t.origin) !== tY() && L2.set(JK(t.data));
});
let RN = null;
function tY() {
  return RN === null && (RN = Ii()), RN;
}
const nY = "tldraw-user-preferences-change";
function Bbe() {
  W0 == null || W0.postMessage({
    type: nY,
    origin: tY(),
    data: {
      user: rY(),
      version: S5
    }
  });
}
function rY() {
  let n = L2.get();
  return n || (n = $be(), eY(n)), n;
}
const Hbe = ze(
  "defaultLocalStorageUserPrefs",
  () => rY()
);
function iY(n = {}) {
  return {
    userPreferences: n.userPreferences ?? Hbe,
    setUserPreferences: n.setUserPreferences ?? eY
  };
}
var sY = { exports: {} };
(function(n) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));
  function i(u, d, f) {
    this.fn = u, this.context = d, this.once = f || !1;
  }
  function s(u, d, f, m, v) {
    if (typeof f != "function")
      throw new TypeError("The listener must be a function");
    var S = new i(f, m || u, v), w = e ? e + d : d;
    return u._events[w] ? u._events[w].fn ? u._events[w] = [u._events[w], S] : u._events[w].push(S) : (u._events[w] = S, u._eventsCount++), u;
  }
  function o(u, d) {
    --u._eventsCount === 0 ? u._events = new r() : delete u._events[d];
  }
  function l() {
    this._events = new r(), this._eventsCount = 0;
  }
  l.prototype.eventNames = function() {
    var d = [], f, m;
    if (this._eventsCount === 0) return d;
    for (m in f = this._events)
      t.call(f, m) && d.push(e ? m.slice(1) : m);
    return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(f)) : d;
  }, l.prototype.listeners = function(d) {
    var f = e ? e + d : d, m = this._events[f];
    if (!m) return [];
    if (m.fn) return [m.fn];
    for (var v = 0, S = m.length, w = new Array(S); v < S; v++)
      w[v] = m[v].fn;
    return w;
  }, l.prototype.listenerCount = function(d) {
    var f = e ? e + d : d, m = this._events[f];
    return m ? m.fn ? 1 : m.length : 0;
  }, l.prototype.emit = function(d, f, m, v, S, w) {
    var E = e ? e + d : d;
    if (!this._events[E]) return !1;
    var A = this._events[E], P = arguments.length, R, M;
    if (A.fn) {
      switch (A.once && this.removeListener(d, A.fn, void 0, !0), P) {
        case 1:
          return A.fn.call(A.context), !0;
        case 2:
          return A.fn.call(A.context, f), !0;
        case 3:
          return A.fn.call(A.context, f, m), !0;
        case 4:
          return A.fn.call(A.context, f, m, v), !0;
        case 5:
          return A.fn.call(A.context, f, m, v, S), !0;
        case 6:
          return A.fn.call(A.context, f, m, v, S, w), !0;
      }
      for (M = 1, R = new Array(P - 1); M < P; M++)
        R[M - 1] = arguments[M];
      A.fn.apply(A.context, R);
    } else {
      var j = A.length, $;
      for (M = 0; M < j; M++)
        switch (A[M].once && this.removeListener(d, A[M].fn, void 0, !0), P) {
          case 1:
            A[M].fn.call(A[M].context);
            break;
          case 2:
            A[M].fn.call(A[M].context, f);
            break;
          case 3:
            A[M].fn.call(A[M].context, f, m);
            break;
          case 4:
            A[M].fn.call(A[M].context, f, m, v);
            break;
          default:
            if (!R) for ($ = 1, R = new Array(P - 1); $ < P; $++)
              R[$ - 1] = arguments[$];
            A[M].fn.apply(A[M].context, R);
        }
    }
    return !0;
  }, l.prototype.on = function(d, f, m) {
    return s(this, d, f, m, !1);
  }, l.prototype.once = function(d, f, m) {
    return s(this, d, f, m, !0);
  }, l.prototype.removeListener = function(d, f, m, v) {
    var S = e ? e + d : d;
    if (!this._events[S]) return this;
    if (!f)
      return o(this, S), this;
    var w = this._events[S];
    if (w.fn)
      w.fn === f && (!v || w.once) && (!m || w.context === m) && o(this, S);
    else {
      for (var E = 0, A = [], P = w.length; E < P; E++)
        (w[E].fn !== f || v && !w[E].once || m && w[E].context !== m) && A.push(w[E]);
      A.length ? this._events[S] = A.length === 1 ? A[0] : A : o(this, S);
    }
    return this;
  }, l.prototype.removeAllListeners = function(d) {
    var f;
    return d ? (f = e ? e + d : d, this._events[f] && o(this, f)) : (this._events = new r(), this._eventsCount = 0), this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = e, l.EventEmitter = l, n.exports = l;
})(sY);
var Vbe = sY.exports;
const Wbe = /* @__PURE__ */ Ep(Vbe);
var S3 = { exports: {} }, bl = {}, dI = { exports: {} }, MN = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var N9;
function Gbe() {
  return N9 || (N9 = 1, function(n) {
    function t(ue, Se) {
      var ke = ue.length;
      ue.push(Se);
      e: for (; 0 < ke; ) {
        var ce = ke - 1 >>> 1, ye = ue[ce];
        if (0 < i(ye, Se)) ue[ce] = Se, ue[ke] = ye, ke = ce;
        else break e;
      }
    }
    function e(ue) {
      return ue.length === 0 ? null : ue[0];
    }
    function r(ue) {
      if (ue.length === 0) return null;
      var Se = ue[0], ke = ue.pop();
      if (ke !== Se) {
        ue[0] = ke;
        e: for (var ce = 0, ye = ue.length, Fe = ye >>> 1; ce < Fe; ) {
          var Xe = 2 * (ce + 1) - 1, je = ue[Xe], nt = Xe + 1, Ze = ue[nt];
          if (0 > i(je, ke)) nt < ye && 0 > i(Ze, je) ? (ue[ce] = Ze, ue[nt] = ke, ce = nt) : (ue[ce] = je, ue[Xe] = ke, ce = Xe);
          else if (nt < ye && 0 > i(Ze, ke)) ue[ce] = Ze, ue[nt] = ke, ce = nt;
          else break e;
        }
      }
      return Se;
    }
    function i(ue, Se) {
      var ke = ue.sortIndex - Se.sortIndex;
      return ke !== 0 ? ke : ue.id - Se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      n.unstable_now = function() {
        return s.now();
      };
    } else {
      var o = Date, l = o.now();
      n.unstable_now = function() {
        return o.now() - l;
      };
    }
    var u = [], d = [], f = 1, m = null, v = 3, S = !1, w = !1, E = !1, A = typeof setTimeout == "function" ? setTimeout : null, P = typeof clearTimeout == "function" ? clearTimeout : null, R = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(ue) {
      for (var Se = e(d); Se !== null; ) {
        if (Se.callback === null) r(d);
        else if (Se.startTime <= ue) r(d), Se.sortIndex = Se.expirationTime, t(u, Se);
        else break;
        Se = e(d);
      }
    }
    function j(ue) {
      if (E = !1, M(ue), !w) if (e(u) !== null) w = !0, fe($);
      else {
        var Se = e(d);
        Se !== null && ie(j, Se.startTime - ue);
      }
    }
    function $(ue, Se) {
      w = !1, E && (E = !1, P(B), B = -1), S = !0;
      var ke = v;
      try {
        for (M(Se), m = e(u); m !== null && (!(m.expirationTime > Se) || ue && !te()); ) {
          var ce = m.callback;
          if (typeof ce == "function") {
            m.callback = null, v = m.priorityLevel;
            var ye = ce(m.expirationTime <= Se);
            Se = n.unstable_now(), typeof ye == "function" ? m.callback = ye : m === e(u) && r(u), M(Se);
          } else r(u);
          m = e(u);
        }
        if (m !== null) var Fe = !0;
        else {
          var Xe = e(d);
          Xe !== null && ie(j, Xe.startTime - Se), Fe = !1;
        }
        return Fe;
      } finally {
        m = null, v = ke, S = !1;
      }
    }
    var U = !1, F = null, B = -1, G = 5, X = -1;
    function te() {
      return !(n.unstable_now() - X < G);
    }
    function ne() {
      if (F !== null) {
        var ue = n.unstable_now();
        X = ue;
        var Se = !0;
        try {
          Se = F(!0, ue);
        } finally {
          Se ? K() : (U = !1, F = null);
        }
      } else U = !1;
    }
    var K;
    if (typeof R == "function") K = function() {
      R(ne);
    };
    else if (typeof MessageChannel < "u") {
      var Z = new MessageChannel(), oe = Z.port2;
      Z.port1.onmessage = ne, K = function() {
        oe.postMessage(null);
      };
    } else K = function() {
      A(ne, 0);
    };
    function fe(ue) {
      F = ue, U || (U = !0, K());
    }
    function ie(ue, Se) {
      B = A(function() {
        ue(n.unstable_now());
      }, Se);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(ue) {
      ue.callback = null;
    }, n.unstable_continueExecution = function() {
      w || S || (w = !0, fe($));
    }, n.unstable_forceFrameRate = function(ue) {
      0 > ue || 125 < ue ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : G = 0 < ue ? Math.floor(1e3 / ue) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, n.unstable_getFirstCallbackNode = function() {
      return e(u);
    }, n.unstable_next = function(ue) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var Se = 3;
          break;
        default:
          Se = v;
      }
      var ke = v;
      v = Se;
      try {
        return ue();
      } finally {
        v = ke;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(ue, Se) {
      switch (ue) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ue = 3;
      }
      var ke = v;
      v = ue;
      try {
        return Se();
      } finally {
        v = ke;
      }
    }, n.unstable_scheduleCallback = function(ue, Se, ke) {
      var ce = n.unstable_now();
      switch (typeof ke == "object" && ke !== null ? (ke = ke.delay, ke = typeof ke == "number" && 0 < ke ? ce + ke : ce) : ke = ce, ue) {
        case 1:
          var ye = -1;
          break;
        case 2:
          ye = 250;
          break;
        case 5:
          ye = 1073741823;
          break;
        case 4:
          ye = 1e4;
          break;
        default:
          ye = 5e3;
      }
      return ye = ke + ye, ue = { id: f++, callback: Se, priorityLevel: ue, startTime: ke, expirationTime: ye, sortIndex: -1 }, ke > ce ? (ue.sortIndex = ke, t(d, ue), e(u) === null && ue === e(d) && (E ? (P(B), B = -1) : E = !0, ie(j, ke - ce))) : (ue.sortIndex = ye, t(u, ue), w || S || (w = !0, fe($))), ue;
    }, n.unstable_shouldYield = te, n.unstable_wrapCallback = function(ue) {
      var Se = v;
      return function() {
        var ke = v;
        v = Se;
        try {
          return ue.apply(this, arguments);
        } finally {
          v = ke;
        }
      };
    };
  }(MN)), MN;
}
var DN = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var F9;
function Kbe() {
  return F9 || (F9 = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, e = !1, r = 5;
      function i(Je, It) {
        var hn = Je.length;
        Je.push(It), l(Je, It, hn);
      }
      function s(Je) {
        return Je.length === 0 ? null : Je[0];
      }
      function o(Je) {
        if (Je.length === 0)
          return null;
        var It = Je[0], hn = Je.pop();
        return hn !== It && (Je[0] = hn, u(Je, hn, 0)), It;
      }
      function l(Je, It, hn) {
        for (var Bn = hn; Bn > 0; ) {
          var Ln = Bn - 1 >>> 1, Yr = Je[Ln];
          if (d(Yr, It) > 0)
            Je[Ln] = It, Je[Bn] = Yr, Bn = Ln;
          else
            return;
        }
      }
      function u(Je, It, hn) {
        for (var Bn = hn, Ln = Je.length, Yr = Ln >>> 1; Bn < Yr; ) {
          var kr = (Bn + 1) * 2 - 1, rs = Je[kr], wn = kr + 1, is = Je[wn];
          if (d(rs, It) < 0)
            wn < Ln && d(is, rs) < 0 ? (Je[Bn] = is, Je[wn] = It, Bn = wn) : (Je[Bn] = rs, Je[kr] = It, Bn = kr);
          else if (wn < Ln && d(is, It) < 0)
            Je[Bn] = is, Je[wn] = It, Bn = wn;
          else
            return;
        }
      }
      function d(Je, It) {
        var hn = Je.sortIndex - It.sortIndex;
        return hn !== 0 ? hn : Je.id - It.id;
      }
      var f = 1, m = 2, v = 3, S = 4, w = 5;
      function E(Je, It) {
      }
      var A = typeof performance == "object" && typeof performance.now == "function";
      if (A) {
        var P = performance;
        n.unstable_now = function() {
          return P.now();
        };
      } else {
        var R = Date, M = R.now();
        n.unstable_now = function() {
          return R.now() - M;
        };
      }
      var j = 1073741823, $ = -1, U = 250, F = 5e3, B = 1e4, G = j, X = [], te = [], ne = 1, K = null, Z = v, oe = !1, fe = !1, ie = !1, ue = typeof setTimeout == "function" ? setTimeout : null, Se = typeof clearTimeout == "function" ? clearTimeout : null, ke = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ce(Je) {
        for (var It = s(te); It !== null; ) {
          if (It.callback === null)
            o(te);
          else if (It.startTime <= Je)
            o(te), It.sortIndex = It.expirationTime, i(X, It);
          else
            return;
          It = s(te);
        }
      }
      function ye(Je) {
        if (ie = !1, ce(Je), !fe)
          if (s(X) !== null)
            fe = !0, ts(Fe);
          else {
            var It = s(te);
            It !== null && On(ye, It.startTime - Je);
          }
      }
      function Fe(Je, It) {
        fe = !1, ie && (ie = !1, Kr()), oe = !0;
        var hn = Z;
        try {
          var Bn;
          if (!e) return Xe(Je, It);
        } finally {
          K = null, Z = hn, oe = !1;
        }
      }
      function Xe(Je, It) {
        var hn = It;
        for (ce(hn), K = s(X); K !== null && !t && !(K.expirationTime > hn && (!Je || Nr())); ) {
          var Bn = K.callback;
          if (typeof Bn == "function") {
            K.callback = null, Z = K.priorityLevel;
            var Ln = K.expirationTime <= hn, Yr = Bn(Ln);
            hn = n.unstable_now(), typeof Yr == "function" ? K.callback = Yr : K === s(X) && o(X), ce(hn);
          } else
            o(X);
          K = s(X);
        }
        if (K !== null)
          return !0;
        var kr = s(te);
        return kr !== null && On(ye, kr.startTime - hn), !1;
      }
      function je(Je, It) {
        switch (Je) {
          case f:
          case m:
          case v:
          case S:
          case w:
            break;
          default:
            Je = v;
        }
        var hn = Z;
        Z = Je;
        try {
          return It();
        } finally {
          Z = hn;
        }
      }
      function nt(Je) {
        var It;
        switch (Z) {
          case f:
          case m:
          case v:
            It = v;
            break;
          default:
            It = Z;
            break;
        }
        var hn = Z;
        Z = It;
        try {
          return Je();
        } finally {
          Z = hn;
        }
      }
      function Ze(Je) {
        var It = Z;
        return function() {
          var hn = Z;
          Z = It;
          try {
            return Je.apply(this, arguments);
          } finally {
            Z = hn;
          }
        };
      }
      function tt(Je, It, hn) {
        var Bn = n.unstable_now(), Ln;
        if (typeof hn == "object" && hn !== null) {
          var Yr = hn.delay;
          typeof Yr == "number" && Yr > 0 ? Ln = Bn + Yr : Ln = Bn;
        } else
          Ln = Bn;
        var kr;
        switch (Je) {
          case f:
            kr = $;
            break;
          case m:
            kr = U;
            break;
          case w:
            kr = G;
            break;
          case S:
            kr = B;
            break;
          case v:
          default:
            kr = F;
            break;
        }
        var rs = Ln + kr, wn = {
          id: ne++,
          callback: It,
          priorityLevel: Je,
          startTime: Ln,
          expirationTime: rs,
          sortIndex: -1
        };
        return Ln > Bn ? (wn.sortIndex = Ln, i(te, wn), s(X) === null && wn === s(te) && (ie ? Kr() : ie = !0, On(ye, Ln - Bn))) : (wn.sortIndex = rs, i(X, wn), !fe && !oe && (fe = !0, ts(Fe))), wn;
      }
      function et() {
      }
      function at() {
        !fe && !oe && (fe = !0, ts(Fe));
      }
      function Yt() {
        return s(X);
      }
      function Un(Je) {
        Je.callback = null;
      }
      function pt() {
        return Z;
      }
      var Ut = !1, jt = null, $t = -1, yn = r, hi = -1;
      function Nr() {
        var Je = n.unstable_now() - hi;
        return !(Je < yn);
      }
      function fi() {
      }
      function oi(Je) {
        if (Je < 0 || Je > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Je > 0 ? yn = Math.floor(1e3 / Je) : yn = r;
      }
      var es = function() {
        if (jt !== null) {
          var Je = n.unstable_now();
          hi = Je;
          var It = !0, hn = !0;
          try {
            hn = jt(It, Je);
          } finally {
            hn ? Di() : (Ut = !1, jt = null);
          }
        } else
          Ut = !1;
      }, Di;
      if (typeof ke == "function")
        Di = function() {
          ke(es);
        };
      else if (typeof MessageChannel < "u") {
        var Ss = new MessageChannel(), wi = Ss.port2;
        Ss.port1.onmessage = es, Di = function() {
          wi.postMessage(null);
        };
      } else
        Di = function() {
          ue(es, 0);
        };
      function ts(Je) {
        jt = Je, Ut || (Ut = !0, Di());
      }
      function On(Je, It) {
        $t = ue(function() {
          Je(n.unstable_now());
        }, It);
      }
      function Kr() {
        Se($t), $t = -1;
      }
      var ns = fi, vr = null;
      n.unstable_IdlePriority = w, n.unstable_ImmediatePriority = f, n.unstable_LowPriority = S, n.unstable_NormalPriority = v, n.unstable_Profiling = vr, n.unstable_UserBlockingPriority = m, n.unstable_cancelCallback = Un, n.unstable_continueExecution = at, n.unstable_forceFrameRate = oi, n.unstable_getCurrentPriorityLevel = pt, n.unstable_getFirstCallbackNode = Yt, n.unstable_next = nt, n.unstable_pauseExecution = et, n.unstable_requestPaint = ns, n.unstable_runWithPriority = je, n.unstable_scheduleCallback = tt, n.unstable_shouldYield = Nr, n.unstable_wrapCallback = Ze, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(DN)), DN;
}
var $9;
function oY() {
  return $9 || ($9 = 1, process.env.NODE_ENV === "production" ? dI.exports = Gbe() : dI.exports = Kbe()), dI.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var z9;
function Ybe() {
  if (z9) return bl;
  z9 = 1;
  var n = D, t = oY();
  function e(h) {
    for (var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + h, x = 1; x < arguments.length; x++) p += "&args[]=" + encodeURIComponent(arguments[x]);
    return "Minified React error #" + h + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function s(h, p) {
    o(h, p), o(h + "Capture", p);
  }
  function o(h, p) {
    for (i[h] = p, h = 0; h < p.length; h++) r.add(p[h]);
  }
  var l = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), u = Object.prototype.hasOwnProperty, d = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, m = {};
  function v(h) {
    return u.call(m, h) ? !0 : u.call(f, h) ? !1 : d.test(h) ? m[h] = !0 : (f[h] = !0, !1);
  }
  function S(h, p, x, k) {
    if (x !== null && x.type === 0) return !1;
    switch (typeof p) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return k ? !1 : x !== null ? !x.acceptsBooleans : (h = h.toLowerCase().slice(0, 5), h !== "data-" && h !== "aria-");
      default:
        return !1;
    }
  }
  function w(h, p, x, k) {
    if (p === null || typeof p > "u" || S(h, p, x, k)) return !0;
    if (k) return !1;
    if (x !== null) switch (x.type) {
      case 3:
        return !p;
      case 4:
        return p === !1;
      case 5:
        return isNaN(p);
      case 6:
        return isNaN(p) || 1 > p;
    }
    return !1;
  }
  function E(h, p, x, k, L, z, Y) {
    this.acceptsBooleans = p === 2 || p === 3 || p === 4, this.attributeName = k, this.attributeNamespace = L, this.mustUseProperty = x, this.propertyName = h, this.type = p, this.sanitizeURL = z, this.removeEmptyString = Y;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(h) {
    A[h] = new E(h, 0, !1, h, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(h) {
    var p = h[0];
    A[p] = new E(p, 1, !1, h[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(h) {
    A[h] = new E(h, 2, !1, h.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(h) {
    A[h] = new E(h, 2, !1, h, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(h) {
    A[h] = new E(h, 3, !1, h.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(h) {
    A[h] = new E(h, 3, !0, h, null, !1, !1);
  }), ["capture", "download"].forEach(function(h) {
    A[h] = new E(h, 4, !1, h, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(h) {
    A[h] = new E(h, 6, !1, h, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(h) {
    A[h] = new E(h, 5, !1, h.toLowerCase(), null, !1, !1);
  });
  var P = /[\-:]([a-z])/g;
  function R(h) {
    return h[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(h) {
    var p = h.replace(
      P,
      R
    );
    A[p] = new E(p, 1, !1, h, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(h) {
    var p = h.replace(P, R);
    A[p] = new E(p, 1, !1, h, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(h) {
    var p = h.replace(P, R);
    A[p] = new E(p, 1, !1, h, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(h) {
    A[h] = new E(h, 1, !1, h.toLowerCase(), null, !1, !1);
  }), A.xlinkHref = new E("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(h) {
    A[h] = new E(h, 1, !1, h.toLowerCase(), null, !0, !0);
  });
  function M(h, p, x, k) {
    var L = A.hasOwnProperty(p) ? A[p] : null;
    (L !== null ? L.type !== 0 : k || !(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (w(p, x, L, k) && (x = null), k || L === null ? v(p) && (x === null ? h.removeAttribute(p) : h.setAttribute(p, "" + x)) : L.mustUseProperty ? h[L.propertyName] = x === null ? L.type === 3 ? !1 : "" : x : (p = L.attributeName, k = L.attributeNamespace, x === null ? h.removeAttribute(p) : (L = L.type, x = L === 3 || L === 4 && x === !0 ? "" : "" + x, k ? h.setAttributeNS(k, p, x) : h.setAttribute(p, x))));
  }
  var j = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, $ = Symbol.for("react.element"), U = Symbol.for("react.portal"), F = Symbol.for("react.fragment"), B = Symbol.for("react.strict_mode"), G = Symbol.for("react.profiler"), X = Symbol.for("react.provider"), te = Symbol.for("react.context"), ne = Symbol.for("react.forward_ref"), K = Symbol.for("react.suspense"), Z = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), fe = Symbol.for("react.lazy"), ie = Symbol.for("react.offscreen"), ue = Symbol.iterator;
  function Se(h) {
    return h === null || typeof h != "object" ? null : (h = ue && h[ue] || h["@@iterator"], typeof h == "function" ? h : null);
  }
  var ke = Object.assign, ce;
  function ye(h) {
    if (ce === void 0) try {
      throw Error();
    } catch (x) {
      var p = x.stack.trim().match(/\n( *(at )?)/);
      ce = p && p[1] || "";
    }
    return `
` + ce + h;
  }
  var Fe = !1;
  function Xe(h, p) {
    if (!h || Fe) return "";
    Fe = !0;
    var x = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (p) if (p = function() {
        throw Error();
      }, Object.defineProperty(p.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(p, []);
        } catch (Ie) {
          var k = Ie;
        }
        Reflect.construct(h, [], p);
      } else {
        try {
          p.call();
        } catch (Ie) {
          k = Ie;
        }
        h.call(p.prototype);
      }
      else {
        try {
          throw Error();
        } catch (Ie) {
          k = Ie;
        }
        h();
      }
    } catch (Ie) {
      if (Ie && k && typeof Ie.stack == "string") {
        for (var L = Ie.stack.split(`
`), z = k.stack.split(`
`), Y = L.length - 1, ae = z.length - 1; 1 <= Y && 0 <= ae && L[Y] !== z[ae]; ) ae--;
        for (; 1 <= Y && 0 <= ae; Y--, ae--) if (L[Y] !== z[ae]) {
          if (Y !== 1 || ae !== 1)
            do
              if (Y--, ae--, 0 > ae || L[Y] !== z[ae]) {
                var he = `
` + L[Y].replace(" at new ", " at ");
                return h.displayName && he.includes("<anonymous>") && (he = he.replace("<anonymous>", h.displayName)), he;
              }
            while (1 <= Y && 0 <= ae);
          break;
        }
      }
    } finally {
      Fe = !1, Error.prepareStackTrace = x;
    }
    return (h = h ? h.displayName || h.name : "") ? ye(h) : "";
  }
  function je(h) {
    switch (h.tag) {
      case 5:
        return ye(h.type);
      case 16:
        return ye("Lazy");
      case 13:
        return ye("Suspense");
      case 19:
        return ye("SuspenseList");
      case 0:
      case 2:
      case 15:
        return h = Xe(h.type, !1), h;
      case 11:
        return h = Xe(h.type.render, !1), h;
      case 1:
        return h = Xe(h.type, !0), h;
      default:
        return "";
    }
  }
  function nt(h) {
    if (h == null) return null;
    if (typeof h == "function") return h.displayName || h.name || null;
    if (typeof h == "string") return h;
    switch (h) {
      case F:
        return "Fragment";
      case U:
        return "Portal";
      case G:
        return "Profiler";
      case B:
        return "StrictMode";
      case K:
        return "Suspense";
      case Z:
        return "SuspenseList";
    }
    if (typeof h == "object") switch (h.$$typeof) {
      case te:
        return (h.displayName || "Context") + ".Consumer";
      case X:
        return (h._context.displayName || "Context") + ".Provider";
      case ne:
        var p = h.render;
        return h = h.displayName, h || (h = p.displayName || p.name || "", h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"), h;
      case oe:
        return p = h.displayName || null, p !== null ? p : nt(h.type) || "Memo";
      case fe:
        p = h._payload, h = h._init;
        try {
          return nt(h(p));
        } catch {
        }
    }
    return null;
  }
  function Ze(h) {
    var p = h.type;
    switch (h.tag) {
      case 24:
        return "Cache";
      case 9:
        return (p.displayName || "Context") + ".Consumer";
      case 10:
        return (p._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return h = p.render, h = h.displayName || h.name || "", p.displayName || (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return p;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return nt(p);
      case 8:
        return p === B ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof p == "function") return p.displayName || p.name || null;
        if (typeof p == "string") return p;
    }
    return null;
  }
  function tt(h) {
    switch (typeof h) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return h;
      case "object":
        return h;
      default:
        return "";
    }
  }
  function et(h) {
    var p = h.type;
    return (h = h.nodeName) && h.toLowerCase() === "input" && (p === "checkbox" || p === "radio");
  }
  function at(h) {
    var p = et(h) ? "checked" : "value", x = Object.getOwnPropertyDescriptor(h.constructor.prototype, p), k = "" + h[p];
    if (!h.hasOwnProperty(p) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
      var L = x.get, z = x.set;
      return Object.defineProperty(h, p, { configurable: !0, get: function() {
        return L.call(this);
      }, set: function(Y) {
        k = "" + Y, z.call(this, Y);
      } }), Object.defineProperty(h, p, { enumerable: x.enumerable }), { getValue: function() {
        return k;
      }, setValue: function(Y) {
        k = "" + Y;
      }, stopTracking: function() {
        h._valueTracker = null, delete h[p];
      } };
    }
  }
  function Yt(h) {
    h._valueTracker || (h._valueTracker = at(h));
  }
  function Un(h) {
    if (!h) return !1;
    var p = h._valueTracker;
    if (!p) return !0;
    var x = p.getValue(), k = "";
    return h && (k = et(h) ? h.checked ? "true" : "false" : h.value), h = k, h !== x ? (p.setValue(h), !0) : !1;
  }
  function pt(h) {
    if (h = h || (typeof document < "u" ? document : void 0), typeof h > "u") return null;
    try {
      return h.activeElement || h.body;
    } catch {
      return h.body;
    }
  }
  function Ut(h, p) {
    var x = p.checked;
    return ke({}, p, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: x ?? h._wrapperState.initialChecked });
  }
  function jt(h, p) {
    var x = p.defaultValue == null ? "" : p.defaultValue, k = p.checked != null ? p.checked : p.defaultChecked;
    x = tt(p.value != null ? p.value : x), h._wrapperState = { initialChecked: k, initialValue: x, controlled: p.type === "checkbox" || p.type === "radio" ? p.checked != null : p.value != null };
  }
  function $t(h, p) {
    p = p.checked, p != null && M(h, "checked", p, !1);
  }
  function yn(h, p) {
    $t(h, p);
    var x = tt(p.value), k = p.type;
    if (x != null) k === "number" ? (x === 0 && h.value === "" || h.value != x) && (h.value = "" + x) : h.value !== "" + x && (h.value = "" + x);
    else if (k === "submit" || k === "reset") {
      h.removeAttribute("value");
      return;
    }
    p.hasOwnProperty("value") ? Nr(h, p.type, x) : p.hasOwnProperty("defaultValue") && Nr(h, p.type, tt(p.defaultValue)), p.checked == null && p.defaultChecked != null && (h.defaultChecked = !!p.defaultChecked);
  }
  function hi(h, p, x) {
    if (p.hasOwnProperty("value") || p.hasOwnProperty("defaultValue")) {
      var k = p.type;
      if (!(k !== "submit" && k !== "reset" || p.value !== void 0 && p.value !== null)) return;
      p = "" + h._wrapperState.initialValue, x || p === h.value || (h.value = p), h.defaultValue = p;
    }
    x = h.name, x !== "" && (h.name = ""), h.defaultChecked = !!h._wrapperState.initialChecked, x !== "" && (h.name = x);
  }
  function Nr(h, p, x) {
    (p !== "number" || pt(h.ownerDocument) !== h) && (x == null ? h.defaultValue = "" + h._wrapperState.initialValue : h.defaultValue !== "" + x && (h.defaultValue = "" + x));
  }
  var fi = Array.isArray;
  function oi(h, p, x, k) {
    if (h = h.options, p) {
      p = {};
      for (var L = 0; L < x.length; L++) p["$" + x[L]] = !0;
      for (x = 0; x < h.length; x++) L = p.hasOwnProperty("$" + h[x].value), h[x].selected !== L && (h[x].selected = L), L && k && (h[x].defaultSelected = !0);
    } else {
      for (x = "" + tt(x), p = null, L = 0; L < h.length; L++) {
        if (h[L].value === x) {
          h[L].selected = !0, k && (h[L].defaultSelected = !0);
          return;
        }
        p !== null || h[L].disabled || (p = h[L]);
      }
      p !== null && (p.selected = !0);
    }
  }
  function es(h, p) {
    if (p.dangerouslySetInnerHTML != null) throw Error(e(91));
    return ke({}, p, { value: void 0, defaultValue: void 0, children: "" + h._wrapperState.initialValue });
  }
  function Di(h, p) {
    var x = p.value;
    if (x == null) {
      if (x = p.children, p = p.defaultValue, x != null) {
        if (p != null) throw Error(e(92));
        if (fi(x)) {
          if (1 < x.length) throw Error(e(93));
          x = x[0];
        }
        p = x;
      }
      p == null && (p = ""), x = p;
    }
    h._wrapperState = { initialValue: tt(x) };
  }
  function Ss(h, p) {
    var x = tt(p.value), k = tt(p.defaultValue);
    x != null && (x = "" + x, x !== h.value && (h.value = x), p.defaultValue == null && h.defaultValue !== x && (h.defaultValue = x)), k != null && (h.defaultValue = "" + k);
  }
  function wi(h) {
    var p = h.textContent;
    p === h._wrapperState.initialValue && p !== "" && p !== null && (h.value = p);
  }
  function ts(h) {
    switch (h) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function On(h, p) {
    return h == null || h === "http://www.w3.org/1999/xhtml" ? ts(p) : h === "http://www.w3.org/2000/svg" && p === "foreignObject" ? "http://www.w3.org/1999/xhtml" : h;
  }
  var Kr, ns = function(h) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(p, x, k, L) {
      MSApp.execUnsafeLocalFunction(function() {
        return h(p, x, k, L);
      });
    } : h;
  }(function(h, p) {
    if (h.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in h) h.innerHTML = p;
    else {
      for (Kr = Kr || document.createElement("div"), Kr.innerHTML = "<svg>" + p.valueOf().toString() + "</svg>", p = Kr.firstChild; h.firstChild; ) h.removeChild(h.firstChild);
      for (; p.firstChild; ) h.appendChild(p.firstChild);
    }
  });
  function vr(h, p) {
    if (p) {
      var x = h.firstChild;
      if (x && x === h.lastChild && x.nodeType === 3) {
        x.nodeValue = p;
        return;
      }
    }
    h.textContent = p;
  }
  var Je = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, It = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Je).forEach(function(h) {
    It.forEach(function(p) {
      p = p + h.charAt(0).toUpperCase() + h.substring(1), Je[p] = Je[h];
    });
  });
  function hn(h, p, x) {
    return p == null || typeof p == "boolean" || p === "" ? "" : x || typeof p != "number" || p === 0 || Je.hasOwnProperty(h) && Je[h] ? ("" + p).trim() : p + "px";
  }
  function Bn(h, p) {
    h = h.style;
    for (var x in p) if (p.hasOwnProperty(x)) {
      var k = x.indexOf("--") === 0, L = hn(x, p[x], k);
      x === "float" && (x = "cssFloat"), k ? h.setProperty(x, L) : h[x] = L;
    }
  }
  var Ln = ke({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Yr(h, p) {
    if (p) {
      if (Ln[h] && (p.children != null || p.dangerouslySetInnerHTML != null)) throw Error(e(137, h));
      if (p.dangerouslySetInnerHTML != null) {
        if (p.children != null) throw Error(e(60));
        if (typeof p.dangerouslySetInnerHTML != "object" || !("__html" in p.dangerouslySetInnerHTML)) throw Error(e(61));
      }
      if (p.style != null && typeof p.style != "object") throw Error(e(62));
    }
  }
  function kr(h, p) {
    if (h.indexOf("-") === -1) return typeof p.is == "string";
    switch (h) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var rs = null;
  function wn(h) {
    return h = h.target || h.srcElement || window, h.correspondingUseElement && (h = h.correspondingUseElement), h.nodeType === 3 ? h.parentNode : h;
  }
  var is = null, Zn = null, Qn = null;
  function so(h) {
    if (h = Jm(h)) {
      if (typeof is != "function") throw Error(e(280));
      var p = h.stateNode;
      p && (p = zt(p), is(h.stateNode, h.type, p));
    }
  }
  function ss(h) {
    Zn ? Qn ? Qn.push(h) : Qn = [h] : Zn = h;
  }
  function Za() {
    if (Zn) {
      var h = Zn, p = Qn;
      if (Qn = Zn = null, so(h), p) for (h = 0; h < p.length; h++) so(p[h]);
    }
  }
  function Hl(h, p) {
    return h(p);
  }
  function Ec() {
  }
  var oo = !1;
  function _c(h, p, x) {
    if (oo) return h(p, x);
    oo = !0;
    try {
      return Hl(h, p, x);
    } finally {
      oo = !1, (Zn !== null || Qn !== null) && (Ec(), Za());
    }
  }
  function ao(h, p) {
    var x = h.stateNode;
    if (x === null) return null;
    var k = zt(x);
    if (k === null) return null;
    x = k[p];
    e: switch (p) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (k = !k.disabled) || (h = h.type, k = !(h === "button" || h === "input" || h === "select" || h === "textarea")), h = !k;
        break e;
      default:
        h = !1;
    }
    if (h) return null;
    if (x && typeof x != "function") throw Error(e(231, p, typeof x));
    return x;
  }
  var Qa = !1;
  if (l) try {
    var lo = {};
    Object.defineProperty(lo, "passive", { get: function() {
      Qa = !0;
    } }), window.addEventListener("test", lo, lo), window.removeEventListener("test", lo, lo);
  } catch {
    Qa = !1;
  }
  function xa(h, p, x, k, L, z, Y, ae, he) {
    var Ie = Array.prototype.slice.call(arguments, 3);
    try {
      p.apply(x, Ie);
    } catch (We) {
      this.onError(We);
    }
  }
  var os = !1, bs = null, as = !1, Ja = null, de = { onError: function(h) {
    os = !0, bs = h;
  } };
  function Be(h, p, x, k, L, z, Y, ae, he) {
    os = !1, bs = null, xa.apply(de, arguments);
  }
  function Ke(h, p, x, k, L, z, Y, ae, he) {
    if (Be.apply(this, arguments), os) {
      if (os) {
        var Ie = bs;
        os = !1, bs = null;
      } else throw Error(e(198));
      as || (as = !0, Ja = Ie);
    }
  }
  function Pt(h) {
    var p = h, x = h;
    if (h.alternate) for (; p.return; ) p = p.return;
    else {
      h = p;
      do
        p = h, p.flags & 4098 && (x = p.return), h = p.return;
      while (h);
    }
    return p.tag === 3 ? x : null;
  }
  function en(h) {
    if (h.tag === 13) {
      var p = h.memoizedState;
      if (p === null && (h = h.alternate, h !== null && (p = h.memoizedState)), p !== null) return p.dehydrated;
    }
    return null;
  }
  function bn(h) {
    if (Pt(h) !== h) throw Error(e(188));
  }
  function Bt(h) {
    var p = h.alternate;
    if (!p) {
      if (p = Pt(h), p === null) throw Error(e(188));
      return p !== h ? null : h;
    }
    for (var x = h, k = p; ; ) {
      var L = x.return;
      if (L === null) break;
      var z = L.alternate;
      if (z === null) {
        if (k = L.return, k !== null) {
          x = k;
          continue;
        }
        break;
      }
      if (L.child === z.child) {
        for (z = L.child; z; ) {
          if (z === x) return bn(L), h;
          if (z === k) return bn(L), p;
          z = z.sibling;
        }
        throw Error(e(188));
      }
      if (x.return !== k.return) x = L, k = z;
      else {
        for (var Y = !1, ae = L.child; ae; ) {
          if (ae === x) {
            Y = !0, x = L, k = z;
            break;
          }
          if (ae === k) {
            Y = !0, k = L, x = z;
            break;
          }
          ae = ae.sibling;
        }
        if (!Y) {
          for (ae = z.child; ae; ) {
            if (ae === x) {
              Y = !0, x = z, k = L;
              break;
            }
            if (ae === k) {
              Y = !0, k = z, x = L;
              break;
            }
            ae = ae.sibling;
          }
          if (!Y) throw Error(e(189));
        }
      }
      if (x.alternate !== k) throw Error(e(190));
    }
    if (x.tag !== 3) throw Error(e(188));
    return x.stateNode.current === x ? h : p;
  }
  function fn(h) {
    return h = Bt(h), h !== null ? pi(h) : null;
  }
  function pi(h) {
    if (h.tag === 5 || h.tag === 6) return h;
    for (h = h.child; h !== null; ) {
      var p = pi(h);
      if (p !== null) return p;
      h = h.sibling;
    }
    return null;
  }
  var fr = t.unstable_scheduleCallback, Yn = t.unstable_cancelCallback, ls = t.unstable_shouldYield, el = t.unstable_requestPaint, Hn = t.unstable_now, Oi = t.unstable_getCurrentPriorityLevel, xs = t.unstable_ImmediatePriority, on = t.unstable_UserBlockingPriority, $o = t.unstable_NormalPriority, Tc = t.unstable_LowPriority, co = t.unstable_IdlePriority, Pc = null, Us = null;
  function Nh(h) {
    if (Us && typeof Us.onCommitFiberRoot == "function") try {
      Us.onCommitFiberRoot(Pc, h, void 0, (h.current.flags & 128) === 128);
    } catch {
    }
  }
  var ws = Math.clz32 ? Math.clz32 : du, Fh = Math.log, $h = Math.LN2;
  function du(h) {
    return h >>>= 0, h === 0 ? 32 : 31 - (Fh(h) / $h | 0) | 0;
  }
  var md = 64, zo = 4194304;
  function Uo(h) {
    switch (h & -h) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return h & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return h;
    }
  }
  function cs(h, p) {
    var x = h.pendingLanes;
    if (x === 0) return 0;
    var k = 0, L = h.suspendedLanes, z = h.pingedLanes, Y = x & 268435455;
    if (Y !== 0) {
      var ae = Y & ~L;
      ae !== 0 ? k = Uo(ae) : (z &= Y, z !== 0 && (k = Uo(z)));
    } else Y = x & ~L, Y !== 0 ? k = Uo(Y) : z !== 0 && (k = Uo(z));
    if (k === 0) return 0;
    if (p !== 0 && p !== k && !(p & L) && (L = k & -k, z = p & -p, L >= z || L === 16 && (z & 4194240) !== 0)) return p;
    if (k & 4 && (k |= x & 16), p = h.entangledLanes, p !== 0) for (h = h.entanglements, p &= k; 0 < p; ) x = 31 - ws(p), L = 1 << x, k |= h[x], p &= ~L;
    return k;
  }
  function Ac(h, p) {
    switch (h) {
      case 1:
      case 2:
      case 4:
        return p + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return p + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function kc(h, p) {
    for (var x = h.suspendedLanes, k = h.pingedLanes, L = h.expirationTimes, z = h.pendingLanes; 0 < z; ) {
      var Y = 31 - ws(z), ae = 1 << Y, he = L[Y];
      he === -1 ? (!(ae & x) || ae & k) && (L[Y] = Ac(ae, p)) : he <= p && (h.expiredLanes |= ae), z &= ~ae;
    }
  }
  function Ic(h) {
    return h = h.pendingLanes & -1073741825, h !== 0 ? h : h & 1073741824 ? 1073741824 : 0;
  }
  function vd() {
    var h = md;
    return md <<= 1, !(md & 4194240) && (md = 64), h;
  }
  function hu(h) {
    for (var p = [], x = 0; 31 > x; x++) p.push(h);
    return p;
  }
  function Vl(h, p, x) {
    h.pendingLanes |= p, p !== 536870912 && (h.suspendedLanes = 0, h.pingedLanes = 0), h = h.eventTimes, p = 31 - ws(p), h[p] = x;
  }
  function $m(h, p) {
    var x = h.pendingLanes & ~p;
    h.pendingLanes = p, h.suspendedLanes = 0, h.pingedLanes = 0, h.expiredLanes &= p, h.mutableReadLanes &= p, h.entangledLanes &= p, p = h.entanglements;
    var k = h.eventTimes;
    for (h = h.expirationTimes; 0 < x; ) {
      var L = 31 - ws(x), z = 1 << L;
      p[L] = 0, k[L] = -1, h[L] = -1, x &= ~z;
    }
  }
  function wa(h, p) {
    var x = h.entangledLanes |= p;
    for (h = h.entanglements; x; ) {
      var k = 31 - ws(x), L = 1 << k;
      L & p | h[k] & p && (h[k] |= p), x &= ~L;
    }
  }
  var Cn = 0;
  function Ca(h) {
    return h &= -h, 1 < h ? 4 < h ? h & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var fu, yd, ln, Sd, bd, tn = !1, pu = [], Fr = null, gi = null, us = null, Rc = /* @__PURE__ */ new Map(), Cr = /* @__PURE__ */ new Map(), Jn = [], xd = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Bs(h, p) {
    switch (h) {
      case "focusin":
      case "focusout":
        Fr = null;
        break;
      case "dragenter":
      case "dragleave":
        gi = null;
        break;
      case "mouseover":
      case "mouseout":
        us = null;
        break;
      case "pointerover":
      case "pointerout":
        Rc.delete(p.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Cr.delete(p.pointerId);
    }
  }
  function Ci(h, p, x, k, L, z) {
    return h === null || h.nativeEvent !== z ? (h = { blockedOn: p, domEventName: x, eventSystemFlags: k, nativeEvent: z, targetContainers: [L] }, p !== null && (p = Jm(p), p !== null && yd(p)), h) : (h.eventSystemFlags |= k, p = h.targetContainers, L !== null && p.indexOf(L) === -1 && p.push(L), h);
  }
  function Ea(h, p, x, k, L) {
    switch (p) {
      case "focusin":
        return Fr = Ci(Fr, h, p, x, k, L), !0;
      case "dragenter":
        return gi = Ci(gi, h, p, x, k, L), !0;
      case "mouseover":
        return us = Ci(us, h, p, x, k, L), !0;
      case "pointerover":
        var z = L.pointerId;
        return Rc.set(z, Ci(Rc.get(z) || null, h, p, x, k, L)), !0;
      case "gotpointercapture":
        return z = L.pointerId, Cr.set(z, Ci(Cr.get(z) || null, h, p, x, k, L)), !0;
    }
    return !1;
  }
  function zh(h) {
    var p = nl(h.target);
    if (p !== null) {
      var x = Pt(p);
      if (x !== null) {
        if (p = x.tag, p === 13) {
          if (p = en(x), p !== null) {
            h.blockedOn = p, bd(h.priority, function() {
              ln(x);
            });
            return;
          }
        } else if (p === 3 && x.stateNode.current.memoizedState.isDehydrated) {
          h.blockedOn = x.tag === 3 ? x.stateNode.containerInfo : null;
          return;
        }
      }
    }
    h.blockedOn = null;
  }
  function uo(h) {
    if (h.blockedOn !== null) return !1;
    for (var p = h.targetContainers; 0 < p.length; ) {
      var x = pr(h.domEventName, h.eventSystemFlags, p[0], h.nativeEvent);
      if (x === null) {
        x = h.nativeEvent;
        var k = new x.constructor(x.type, x);
        rs = k, x.target.dispatchEvent(k), rs = null;
      } else return p = Jm(x), p !== null && yd(p), h.blockedOn = x, !1;
      p.shift();
    }
    return !0;
  }
  function Wl(h, p, x) {
    uo(h) && x.delete(p);
  }
  function Dp() {
    tn = !1, Fr !== null && uo(Fr) && (Fr = null), gi !== null && uo(gi) && (gi = null), us !== null && uo(us) && (us = null), Rc.forEach(Wl), Cr.forEach(Wl);
  }
  function Bo(h, p) {
    h.blockedOn === p && (h.blockedOn = null, tn || (tn = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Dp)));
  }
  function Mc(h) {
    function p(L) {
      return Bo(L, h);
    }
    if (0 < pu.length) {
      Bo(pu[0], h);
      for (var x = 1; x < pu.length; x++) {
        var k = pu[x];
        k.blockedOn === h && (k.blockedOn = null);
      }
    }
    for (Fr !== null && Bo(Fr, h), gi !== null && Bo(gi, h), us !== null && Bo(us, h), Rc.forEach(p), Cr.forEach(p), x = 0; x < Jn.length; x++) k = Jn[x], k.blockedOn === h && (k.blockedOn = null);
    for (; 0 < Jn.length && (x = Jn[0], x.blockedOn === null); ) zh(x), x.blockedOn === null && Jn.shift();
  }
  var se = j.ReactCurrentBatchConfig, ve = !0;
  function $e(h, p, x, k) {
    var L = Cn, z = se.transition;
    se.transition = null;
    try {
      Cn = 1, Vn(h, p, x, k);
    } finally {
      Cn = L, se.transition = z;
    }
  }
  function st(h, p, x, k) {
    var L = Cn, z = se.transition;
    se.transition = null;
    try {
      Cn = 4, Vn(h, p, x, k);
    } finally {
      Cn = L, se.transition = z;
    }
  }
  function Vn(h, p, x, k) {
    if (ve) {
      var L = pr(h, p, x, k);
      if (L === null) LS(h, p, k, Zt, x), Bs(h, k);
      else if (Ea(L, h, p, x, k)) k.stopPropagation();
      else if (Bs(h, k), p & 4 && -1 < xd.indexOf(h)) {
        for (; L !== null; ) {
          var z = Jm(L);
          if (z !== null && fu(z), z = pr(h, p, x, k), z === null && LS(h, p, k, Zt, x), z === L) break;
          L = z;
        }
        L !== null && k.stopPropagation();
      } else LS(h, p, k, null, x);
    }
  }
  var Zt = null;
  function pr(h, p, x, k) {
    if (Zt = null, h = wn(k), h = nl(h), h !== null) if (p = Pt(h), p === null) h = null;
    else if (x = p.tag, x === 13) {
      if (h = en(p), h !== null) return h;
      h = null;
    } else if (x === 3) {
      if (p.stateNode.current.memoizedState.isDehydrated) return p.tag === 3 ? p.stateNode.containerInfo : null;
      h = null;
    } else p !== h && (h = null);
    return Zt = h, null;
  }
  function Xr(h) {
    switch (h) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Oi()) {
          case xs:
            return 1;
          case on:
            return 4;
          case $o:
          case Tc:
            return 16;
          case co:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var gr = null, W = null, le = null;
  function Ce() {
    if (le) return le;
    var h, p = W, x = p.length, k, L = "value" in gr ? gr.value : gr.textContent, z = L.length;
    for (h = 0; h < x && p[h] === L[h]; h++) ;
    var Y = x - h;
    for (k = 1; k <= Y && p[x - k] === L[z - k]; k++) ;
    return le = L.slice(h, 1 < k ? 1 - k : void 0);
  }
  function Pe(h) {
    var p = h.keyCode;
    return "charCode" in h ? (h = h.charCode, h === 0 && p === 13 && (h = 13)) : h = p, h === 10 && (h = 13), 32 <= h || h === 13 ? h : 0;
  }
  function He() {
    return !0;
  }
  function yt() {
    return !1;
  }
  function Qe(h) {
    function p(x, k, L, z, Y) {
      this._reactName = x, this._targetInst = L, this.type = k, this.nativeEvent = z, this.target = Y, this.currentTarget = null;
      for (var ae in h) h.hasOwnProperty(ae) && (x = h[ae], this[ae] = x ? x(z) : z[ae]);
      return this.isDefaultPrevented = (z.defaultPrevented != null ? z.defaultPrevented : z.returnValue === !1) ? He : yt, this.isPropagationStopped = yt, this;
    }
    return ke(p.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var x = this.nativeEvent;
      x && (x.preventDefault ? x.preventDefault() : typeof x.returnValue != "unknown" && (x.returnValue = !1), this.isDefaultPrevented = He);
    }, stopPropagation: function() {
      var x = this.nativeEvent;
      x && (x.stopPropagation ? x.stopPropagation() : typeof x.cancelBubble != "unknown" && (x.cancelBubble = !0), this.isPropagationStopped = He);
    }, persist: function() {
    }, isPersistent: He }), p;
  }
  var Ct = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(h) {
    return h.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, sn = Qe(Ct), En = ke({}, Ct, { view: 0, detail: 0 }), er = Qe(En), Wn, Er, Ir, Pn = ke({}, En, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Cw, button: 0, buttons: 0, relatedTarget: function(h) {
    return h.relatedTarget === void 0 ? h.fromElement === h.srcElement ? h.toElement : h.fromElement : h.relatedTarget;
  }, movementX: function(h) {
    return "movementX" in h ? h.movementX : (h !== Ir && (Ir && h.type === "mousemove" ? (Wn = h.screenX - Ir.screenX, Er = h.screenY - Ir.screenY) : Er = Wn = 0, Ir = h), Wn);
  }, movementY: function(h) {
    return "movementY" in h ? h.movementY : Er;
  } }), gu = Qe(Pn), Op = ke({}, Pn, { dataTransfer: 0 }), zm = Qe(Op), Sw = ke({}, En, { relatedTarget: 0 }), Gl = Qe(Sw), Um = ke({}, Ct, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Bm = Qe(Um), bw = ke({}, Ct, { clipboardData: function(h) {
    return "clipboardData" in h ? h.clipboardData : window.clipboardData;
  } }), AD = Qe(bw), kD = ke({}, Ct, { data: 0 }), xw = Qe(kD), ww = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, lP = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, cP = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function uP(h) {
    var p = this.nativeEvent;
    return p.getModifierState ? p.getModifierState(h) : (h = cP[h]) ? !!p[h] : !1;
  }
  function Cw() {
    return uP;
  }
  var mu = ke({}, En, { key: function(h) {
    if (h.key) {
      var p = ww[h.key] || h.key;
      if (p !== "Unidentified") return p;
    }
    return h.type === "keypress" ? (h = Pe(h), h === 13 ? "Enter" : String.fromCharCode(h)) : h.type === "keydown" || h.type === "keyup" ? lP[h.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Cw, charCode: function(h) {
    return h.type === "keypress" ? Pe(h) : 0;
  }, keyCode: function(h) {
    return h.type === "keydown" || h.type === "keyup" ? h.keyCode : 0;
  }, which: function(h) {
    return h.type === "keypress" ? Pe(h) : h.type === "keydown" || h.type === "keyup" ? h.keyCode : 0;
  } }), ID = Qe(mu), Ew = ke({}, Pn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), PS = Qe(Ew), _w = ke({}, En, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Cw }), RD = Qe(_w), AS = ke({}, Ct, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), dP = Qe(AS), Ho = ke({}, Pn, {
    deltaX: function(h) {
      return "deltaX" in h ? h.deltaX : "wheelDeltaX" in h ? -h.wheelDeltaX : 0;
    },
    deltaY: function(h) {
      return "deltaY" in h ? h.deltaY : "wheelDeltaY" in h ? -h.wheelDeltaY : "wheelDelta" in h ? -h.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), vu = Qe(Ho), Li = [9, 13, 27, 32], Kl = l && "CompositionEvent" in window, Uh = null;
  l && "documentMode" in document && (Uh = document.documentMode);
  var kS = l && "TextEvent" in window && !Uh, hP = l && (!Kl || Uh && 8 < Uh && 11 >= Uh), Lp = " ", fP = !1;
  function pP(h, p) {
    switch (h) {
      case "keyup":
        return Li.indexOf(p.keyCode) !== -1;
      case "keydown":
        return p.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function IS(h) {
    return h = h.detail, typeof h == "object" && "data" in h ? h.data : null;
  }
  var jp = !1;
  function MD(h, p) {
    switch (h) {
      case "compositionend":
        return IS(p);
      case "keypress":
        return p.which !== 32 ? null : (fP = !0, Lp);
      case "textInput":
        return h = p.data, h === Lp && fP ? null : h;
      default:
        return null;
    }
  }
  function DD(h, p) {
    if (jp) return h === "compositionend" || !Kl && pP(h, p) ? (h = Ce(), le = W = gr = null, jp = !1, h) : null;
    switch (h) {
      case "paste":
        return null;
      case "keypress":
        if (!(p.ctrlKey || p.altKey || p.metaKey) || p.ctrlKey && p.altKey) {
          if (p.char && 1 < p.char.length) return p.char;
          if (p.which) return String.fromCharCode(p.which);
        }
        return null;
      case "compositionend":
        return hP && p.locale !== "ko" ? null : p.data;
      default:
        return null;
    }
  }
  var gP = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function mP(h) {
    var p = h && h.nodeName && h.nodeName.toLowerCase();
    return p === "input" ? !!gP[h.type] : p === "textarea";
  }
  function vP(h, p, x, k) {
    ss(k), p = qm(p, "onChange"), 0 < p.length && (x = new sn("onChange", "change", null, x, k), h.push({ event: x, listeners: p }));
  }
  var Hm = null, Np = null;
  function Fp(h) {
    OS(h, 0);
  }
  function $p(h) {
    var p = Up(h);
    if (Un(p)) return h;
  }
  function yP(h, p) {
    if (h === "change") return p;
  }
  var Tw = !1;
  if (l) {
    var Pw;
    if (l) {
      var Aw = "oninput" in document;
      if (!Aw) {
        var SP = document.createElement("div");
        SP.setAttribute("oninput", "return;"), Aw = typeof SP.oninput == "function";
      }
      Pw = Aw;
    } else Pw = !1;
    Tw = Pw && (!document.documentMode || 9 < document.documentMode);
  }
  function bP() {
    Hm && (Hm.detachEvent("onpropertychange", xP), Np = Hm = null);
  }
  function xP(h) {
    if (h.propertyName === "value" && $p(Np)) {
      var p = [];
      vP(p, Np, h, wn(h)), _c(Fp, p);
    }
  }
  function OD(h, p, x) {
    h === "focusin" ? (bP(), Hm = p, Np = x, Hm.attachEvent("onpropertychange", xP)) : h === "focusout" && bP();
  }
  function LD(h) {
    if (h === "selectionchange" || h === "keyup" || h === "keydown") return $p(Np);
  }
  function jD(h, p) {
    if (h === "click") return $p(p);
  }
  function wP(h, p) {
    if (h === "input" || h === "change") return $p(p);
  }
  function ND(h, p) {
    return h === p && (h !== 0 || 1 / h === 1 / p) || h !== h && p !== p;
  }
  var tl = typeof Object.is == "function" ? Object.is : ND;
  function Vm(h, p) {
    if (tl(h, p)) return !0;
    if (typeof h != "object" || h === null || typeof p != "object" || p === null) return !1;
    var x = Object.keys(h), k = Object.keys(p);
    if (x.length !== k.length) return !1;
    for (k = 0; k < x.length; k++) {
      var L = x[k];
      if (!u.call(p, L) || !tl(h[L], p[L])) return !1;
    }
    return !0;
  }
  function CP(h) {
    for (; h && h.firstChild; ) h = h.firstChild;
    return h;
  }
  function EP(h, p) {
    var x = CP(h);
    h = 0;
    for (var k; x; ) {
      if (x.nodeType === 3) {
        if (k = h + x.textContent.length, h <= p && k >= p) return { node: x, offset: p - h };
        h = k;
      }
      e: {
        for (; x; ) {
          if (x.nextSibling) {
            x = x.nextSibling;
            break e;
          }
          x = x.parentNode;
        }
        x = void 0;
      }
      x = CP(x);
    }
  }
  function _P(h, p) {
    return h && p ? h === p ? !0 : h && h.nodeType === 3 ? !1 : p && p.nodeType === 3 ? _P(h, p.parentNode) : "contains" in h ? h.contains(p) : h.compareDocumentPosition ? !!(h.compareDocumentPosition(p) & 16) : !1 : !1;
  }
  function RS() {
    for (var h = window, p = pt(); p instanceof h.HTMLIFrameElement; ) {
      try {
        var x = typeof p.contentWindow.location.href == "string";
      } catch {
        x = !1;
      }
      if (x) h = p.contentWindow;
      else break;
      p = pt(h.document);
    }
    return p;
  }
  function yu(h) {
    var p = h && h.nodeName && h.nodeName.toLowerCase();
    return p && (p === "input" && (h.type === "text" || h.type === "search" || h.type === "tel" || h.type === "url" || h.type === "password") || p === "textarea" || h.contentEditable === "true");
  }
  function MS(h) {
    var p = RS(), x = h.focusedElem, k = h.selectionRange;
    if (p !== x && x && x.ownerDocument && _P(x.ownerDocument.documentElement, x)) {
      if (k !== null && yu(x)) {
        if (p = k.start, h = k.end, h === void 0 && (h = p), "selectionStart" in x) x.selectionStart = p, x.selectionEnd = Math.min(h, x.value.length);
        else if (h = (p = x.ownerDocument || document) && p.defaultView || window, h.getSelection) {
          h = h.getSelection();
          var L = x.textContent.length, z = Math.min(k.start, L);
          k = k.end === void 0 ? z : Math.min(k.end, L), !h.extend && z > k && (L = k, k = z, z = L), L = EP(x, z);
          var Y = EP(
            x,
            k
          );
          L && Y && (h.rangeCount !== 1 || h.anchorNode !== L.node || h.anchorOffset !== L.offset || h.focusNode !== Y.node || h.focusOffset !== Y.offset) && (p = p.createRange(), p.setStart(L.node, L.offset), h.removeAllRanges(), z > k ? (h.addRange(p), h.extend(Y.node, Y.offset)) : (p.setEnd(Y.node, Y.offset), h.addRange(p)));
        }
      }
      for (p = [], h = x; h = h.parentNode; ) h.nodeType === 1 && p.push({ element: h, left: h.scrollLeft, top: h.scrollTop });
      for (typeof x.focus == "function" && x.focus(), x = 0; x < p.length; x++) h = p[x], h.element.scrollLeft = h.left, h.element.scrollTop = h.top;
    }
  }
  var TP = l && "documentMode" in document && 11 >= document.documentMode, Yl = null, kw = null, Wm = null, Iw = !1;
  function PP(h, p, x) {
    var k = x.window === x ? x.document : x.nodeType === 9 ? x : x.ownerDocument;
    Iw || Yl == null || Yl !== pt(k) || (k = Yl, "selectionStart" in k && yu(k) ? k = { start: k.selectionStart, end: k.selectionEnd } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = { anchorNode: k.anchorNode, anchorOffset: k.anchorOffset, focusNode: k.focusNode, focusOffset: k.focusOffset }), Wm && Vm(Wm, k) || (Wm = k, k = qm(kw, "onSelect"), 0 < k.length && (p = new sn("onSelect", "select", null, p, x), h.push({ event: p, listeners: k }), p.target = Yl)));
  }
  function DS(h, p) {
    var x = {};
    return x[h.toLowerCase()] = p.toLowerCase(), x["Webkit" + h] = "webkit" + p, x["Moz" + h] = "moz" + p, x;
  }
  var Bh = { animationend: DS("Animation", "AnimationEnd"), animationiteration: DS("Animation", "AnimationIteration"), animationstart: DS("Animation", "AnimationStart"), transitionend: DS("Transition", "TransitionEnd") }, Rw = {}, Mw = {};
  l && (Mw = document.createElement("div").style, "AnimationEvent" in window || (delete Bh.animationend.animation, delete Bh.animationiteration.animation, delete Bh.animationstart.animation), "TransitionEvent" in window || delete Bh.transitionend.transition);
  function ds(h) {
    if (Rw[h]) return Rw[h];
    if (!Bh[h]) return h;
    var p = Bh[h], x;
    for (x in p) if (p.hasOwnProperty(x) && x in Mw) return Rw[h] = p[x];
    return h;
  }
  var Dw = ds("animationend"), AP = ds("animationiteration"), kP = ds("animationstart"), IP = ds("transitionend"), RP = /* @__PURE__ */ new Map(), MP = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Su(h, p) {
    RP.set(h, p), s(p, [h]);
  }
  for (var Gm = 0; Gm < MP.length; Gm++) {
    var Hh = MP[Gm], FD = Hh.toLowerCase(), Km = Hh[0].toUpperCase() + Hh.slice(1);
    Su(FD, "on" + Km);
  }
  Su(Dw, "onAnimationEnd"), Su(AP, "onAnimationIteration"), Su(kP, "onAnimationStart"), Su("dblclick", "onDoubleClick"), Su("focusin", "onFocus"), Su("focusout", "onBlur"), Su(IP, "onTransitionEnd"), o("onMouseEnter", ["mouseout", "mouseover"]), o("onMouseLeave", ["mouseout", "mouseover"]), o("onPointerEnter", ["pointerout", "pointerover"]), o("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Ym = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), $D = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ym));
  function DP(h, p, x) {
    var k = h.type || "unknown-event";
    h.currentTarget = x, Ke(k, p, void 0, h), h.currentTarget = null;
  }
  function OS(h, p) {
    p = (p & 4) !== 0;
    for (var x = 0; x < h.length; x++) {
      var k = h[x], L = k.event;
      k = k.listeners;
      e: {
        var z = void 0;
        if (p) for (var Y = k.length - 1; 0 <= Y; Y--) {
          var ae = k[Y], he = ae.instance, Ie = ae.currentTarget;
          if (ae = ae.listener, he !== z && L.isPropagationStopped()) break e;
          DP(L, ae, Ie), z = he;
        }
        else for (Y = 0; Y < k.length; Y++) {
          if (ae = k[Y], he = ae.instance, Ie = ae.currentTarget, ae = ae.listener, he !== z && L.isPropagationStopped()) break e;
          DP(L, ae, Ie), z = he;
        }
      }
    }
    if (as) throw h = Ja, as = !1, Ja = null, h;
  }
  function _r(h, p) {
    var x = p[zw];
    x === void 0 && (x = p[zw] = /* @__PURE__ */ new Set());
    var k = h + "__bubble";
    x.has(k) || (OP(p, h, 2, !1), x.add(k));
  }
  function wd(h, p, x) {
    var k = 0;
    p && (k |= 4), OP(x, h, k, p);
  }
  var bu = "_reactListening" + Math.random().toString(36).slice(2);
  function zp(h) {
    if (!h[bu]) {
      h[bu] = !0, r.forEach(function(x) {
        x !== "selectionchange" && ($D.has(x) || wd(x, !1, h), wd(x, !0, h));
      });
      var p = h.nodeType === 9 ? h : h.ownerDocument;
      p === null || p[bu] || (p[bu] = !0, wd("selectionchange", !1, p));
    }
  }
  function OP(h, p, x, k) {
    switch (Xr(p)) {
      case 1:
        var L = $e;
        break;
      case 4:
        L = st;
        break;
      default:
        L = Vn;
    }
    x = L.bind(null, p, x, h), L = void 0, !Qa || p !== "touchstart" && p !== "touchmove" && p !== "wheel" || (L = !0), k ? L !== void 0 ? h.addEventListener(p, x, { capture: !0, passive: L }) : h.addEventListener(p, x, !0) : L !== void 0 ? h.addEventListener(p, x, { passive: L }) : h.addEventListener(p, x, !1);
  }
  function LS(h, p, x, k, L) {
    var z = k;
    if (!(p & 1) && !(p & 2) && k !== null) e: for (; ; ) {
      if (k === null) return;
      var Y = k.tag;
      if (Y === 3 || Y === 4) {
        var ae = k.stateNode.containerInfo;
        if (ae === L || ae.nodeType === 8 && ae.parentNode === L) break;
        if (Y === 4) for (Y = k.return; Y !== null; ) {
          var he = Y.tag;
          if ((he === 3 || he === 4) && (he = Y.stateNode.containerInfo, he === L || he.nodeType === 8 && he.parentNode === L)) return;
          Y = Y.return;
        }
        for (; ae !== null; ) {
          if (Y = nl(ae), Y === null) return;
          if (he = Y.tag, he === 5 || he === 6) {
            k = z = Y;
            continue e;
          }
          ae = ae.parentNode;
        }
      }
      k = k.return;
    }
    _c(function() {
      var Ie = z, We = wn(x), Ge = [];
      e: {
        var Ve = RP.get(h);
        if (Ve !== void 0) {
          var dt = sn, St = h;
          switch (h) {
            case "keypress":
              if (Pe(x) === 0) break e;
            case "keydown":
            case "keyup":
              dt = ID;
              break;
            case "focusin":
              St = "focus", dt = Gl;
              break;
            case "focusout":
              St = "blur", dt = Gl;
              break;
            case "beforeblur":
            case "afterblur":
              dt = Gl;
              break;
            case "click":
              if (x.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              dt = gu;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              dt = zm;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              dt = RD;
              break;
            case Dw:
            case AP:
            case kP:
              dt = Bm;
              break;
            case IP:
              dt = dP;
              break;
            case "scroll":
              dt = er;
              break;
            case "wheel":
              dt = vu;
              break;
            case "copy":
            case "cut":
            case "paste":
              dt = AD;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              dt = PS;
          }
          var _t = (p & 4) !== 0, Ti = !_t && h === "scroll", xe = _t ? Ve !== null ? Ve + "Capture" : null : Ve;
          _t = [];
          for (var ge = Ie, Te; ge !== null; ) {
            Te = ge;
            var qe = Te.stateNode;
            if (Te.tag === 5 && qe !== null && (Te = qe, xe !== null && (qe = ao(ge, xe), qe != null && _t.push(Xm(ge, qe, Te)))), Ti) break;
            ge = ge.return;
          }
          0 < _t.length && (Ve = new dt(Ve, St, null, x, We), Ge.push({ event: Ve, listeners: _t }));
        }
      }
      if (!(p & 7)) {
        e: {
          if (Ve = h === "mouseover" || h === "pointerover", dt = h === "mouseout" || h === "pointerout", Ve && x !== rs && (St = x.relatedTarget || x.fromElement) && (nl(St) || St[xu])) break e;
          if ((dt || Ve) && (Ve = We.window === We ? We : (Ve = We.ownerDocument) ? Ve.defaultView || Ve.parentWindow : window, dt ? (St = x.relatedTarget || x.toElement, dt = Ie, St = St ? nl(St) : null, St !== null && (Ti = Pt(St), St !== Ti || St.tag !== 5 && St.tag !== 6) && (St = null)) : (dt = null, St = Ie), dt !== St)) {
            if (_t = gu, qe = "onMouseLeave", xe = "onMouseEnter", ge = "mouse", (h === "pointerout" || h === "pointerover") && (_t = PS, qe = "onPointerLeave", xe = "onPointerEnter", ge = "pointer"), Ti = dt == null ? Ve : Up(dt), Te = St == null ? Ve : Up(St), Ve = new _t(qe, ge + "leave", dt, x, We), Ve.target = Ti, Ve.relatedTarget = Te, qe = null, nl(We) === Ie && (_t = new _t(xe, ge + "enter", St, x, We), _t.target = Te, _t.relatedTarget = Ti, qe = _t), Ti = qe, dt && St) t: {
              for (_t = dt, xe = St, ge = 0, Te = _t; Te; Te = Vh(Te)) ge++;
              for (Te = 0, qe = xe; qe; qe = Vh(qe)) Te++;
              for (; 0 < ge - Te; ) _t = Vh(_t), ge--;
              for (; 0 < Te - ge; ) xe = Vh(xe), Te--;
              for (; ge--; ) {
                if (_t === xe || xe !== null && _t === xe.alternate) break t;
                _t = Vh(_t), xe = Vh(xe);
              }
              _t = null;
            }
            else _t = null;
            dt !== null && Ow(Ge, Ve, dt, _t, !1), St !== null && Ti !== null && Ow(Ge, Ti, St, _t, !0);
          }
        }
        e: {
          if (Ve = Ie ? Up(Ie) : window, dt = Ve.nodeName && Ve.nodeName.toLowerCase(), dt === "select" || dt === "input" && Ve.type === "file") var Mt = yP;
          else if (mP(Ve)) if (Tw) Mt = wP;
          else {
            Mt = LD;
            var Kt = OD;
          }
          else (dt = Ve.nodeName) && dt.toLowerCase() === "input" && (Ve.type === "checkbox" || Ve.type === "radio") && (Mt = jD);
          if (Mt && (Mt = Mt(h, Ie))) {
            vP(Ge, Mt, x, We);
            break e;
          }
          Kt && Kt(h, Ve, Ie), h === "focusout" && (Kt = Ve._wrapperState) && Kt.controlled && Ve.type === "number" && Nr(Ve, "number", Ve.value);
        }
        switch (Kt = Ie ? Up(Ie) : window, h) {
          case "focusin":
            (mP(Kt) || Kt.contentEditable === "true") && (Yl = Kt, kw = Ie, Wm = null);
            break;
          case "focusout":
            Wm = kw = Yl = null;
            break;
          case "mousedown":
            Iw = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Iw = !1, PP(Ge, x, We);
            break;
          case "selectionchange":
            if (TP) break;
          case "keydown":
          case "keyup":
            PP(Ge, x, We);
        }
        var bt;
        if (Kl) e: {
          switch (h) {
            case "compositionstart":
              var Xt = "onCompositionStart";
              break e;
            case "compositionend":
              Xt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              Xt = "onCompositionUpdate";
              break e;
          }
          Xt = void 0;
        }
        else jp ? pP(h, x) && (Xt = "onCompositionEnd") : h === "keydown" && x.keyCode === 229 && (Xt = "onCompositionStart");
        Xt && (hP && x.locale !== "ko" && (jp || Xt !== "onCompositionStart" ? Xt === "onCompositionEnd" && jp && (bt = Ce()) : (gr = We, W = "value" in gr ? gr.value : gr.textContent, jp = !0)), Kt = qm(Ie, Xt), 0 < Kt.length && (Xt = new xw(Xt, h, null, x, We), Ge.push({ event: Xt, listeners: Kt }), bt ? Xt.data = bt : (bt = IS(x), bt !== null && (Xt.data = bt)))), (bt = kS ? MD(h, x) : DD(h, x)) && (Ie = qm(Ie, "onBeforeInput"), 0 < Ie.length && (We = new xw("onBeforeInput", "beforeinput", null, x, We), Ge.push({ event: We, listeners: Ie }), We.data = bt));
      }
      OS(Ge, p);
    });
  }
  function Xm(h, p, x) {
    return { instance: h, listener: p, currentTarget: x };
  }
  function qm(h, p) {
    for (var x = p + "Capture", k = []; h !== null; ) {
      var L = h, z = L.stateNode;
      L.tag === 5 && z !== null && (L = z, z = ao(h, x), z != null && k.unshift(Xm(h, z, L)), z = ao(h, p), z != null && k.push(Xm(h, z, L))), h = h.return;
    }
    return k;
  }
  function Vh(h) {
    if (h === null) return null;
    do
      h = h.return;
    while (h && h.tag !== 5);
    return h || null;
  }
  function Ow(h, p, x, k, L) {
    for (var z = p._reactName, Y = []; x !== null && x !== k; ) {
      var ae = x, he = ae.alternate, Ie = ae.stateNode;
      if (he !== null && he === k) break;
      ae.tag === 5 && Ie !== null && (ae = Ie, L ? (he = ao(x, z), he != null && Y.unshift(Xm(x, he, ae))) : L || (he = ao(x, z), he != null && Y.push(Xm(x, he, ae)))), x = x.return;
    }
    Y.length !== 0 && h.push({ event: p, listeners: Y });
  }
  var Lw = /\r\n?/g, zD = /\u0000|\uFFFD/g;
  function jw(h) {
    return (typeof h == "string" ? h : "" + h).replace(Lw, `
`).replace(zD, "");
  }
  function jS(h, p, x) {
    if (p = jw(p), jw(h) !== p && x) throw Error(e(425));
  }
  function NS() {
  }
  var Nw = null, Wh = null;
  function Zm(h, p) {
    return h === "textarea" || h === "noscript" || typeof p.children == "string" || typeof p.children == "number" || typeof p.dangerouslySetInnerHTML == "object" && p.dangerouslySetInnerHTML !== null && p.dangerouslySetInnerHTML.__html != null;
  }
  var Gh = typeof setTimeout == "function" ? setTimeout : void 0, LP = typeof clearTimeout == "function" ? clearTimeout : void 0, Fw = typeof Promise == "function" ? Promise : void 0, $w = typeof queueMicrotask == "function" ? queueMicrotask : typeof Fw < "u" ? function(h) {
    return Fw.resolve(null).then(h).catch(UD);
  } : Gh;
  function UD(h) {
    setTimeout(function() {
      throw h;
    });
  }
  function Cd(h, p) {
    var x = p, k = 0;
    do {
      var L = x.nextSibling;
      if (h.removeChild(x), L && L.nodeType === 8) if (x = L.data, x === "/$") {
        if (k === 0) {
          h.removeChild(L), Mc(p);
          return;
        }
        k--;
      } else x !== "$" && x !== "$?" && x !== "$!" || k++;
      x = L;
    } while (x);
    Mc(p);
  }
  function Xl(h) {
    for (; h != null; h = h.nextSibling) {
      var p = h.nodeType;
      if (p === 1 || p === 3) break;
      if (p === 8) {
        if (p = h.data, p === "$" || p === "$!" || p === "$?") break;
        if (p === "/$") return null;
      }
    }
    return h;
  }
  function Qm(h) {
    h = h.previousSibling;
    for (var p = 0; h; ) {
      if (h.nodeType === 8) {
        var x = h.data;
        if (x === "$" || x === "$!" || x === "$?") {
          if (p === 0) return h;
          p--;
        } else x === "/$" && p++;
      }
      h = h.previousSibling;
    }
    return null;
  }
  var Ed = Math.random().toString(36).slice(2), Dc = "__reactFiber$" + Ed, Kh = "__reactProps$" + Ed, xu = "__reactContainer$" + Ed, zw = "__reactEvents$" + Ed, BD = "__reactListeners$" + Ed, Uw = "__reactHandles$" + Ed;
  function nl(h) {
    var p = h[Dc];
    if (p) return p;
    for (var x = h.parentNode; x; ) {
      if (p = x[xu] || x[Dc]) {
        if (x = p.alternate, p.child !== null || x !== null && x.child !== null) for (h = Qm(h); h !== null; ) {
          if (x = h[Dc]) return x;
          h = Qm(h);
        }
        return p;
      }
      h = x, x = h.parentNode;
    }
    return null;
  }
  function Jm(h) {
    return h = h[Dc] || h[xu], !h || h.tag !== 5 && h.tag !== 6 && h.tag !== 13 && h.tag !== 3 ? null : h;
  }
  function Up(h) {
    if (h.tag === 5 || h.tag === 6) return h.stateNode;
    throw Error(e(33));
  }
  function zt(h) {
    return h[Kh] || null;
  }
  var _d = [], $r = -1;
  function pn(h) {
    return { current: h };
  }
  function or(h) {
    0 > $r || (h.current = _d[$r], _d[$r] = null, $r--);
  }
  function ur(h, p) {
    $r++, _d[$r] = h.current, h.current = p;
  }
  var Oc = {}, nn = pn(Oc), mi = pn(!1), Vo = Oc;
  function rl(h, p) {
    var x = h.type.contextTypes;
    if (!x) return Oc;
    var k = h.stateNode;
    if (k && k.__reactInternalMemoizedUnmaskedChildContext === p) return k.__reactInternalMemoizedMaskedChildContext;
    var L = {}, z;
    for (z in x) L[z] = p[z];
    return k && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = p, h.__reactInternalMemoizedMaskedChildContext = L), L;
  }
  function qr(h) {
    return h = h.childContextTypes, h != null;
  }
  function il() {
    or(mi), or(nn);
  }
  function Td(h, p, x) {
    if (nn.current !== Oc) throw Error(e(168));
    ur(nn, p), ur(mi, x);
  }
  function ev(h, p, x) {
    var k = h.stateNode;
    if (p = p.childContextTypes, typeof k.getChildContext != "function") return x;
    k = k.getChildContext();
    for (var L in k) if (!(L in p)) throw Error(e(108, Ze(h) || "Unknown", L));
    return ke({}, x, k);
  }
  function FS(h) {
    return h = (h = h.stateNode) && h.__reactInternalMemoizedMergedChildContext || Oc, Vo = nn.current, ur(nn, h), ur(mi, mi.current), !0;
  }
  function jP(h, p, x) {
    var k = h.stateNode;
    if (!k) throw Error(e(169));
    x ? (h = ev(h, p, Vo), k.__reactInternalMemoizedMergedChildContext = h, or(mi), or(nn), ur(nn, h)) : or(mi), ur(mi, x);
  }
  var _a = null, hs = !1, tv = !1;
  function Bw(h) {
    _a === null ? _a = [h] : _a.push(h);
  }
  function Hw(h) {
    hs = !0, Bw(h);
  }
  function Wo() {
    if (!tv && _a !== null) {
      tv = !0;
      var h = 0, p = Cn;
      try {
        var x = _a;
        for (Cn = 1; h < x.length; h++) {
          var k = x[h];
          do
            k = k(!0);
          while (k !== null);
        }
        _a = null, hs = !1;
      } catch (L) {
        throw _a !== null && (_a = _a.slice(h + 1)), fr(xs, Wo), L;
      } finally {
        Cn = p, tv = !1;
      }
    }
    return null;
  }
  var Pd = [], Go = 0, Yh = null, Bp = 0, Ko = [], Hs = 0, sl = null, Cs = 1, wu = "";
  function Ta(h, p) {
    Pd[Go++] = Bp, Pd[Go++] = Yh, Yh = h, Bp = p;
  }
  function Vw(h, p, x) {
    Ko[Hs++] = Cs, Ko[Hs++] = wu, Ko[Hs++] = sl, sl = h;
    var k = Cs;
    h = wu;
    var L = 32 - ws(k) - 1;
    k &= ~(1 << L), x += 1;
    var z = 32 - ws(p) + L;
    if (30 < z) {
      var Y = L - L % 5;
      z = (k & (1 << Y) - 1).toString(32), k >>= Y, L -= Y, Cs = 1 << 32 - ws(p) + L | x << L | k, wu = z + h;
    } else Cs = 1 << z | x << L | k, wu = h;
  }
  function $S(h) {
    h.return !== null && (Ta(h, 1), Vw(h, 1, 0));
  }
  function Ww(h) {
    for (; h === Yh; ) Yh = Pd[--Go], Pd[Go] = null, Bp = Pd[--Go], Pd[Go] = null;
    for (; h === sl; ) sl = Ko[--Hs], Ko[Hs] = null, wu = Ko[--Hs], Ko[Hs] = null, Cs = Ko[--Hs], Ko[Hs] = null;
  }
  var Pa = null, Yo = null, zr = !1, ol = null;
  function Gw(h, p) {
    var x = pl(5, null, null, 0);
    x.elementType = "DELETED", x.stateNode = p, x.return = h, p = h.deletions, p === null ? (h.deletions = [x], h.flags |= 16) : p.push(x);
  }
  function NP(h, p) {
    switch (h.tag) {
      case 5:
        var x = h.type;
        return p = p.nodeType !== 1 || x.toLowerCase() !== p.nodeName.toLowerCase() ? null : p, p !== null ? (h.stateNode = p, Pa = h, Yo = Xl(p.firstChild), !0) : !1;
      case 6:
        return p = h.pendingProps === "" || p.nodeType !== 3 ? null : p, p !== null ? (h.stateNode = p, Pa = h, Yo = null, !0) : !1;
      case 13:
        return p = p.nodeType !== 8 ? null : p, p !== null ? (x = sl !== null ? { id: Cs, overflow: wu } : null, h.memoizedState = { dehydrated: p, treeContext: x, retryLane: 1073741824 }, x = pl(18, null, null, 0), x.stateNode = p, x.return = h, h.child = x, Pa = h, Yo = null, !0) : !1;
      default:
        return !1;
    }
  }
  function zS(h) {
    return (h.mode & 1) !== 0 && (h.flags & 128) === 0;
  }
  function US(h) {
    if (zr) {
      var p = Yo;
      if (p) {
        var x = p;
        if (!NP(h, p)) {
          if (zS(h)) throw Error(e(418));
          p = Xl(x.nextSibling);
          var k = Pa;
          p && NP(h, p) ? Gw(k, x) : (h.flags = h.flags & -4097 | 2, zr = !1, Pa = h);
        }
      } else {
        if (zS(h)) throw Error(e(418));
        h.flags = h.flags & -4097 | 2, zr = !1, Pa = h;
      }
    }
  }
  function FP(h) {
    for (h = h.return; h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13; ) h = h.return;
    Pa = h;
  }
  function BS(h) {
    if (h !== Pa) return !1;
    if (!zr) return FP(h), zr = !0, !1;
    var p;
    if ((p = h.tag !== 3) && !(p = h.tag !== 5) && (p = h.type, p = p !== "head" && p !== "body" && !Zm(h.type, h.memoizedProps)), p && (p = Yo)) {
      if (zS(h)) throw $P(), Error(e(418));
      for (; p; ) Gw(h, p), p = Xl(p.nextSibling);
    }
    if (FP(h), h.tag === 13) {
      if (h = h.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(e(317));
      e: {
        for (h = h.nextSibling, p = 0; h; ) {
          if (h.nodeType === 8) {
            var x = h.data;
            if (x === "/$") {
              if (p === 0) {
                Yo = Xl(h.nextSibling);
                break e;
              }
              p--;
            } else x !== "$" && x !== "$!" && x !== "$?" || p++;
          }
          h = h.nextSibling;
        }
        Yo = null;
      }
    } else Yo = Pa ? Xl(h.stateNode.nextSibling) : null;
    return !0;
  }
  function $P() {
    for (var h = Yo; h; ) h = Xl(h.nextSibling);
  }
  function ai() {
    Yo = Pa = null, zr = !1;
  }
  function Kw(h) {
    ol === null ? ol = [h] : ol.push(h);
  }
  var HS = j.ReactCurrentBatchConfig;
  function Xh(h, p, x) {
    if (h = x.ref, h !== null && typeof h != "function" && typeof h != "object") {
      if (x._owner) {
        if (x = x._owner, x) {
          if (x.tag !== 1) throw Error(e(309));
          var k = x.stateNode;
        }
        if (!k) throw Error(e(147, h));
        var L = k, z = "" + h;
        return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === z ? p.ref : (p = function(Y) {
          var ae = L.refs;
          Y === null ? delete ae[z] : ae[z] = Y;
        }, p._stringRef = z, p);
      }
      if (typeof h != "string") throw Error(e(284));
      if (!x._owner) throw Error(e(290, h));
    }
    return h;
  }
  function Lc(h, p) {
    throw h = Object.prototype.toString.call(p), Error(e(31, h === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : h));
  }
  function zP(h) {
    var p = h._init;
    return p(h._payload);
  }
  function VS(h) {
    function p(xe, ge) {
      if (h) {
        var Te = xe.deletions;
        Te === null ? (xe.deletions = [ge], xe.flags |= 16) : Te.push(ge);
      }
    }
    function x(xe, ge) {
      if (!h) return null;
      for (; ge !== null; ) p(xe, ge), ge = ge.sibling;
      return null;
    }
    function k(xe, ge) {
      for (xe = /* @__PURE__ */ new Map(); ge !== null; ) ge.key !== null ? xe.set(ge.key, ge) : xe.set(ge.index, ge), ge = ge.sibling;
      return xe;
    }
    function L(xe, ge) {
      return xe = Ld(xe, ge), xe.index = 0, xe.sibling = null, xe;
    }
    function z(xe, ge, Te) {
      return xe.index = Te, h ? (Te = xe.alternate, Te !== null ? (Te = Te.index, Te < ge ? (xe.flags |= 2, ge) : Te) : (xe.flags |= 2, ge)) : (xe.flags |= 1048576, ge);
    }
    function Y(xe) {
      return h && xe.alternate === null && (xe.flags |= 2), xe;
    }
    function ae(xe, ge, Te, qe) {
      return ge === null || ge.tag !== 6 ? (ge = Rb(Te, xe.mode, qe), ge.return = xe, ge) : (ge = L(ge, Te), ge.return = xe, ge);
    }
    function he(xe, ge, Te, qe) {
      var Mt = Te.type;
      return Mt === F ? We(xe, ge, Te.props.children, qe, Te.key) : ge !== null && (ge.elementType === Mt || typeof Mt == "object" && Mt !== null && Mt.$$typeof === fe && zP(Mt) === ge.type) ? (qe = L(ge, Te.props), qe.ref = Xh(xe, ge, Te), qe.return = xe, qe) : (qe = kb(Te.type, Te.key, Te.props, null, xe.mode, qe), qe.ref = Xh(xe, ge, Te), qe.return = xe, qe);
    }
    function Ie(xe, ge, Te, qe) {
      return ge === null || ge.tag !== 4 || ge.stateNode.containerInfo !== Te.containerInfo || ge.stateNode.implementation !== Te.implementation ? (ge = Sv(Te, xe.mode, qe), ge.return = xe, ge) : (ge = L(ge, Te.children || []), ge.return = xe, ge);
    }
    function We(xe, ge, Te, qe, Mt) {
      return ge === null || ge.tag !== 7 ? (ge = df(Te, xe.mode, qe, Mt), ge.return = xe, ge) : (ge = L(ge, Te), ge.return = xe, ge);
    }
    function Ge(xe, ge, Te) {
      if (typeof ge == "string" && ge !== "" || typeof ge == "number") return ge = Rb("" + ge, xe.mode, Te), ge.return = xe, ge;
      if (typeof ge == "object" && ge !== null) {
        switch (ge.$$typeof) {
          case $:
            return Te = kb(ge.type, ge.key, ge.props, null, xe.mode, Te), Te.ref = Xh(xe, null, ge), Te.return = xe, Te;
          case U:
            return ge = Sv(ge, xe.mode, Te), ge.return = xe, ge;
          case fe:
            var qe = ge._init;
            return Ge(xe, qe(ge._payload), Te);
        }
        if (fi(ge) || Se(ge)) return ge = df(ge, xe.mode, Te, null), ge.return = xe, ge;
        Lc(xe, ge);
      }
      return null;
    }
    function Ve(xe, ge, Te, qe) {
      var Mt = ge !== null ? ge.key : null;
      if (typeof Te == "string" && Te !== "" || typeof Te == "number") return Mt !== null ? null : ae(xe, ge, "" + Te, qe);
      if (typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case $:
            return Te.key === Mt ? he(xe, ge, Te, qe) : null;
          case U:
            return Te.key === Mt ? Ie(xe, ge, Te, qe) : null;
          case fe:
            return Mt = Te._init, Ve(
              xe,
              ge,
              Mt(Te._payload),
              qe
            );
        }
        if (fi(Te) || Se(Te)) return Mt !== null ? null : We(xe, ge, Te, qe, null);
        Lc(xe, Te);
      }
      return null;
    }
    function dt(xe, ge, Te, qe, Mt) {
      if (typeof qe == "string" && qe !== "" || typeof qe == "number") return xe = xe.get(Te) || null, ae(ge, xe, "" + qe, Mt);
      if (typeof qe == "object" && qe !== null) {
        switch (qe.$$typeof) {
          case $:
            return xe = xe.get(qe.key === null ? Te : qe.key) || null, he(ge, xe, qe, Mt);
          case U:
            return xe = xe.get(qe.key === null ? Te : qe.key) || null, Ie(ge, xe, qe, Mt);
          case fe:
            var Kt = qe._init;
            return dt(xe, ge, Te, Kt(qe._payload), Mt);
        }
        if (fi(qe) || Se(qe)) return xe = xe.get(Te) || null, We(ge, xe, qe, Mt, null);
        Lc(ge, qe);
      }
      return null;
    }
    function St(xe, ge, Te, qe) {
      for (var Mt = null, Kt = null, bt = ge, Xt = ge = 0, Gi = null; bt !== null && Xt < Te.length; Xt++) {
        bt.index > Xt ? (Gi = bt, bt = null) : Gi = bt.sibling;
        var tr = Ve(xe, bt, Te[Xt], qe);
        if (tr === null) {
          bt === null && (bt = Gi);
          break;
        }
        h && bt && tr.alternate === null && p(xe, bt), ge = z(tr, ge, Xt), Kt === null ? Mt = tr : Kt.sibling = tr, Kt = tr, bt = Gi;
      }
      if (Xt === Te.length) return x(xe, bt), zr && Ta(xe, Xt), Mt;
      if (bt === null) {
        for (; Xt < Te.length; Xt++) bt = Ge(xe, Te[Xt], qe), bt !== null && (ge = z(bt, ge, Xt), Kt === null ? Mt = bt : Kt.sibling = bt, Kt = bt);
        return zr && Ta(xe, Xt), Mt;
      }
      for (bt = k(xe, bt); Xt < Te.length; Xt++) Gi = dt(bt, xe, Xt, Te[Xt], qe), Gi !== null && (h && Gi.alternate !== null && bt.delete(Gi.key === null ? Xt : Gi.key), ge = z(Gi, ge, Xt), Kt === null ? Mt = Gi : Kt.sibling = Gi, Kt = Gi);
      return h && bt.forEach(function(ku) {
        return p(xe, ku);
      }), zr && Ta(xe, Xt), Mt;
    }
    function _t(xe, ge, Te, qe) {
      var Mt = Se(Te);
      if (typeof Mt != "function") throw Error(e(150));
      if (Te = Mt.call(Te), Te == null) throw Error(e(151));
      for (var Kt = Mt = null, bt = ge, Xt = ge = 0, Gi = null, tr = Te.next(); bt !== null && !tr.done; Xt++, tr = Te.next()) {
        bt.index > Xt ? (Gi = bt, bt = null) : Gi = bt.sibling;
        var ku = Ve(xe, bt, tr.value, qe);
        if (ku === null) {
          bt === null && (bt = Gi);
          break;
        }
        h && bt && ku.alternate === null && p(xe, bt), ge = z(ku, ge, Xt), Kt === null ? Mt = ku : Kt.sibling = ku, Kt = ku, bt = Gi;
      }
      if (tr.done) return x(
        xe,
        bt
      ), zr && Ta(xe, Xt), Mt;
      if (bt === null) {
        for (; !tr.done; Xt++, tr = Te.next()) tr = Ge(xe, tr.value, qe), tr !== null && (ge = z(tr, ge, Xt), Kt === null ? Mt = tr : Kt.sibling = tr, Kt = tr);
        return zr && Ta(xe, Xt), Mt;
      }
      for (bt = k(xe, bt); !tr.done; Xt++, tr = Te.next()) tr = dt(bt, xe, Xt, tr.value, qe), tr !== null && (h && tr.alternate !== null && bt.delete(tr.key === null ? Xt : tr.key), ge = z(tr, ge, Xt), Kt === null ? Mt = tr : Kt.sibling = tr, Kt = tr);
      return h && bt.forEach(function(oO) {
        return p(xe, oO);
      }), zr && Ta(xe, Xt), Mt;
    }
    function Ti(xe, ge, Te, qe) {
      if (typeof Te == "object" && Te !== null && Te.type === F && Te.key === null && (Te = Te.props.children), typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case $:
            e: {
              for (var Mt = Te.key, Kt = ge; Kt !== null; ) {
                if (Kt.key === Mt) {
                  if (Mt = Te.type, Mt === F) {
                    if (Kt.tag === 7) {
                      x(xe, Kt.sibling), ge = L(Kt, Te.props.children), ge.return = xe, xe = ge;
                      break e;
                    }
                  } else if (Kt.elementType === Mt || typeof Mt == "object" && Mt !== null && Mt.$$typeof === fe && zP(Mt) === Kt.type) {
                    x(xe, Kt.sibling), ge = L(Kt, Te.props), ge.ref = Xh(xe, Kt, Te), ge.return = xe, xe = ge;
                    break e;
                  }
                  x(xe, Kt);
                  break;
                } else p(xe, Kt);
                Kt = Kt.sibling;
              }
              Te.type === F ? (ge = df(Te.props.children, xe.mode, qe, Te.key), ge.return = xe, xe = ge) : (qe = kb(Te.type, Te.key, Te.props, null, xe.mode, qe), qe.ref = Xh(xe, ge, Te), qe.return = xe, xe = qe);
            }
            return Y(xe);
          case U:
            e: {
              for (Kt = Te.key; ge !== null; ) {
                if (ge.key === Kt) if (ge.tag === 4 && ge.stateNode.containerInfo === Te.containerInfo && ge.stateNode.implementation === Te.implementation) {
                  x(xe, ge.sibling), ge = L(ge, Te.children || []), ge.return = xe, xe = ge;
                  break e;
                } else {
                  x(xe, ge);
                  break;
                }
                else p(xe, ge);
                ge = ge.sibling;
              }
              ge = Sv(Te, xe.mode, qe), ge.return = xe, xe = ge;
            }
            return Y(xe);
          case fe:
            return Kt = Te._init, Ti(xe, ge, Kt(Te._payload), qe);
        }
        if (fi(Te)) return St(xe, ge, Te, qe);
        if (Se(Te)) return _t(xe, ge, Te, qe);
        Lc(xe, Te);
      }
      return typeof Te == "string" && Te !== "" || typeof Te == "number" ? (Te = "" + Te, ge !== null && ge.tag === 6 ? (x(xe, ge.sibling), ge = L(ge, Te), ge.return = xe, xe = ge) : (x(xe, ge), ge = Rb(Te, xe.mode, qe), ge.return = xe, xe = ge), Y(xe)) : x(xe, ge);
    }
    return Ti;
  }
  var Hp = VS(!0), UP = VS(!1), Cu = pn(null), Bi = null, rt = null, al = null;
  function Aa() {
    al = rt = Bi = null;
  }
  function Yw(h) {
    var p = Cu.current;
    or(Cu), h._currentValue = p;
  }
  function Xw(h, p, x) {
    for (; h !== null; ) {
      var k = h.alternate;
      if ((h.childLanes & p) !== p ? (h.childLanes |= p, k !== null && (k.childLanes |= p)) : k !== null && (k.childLanes & p) !== p && (k.childLanes |= p), h === x) break;
      h = h.return;
    }
  }
  function Vp(h, p) {
    Bi = h, al = rt = null, h = h.dependencies, h !== null && h.firstContext !== null && (h.lanes & p && (Zo = !0), h.firstContext = null);
  }
  function ll(h) {
    var p = h._currentValue;
    if (al !== h) if (h = { context: h, memoizedValue: p, next: null }, rt === null) {
      if (Bi === null) throw Error(e(308));
      rt = h, Bi.dependencies = { lanes: 0, firstContext: h };
    } else rt = rt.next = h;
    return p;
  }
  var qh = null;
  function ji(h) {
    qh === null ? qh = [h] : qh.push(h);
  }
  function BP(h, p, x, k) {
    var L = p.interleaved;
    return L === null ? (x.next = x, ji(p)) : (x.next = L.next, L.next = x), p.interleaved = x, Eu(h, k);
  }
  function Eu(h, p) {
    h.lanes |= p;
    var x = h.alternate;
    for (x !== null && (x.lanes |= p), x = h, h = h.return; h !== null; ) h.childLanes |= p, x = h.alternate, x !== null && (x.childLanes |= p), x = h, h = h.return;
    return x.tag === 3 ? x.stateNode : null;
  }
  var Ad = !1;
  function WS(h) {
    h.updateQueue = { baseState: h.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Wp(h, p) {
    h = h.updateQueue, p.updateQueue === h && (p.updateQueue = { baseState: h.baseState, firstBaseUpdate: h.firstBaseUpdate, lastBaseUpdate: h.lastBaseUpdate, shared: h.shared, effects: h.effects });
  }
  function Xo(h, p) {
    return { eventTime: h, lane: p, tag: 0, payload: null, callback: null, next: null };
  }
  function kd(h, p, x) {
    var k = h.updateQueue;
    if (k === null) return null;
    if (k = k.shared, _n & 2) {
      var L = k.pending;
      return L === null ? p.next = p : (p.next = L.next, L.next = p), k.pending = p, Eu(h, x);
    }
    return L = k.interleaved, L === null ? (p.next = p, ji(k)) : (p.next = L.next, L.next = p), k.interleaved = p, Eu(h, x);
  }
  function GS(h, p, x) {
    if (p = p.updateQueue, p !== null && (p = p.shared, (x & 4194240) !== 0)) {
      var k = p.lanes;
      k &= h.pendingLanes, x |= k, p.lanes = x, wa(h, x);
    }
  }
  function HP(h, p) {
    var x = h.updateQueue, k = h.alternate;
    if (k !== null && (k = k.updateQueue, x === k)) {
      var L = null, z = null;
      if (x = x.firstBaseUpdate, x !== null) {
        do {
          var Y = { eventTime: x.eventTime, lane: x.lane, tag: x.tag, payload: x.payload, callback: x.callback, next: null };
          z === null ? L = z = Y : z = z.next = Y, x = x.next;
        } while (x !== null);
        z === null ? L = z = p : z = z.next = p;
      } else L = z = p;
      x = { baseState: k.baseState, firstBaseUpdate: L, lastBaseUpdate: z, shared: k.shared, effects: k.effects }, h.updateQueue = x;
      return;
    }
    h = x.lastBaseUpdate, h === null ? x.firstBaseUpdate = p : h.next = p, x.lastBaseUpdate = p;
  }
  function KS(h, p, x, k) {
    var L = h.updateQueue;
    Ad = !1;
    var z = L.firstBaseUpdate, Y = L.lastBaseUpdate, ae = L.shared.pending;
    if (ae !== null) {
      L.shared.pending = null;
      var he = ae, Ie = he.next;
      he.next = null, Y === null ? z = Ie : Y.next = Ie, Y = he;
      var We = h.alternate;
      We !== null && (We = We.updateQueue, ae = We.lastBaseUpdate, ae !== Y && (ae === null ? We.firstBaseUpdate = Ie : ae.next = Ie, We.lastBaseUpdate = he));
    }
    if (z !== null) {
      var Ge = L.baseState;
      Y = 0, We = Ie = he = null, ae = z;
      do {
        var Ve = ae.lane, dt = ae.eventTime;
        if ((k & Ve) === Ve) {
          We !== null && (We = We.next = {
            eventTime: dt,
            lane: 0,
            tag: ae.tag,
            payload: ae.payload,
            callback: ae.callback,
            next: null
          });
          e: {
            var St = h, _t = ae;
            switch (Ve = p, dt = x, _t.tag) {
              case 1:
                if (St = _t.payload, typeof St == "function") {
                  Ge = St.call(dt, Ge, Ve);
                  break e;
                }
                Ge = St;
                break e;
              case 3:
                St.flags = St.flags & -65537 | 128;
              case 0:
                if (St = _t.payload, Ve = typeof St == "function" ? St.call(dt, Ge, Ve) : St, Ve == null) break e;
                Ge = ke({}, Ge, Ve);
                break e;
              case 2:
                Ad = !0;
            }
          }
          ae.callback !== null && ae.lane !== 0 && (h.flags |= 64, Ve = L.effects, Ve === null ? L.effects = [ae] : Ve.push(ae));
        } else dt = { eventTime: dt, lane: Ve, tag: ae.tag, payload: ae.payload, callback: ae.callback, next: null }, We === null ? (Ie = We = dt, he = Ge) : We = We.next = dt, Y |= Ve;
        if (ae = ae.next, ae === null) {
          if (ae = L.shared.pending, ae === null) break;
          Ve = ae, ae = Ve.next, Ve.next = null, L.lastBaseUpdate = Ve, L.shared.pending = null;
        }
      } while (!0);
      if (We === null && (he = Ge), L.baseState = he, L.firstBaseUpdate = Ie, L.lastBaseUpdate = We, p = L.shared.interleaved, p !== null) {
        L = p;
        do
          Y |= L.lane, L = L.next;
        while (L !== p);
      } else z === null && (L.shared.lanes = 0);
      af |= Y, h.lanes = Y, h.memoizedState = Ge;
    }
  }
  function VP(h, p, x) {
    if (h = p.effects, p.effects = null, h !== null) for (p = 0; p < h.length; p++) {
      var k = h[p], L = k.callback;
      if (L !== null) {
        if (k.callback = null, k = x, typeof L != "function") throw Error(e(191, L));
        L.call(k);
      }
    }
  }
  var nv = {}, ql = pn(nv), Gp = pn(nv), rv = pn(nv);
  function Zh(h) {
    if (h === nv) throw Error(e(174));
    return h;
  }
  function qw(h, p) {
    switch (ur(rv, p), ur(Gp, h), ur(ql, nv), h = p.nodeType, h) {
      case 9:
      case 11:
        p = (p = p.documentElement) ? p.namespaceURI : On(null, "");
        break;
      default:
        h = h === 8 ? p.parentNode : p, p = h.namespaceURI || null, h = h.tagName, p = On(p, h);
    }
    or(ql), ur(ql, p);
  }
  function Kp() {
    or(ql), or(Gp), or(rv);
  }
  function WP(h) {
    Zh(rv.current);
    var p = Zh(ql.current), x = On(p, h.type);
    p !== x && (ur(Gp, h), ur(ql, x));
  }
  function Zw(h) {
    Gp.current === h && (or(ql), or(Gp));
  }
  var Zr = pn(0);
  function YS(h) {
    for (var p = h; p !== null; ) {
      if (p.tag === 13) {
        var x = p.memoizedState;
        if (x !== null && (x = x.dehydrated, x === null || x.data === "$?" || x.data === "$!")) return p;
      } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
        if (p.flags & 128) return p;
      } else if (p.child !== null) {
        p.child.return = p, p = p.child;
        continue;
      }
      if (p === h) break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === h) return null;
        p = p.return;
      }
      p.sibling.return = p.return, p = p.sibling;
    }
    return null;
  }
  var XS = [];
  function Qw() {
    for (var h = 0; h < XS.length; h++) XS[h]._workInProgressVersionPrimary = null;
    XS.length = 0;
  }
  var qS = j.ReactCurrentDispatcher, iv = j.ReactCurrentBatchConfig, Rt = 0, Ot = null, rn = null, Sn = null, ka = !1, Yp = !1, sv = 0, HD = 0;
  function Vs() {
    throw Error(e(321));
  }
  function ov(h, p) {
    if (p === null) return !1;
    for (var x = 0; x < p.length && x < h.length; x++) if (!tl(h[x], p[x])) return !1;
    return !0;
  }
  function Ue(h, p, x, k, L, z) {
    if (Rt = z, Ot = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, qS.current = h === null || h.memoizedState === null ? VD : Rr, h = x(k, L), Yp) {
      z = 0;
      do {
        if (Yp = !1, sv = 0, 25 <= z) throw Error(e(301));
        z += 1, Sn = rn = null, p.updateQueue = null, qS.current = db, h = x(k, L);
      } while (Yp);
    }
    if (qS.current = Ws, p = rn !== null && rn.next !== null, Rt = 0, Sn = rn = Ot = null, ka = !1, p) throw Error(e(300));
    return h;
  }
  function Ni() {
    var h = sv !== 0;
    return sv = 0, h;
  }
  function Nt() {
    var h = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Sn === null ? Ot.memoizedState = Sn = h : Sn = Sn.next = h, Sn;
  }
  function Es() {
    if (rn === null) {
      var h = Ot.alternate;
      h = h !== null ? h.memoizedState : null;
    } else h = rn.next;
    var p = Sn === null ? Ot.memoizedState : Sn.next;
    if (p !== null) Sn = p, rn = h;
    else {
      if (h === null) throw Error(e(310));
      rn = h, h = { memoizedState: rn.memoizedState, baseState: rn.baseState, baseQueue: rn.baseQueue, queue: rn.queue, next: null }, Sn === null ? Ot.memoizedState = Sn = h : Sn = Sn.next = h;
    }
    return Sn;
  }
  function Ia(h, p) {
    return typeof p == "function" ? p(h) : p;
  }
  function _u(h) {
    var p = Es(), x = p.queue;
    if (x === null) throw Error(e(311));
    x.lastRenderedReducer = h;
    var k = rn, L = k.baseQueue, z = x.pending;
    if (z !== null) {
      if (L !== null) {
        var Y = L.next;
        L.next = z.next, z.next = Y;
      }
      k.baseQueue = L = z, x.pending = null;
    }
    if (L !== null) {
      z = L.next, k = k.baseState;
      var ae = Y = null, he = null, Ie = z;
      do {
        var We = Ie.lane;
        if ((Rt & We) === We) he !== null && (he = he.next = { lane: 0, action: Ie.action, hasEagerState: Ie.hasEagerState, eagerState: Ie.eagerState, next: null }), k = Ie.hasEagerState ? Ie.eagerState : h(k, Ie.action);
        else {
          var Ge = {
            lane: We,
            action: Ie.action,
            hasEagerState: Ie.hasEagerState,
            eagerState: Ie.eagerState,
            next: null
          };
          he === null ? (ae = he = Ge, Y = k) : he = he.next = Ge, Ot.lanes |= We, af |= We;
        }
        Ie = Ie.next;
      } while (Ie !== null && Ie !== z);
      he === null ? Y = k : he.next = ae, tl(k, p.memoizedState) || (Zo = !0), p.memoizedState = k, p.baseState = Y, p.baseQueue = he, x.lastRenderedState = k;
    }
    if (h = x.interleaved, h !== null) {
      L = h;
      do
        z = L.lane, Ot.lanes |= z, af |= z, L = L.next;
      while (L !== h);
    } else L === null && (x.lanes = 0);
    return [p.memoizedState, x.dispatch];
  }
  function cl(h) {
    var p = Es(), x = p.queue;
    if (x === null) throw Error(e(311));
    x.lastRenderedReducer = h;
    var k = x.dispatch, L = x.pending, z = p.memoizedState;
    if (L !== null) {
      x.pending = null;
      var Y = L = L.next;
      do
        z = h(z, Y.action), Y = Y.next;
      while (Y !== L);
      tl(z, p.memoizedState) || (Zo = !0), p.memoizedState = z, p.baseQueue === null && (p.baseState = z), x.lastRenderedState = z;
    }
    return [z, k];
  }
  function Xp() {
  }
  function Qh(h, p) {
    var x = Ot, k = Es(), L = p(), z = !tl(k.memoizedState, L);
    if (z && (k.memoizedState = L, Zo = !0), k = k.queue, av(QS.bind(null, x, k, h), [h]), k.getSnapshot !== p || z || Sn !== null && Sn.memoizedState.tag & 1) {
      if (x.flags |= 2048, Jh(9, ZS.bind(null, x, k, L, p), void 0, null), yi === null) throw Error(e(349));
      Rt & 30 || qp(x, p, L);
    }
    return L;
  }
  function qp(h, p, x) {
    h.flags |= 16384, h = { getSnapshot: p, value: x }, p = Ot.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, Ot.updateQueue = p, p.stores = [h]) : (x = p.stores, x === null ? p.stores = [h] : x.push(h));
  }
  function ZS(h, p, x, k) {
    p.value = x, p.getSnapshot = k, JS(p) && eb(h);
  }
  function QS(h, p, x) {
    return x(function() {
      JS(p) && eb(h);
    });
  }
  function JS(h) {
    var p = h.getSnapshot;
    h = h.value;
    try {
      var x = p();
      return !tl(h, x);
    } catch {
      return !0;
    }
  }
  function eb(h) {
    var p = Eu(h, 1);
    p !== null && li(p, h, 1, -1);
  }
  function tb(h) {
    var p = Nt();
    return typeof h == "function" && (h = h()), p.memoizedState = p.baseState = h, h = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ia, lastRenderedState: h }, p.queue = h, h = h.dispatch = lv.bind(null, Ot, h), [p.memoizedState, h];
  }
  function Jh(h, p, x, k) {
    return h = { tag: h, create: p, destroy: x, deps: k, next: null }, p = Ot.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, Ot.updateQueue = p, p.lastEffect = h.next = h) : (x = p.lastEffect, x === null ? p.lastEffect = h.next = h : (k = x.next, x.next = h, h.next = k, p.lastEffect = h)), h;
  }
  function nb() {
    return Es().memoizedState;
  }
  function Zp(h, p, x, k) {
    var L = Nt();
    Ot.flags |= h, L.memoizedState = Jh(1 | p, x, void 0, k === void 0 ? null : k);
  }
  function Qp(h, p, x, k) {
    var L = Es();
    k = k === void 0 ? null : k;
    var z = void 0;
    if (rn !== null) {
      var Y = rn.memoizedState;
      if (z = Y.destroy, k !== null && ov(k, Y.deps)) {
        L.memoizedState = Jh(p, x, z, k);
        return;
      }
    }
    Ot.flags |= h, L.memoizedState = Jh(1 | p, x, z, k);
  }
  function rb(h, p) {
    return Zp(8390656, 8, h, p);
  }
  function av(h, p) {
    return Qp(2048, 8, h, p);
  }
  function ib(h, p) {
    return Qp(4, 2, h, p);
  }
  function sb(h, p) {
    return Qp(4, 4, h, p);
  }
  function ob(h, p) {
    if (typeof p == "function") return h = h(), p(h), function() {
      p(null);
    };
    if (p != null) return h = h(), p.current = h, function() {
      p.current = null;
    };
  }
  function ab(h, p, x) {
    return x = x != null ? x.concat([h]) : null, Qp(4, 4, ob.bind(null, p, h), x);
  }
  function Jp() {
  }
  function ef(h, p) {
    var x = Es();
    p = p === void 0 ? null : p;
    var k = x.memoizedState;
    return k !== null && p !== null && ov(p, k[1]) ? k[0] : (x.memoizedState = [h, p], h);
  }
  function lb(h, p) {
    var x = Es();
    p = p === void 0 ? null : p;
    var k = x.memoizedState;
    return k !== null && p !== null && ov(p, k[1]) ? k[0] : (h = h(), x.memoizedState = [h, p], h);
  }
  function cb(h, p, x) {
    return Rt & 21 ? (tl(x, p) || (x = vd(), Ot.lanes |= x, af |= x, h.baseState = !0), p) : (h.baseState && (h.baseState = !1, Zo = !0), h.memoizedState = x);
  }
  function Jw(h, p) {
    var x = Cn;
    Cn = x !== 0 && 4 > x ? x : 4, h(!0);
    var k = iv.transition;
    iv.transition = {};
    try {
      h(!1), p();
    } finally {
      Cn = x, iv.transition = k;
    }
  }
  function ub() {
    return Es().memoizedState;
  }
  function GP(h, p, x) {
    var k = Au(h);
    if (x = { lane: k, action: x, hasEagerState: !1, eagerState: null, next: null }, eC(h)) eg(p, x);
    else if (x = BP(h, p, x, k), x !== null) {
      var L = gs();
      li(x, h, k, L), Id(x, p, k);
    }
  }
  function lv(h, p, x) {
    var k = Au(h), L = { lane: k, action: x, hasEagerState: !1, eagerState: null, next: null };
    if (eC(h)) eg(p, L);
    else {
      var z = h.alternate;
      if (h.lanes === 0 && (z === null || z.lanes === 0) && (z = p.lastRenderedReducer, z !== null)) try {
        var Y = p.lastRenderedState, ae = z(Y, x);
        if (L.hasEagerState = !0, L.eagerState = ae, tl(ae, Y)) {
          var he = p.interleaved;
          he === null ? (L.next = L, ji(p)) : (L.next = he.next, he.next = L), p.interleaved = L;
          return;
        }
      } catch {
      } finally {
      }
      x = BP(h, p, L, k), x !== null && (L = gs(), li(x, h, k, L), Id(x, p, k));
    }
  }
  function eC(h) {
    var p = h.alternate;
    return h === Ot || p !== null && p === Ot;
  }
  function eg(h, p) {
    Yp = ka = !0;
    var x = h.pending;
    x === null ? p.next = p : (p.next = x.next, x.next = p), h.pending = p;
  }
  function Id(h, p, x) {
    if (x & 4194240) {
      var k = p.lanes;
      k &= h.pendingLanes, x |= k, p.lanes = x, wa(h, x);
    }
  }
  var Ws = { readContext: ll, useCallback: Vs, useContext: Vs, useEffect: Vs, useImperativeHandle: Vs, useInsertionEffect: Vs, useLayoutEffect: Vs, useMemo: Vs, useReducer: Vs, useRef: Vs, useState: Vs, useDebugValue: Vs, useDeferredValue: Vs, useTransition: Vs, useMutableSource: Vs, useSyncExternalStore: Vs, useId: Vs, unstable_isNewReconciler: !1 }, VD = { readContext: ll, useCallback: function(h, p) {
    return Nt().memoizedState = [h, p === void 0 ? null : p], h;
  }, useContext: ll, useEffect: rb, useImperativeHandle: function(h, p, x) {
    return x = x != null ? x.concat([h]) : null, Zp(
      4194308,
      4,
      ob.bind(null, p, h),
      x
    );
  }, useLayoutEffect: function(h, p) {
    return Zp(4194308, 4, h, p);
  }, useInsertionEffect: function(h, p) {
    return Zp(4, 2, h, p);
  }, useMemo: function(h, p) {
    var x = Nt();
    return p = p === void 0 ? null : p, h = h(), x.memoizedState = [h, p], h;
  }, useReducer: function(h, p, x) {
    var k = Nt();
    return p = x !== void 0 ? x(p) : p, k.memoizedState = k.baseState = p, h = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: h, lastRenderedState: p }, k.queue = h, h = h.dispatch = GP.bind(null, Ot, h), [k.memoizedState, h];
  }, useRef: function(h) {
    var p = Nt();
    return h = { current: h }, p.memoizedState = h;
  }, useState: tb, useDebugValue: Jp, useDeferredValue: function(h) {
    return Nt().memoizedState = h;
  }, useTransition: function() {
    var h = tb(!1), p = h[0];
    return h = Jw.bind(null, h[1]), Nt().memoizedState = h, [p, h];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(h, p, x) {
    var k = Ot, L = Nt();
    if (zr) {
      if (x === void 0) throw Error(e(407));
      x = x();
    } else {
      if (x = p(), yi === null) throw Error(e(349));
      Rt & 30 || qp(k, p, x);
    }
    L.memoizedState = x;
    var z = { value: x, getSnapshot: p };
    return L.queue = z, rb(QS.bind(
      null,
      k,
      z,
      h
    ), [h]), k.flags |= 2048, Jh(9, ZS.bind(null, k, z, x, p), void 0, null), x;
  }, useId: function() {
    var h = Nt(), p = yi.identifierPrefix;
    if (zr) {
      var x = wu, k = Cs;
      x = (k & ~(1 << 32 - ws(k) - 1)).toString(32) + x, p = ":" + p + "R" + x, x = sv++, 0 < x && (p += "H" + x.toString(32)), p += ":";
    } else x = HD++, p = ":" + p + "r" + x.toString(32) + ":";
    return h.memoizedState = p;
  }, unstable_isNewReconciler: !1 }, Rr = {
    readContext: ll,
    useCallback: ef,
    useContext: ll,
    useEffect: av,
    useImperativeHandle: ab,
    useInsertionEffect: ib,
    useLayoutEffect: sb,
    useMemo: lb,
    useReducer: _u,
    useRef: nb,
    useState: function() {
      return _u(Ia);
    },
    useDebugValue: Jp,
    useDeferredValue: function(h) {
      var p = Es();
      return cb(p, rn.memoizedState, h);
    },
    useTransition: function() {
      var h = _u(Ia)[0], p = Es().memoizedState;
      return [h, p];
    },
    useMutableSource: Xp,
    useSyncExternalStore: Qh,
    useId: ub,
    unstable_isNewReconciler: !1
  }, db = { readContext: ll, useCallback: ef, useContext: ll, useEffect: av, useImperativeHandle: ab, useInsertionEffect: ib, useLayoutEffect: sb, useMemo: lb, useReducer: cl, useRef: nb, useState: function() {
    return cl(Ia);
  }, useDebugValue: Jp, useDeferredValue: function(h) {
    var p = Es();
    return rn === null ? p.memoizedState = h : cb(p, rn.memoizedState, h);
  }, useTransition: function() {
    var h = cl(Ia)[0], p = Es().memoizedState;
    return [h, p];
  }, useMutableSource: Xp, useSyncExternalStore: Qh, useId: ub, unstable_isNewReconciler: !1 };
  function qo(h, p) {
    if (h && h.defaultProps) {
      p = ke({}, p), h = h.defaultProps;
      for (var x in h) p[x] === void 0 && (p[x] = h[x]);
      return p;
    }
    return p;
  }
  function tf(h, p, x, k) {
    p = h.memoizedState, x = x(k, p), x = x == null ? p : ke({}, p, x), h.memoizedState = x, h.lanes === 0 && (h.updateQueue.baseState = x);
  }
  var nf = { isMounted: function(h) {
    return (h = h._reactInternals) ? Pt(h) === h : !1;
  }, enqueueSetState: function(h, p, x) {
    h = h._reactInternals;
    var k = gs(), L = Au(h), z = Xo(k, L);
    z.payload = p, x != null && (z.callback = x), p = kd(h, z, L), p !== null && (li(p, h, L, k), GS(p, h, L));
  }, enqueueReplaceState: function(h, p, x) {
    h = h._reactInternals;
    var k = gs(), L = Au(h), z = Xo(k, L);
    z.tag = 1, z.payload = p, x != null && (z.callback = x), p = kd(h, z, L), p !== null && (li(p, h, L, k), GS(p, h, L));
  }, enqueueForceUpdate: function(h, p) {
    h = h._reactInternals;
    var x = gs(), k = Au(h), L = Xo(x, k);
    L.tag = 2, p != null && (L.callback = p), p = kd(h, L, k), p !== null && (li(p, h, k, x), GS(p, h, k));
  } };
  function KP(h, p, x, k, L, z, Y) {
    return h = h.stateNode, typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(k, z, Y) : p.prototype && p.prototype.isPureReactComponent ? !Vm(x, k) || !Vm(L, z) : !0;
  }
  function YP(h, p, x) {
    var k = !1, L = Oc, z = p.contextType;
    return typeof z == "object" && z !== null ? z = ll(z) : (L = qr(p) ? Vo : nn.current, k = p.contextTypes, z = (k = k != null) ? rl(h, L) : Oc), p = new p(x, z), h.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = nf, h.stateNode = p, p._reactInternals = h, k && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = L, h.__reactInternalMemoizedMaskedChildContext = z), p;
  }
  function XP(h, p, x, k) {
    h = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(x, k), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(x, k), p.state !== h && nf.enqueueReplaceState(p, p.state, null);
  }
  function tC(h, p, x, k) {
    var L = h.stateNode;
    L.props = x, L.state = h.memoizedState, L.refs = {}, WS(h);
    var z = p.contextType;
    typeof z == "object" && z !== null ? L.context = ll(z) : (z = qr(p) ? Vo : nn.current, L.context = rl(h, z)), L.state = h.memoizedState, z = p.getDerivedStateFromProps, typeof z == "function" && (tf(h, p, z, x), L.state = h.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function" || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (p = L.state, typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount(), p !== L.state && nf.enqueueReplaceState(L, L.state, null), KS(h, x, L, k), L.state = h.memoizedState), typeof L.componentDidMount == "function" && (h.flags |= 4194308);
  }
  function Rd(h, p) {
    try {
      var x = "", k = p;
      do
        x += je(k), k = k.return;
      while (k);
      var L = x;
    } catch (z) {
      L = `
Error generating stack: ` + z.message + `
` + z.stack;
    }
    return { value: h, source: p, stack: L, digest: null };
  }
  function nC(h, p, x) {
    return { value: h, source: null, stack: x ?? null, digest: p ?? null };
  }
  function cv(h, p) {
    try {
      console.error(p.value);
    } catch (x) {
      setTimeout(function() {
        throw x;
      });
    }
  }
  var qP = typeof WeakMap == "function" ? WeakMap : Map;
  function ZP(h, p, x) {
    x = Xo(-1, x), x.tag = 3, x.payload = { element: null };
    var k = p.value;
    return x.callback = function() {
      Cb || (Cb = !0, dC = k), cv(h, p);
    }, x;
  }
  function QP(h, p, x) {
    x = Xo(-1, x), x.tag = 3;
    var k = h.type.getDerivedStateFromError;
    if (typeof k == "function") {
      var L = p.value;
      x.payload = function() {
        return k(L);
      }, x.callback = function() {
        cv(h, p);
      };
    }
    var z = h.stateNode;
    return z !== null && typeof z.componentDidCatch == "function" && (x.callback = function() {
      cv(h, p), typeof k != "function" && (hl === null ? hl = /* @__PURE__ */ new Set([this]) : hl.add(this));
      var Y = p.stack;
      this.componentDidCatch(p.value, { componentStack: Y !== null ? Y : "" });
    }), x;
  }
  function uv(h, p, x) {
    var k = h.pingCache;
    if (k === null) {
      k = h.pingCache = new qP();
      var L = /* @__PURE__ */ new Set();
      k.set(p, L);
    } else L = k.get(p), L === void 0 && (L = /* @__PURE__ */ new Set(), k.set(p, L));
    L.has(x) || (L.add(x), h = eO.bind(null, h, p, x), p.then(h, h));
  }
  function JP(h) {
    do {
      var p;
      if ((p = h.tag === 13) && (p = h.memoizedState, p = p !== null ? p.dehydrated !== null : !0), p) return h;
      h = h.return;
    } while (h !== null);
    return null;
  }
  function rC(h, p, x, k, L) {
    return h.mode & 1 ? (h.flags |= 65536, h.lanes = L, h) : (h === p ? h.flags |= 65536 : (h.flags |= 128, x.flags |= 131072, x.flags &= -52805, x.tag === 1 && (x.alternate === null ? x.tag = 17 : (p = Xo(-1, 1), p.tag = 2, kd(x, p, 1))), x.lanes |= 1), h);
  }
  var eA = j.ReactCurrentOwner, Zo = !1;
  function Ei(h, p, x, k) {
    p.child = h === null ? UP(p, null, x, k) : Hp(p, h.child, x, k);
  }
  function tg(h, p, x, k, L) {
    x = x.render;
    var z = p.ref;
    return Vp(p, L), k = Ue(h, p, x, k, z, L), x = Ni(), h !== null && !Zo ? (p.updateQueue = h.updateQueue, p.flags &= -2053, h.lanes &= ~L, _i(h, p, L)) : (zr && x && $S(p), p.flags |= 1, Ei(h, p, k, L), p.child);
  }
  function Md(h, p, x, k, L) {
    if (h === null) {
      var z = x.type;
      return typeof z == "function" && !mC(z) && z.defaultProps === void 0 && x.compare === null && x.defaultProps === void 0 ? (p.tag = 15, p.type = z, hb(h, p, z, k, L)) : (h = kb(x.type, null, k, p, p.mode, L), h.ref = p.ref, h.return = p, p.child = h);
    }
    if (z = h.child, !(h.lanes & L)) {
      var Y = z.memoizedProps;
      if (x = x.compare, x = x !== null ? x : Vm, x(Y, k) && h.ref === p.ref) return _i(h, p, L);
    }
    return p.flags |= 1, h = Ld(z, k), h.ref = p.ref, h.return = p, p.child = h;
  }
  function hb(h, p, x, k, L) {
    if (h !== null) {
      var z = h.memoizedProps;
      if (Vm(z, k) && h.ref === p.ref) if (Zo = !1, p.pendingProps = k = z, (h.lanes & L) !== 0) h.flags & 131072 && (Zo = !0);
      else return p.lanes = h.lanes, _i(h, p, L);
    }
    return dn(h, p, x, k, L);
  }
  function Qo(h, p, x) {
    var k = p.pendingProps, L = k.children, z = h !== null ? h.memoizedState : null;
    if (k.mode === "hidden") if (!(p.mode & 1)) p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ur(dg, Jo), Jo |= x;
    else {
      if (!(x & 1073741824)) return h = z !== null ? z.baseLanes | x : x, p.lanes = p.childLanes = 1073741824, p.memoizedState = { baseLanes: h, cachePool: null, transitions: null }, p.updateQueue = null, ur(dg, Jo), Jo |= h, null;
      p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, k = z !== null ? z.baseLanes : x, ur(dg, Jo), Jo |= k;
    }
    else z !== null ? (k = z.baseLanes | x, p.memoizedState = null) : k = x, ur(dg, Jo), Jo |= k;
    return Ei(h, p, L, x), p.child;
  }
  function rf(h, p) {
    var x = p.ref;
    (h === null && x !== null || h !== null && h.ref !== x) && (p.flags |= 512, p.flags |= 2097152);
  }
  function dn(h, p, x, k, L) {
    var z = qr(x) ? Vo : nn.current;
    return z = rl(p, z), Vp(p, L), x = Ue(h, p, x, k, z, L), k = Ni(), h !== null && !Zo ? (p.updateQueue = h.updateQueue, p.flags &= -2053, h.lanes &= ~L, _i(h, p, L)) : (zr && k && $S(p), p.flags |= 1, Ei(h, p, x, L), p.child);
  }
  function dv(h, p, x, k, L) {
    if (qr(x)) {
      var z = !0;
      FS(p);
    } else z = !1;
    if (Vp(p, L), p.stateNode === null) fv(h, p), YP(p, x, k), tC(p, x, k, L), k = !0;
    else if (h === null) {
      var Y = p.stateNode, ae = p.memoizedProps;
      Y.props = ae;
      var he = Y.context, Ie = x.contextType;
      typeof Ie == "object" && Ie !== null ? Ie = ll(Ie) : (Ie = qr(x) ? Vo : nn.current, Ie = rl(p, Ie));
      var We = x.getDerivedStateFromProps, Ge = typeof We == "function" || typeof Y.getSnapshotBeforeUpdate == "function";
      Ge || typeof Y.UNSAFE_componentWillReceiveProps != "function" && typeof Y.componentWillReceiveProps != "function" || (ae !== k || he !== Ie) && XP(p, Y, k, Ie), Ad = !1;
      var Ve = p.memoizedState;
      Y.state = Ve, KS(p, k, Y, L), he = p.memoizedState, ae !== k || Ve !== he || mi.current || Ad ? (typeof We == "function" && (tf(p, x, We, k), he = p.memoizedState), (ae = Ad || KP(p, x, ae, k, Ve, he, Ie)) ? (Ge || typeof Y.UNSAFE_componentWillMount != "function" && typeof Y.componentWillMount != "function" || (typeof Y.componentWillMount == "function" && Y.componentWillMount(), typeof Y.UNSAFE_componentWillMount == "function" && Y.UNSAFE_componentWillMount()), typeof Y.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof Y.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = k, p.memoizedState = he), Y.props = k, Y.state = he, Y.context = Ie, k = ae) : (typeof Y.componentDidMount == "function" && (p.flags |= 4194308), k = !1);
    } else {
      Y = p.stateNode, Wp(h, p), ae = p.memoizedProps, Ie = p.type === p.elementType ? ae : qo(p.type, ae), Y.props = Ie, Ge = p.pendingProps, Ve = Y.context, he = x.contextType, typeof he == "object" && he !== null ? he = ll(he) : (he = qr(x) ? Vo : nn.current, he = rl(p, he));
      var dt = x.getDerivedStateFromProps;
      (We = typeof dt == "function" || typeof Y.getSnapshotBeforeUpdate == "function") || typeof Y.UNSAFE_componentWillReceiveProps != "function" && typeof Y.componentWillReceiveProps != "function" || (ae !== Ge || Ve !== he) && XP(p, Y, k, he), Ad = !1, Ve = p.memoizedState, Y.state = Ve, KS(p, k, Y, L);
      var St = p.memoizedState;
      ae !== Ge || Ve !== St || mi.current || Ad ? (typeof dt == "function" && (tf(p, x, dt, k), St = p.memoizedState), (Ie = Ad || KP(p, x, Ie, k, Ve, St, he) || !1) ? (We || typeof Y.UNSAFE_componentWillUpdate != "function" && typeof Y.componentWillUpdate != "function" || (typeof Y.componentWillUpdate == "function" && Y.componentWillUpdate(k, St, he), typeof Y.UNSAFE_componentWillUpdate == "function" && Y.UNSAFE_componentWillUpdate(k, St, he)), typeof Y.componentDidUpdate == "function" && (p.flags |= 4), typeof Y.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof Y.componentDidUpdate != "function" || ae === h.memoizedProps && Ve === h.memoizedState || (p.flags |= 4), typeof Y.getSnapshotBeforeUpdate != "function" || ae === h.memoizedProps && Ve === h.memoizedState || (p.flags |= 1024), p.memoizedProps = k, p.memoizedState = St), Y.props = k, Y.state = St, Y.context = he, k = Ie) : (typeof Y.componentDidUpdate != "function" || ae === h.memoizedProps && Ve === h.memoizedState || (p.flags |= 4), typeof Y.getSnapshotBeforeUpdate != "function" || ae === h.memoizedProps && Ve === h.memoizedState || (p.flags |= 1024), k = !1);
    }
    return fb(h, p, x, k, z, L);
  }
  function fb(h, p, x, k, L, z) {
    rf(h, p);
    var Y = (p.flags & 128) !== 0;
    if (!k && !Y) return L && jP(p, x, !1), _i(h, p, z);
    k = p.stateNode, eA.current = p;
    var ae = Y && typeof x.getDerivedStateFromError != "function" ? null : k.render();
    return p.flags |= 1, h !== null && Y ? (p.child = Hp(p, h.child, null, z), p.child = Hp(p, null, ae, z)) : Ei(h, p, ae, z), p.memoizedState = k.state, L && jP(p, x, !0), p.child;
  }
  function WD(h) {
    var p = h.stateNode;
    p.pendingContext ? Td(h, p.pendingContext, p.pendingContext !== p.context) : p.context && Td(h, p.context, !1), qw(h, p.containerInfo);
  }
  function tA(h, p, x, k, L) {
    return ai(), Kw(L), p.flags |= 256, Ei(h, p, x, k), p.child;
  }
  var hv = { dehydrated: null, treeContext: null, retryLane: 0 };
  function sf(h) {
    return { baseLanes: h, cachePool: null, transitions: null };
  }
  function nA(h, p, x) {
    var k = p.pendingProps, L = Zr.current, z = !1, Y = (p.flags & 128) !== 0, ae;
    if ((ae = Y) || (ae = h !== null && h.memoizedState === null ? !1 : (L & 2) !== 0), ae ? (z = !0, p.flags &= -129) : (h === null || h.memoizedState !== null) && (L |= 1), ur(Zr, L & 1), h === null)
      return US(p), h = p.memoizedState, h !== null && (h = h.dehydrated, h !== null) ? (p.mode & 1 ? h.data === "$!" ? p.lanes = 8 : p.lanes = 1073741824 : p.lanes = 1, null) : (Y = k.children, h = k.fallback, z ? (k = p.mode, z = p.child, Y = { mode: "hidden", children: Y }, !(k & 1) && z !== null ? (z.childLanes = 0, z.pendingProps = Y) : z = Ib(Y, k, 0, null), h = df(h, k, x, null), z.return = p, h.return = p, z.sibling = h, p.child = z, p.child.memoizedState = sf(x), p.memoizedState = hv, h) : pb(p, Y));
    if (L = h.memoizedState, L !== null && (ae = L.dehydrated, ae !== null)) return iC(h, p, Y, k, ae, L, x);
    if (z) {
      z = k.fallback, Y = p.mode, L = h.child, ae = L.sibling;
      var he = { mode: "hidden", children: k.children };
      return !(Y & 1) && p.child !== L ? (k = p.child, k.childLanes = 0, k.pendingProps = he, p.deletions = null) : (k = Ld(L, he), k.subtreeFlags = L.subtreeFlags & 14680064), ae !== null ? z = Ld(ae, z) : (z = df(z, Y, x, null), z.flags |= 2), z.return = p, k.return = p, k.sibling = z, p.child = k, k = z, z = p.child, Y = h.child.memoizedState, Y = Y === null ? sf(x) : { baseLanes: Y.baseLanes | x, cachePool: null, transitions: Y.transitions }, z.memoizedState = Y, z.childLanes = h.childLanes & ~x, p.memoizedState = hv, k;
    }
    return z = h.child, h = z.sibling, k = Ld(z, { mode: "visible", children: k.children }), !(p.mode & 1) && (k.lanes = x), k.return = p, k.sibling = null, h !== null && (x = p.deletions, x === null ? (p.deletions = [h], p.flags |= 16) : x.push(h)), p.child = k, p.memoizedState = null, k;
  }
  function pb(h, p) {
    return p = Ib({ mode: "visible", children: p }, h.mode, 0, null), p.return = h, h.child = p;
  }
  function gb(h, p, x, k) {
    return k !== null && Kw(k), Hp(p, h.child, null, x), h = pb(p, p.pendingProps.children), h.flags |= 2, p.memoizedState = null, h;
  }
  function iC(h, p, x, k, L, z, Y) {
    if (x)
      return p.flags & 256 ? (p.flags &= -257, k = nC(Error(e(422))), gb(h, p, Y, k)) : p.memoizedState !== null ? (p.child = h.child, p.flags |= 128, null) : (z = k.fallback, L = p.mode, k = Ib({ mode: "visible", children: k.children }, L, 0, null), z = df(z, L, Y, null), z.flags |= 2, k.return = p, z.return = p, k.sibling = z, p.child = k, p.mode & 1 && Hp(p, h.child, null, Y), p.child.memoizedState = sf(Y), p.memoizedState = hv, z);
    if (!(p.mode & 1)) return gb(h, p, Y, null);
    if (L.data === "$!") {
      if (k = L.nextSibling && L.nextSibling.dataset, k) var ae = k.dgst;
      return k = ae, z = Error(e(419)), k = nC(z, k, void 0), gb(h, p, Y, k);
    }
    if (ae = (Y & h.childLanes) !== 0, Zo || ae) {
      if (k = yi, k !== null) {
        switch (Y & -Y) {
          case 4:
            L = 2;
            break;
          case 16:
            L = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            L = 32;
            break;
          case 536870912:
            L = 268435456;
            break;
          default:
            L = 0;
        }
        L = L & (k.suspendedLanes | Y) ? 0 : L, L !== 0 && L !== z.retryLane && (z.retryLane = L, Eu(h, L), li(k, h, L, -1));
      }
      return yv(), k = nC(Error(e(421))), gb(h, p, Y, k);
    }
    return L.data === "$?" ? (p.flags |= 128, p.child = h.child, p = gC.bind(null, h), L._reactRetry = p, null) : (h = z.treeContext, Yo = Xl(L.nextSibling), Pa = p, zr = !0, ol = null, h !== null && (Ko[Hs++] = Cs, Ko[Hs++] = wu, Ko[Hs++] = sl, Cs = h.id, wu = h.overflow, sl = p), p = pb(p, k.children), p.flags |= 4096, p);
  }
  function rA(h, p, x) {
    h.lanes |= p;
    var k = h.alternate;
    k !== null && (k.lanes |= p), Xw(h.return, p, x);
  }
  function mb(h, p, x, k, L) {
    var z = h.memoizedState;
    z === null ? h.memoizedState = { isBackwards: p, rendering: null, renderingStartTime: 0, last: k, tail: x, tailMode: L } : (z.isBackwards = p, z.rendering = null, z.renderingStartTime = 0, z.last = k, z.tail = x, z.tailMode = L);
  }
  function sC(h, p, x) {
    var k = p.pendingProps, L = k.revealOrder, z = k.tail;
    if (Ei(h, p, k.children, x), k = Zr.current, k & 2) k = k & 1 | 2, p.flags |= 128;
    else {
      if (h !== null && h.flags & 128) e: for (h = p.child; h !== null; ) {
        if (h.tag === 13) h.memoizedState !== null && rA(h, x, p);
        else if (h.tag === 19) rA(h, x, p);
        else if (h.child !== null) {
          h.child.return = h, h = h.child;
          continue;
        }
        if (h === p) break e;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === p) break e;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
      k &= 1;
    }
    if (ur(Zr, k), !(p.mode & 1)) p.memoizedState = null;
    else switch (L) {
      case "forwards":
        for (x = p.child, L = null; x !== null; ) h = x.alternate, h !== null && YS(h) === null && (L = x), x = x.sibling;
        x = L, x === null ? (L = p.child, p.child = null) : (L = x.sibling, x.sibling = null), mb(p, !1, L, x, z);
        break;
      case "backwards":
        for (x = null, L = p.child, p.child = null; L !== null; ) {
          if (h = L.alternate, h !== null && YS(h) === null) {
            p.child = L;
            break;
          }
          h = L.sibling, L.sibling = x, x = L, L = h;
        }
        mb(p, !0, x, null, z);
        break;
      case "together":
        mb(p, !1, null, null, void 0);
        break;
      default:
        p.memoizedState = null;
    }
    return p.child;
  }
  function fv(h, p) {
    !(p.mode & 1) && h !== null && (h.alternate = null, p.alternate = null, p.flags |= 2);
  }
  function _i(h, p, x) {
    if (h !== null && (p.dependencies = h.dependencies), af |= p.lanes, !(x & p.childLanes)) return null;
    if (h !== null && p.child !== h.child) throw Error(e(153));
    if (p.child !== null) {
      for (h = p.child, x = Ld(h, h.pendingProps), p.child = x, x.return = p; h.sibling !== null; ) h = h.sibling, x = x.sibling = Ld(h, h.pendingProps), x.return = p;
      x.sibling = null;
    }
    return p.child;
  }
  function Tu(h, p, x) {
    switch (p.tag) {
      case 3:
        WD(p), ai();
        break;
      case 5:
        WP(p);
        break;
      case 1:
        qr(p.type) && FS(p);
        break;
      case 4:
        qw(p, p.stateNode.containerInfo);
        break;
      case 10:
        var k = p.type._context, L = p.memoizedProps.value;
        ur(Cu, k._currentValue), k._currentValue = L;
        break;
      case 13:
        if (k = p.memoizedState, k !== null)
          return k.dehydrated !== null ? (ur(Zr, Zr.current & 1), p.flags |= 128, null) : x & p.child.childLanes ? nA(h, p, x) : (ur(Zr, Zr.current & 1), h = _i(h, p, x), h !== null ? h.sibling : null);
        ur(Zr, Zr.current & 1);
        break;
      case 19:
        if (k = (x & p.childLanes) !== 0, h.flags & 128) {
          if (k) return sC(h, p, x);
          p.flags |= 128;
        }
        if (L = p.memoizedState, L !== null && (L.rendering = null, L.tail = null, L.lastEffect = null), ur(Zr, Zr.current), k) break;
        return null;
      case 22:
      case 23:
        return p.lanes = 0, Qo(h, p, x);
    }
    return _i(h, p, x);
  }
  var jc, ng, rg, ul;
  jc = function(h, p) {
    for (var x = p.child; x !== null; ) {
      if (x.tag === 5 || x.tag === 6) h.appendChild(x.stateNode);
      else if (x.tag !== 4 && x.child !== null) {
        x.child.return = x, x = x.child;
        continue;
      }
      if (x === p) break;
      for (; x.sibling === null; ) {
        if (x.return === null || x.return === p) return;
        x = x.return;
      }
      x.sibling.return = x.return, x = x.sibling;
    }
  }, ng = function() {
  }, rg = function(h, p, x, k) {
    var L = h.memoizedProps;
    if (L !== k) {
      h = p.stateNode, Zh(ql.current);
      var z = null;
      switch (x) {
        case "input":
          L = Ut(h, L), k = Ut(h, k), z = [];
          break;
        case "select":
          L = ke({}, L, { value: void 0 }), k = ke({}, k, { value: void 0 }), z = [];
          break;
        case "textarea":
          L = es(h, L), k = es(h, k), z = [];
          break;
        default:
          typeof L.onClick != "function" && typeof k.onClick == "function" && (h.onclick = NS);
      }
      Yr(x, k);
      var Y;
      x = null;
      for (Ie in L) if (!k.hasOwnProperty(Ie) && L.hasOwnProperty(Ie) && L[Ie] != null) if (Ie === "style") {
        var ae = L[Ie];
        for (Y in ae) ae.hasOwnProperty(Y) && (x || (x = {}), x[Y] = "");
      } else Ie !== "dangerouslySetInnerHTML" && Ie !== "children" && Ie !== "suppressContentEditableWarning" && Ie !== "suppressHydrationWarning" && Ie !== "autoFocus" && (i.hasOwnProperty(Ie) ? z || (z = []) : (z = z || []).push(Ie, null));
      for (Ie in k) {
        var he = k[Ie];
        if (ae = L != null ? L[Ie] : void 0, k.hasOwnProperty(Ie) && he !== ae && (he != null || ae != null)) if (Ie === "style") if (ae) {
          for (Y in ae) !ae.hasOwnProperty(Y) || he && he.hasOwnProperty(Y) || (x || (x = {}), x[Y] = "");
          for (Y in he) he.hasOwnProperty(Y) && ae[Y] !== he[Y] && (x || (x = {}), x[Y] = he[Y]);
        } else x || (z || (z = []), z.push(
          Ie,
          x
        )), x = he;
        else Ie === "dangerouslySetInnerHTML" ? (he = he ? he.__html : void 0, ae = ae ? ae.__html : void 0, he != null && ae !== he && (z = z || []).push(Ie, he)) : Ie === "children" ? typeof he != "string" && typeof he != "number" || (z = z || []).push(Ie, "" + he) : Ie !== "suppressContentEditableWarning" && Ie !== "suppressHydrationWarning" && (i.hasOwnProperty(Ie) ? (he != null && Ie === "onScroll" && _r("scroll", h), z || ae === he || (z = [])) : (z = z || []).push(Ie, he));
      }
      x && (z = z || []).push("style", x);
      var Ie = z;
      (p.updateQueue = Ie) && (p.flags |= 4);
    }
  }, ul = function(h, p, x, k) {
    x !== k && (p.flags |= 4);
  };
  function vi(h, p) {
    if (!zr) switch (h.tailMode) {
      case "hidden":
        p = h.tail;
        for (var x = null; p !== null; ) p.alternate !== null && (x = p), p = p.sibling;
        x === null ? h.tail = null : x.sibling = null;
        break;
      case "collapsed":
        x = h.tail;
        for (var k = null; x !== null; ) x.alternate !== null && (k = x), x = x.sibling;
        k === null ? p || h.tail === null ? h.tail = null : h.tail.sibling = null : k.sibling = null;
    }
  }
  function Gs(h) {
    var p = h.alternate !== null && h.alternate.child === h.child, x = 0, k = 0;
    if (p) for (var L = h.child; L !== null; ) x |= L.lanes | L.childLanes, k |= L.subtreeFlags & 14680064, k |= L.flags & 14680064, L.return = h, L = L.sibling;
    else for (L = h.child; L !== null; ) x |= L.lanes | L.childLanes, k |= L.subtreeFlags, k |= L.flags, L.return = h, L = L.sibling;
    return h.subtreeFlags |= k, h.childLanes = x, p;
  }
  function GD(h, p, x) {
    var k = p.pendingProps;
    switch (Ww(p), p.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Gs(p), null;
      case 1:
        return qr(p.type) && il(), Gs(p), null;
      case 3:
        return k = p.stateNode, Kp(), or(mi), or(nn), Qw(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (h === null || h.child === null) && (BS(p) ? p.flags |= 4 : h === null || h.memoizedState.isDehydrated && !(p.flags & 256) || (p.flags |= 1024, ol !== null && (hC(ol), ol = null))), ng(h, p), Gs(p), null;
      case 5:
        Zw(p);
        var L = Zh(rv.current);
        if (x = p.type, h !== null && p.stateNode != null) rg(h, p, x, k, L), h.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152);
        else {
          if (!k) {
            if (p.stateNode === null) throw Error(e(166));
            return Gs(p), null;
          }
          if (h = Zh(ql.current), BS(p)) {
            k = p.stateNode, x = p.type;
            var z = p.memoizedProps;
            switch (k[Dc] = p, k[Kh] = z, h = (p.mode & 1) !== 0, x) {
              case "dialog":
                _r("cancel", k), _r("close", k);
                break;
              case "iframe":
              case "object":
              case "embed":
                _r("load", k);
                break;
              case "video":
              case "audio":
                for (L = 0; L < Ym.length; L++) _r(Ym[L], k);
                break;
              case "source":
                _r("error", k);
                break;
              case "img":
              case "image":
              case "link":
                _r(
                  "error",
                  k
                ), _r("load", k);
                break;
              case "details":
                _r("toggle", k);
                break;
              case "input":
                jt(k, z), _r("invalid", k);
                break;
              case "select":
                k._wrapperState = { wasMultiple: !!z.multiple }, _r("invalid", k);
                break;
              case "textarea":
                Di(k, z), _r("invalid", k);
            }
            Yr(x, z), L = null;
            for (var Y in z) if (z.hasOwnProperty(Y)) {
              var ae = z[Y];
              Y === "children" ? typeof ae == "string" ? k.textContent !== ae && (z.suppressHydrationWarning !== !0 && jS(k.textContent, ae, h), L = ["children", ae]) : typeof ae == "number" && k.textContent !== "" + ae && (z.suppressHydrationWarning !== !0 && jS(
                k.textContent,
                ae,
                h
              ), L = ["children", "" + ae]) : i.hasOwnProperty(Y) && ae != null && Y === "onScroll" && _r("scroll", k);
            }
            switch (x) {
              case "input":
                Yt(k), hi(k, z, !0);
                break;
              case "textarea":
                Yt(k), wi(k);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof z.onClick == "function" && (k.onclick = NS);
            }
            k = L, p.updateQueue = k, k !== null && (p.flags |= 4);
          } else {
            Y = L.nodeType === 9 ? L : L.ownerDocument, h === "http://www.w3.org/1999/xhtml" && (h = ts(x)), h === "http://www.w3.org/1999/xhtml" ? x === "script" ? (h = Y.createElement("div"), h.innerHTML = "<script><\/script>", h = h.removeChild(h.firstChild)) : typeof k.is == "string" ? h = Y.createElement(x, { is: k.is }) : (h = Y.createElement(x), x === "select" && (Y = h, k.multiple ? Y.multiple = !0 : k.size && (Y.size = k.size))) : h = Y.createElementNS(h, x), h[Dc] = p, h[Kh] = k, jc(h, p, !1, !1), p.stateNode = h;
            e: {
              switch (Y = kr(x, k), x) {
                case "dialog":
                  _r("cancel", h), _r("close", h), L = k;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  _r("load", h), L = k;
                  break;
                case "video":
                case "audio":
                  for (L = 0; L < Ym.length; L++) _r(Ym[L], h);
                  L = k;
                  break;
                case "source":
                  _r("error", h), L = k;
                  break;
                case "img":
                case "image":
                case "link":
                  _r(
                    "error",
                    h
                  ), _r("load", h), L = k;
                  break;
                case "details":
                  _r("toggle", h), L = k;
                  break;
                case "input":
                  jt(h, k), L = Ut(h, k), _r("invalid", h);
                  break;
                case "option":
                  L = k;
                  break;
                case "select":
                  h._wrapperState = { wasMultiple: !!k.multiple }, L = ke({}, k, { value: void 0 }), _r("invalid", h);
                  break;
                case "textarea":
                  Di(h, k), L = es(h, k), _r("invalid", h);
                  break;
                default:
                  L = k;
              }
              Yr(x, L), ae = L;
              for (z in ae) if (ae.hasOwnProperty(z)) {
                var he = ae[z];
                z === "style" ? Bn(h, he) : z === "dangerouslySetInnerHTML" ? (he = he ? he.__html : void 0, he != null && ns(h, he)) : z === "children" ? typeof he == "string" ? (x !== "textarea" || he !== "") && vr(h, he) : typeof he == "number" && vr(h, "" + he) : z !== "suppressContentEditableWarning" && z !== "suppressHydrationWarning" && z !== "autoFocus" && (i.hasOwnProperty(z) ? he != null && z === "onScroll" && _r("scroll", h) : he != null && M(h, z, he, Y));
              }
              switch (x) {
                case "input":
                  Yt(h), hi(h, k, !1);
                  break;
                case "textarea":
                  Yt(h), wi(h);
                  break;
                case "option":
                  k.value != null && h.setAttribute("value", "" + tt(k.value));
                  break;
                case "select":
                  h.multiple = !!k.multiple, z = k.value, z != null ? oi(h, !!k.multiple, z, !1) : k.defaultValue != null && oi(
                    h,
                    !!k.multiple,
                    k.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof L.onClick == "function" && (h.onclick = NS);
              }
              switch (x) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k = !!k.autoFocus;
                  break e;
                case "img":
                  k = !0;
                  break e;
                default:
                  k = !1;
              }
            }
            k && (p.flags |= 4);
          }
          p.ref !== null && (p.flags |= 512, p.flags |= 2097152);
        }
        return Gs(p), null;
      case 6:
        if (h && p.stateNode != null) ul(h, p, h.memoizedProps, k);
        else {
          if (typeof k != "string" && p.stateNode === null) throw Error(e(166));
          if (x = Zh(rv.current), Zh(ql.current), BS(p)) {
            if (k = p.stateNode, x = p.memoizedProps, k[Dc] = p, (z = k.nodeValue !== x) && (h = Pa, h !== null)) switch (h.tag) {
              case 3:
                jS(k.nodeValue, x, (h.mode & 1) !== 0);
                break;
              case 5:
                h.memoizedProps.suppressHydrationWarning !== !0 && jS(k.nodeValue, x, (h.mode & 1) !== 0);
            }
            z && (p.flags |= 4);
          } else k = (x.nodeType === 9 ? x : x.ownerDocument).createTextNode(k), k[Dc] = p, p.stateNode = k;
        }
        return Gs(p), null;
      case 13:
        if (or(Zr), k = p.memoizedState, h === null || h.memoizedState !== null && h.memoizedState.dehydrated !== null) {
          if (zr && Yo !== null && p.mode & 1 && !(p.flags & 128)) $P(), ai(), p.flags |= 98560, z = !1;
          else if (z = BS(p), k !== null && k.dehydrated !== null) {
            if (h === null) {
              if (!z) throw Error(e(318));
              if (z = p.memoizedState, z = z !== null ? z.dehydrated : null, !z) throw Error(e(317));
              z[Dc] = p;
            } else ai(), !(p.flags & 128) && (p.memoizedState = null), p.flags |= 4;
            Gs(p), z = !1;
          } else ol !== null && (hC(ol), ol = null), z = !0;
          if (!z) return p.flags & 65536 ? p : null;
        }
        return p.flags & 128 ? (p.lanes = x, p) : (k = k !== null, k !== (h !== null && h.memoizedState !== null) && k && (p.child.flags |= 8192, p.mode & 1 && (h === null || Zr.current & 1 ? Vi === 0 && (Vi = 3) : yv())), p.updateQueue !== null && (p.flags |= 4), Gs(p), null);
      case 4:
        return Kp(), ng(h, p), h === null && zp(p.stateNode.containerInfo), Gs(p), null;
      case 10:
        return Yw(p.type._context), Gs(p), null;
      case 17:
        return qr(p.type) && il(), Gs(p), null;
      case 19:
        if (or(Zr), z = p.memoizedState, z === null) return Gs(p), null;
        if (k = (p.flags & 128) !== 0, Y = z.rendering, Y === null) if (k) vi(z, !1);
        else {
          if (Vi !== 0 || h !== null && h.flags & 128) for (h = p.child; h !== null; ) {
            if (Y = YS(h), Y !== null) {
              for (p.flags |= 128, vi(z, !1), k = Y.updateQueue, k !== null && (p.updateQueue = k, p.flags |= 4), p.subtreeFlags = 0, k = x, x = p.child; x !== null; ) z = x, h = k, z.flags &= 14680066, Y = z.alternate, Y === null ? (z.childLanes = 0, z.lanes = h, z.child = null, z.subtreeFlags = 0, z.memoizedProps = null, z.memoizedState = null, z.updateQueue = null, z.dependencies = null, z.stateNode = null) : (z.childLanes = Y.childLanes, z.lanes = Y.lanes, z.child = Y.child, z.subtreeFlags = 0, z.deletions = null, z.memoizedProps = Y.memoizedProps, z.memoizedState = Y.memoizedState, z.updateQueue = Y.updateQueue, z.type = Y.type, h = Y.dependencies, z.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }), x = x.sibling;
              return ur(Zr, Zr.current & 1 | 2), p.child;
            }
            h = h.sibling;
          }
          z.tail !== null && Hn() > fg && (p.flags |= 128, k = !0, vi(z, !1), p.lanes = 4194304);
        }
        else {
          if (!k) if (h = YS(Y), h !== null) {
            if (p.flags |= 128, k = !0, x = h.updateQueue, x !== null && (p.updateQueue = x, p.flags |= 4), vi(z, !0), z.tail === null && z.tailMode === "hidden" && !Y.alternate && !zr) return Gs(p), null;
          } else 2 * Hn() - z.renderingStartTime > fg && x !== 1073741824 && (p.flags |= 128, k = !0, vi(z, !1), p.lanes = 4194304);
          z.isBackwards ? (Y.sibling = p.child, p.child = Y) : (x = z.last, x !== null ? x.sibling = Y : p.child = Y, z.last = Y);
        }
        return z.tail !== null ? (p = z.tail, z.rendering = p, z.tail = p.sibling, z.renderingStartTime = Hn(), p.sibling = null, x = Zr.current, ur(Zr, k ? x & 1 | 2 : x & 1), p) : (Gs(p), null);
      case 22:
      case 23:
        return Pb(), k = p.memoizedState !== null, h !== null && h.memoizedState !== null !== k && (p.flags |= 8192), k && p.mode & 1 ? Jo & 1073741824 && (Gs(p), p.subtreeFlags & 6 && (p.flags |= 8192)) : Gs(p), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(e(156, p.tag));
  }
  function KD(h, p) {
    switch (Ww(p), p.tag) {
      case 1:
        return qr(p.type) && il(), h = p.flags, h & 65536 ? (p.flags = h & -65537 | 128, p) : null;
      case 3:
        return Kp(), or(mi), or(nn), Qw(), h = p.flags, h & 65536 && !(h & 128) ? (p.flags = h & -65537 | 128, p) : null;
      case 5:
        return Zw(p), null;
      case 13:
        if (or(Zr), h = p.memoizedState, h !== null && h.dehydrated !== null) {
          if (p.alternate === null) throw Error(e(340));
          ai();
        }
        return h = p.flags, h & 65536 ? (p.flags = h & -65537 | 128, p) : null;
      case 19:
        return or(Zr), null;
      case 4:
        return Kp(), null;
      case 10:
        return Yw(p.type._context), null;
      case 22:
      case 23:
        return Pb(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ig = !1, _s = !1, vb = typeof WeakSet == "function" ? WeakSet : Set, gt = null;
  function sg(h, p) {
    var x = h.ref;
    if (x !== null) if (typeof x == "function") try {
      x(null);
    } catch (k) {
      Si(h, p, k);
    }
    else x.current = null;
  }
  function oC(h, p, x) {
    try {
      x();
    } catch (k) {
      Si(h, p, k);
    }
  }
  var yb = !1;
  function YD(h, p) {
    if (Nw = ve, h = RS(), yu(h)) {
      if ("selectionStart" in h) var x = { start: h.selectionStart, end: h.selectionEnd };
      else e: {
        x = (x = h.ownerDocument) && x.defaultView || window;
        var k = x.getSelection && x.getSelection();
        if (k && k.rangeCount !== 0) {
          x = k.anchorNode;
          var L = k.anchorOffset, z = k.focusNode;
          k = k.focusOffset;
          try {
            x.nodeType, z.nodeType;
          } catch {
            x = null;
            break e;
          }
          var Y = 0, ae = -1, he = -1, Ie = 0, We = 0, Ge = h, Ve = null;
          t: for (; ; ) {
            for (var dt; Ge !== x || L !== 0 && Ge.nodeType !== 3 || (ae = Y + L), Ge !== z || k !== 0 && Ge.nodeType !== 3 || (he = Y + k), Ge.nodeType === 3 && (Y += Ge.nodeValue.length), (dt = Ge.firstChild) !== null; )
              Ve = Ge, Ge = dt;
            for (; ; ) {
              if (Ge === h) break t;
              if (Ve === x && ++Ie === L && (ae = Y), Ve === z && ++We === k && (he = Y), (dt = Ge.nextSibling) !== null) break;
              Ge = Ve, Ve = Ge.parentNode;
            }
            Ge = dt;
          }
          x = ae === -1 || he === -1 ? null : { start: ae, end: he };
        } else x = null;
      }
      x = x || { start: 0, end: 0 };
    } else x = null;
    for (Wh = { focusedElem: h, selectionRange: x }, ve = !1, gt = p; gt !== null; ) if (p = gt, h = p.child, (p.subtreeFlags & 1028) !== 0 && h !== null) h.return = p, gt = h;
    else for (; gt !== null; ) {
      p = gt;
      try {
        var St = p.alternate;
        if (p.flags & 1024) switch (p.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (St !== null) {
              var _t = St.memoizedProps, Ti = St.memoizedState, xe = p.stateNode, ge = xe.getSnapshotBeforeUpdate(p.elementType === p.type ? _t : qo(p.type, _t), Ti);
              xe.__reactInternalSnapshotBeforeUpdate = ge;
            }
            break;
          case 3:
            var Te = p.stateNode.containerInfo;
            Te.nodeType === 1 ? Te.textContent = "" : Te.nodeType === 9 && Te.documentElement && Te.removeChild(Te.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(e(163));
        }
      } catch (qe) {
        Si(p, p.return, qe);
      }
      if (h = p.sibling, h !== null) {
        h.return = p.return, gt = h;
        break;
      }
      gt = p.return;
    }
    return St = yb, yb = !1, St;
  }
  function og(h, p, x) {
    var k = p.updateQueue;
    if (k = k !== null ? k.lastEffect : null, k !== null) {
      var L = k = k.next;
      do {
        if ((L.tag & h) === h) {
          var z = L.destroy;
          L.destroy = void 0, z !== void 0 && oC(p, x, z);
        }
        L = L.next;
      } while (L !== k);
    }
  }
  function Sb(h, p) {
    if (p = p.updateQueue, p = p !== null ? p.lastEffect : null, p !== null) {
      var x = p = p.next;
      do {
        if ((x.tag & h) === h) {
          var k = x.create;
          x.destroy = k();
        }
        x = x.next;
      } while (x !== p);
    }
  }
  function bb(h) {
    var p = h.ref;
    if (p !== null) {
      var x = h.stateNode;
      switch (h.tag) {
        case 5:
          h = x;
          break;
        default:
          h = x;
      }
      typeof p == "function" ? p(h) : p.current = h;
    }
  }
  function iA(h) {
    var p = h.alternate;
    p !== null && (h.alternate = null, iA(p)), h.child = null, h.deletions = null, h.sibling = null, h.tag === 5 && (p = h.stateNode, p !== null && (delete p[Dc], delete p[Kh], delete p[zw], delete p[BD], delete p[Uw])), h.stateNode = null, h.return = null, h.dependencies = null, h.memoizedProps = null, h.memoizedState = null, h.pendingProps = null, h.stateNode = null, h.updateQueue = null;
  }
  function aC(h) {
    return h.tag === 5 || h.tag === 3 || h.tag === 4;
  }
  function sA(h) {
    e: for (; ; ) {
      for (; h.sibling === null; ) {
        if (h.return === null || aC(h.return)) return null;
        h = h.return;
      }
      for (h.sibling.return = h.return, h = h.sibling; h.tag !== 5 && h.tag !== 6 && h.tag !== 18; ) {
        if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
        h.child.return = h, h = h.child;
      }
      if (!(h.flags & 2)) return h.stateNode;
    }
  }
  function pv(h, p, x) {
    var k = h.tag;
    if (k === 5 || k === 6) h = h.stateNode, p ? x.nodeType === 8 ? x.parentNode.insertBefore(h, p) : x.insertBefore(h, p) : (x.nodeType === 8 ? (p = x.parentNode, p.insertBefore(h, x)) : (p = x, p.appendChild(h)), x = x._reactRootContainer, x != null || p.onclick !== null || (p.onclick = NS));
    else if (k !== 4 && (h = h.child, h !== null)) for (pv(h, p, x), h = h.sibling; h !== null; ) pv(h, p, x), h = h.sibling;
  }
  function ag(h, p, x) {
    var k = h.tag;
    if (k === 5 || k === 6) h = h.stateNode, p ? x.insertBefore(h, p) : x.appendChild(h);
    else if (k !== 4 && (h = h.child, h !== null)) for (ag(h, p, x), h = h.sibling; h !== null; ) ag(h, p, x), h = h.sibling;
  }
  var Qr = null, fs = !1;
  function ho(h, p, x) {
    for (x = x.child; x !== null; ) lg(h, p, x), x = x.sibling;
  }
  function lg(h, p, x) {
    if (Us && typeof Us.onCommitFiberUnmount == "function") try {
      Us.onCommitFiberUnmount(Pc, x);
    } catch {
    }
    switch (x.tag) {
      case 5:
        _s || sg(x, p);
      case 6:
        var k = Qr, L = fs;
        Qr = null, ho(h, p, x), Qr = k, fs = L, Qr !== null && (fs ? (h = Qr, x = x.stateNode, h.nodeType === 8 ? h.parentNode.removeChild(x) : h.removeChild(x)) : Qr.removeChild(x.stateNode));
        break;
      case 18:
        Qr !== null && (fs ? (h = Qr, x = x.stateNode, h.nodeType === 8 ? Cd(h.parentNode, x) : h.nodeType === 1 && Cd(h, x), Mc(h)) : Cd(Qr, x.stateNode));
        break;
      case 4:
        k = Qr, L = fs, Qr = x.stateNode.containerInfo, fs = !0, ho(h, p, x), Qr = k, fs = L;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!_s && (k = x.updateQueue, k !== null && (k = k.lastEffect, k !== null))) {
          L = k = k.next;
          do {
            var z = L, Y = z.destroy;
            z = z.tag, Y !== void 0 && (z & 2 || z & 4) && oC(x, p, Y), L = L.next;
          } while (L !== k);
        }
        ho(h, p, x);
        break;
      case 1:
        if (!_s && (sg(x, p), k = x.stateNode, typeof k.componentWillUnmount == "function")) try {
          k.props = x.memoizedProps, k.state = x.memoizedState, k.componentWillUnmount();
        } catch (ae) {
          Si(x, p, ae);
        }
        ho(h, p, x);
        break;
      case 21:
        ho(h, p, x);
        break;
      case 22:
        x.mode & 1 ? (_s = (k = _s) || x.memoizedState !== null, ho(h, p, x), _s = k) : ho(h, p, x);
        break;
      default:
        ho(h, p, x);
    }
  }
  function cg(h) {
    var p = h.updateQueue;
    if (p !== null) {
      h.updateQueue = null;
      var x = h.stateNode;
      x === null && (x = h.stateNode = new vb()), p.forEach(function(k) {
        var L = tO.bind(null, h, k);
        x.has(k) || (x.add(k), k.then(L, L));
      });
    }
  }
  function ps(h, p) {
    var x = p.deletions;
    if (x !== null) for (var k = 0; k < x.length; k++) {
      var L = x[k];
      try {
        var z = h, Y = p, ae = Y;
        e: for (; ae !== null; ) {
          switch (ae.tag) {
            case 5:
              Qr = ae.stateNode, fs = !1;
              break e;
            case 3:
              Qr = ae.stateNode.containerInfo, fs = !0;
              break e;
            case 4:
              Qr = ae.stateNode.containerInfo, fs = !0;
              break e;
          }
          ae = ae.return;
        }
        if (Qr === null) throw Error(e(160));
        lg(z, Y, L), Qr = null, fs = !1;
        var he = L.alternate;
        he !== null && (he.return = null), L.return = null;
      } catch (Ie) {
        Si(L, p, Ie);
      }
    }
    if (p.subtreeFlags & 12854) for (p = p.child; p !== null; ) oA(p, h), p = p.sibling;
  }
  function oA(h, p) {
    var x = h.alternate, k = h.flags;
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ps(p, h), Nc(h), k & 4) {
          try {
            og(3, h, h.return), Sb(3, h);
          } catch (_t) {
            Si(h, h.return, _t);
          }
          try {
            og(5, h, h.return);
          } catch (_t) {
            Si(h, h.return, _t);
          }
        }
        break;
      case 1:
        ps(p, h), Nc(h), k & 512 && x !== null && sg(x, x.return);
        break;
      case 5:
        if (ps(p, h), Nc(h), k & 512 && x !== null && sg(x, x.return), h.flags & 32) {
          var L = h.stateNode;
          try {
            vr(L, "");
          } catch (_t) {
            Si(h, h.return, _t);
          }
        }
        if (k & 4 && (L = h.stateNode, L != null)) {
          var z = h.memoizedProps, Y = x !== null ? x.memoizedProps : z, ae = h.type, he = h.updateQueue;
          if (h.updateQueue = null, he !== null) try {
            ae === "input" && z.type === "radio" && z.name != null && $t(L, z), kr(ae, Y);
            var Ie = kr(ae, z);
            for (Y = 0; Y < he.length; Y += 2) {
              var We = he[Y], Ge = he[Y + 1];
              We === "style" ? Bn(L, Ge) : We === "dangerouslySetInnerHTML" ? ns(L, Ge) : We === "children" ? vr(L, Ge) : M(L, We, Ge, Ie);
            }
            switch (ae) {
              case "input":
                yn(L, z);
                break;
              case "textarea":
                Ss(L, z);
                break;
              case "select":
                var Ve = L._wrapperState.wasMultiple;
                L._wrapperState.wasMultiple = !!z.multiple;
                var dt = z.value;
                dt != null ? oi(L, !!z.multiple, dt, !1) : Ve !== !!z.multiple && (z.defaultValue != null ? oi(
                  L,
                  !!z.multiple,
                  z.defaultValue,
                  !0
                ) : oi(L, !!z.multiple, z.multiple ? [] : "", !1));
            }
            L[Kh] = z;
          } catch (_t) {
            Si(h, h.return, _t);
          }
        }
        break;
      case 6:
        if (ps(p, h), Nc(h), k & 4) {
          if (h.stateNode === null) throw Error(e(162));
          L = h.stateNode, z = h.memoizedProps;
          try {
            L.nodeValue = z;
          } catch (_t) {
            Si(h, h.return, _t);
          }
        }
        break;
      case 3:
        if (ps(p, h), Nc(h), k & 4 && x !== null && x.memoizedState.isDehydrated) try {
          Mc(p.containerInfo);
        } catch (_t) {
          Si(h, h.return, _t);
        }
        break;
      case 4:
        ps(p, h), Nc(h);
        break;
      case 13:
        ps(p, h), Nc(h), L = h.child, L.flags & 8192 && (z = L.memoizedState !== null, L.stateNode.isHidden = z, !z || L.alternate !== null && L.alternate.memoizedState !== null || (wb = Hn())), k & 4 && cg(h);
        break;
      case 22:
        if (We = x !== null && x.memoizedState !== null, h.mode & 1 ? (_s = (Ie = _s) || We, ps(p, h), _s = Ie) : ps(p, h), Nc(h), k & 8192) {
          if (Ie = h.memoizedState !== null, (h.stateNode.isHidden = Ie) && !We && h.mode & 1) for (gt = h, We = h.child; We !== null; ) {
            for (Ge = gt = We; gt !== null; ) {
              switch (Ve = gt, dt = Ve.child, Ve.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  og(4, Ve, Ve.return);
                  break;
                case 1:
                  sg(Ve, Ve.return);
                  var St = Ve.stateNode;
                  if (typeof St.componentWillUnmount == "function") {
                    k = Ve, x = Ve.return;
                    try {
                      p = k, St.props = p.memoizedProps, St.state = p.memoizedState, St.componentWillUnmount();
                    } catch (_t) {
                      Si(k, x, _t);
                    }
                  }
                  break;
                case 5:
                  sg(Ve, Ve.return);
                  break;
                case 22:
                  if (Ve.memoizedState !== null) {
                    aA(Ge);
                    continue;
                  }
              }
              dt !== null ? (dt.return = Ve, gt = dt) : aA(Ge);
            }
            We = We.sibling;
          }
          e: for (We = null, Ge = h; ; ) {
            if (Ge.tag === 5) {
              if (We === null) {
                We = Ge;
                try {
                  L = Ge.stateNode, Ie ? (z = L.style, typeof z.setProperty == "function" ? z.setProperty("display", "none", "important") : z.display = "none") : (ae = Ge.stateNode, he = Ge.memoizedProps.style, Y = he != null && he.hasOwnProperty("display") ? he.display : null, ae.style.display = hn("display", Y));
                } catch (_t) {
                  Si(h, h.return, _t);
                }
              }
            } else if (Ge.tag === 6) {
              if (We === null) try {
                Ge.stateNode.nodeValue = Ie ? "" : Ge.memoizedProps;
              } catch (_t) {
                Si(h, h.return, _t);
              }
            } else if ((Ge.tag !== 22 && Ge.tag !== 23 || Ge.memoizedState === null || Ge === h) && Ge.child !== null) {
              Ge.child.return = Ge, Ge = Ge.child;
              continue;
            }
            if (Ge === h) break e;
            for (; Ge.sibling === null; ) {
              if (Ge.return === null || Ge.return === h) break e;
              We === Ge && (We = null), Ge = Ge.return;
            }
            We === Ge && (We = null), Ge.sibling.return = Ge.return, Ge = Ge.sibling;
          }
        }
        break;
      case 19:
        ps(p, h), Nc(h), k & 4 && cg(h);
        break;
      case 21:
        break;
      default:
        ps(
          p,
          h
        ), Nc(h);
    }
  }
  function Nc(h) {
    var p = h.flags;
    if (p & 2) {
      try {
        e: {
          for (var x = h.return; x !== null; ) {
            if (aC(x)) {
              var k = x;
              break e;
            }
            x = x.return;
          }
          throw Error(e(160));
        }
        switch (k.tag) {
          case 5:
            var L = k.stateNode;
            k.flags & 32 && (vr(L, ""), k.flags &= -33);
            var z = sA(h);
            ag(h, z, L);
            break;
          case 3:
          case 4:
            var Y = k.stateNode.containerInfo, ae = sA(h);
            pv(h, ae, Y);
            break;
          default:
            throw Error(e(161));
        }
      } catch (he) {
        Si(h, h.return, he);
      }
      h.flags &= -3;
    }
    p & 4096 && (h.flags &= -4097);
  }
  function XD(h, p, x) {
    gt = h, lC(h);
  }
  function lC(h, p, x) {
    for (var k = (h.mode & 1) !== 0; gt !== null; ) {
      var L = gt, z = L.child;
      if (L.tag === 22 && k) {
        var Y = L.memoizedState !== null || ig;
        if (!Y) {
          var ae = L.alternate, he = ae !== null && ae.memoizedState !== null || _s;
          ae = ig;
          var Ie = _s;
          if (ig = Y, (_s = he) && !Ie) for (gt = L; gt !== null; ) Y = gt, he = Y.child, Y.tag === 22 && Y.memoizedState !== null ? cC(L) : he !== null ? (he.return = Y, gt = he) : cC(L);
          for (; z !== null; ) gt = z, lC(z), z = z.sibling;
          gt = L, ig = ae, _s = Ie;
        }
        ug(h);
      } else L.subtreeFlags & 8772 && z !== null ? (z.return = L, gt = z) : ug(h);
    }
  }
  function ug(h) {
    for (; gt !== null; ) {
      var p = gt;
      if (p.flags & 8772) {
        var x = p.alternate;
        try {
          if (p.flags & 8772) switch (p.tag) {
            case 0:
            case 11:
            case 15:
              _s || Sb(5, p);
              break;
            case 1:
              var k = p.stateNode;
              if (p.flags & 4 && !_s) if (x === null) k.componentDidMount();
              else {
                var L = p.elementType === p.type ? x.memoizedProps : qo(p.type, x.memoizedProps);
                k.componentDidUpdate(L, x.memoizedState, k.__reactInternalSnapshotBeforeUpdate);
              }
              var z = p.updateQueue;
              z !== null && VP(p, z, k);
              break;
            case 3:
              var Y = p.updateQueue;
              if (Y !== null) {
                if (x = null, p.child !== null) switch (p.child.tag) {
                  case 5:
                    x = p.child.stateNode;
                    break;
                  case 1:
                    x = p.child.stateNode;
                }
                VP(p, Y, x);
              }
              break;
            case 5:
              var ae = p.stateNode;
              if (x === null && p.flags & 4) {
                x = ae;
                var he = p.memoizedProps;
                switch (p.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    he.autoFocus && x.focus();
                    break;
                  case "img":
                    he.src && (x.src = he.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (p.memoizedState === null) {
                var Ie = p.alternate;
                if (Ie !== null) {
                  var We = Ie.memoizedState;
                  if (We !== null) {
                    var Ge = We.dehydrated;
                    Ge !== null && Mc(Ge);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(e(163));
          }
          _s || p.flags & 512 && bb(p);
        } catch (Ve) {
          Si(p, p.return, Ve);
        }
      }
      if (p === h) {
        gt = null;
        break;
      }
      if (x = p.sibling, x !== null) {
        x.return = p.return, gt = x;
        break;
      }
      gt = p.return;
    }
  }
  function aA(h) {
    for (; gt !== null; ) {
      var p = gt;
      if (p === h) {
        gt = null;
        break;
      }
      var x = p.sibling;
      if (x !== null) {
        x.return = p.return, gt = x;
        break;
      }
      gt = p.return;
    }
  }
  function cC(h) {
    for (; gt !== null; ) {
      var p = gt;
      try {
        switch (p.tag) {
          case 0:
          case 11:
          case 15:
            var x = p.return;
            try {
              Sb(4, p);
            } catch (he) {
              Si(p, x, he);
            }
            break;
          case 1:
            var k = p.stateNode;
            if (typeof k.componentDidMount == "function") {
              var L = p.return;
              try {
                k.componentDidMount();
              } catch (he) {
                Si(p, L, he);
              }
            }
            var z = p.return;
            try {
              bb(p);
            } catch (he) {
              Si(p, z, he);
            }
            break;
          case 5:
            var Y = p.return;
            try {
              bb(p);
            } catch (he) {
              Si(p, Y, he);
            }
        }
      } catch (he) {
        Si(p, p.return, he);
      }
      if (p === h) {
        gt = null;
        break;
      }
      var ae = p.sibling;
      if (ae !== null) {
        ae.return = p.return, gt = ae;
        break;
      }
      gt = p.return;
    }
  }
  var qD = Math.ceil, of = j.ReactCurrentDispatcher, xb = j.ReactCurrentOwner, dl = j.ReactCurrentBatchConfig, _n = 0, yi = null, Ur = null, Hi = 0, Jo = 0, dg = pn(0), Vi = 0, gv = null, af = 0, hg = 0, uC = 0, Dd = null, Ks = null, wb = 0, fg = 1 / 0, Pu = null, Cb = !1, dC = null, hl = null, pg = !1, fl = null, Eb = 0, mv = 0, _b = null, vv = -1, lf = 0;
  function gs() {
    return _n & 6 ? Hn() : vv !== -1 ? vv : vv = Hn();
  }
  function Au(h) {
    return h.mode & 1 ? _n & 2 && Hi !== 0 ? Hi & -Hi : HS.transition !== null ? (lf === 0 && (lf = vd()), lf) : (h = Cn, h !== 0 || (h = window.event, h = h === void 0 ? 16 : Xr(h.type)), h) : 1;
  }
  function li(h, p, x, k) {
    if (50 < mv) throw mv = 0, _b = null, Error(e(185));
    Vl(h, x, k), (!(_n & 2) || h !== yi) && (h === yi && (!(_n & 2) && (hg |= x), Vi === 4 && Fc(h, Hi)), Wi(h, k), x === 1 && _n === 0 && !(p.mode & 1) && (fg = Hn() + 500, hs && Wo()));
  }
  function Wi(h, p) {
    var x = h.callbackNode;
    kc(h, p);
    var k = cs(h, h === yi ? Hi : 0);
    if (k === 0) x !== null && Yn(x), h.callbackNode = null, h.callbackPriority = 0;
    else if (p = k & -k, h.callbackPriority !== p) {
      if (x != null && Yn(x), p === 1) h.tag === 0 ? Hw(gg.bind(null, h)) : Bw(gg.bind(null, h)), $w(function() {
        !(_n & 6) && Wo();
      }), x = null;
      else {
        switch (Ca(k)) {
          case 1:
            x = xs;
            break;
          case 4:
            x = on;
            break;
          case 16:
            x = $o;
            break;
          case 536870912:
            x = co;
            break;
          default:
            x = $o;
        }
        x = gA(x, Tb.bind(null, h));
      }
      h.callbackPriority = p, h.callbackNode = x;
    }
  }
  function Tb(h, p) {
    if (vv = -1, lf = 0, _n & 6) throw Error(e(327));
    var x = h.callbackNode;
    if (mg() && h.callbackNode !== x) return null;
    var k = cs(h, h === yi ? Hi : 0);
    if (k === 0) return null;
    if (k & 30 || k & h.expiredLanes || p) p = Ab(h, k);
    else {
      p = k;
      var L = _n;
      _n |= 2;
      var z = cA();
      (yi !== h || Hi !== p) && (Pu = null, fg = Hn() + 500, uf(h, p));
      do
        try {
          QD();
          break;
        } catch (ae) {
          lA(h, ae);
        }
      while (!0);
      Aa(), of.current = z, _n = L, Ur !== null ? p = 0 : (yi = null, Hi = 0, p = Vi);
    }
    if (p !== 0) {
      if (p === 2 && (L = Ic(h), L !== 0 && (k = L, p = cf(h, L))), p === 1) throw x = gv, uf(h, 0), Fc(h, k), Wi(h, Hn()), x;
      if (p === 6) Fc(h, k);
      else {
        if (L = h.current.alternate, !(k & 30) && !fC(L) && (p = Ab(h, k), p === 2 && (z = Ic(h), z !== 0 && (k = z, p = cf(h, z))), p === 1)) throw x = gv, uf(h, 0), Fc(h, k), Wi(h, Hn()), x;
        switch (h.finishedWork = L, h.finishedLanes = k, p) {
          case 0:
          case 1:
            throw Error(e(345));
          case 2:
            Od(h, Ks, Pu);
            break;
          case 3:
            if (Fc(h, k), (k & 130023424) === k && (p = wb + 500 - Hn(), 10 < p)) {
              if (cs(h, 0) !== 0) break;
              if (L = h.suspendedLanes, (L & k) !== k) {
                gs(), h.pingedLanes |= h.suspendedLanes & L;
                break;
              }
              h.timeoutHandle = Gh(Od.bind(null, h, Ks, Pu), p);
              break;
            }
            Od(h, Ks, Pu);
            break;
          case 4:
            if (Fc(h, k), (k & 4194240) === k) break;
            for (p = h.eventTimes, L = -1; 0 < k; ) {
              var Y = 31 - ws(k);
              z = 1 << Y, Y = p[Y], Y > L && (L = Y), k &= ~z;
            }
            if (k = L, k = Hn() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * qD(k / 1960)) - k, 10 < k) {
              h.timeoutHandle = Gh(Od.bind(null, h, Ks, Pu), k);
              break;
            }
            Od(h, Ks, Pu);
            break;
          case 5:
            Od(h, Ks, Pu);
            break;
          default:
            throw Error(e(329));
        }
      }
    }
    return Wi(h, Hn()), h.callbackNode === x ? Tb.bind(null, h) : null;
  }
  function cf(h, p) {
    var x = Dd;
    return h.current.memoizedState.isDehydrated && (uf(h, p).flags |= 256), h = Ab(h, p), h !== 2 && (p = Ks, Ks = x, p !== null && hC(p)), h;
  }
  function hC(h) {
    Ks === null ? Ks = h : Ks.push.apply(Ks, h);
  }
  function fC(h) {
    for (var p = h; ; ) {
      if (p.flags & 16384) {
        var x = p.updateQueue;
        if (x !== null && (x = x.stores, x !== null)) for (var k = 0; k < x.length; k++) {
          var L = x[k], z = L.getSnapshot;
          L = L.value;
          try {
            if (!tl(z(), L)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (x = p.child, p.subtreeFlags & 16384 && x !== null) x.return = p, p = x;
      else {
        if (p === h) break;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === h) return !0;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    return !0;
  }
  function Fc(h, p) {
    for (p &= ~uC, p &= ~hg, h.suspendedLanes |= p, h.pingedLanes &= ~p, h = h.expirationTimes; 0 < p; ) {
      var x = 31 - ws(p), k = 1 << x;
      h[x] = -1, p &= ~k;
    }
  }
  function gg(h) {
    if (_n & 6) throw Error(e(327));
    mg();
    var p = cs(h, 0);
    if (!(p & 1)) return Wi(h, Hn()), null;
    var x = Ab(h, p);
    if (h.tag !== 0 && x === 2) {
      var k = Ic(h);
      k !== 0 && (p = k, x = cf(h, k));
    }
    if (x === 1) throw x = gv, uf(h, 0), Fc(h, p), Wi(h, Hn()), x;
    if (x === 6) throw Error(e(345));
    return h.finishedWork = h.current.alternate, h.finishedLanes = p, Od(h, Ks, Pu), Wi(h, Hn()), null;
  }
  function pC(h, p) {
    var x = _n;
    _n |= 1;
    try {
      return h(p);
    } finally {
      _n = x, _n === 0 && (fg = Hn() + 500, hs && Wo());
    }
  }
  function $c(h) {
    fl !== null && fl.tag === 0 && !(_n & 6) && mg();
    var p = _n;
    _n |= 1;
    var x = dl.transition, k = Cn;
    try {
      if (dl.transition = null, Cn = 1, h) return h();
    } finally {
      Cn = k, dl.transition = x, _n = p, !(_n & 6) && Wo();
    }
  }
  function Pb() {
    Jo = dg.current, or(dg);
  }
  function uf(h, p) {
    h.finishedWork = null, h.finishedLanes = 0;
    var x = h.timeoutHandle;
    if (x !== -1 && (h.timeoutHandle = -1, LP(x)), Ur !== null) for (x = Ur.return; x !== null; ) {
      var k = x;
      switch (Ww(k), k.tag) {
        case 1:
          k = k.type.childContextTypes, k != null && il();
          break;
        case 3:
          Kp(), or(mi), or(nn), Qw();
          break;
        case 5:
          Zw(k);
          break;
        case 4:
          Kp();
          break;
        case 13:
          or(Zr);
          break;
        case 19:
          or(Zr);
          break;
        case 10:
          Yw(k.type._context);
          break;
        case 22:
        case 23:
          Pb();
      }
      x = x.return;
    }
    if (yi = h, Ur = h = Ld(h.current, null), Hi = Jo = p, Vi = 0, gv = null, uC = hg = af = 0, Ks = Dd = null, qh !== null) {
      for (p = 0; p < qh.length; p++) if (x = qh[p], k = x.interleaved, k !== null) {
        x.interleaved = null;
        var L = k.next, z = x.pending;
        if (z !== null) {
          var Y = z.next;
          z.next = L, k.next = Y;
        }
        x.pending = k;
      }
      qh = null;
    }
    return h;
  }
  function lA(h, p) {
    do {
      var x = Ur;
      try {
        if (Aa(), qS.current = Ws, ka) {
          for (var k = Ot.memoizedState; k !== null; ) {
            var L = k.queue;
            L !== null && (L.pending = null), k = k.next;
          }
          ka = !1;
        }
        if (Rt = 0, Sn = rn = Ot = null, Yp = !1, sv = 0, xb.current = null, x === null || x.return === null) {
          Vi = 1, gv = p, Ur = null;
          break;
        }
        e: {
          var z = h, Y = x.return, ae = x, he = p;
          if (p = Hi, ae.flags |= 32768, he !== null && typeof he == "object" && typeof he.then == "function") {
            var Ie = he, We = ae, Ge = We.tag;
            if (!(We.mode & 1) && (Ge === 0 || Ge === 11 || Ge === 15)) {
              var Ve = We.alternate;
              Ve ? (We.updateQueue = Ve.updateQueue, We.memoizedState = Ve.memoizedState, We.lanes = Ve.lanes) : (We.updateQueue = null, We.memoizedState = null);
            }
            var dt = JP(Y);
            if (dt !== null) {
              dt.flags &= -257, rC(dt, Y, ae, z, p), dt.mode & 1 && uv(z, Ie, p), p = dt, he = Ie;
              var St = p.updateQueue;
              if (St === null) {
                var _t = /* @__PURE__ */ new Set();
                _t.add(he), p.updateQueue = _t;
              } else St.add(he);
              break e;
            } else {
              if (!(p & 1)) {
                uv(z, Ie, p), yv();
                break e;
              }
              he = Error(e(426));
            }
          } else if (zr && ae.mode & 1) {
            var Ti = JP(Y);
            if (Ti !== null) {
              !(Ti.flags & 65536) && (Ti.flags |= 256), rC(Ti, Y, ae, z, p), Kw(Rd(he, ae));
              break e;
            }
          }
          z = he = Rd(he, ae), Vi !== 4 && (Vi = 2), Dd === null ? Dd = [z] : Dd.push(z), z = Y;
          do {
            switch (z.tag) {
              case 3:
                z.flags |= 65536, p &= -p, z.lanes |= p;
                var xe = ZP(z, he, p);
                HP(z, xe);
                break e;
              case 1:
                ae = he;
                var ge = z.type, Te = z.stateNode;
                if (!(z.flags & 128) && (typeof ge.getDerivedStateFromError == "function" || Te !== null && typeof Te.componentDidCatch == "function" && (hl === null || !hl.has(Te)))) {
                  z.flags |= 65536, p &= -p, z.lanes |= p;
                  var qe = QP(z, ae, p);
                  HP(z, qe);
                  break e;
                }
            }
            z = z.return;
          } while (z !== null);
        }
        dA(x);
      } catch (Mt) {
        p = Mt, Ur === x && x !== null && (Ur = x = x.return);
        continue;
      }
      break;
    } while (!0);
  }
  function cA() {
    var h = of.current;
    return of.current = Ws, h === null ? Ws : h;
  }
  function yv() {
    (Vi === 0 || Vi === 3 || Vi === 2) && (Vi = 4), yi === null || !(af & 268435455) && !(hg & 268435455) || Fc(yi, Hi);
  }
  function Ab(h, p) {
    var x = _n;
    _n |= 2;
    var k = cA();
    (yi !== h || Hi !== p) && (Pu = null, uf(h, p));
    do
      try {
        ZD();
        break;
      } catch (L) {
        lA(h, L);
      }
    while (!0);
    if (Aa(), _n = x, of.current = k, Ur !== null) throw Error(e(261));
    return yi = null, Hi = 0, Vi;
  }
  function ZD() {
    for (; Ur !== null; ) uA(Ur);
  }
  function QD() {
    for (; Ur !== null && !ls(); ) uA(Ur);
  }
  function uA(h) {
    var p = pA(h.alternate, h, Jo);
    h.memoizedProps = h.pendingProps, p === null ? dA(h) : Ur = p, xb.current = null;
  }
  function dA(h) {
    var p = h;
    do {
      var x = p.alternate;
      if (h = p.return, p.flags & 32768) {
        if (x = KD(x, p), x !== null) {
          x.flags &= 32767, Ur = x;
          return;
        }
        if (h !== null) h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null;
        else {
          Vi = 6, Ur = null;
          return;
        }
      } else if (x = GD(x, p, Jo), x !== null) {
        Ur = x;
        return;
      }
      if (p = p.sibling, p !== null) {
        Ur = p;
        return;
      }
      Ur = p = h;
    } while (p !== null);
    Vi === 0 && (Vi = 5);
  }
  function Od(h, p, x) {
    var k = Cn, L = dl.transition;
    try {
      dl.transition = null, Cn = 1, JD(h, p, x, k);
    } finally {
      dl.transition = L, Cn = k;
    }
    return null;
  }
  function JD(h, p, x, k) {
    do
      mg();
    while (fl !== null);
    if (_n & 6) throw Error(e(327));
    x = h.finishedWork;
    var L = h.finishedLanes;
    if (x === null) return null;
    if (h.finishedWork = null, h.finishedLanes = 0, x === h.current) throw Error(e(177));
    h.callbackNode = null, h.callbackPriority = 0;
    var z = x.lanes | x.childLanes;
    if ($m(h, z), h === yi && (Ur = yi = null, Hi = 0), !(x.subtreeFlags & 2064) && !(x.flags & 2064) || pg || (pg = !0, gA($o, function() {
      return mg(), null;
    })), z = (x.flags & 15990) !== 0, x.subtreeFlags & 15990 || z) {
      z = dl.transition, dl.transition = null;
      var Y = Cn;
      Cn = 1;
      var ae = _n;
      _n |= 4, xb.current = null, YD(h, x), oA(x, h), MS(Wh), ve = !!Nw, Wh = Nw = null, h.current = x, XD(x), el(), _n = ae, Cn = Y, dl.transition = z;
    } else h.current = x;
    if (pg && (pg = !1, fl = h, Eb = L), z = h.pendingLanes, z === 0 && (hl = null), Nh(x.stateNode), Wi(h, Hn()), p !== null) for (k = h.onRecoverableError, x = 0; x < p.length; x++) L = p[x], k(L.value, { componentStack: L.stack, digest: L.digest });
    if (Cb) throw Cb = !1, h = dC, dC = null, h;
    return Eb & 1 && h.tag !== 0 && mg(), z = h.pendingLanes, z & 1 ? h === _b ? mv++ : (mv = 0, _b = h) : mv = 0, Wo(), null;
  }
  function mg() {
    if (fl !== null) {
      var h = Ca(Eb), p = dl.transition, x = Cn;
      try {
        if (dl.transition = null, Cn = 16 > h ? 16 : h, fl === null) var k = !1;
        else {
          if (h = fl, fl = null, Eb = 0, _n & 6) throw Error(e(331));
          var L = _n;
          for (_n |= 4, gt = h.current; gt !== null; ) {
            var z = gt, Y = z.child;
            if (gt.flags & 16) {
              var ae = z.deletions;
              if (ae !== null) {
                for (var he = 0; he < ae.length; he++) {
                  var Ie = ae[he];
                  for (gt = Ie; gt !== null; ) {
                    var We = gt;
                    switch (We.tag) {
                      case 0:
                      case 11:
                      case 15:
                        og(8, We, z);
                    }
                    var Ge = We.child;
                    if (Ge !== null) Ge.return = We, gt = Ge;
                    else for (; gt !== null; ) {
                      We = gt;
                      var Ve = We.sibling, dt = We.return;
                      if (iA(We), We === Ie) {
                        gt = null;
                        break;
                      }
                      if (Ve !== null) {
                        Ve.return = dt, gt = Ve;
                        break;
                      }
                      gt = dt;
                    }
                  }
                }
                var St = z.alternate;
                if (St !== null) {
                  var _t = St.child;
                  if (_t !== null) {
                    St.child = null;
                    do {
                      var Ti = _t.sibling;
                      _t.sibling = null, _t = Ti;
                    } while (_t !== null);
                  }
                }
                gt = z;
              }
            }
            if (z.subtreeFlags & 2064 && Y !== null) Y.return = z, gt = Y;
            else e: for (; gt !== null; ) {
              if (z = gt, z.flags & 2048) switch (z.tag) {
                case 0:
                case 11:
                case 15:
                  og(9, z, z.return);
              }
              var xe = z.sibling;
              if (xe !== null) {
                xe.return = z.return, gt = xe;
                break e;
              }
              gt = z.return;
            }
          }
          var ge = h.current;
          for (gt = ge; gt !== null; ) {
            Y = gt;
            var Te = Y.child;
            if (Y.subtreeFlags & 2064 && Te !== null) Te.return = Y, gt = Te;
            else e: for (Y = ge; gt !== null; ) {
              if (ae = gt, ae.flags & 2048) try {
                switch (ae.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Sb(9, ae);
                }
              } catch (Mt) {
                Si(ae, ae.return, Mt);
              }
              if (ae === Y) {
                gt = null;
                break e;
              }
              var qe = ae.sibling;
              if (qe !== null) {
                qe.return = ae.return, gt = qe;
                break e;
              }
              gt = ae.return;
            }
          }
          if (_n = L, Wo(), Us && typeof Us.onPostCommitFiberRoot == "function") try {
            Us.onPostCommitFiberRoot(Pc, h);
          } catch {
          }
          k = !0;
        }
        return k;
      } finally {
        Cn = x, dl.transition = p;
      }
    }
    return !1;
  }
  function hA(h, p, x) {
    p = Rd(x, p), p = ZP(h, p, 1), h = kd(h, p, 1), p = gs(), h !== null && (Vl(h, 1, p), Wi(h, p));
  }
  function Si(h, p, x) {
    if (h.tag === 3) hA(h, h, x);
    else for (; p !== null; ) {
      if (p.tag === 3) {
        hA(p, h, x);
        break;
      } else if (p.tag === 1) {
        var k = p.stateNode;
        if (typeof p.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (hl === null || !hl.has(k))) {
          h = Rd(x, h), h = QP(p, h, 1), p = kd(p, h, 1), h = gs(), p !== null && (Vl(p, 1, h), Wi(p, h));
          break;
        }
      }
      p = p.return;
    }
  }
  function eO(h, p, x) {
    var k = h.pingCache;
    k !== null && k.delete(p), p = gs(), h.pingedLanes |= h.suspendedLanes & x, yi === h && (Hi & x) === x && (Vi === 4 || Vi === 3 && (Hi & 130023424) === Hi && 500 > Hn() - wb ? uf(h, 0) : uC |= x), Wi(h, p);
  }
  function fA(h, p) {
    p === 0 && (h.mode & 1 ? (p = zo, zo <<= 1, !(zo & 130023424) && (zo = 4194304)) : p = 1);
    var x = gs();
    h = Eu(h, p), h !== null && (Vl(h, p, x), Wi(h, x));
  }
  function gC(h) {
    var p = h.memoizedState, x = 0;
    p !== null && (x = p.retryLane), fA(h, x);
  }
  function tO(h, p) {
    var x = 0;
    switch (h.tag) {
      case 13:
        var k = h.stateNode, L = h.memoizedState;
        L !== null && (x = L.retryLane);
        break;
      case 19:
        k = h.stateNode;
        break;
      default:
        throw Error(e(314));
    }
    k !== null && k.delete(p), fA(h, x);
  }
  var pA;
  pA = function(h, p, x) {
    if (h !== null) if (h.memoizedProps !== p.pendingProps || mi.current) Zo = !0;
    else {
      if (!(h.lanes & x) && !(p.flags & 128)) return Zo = !1, Tu(h, p, x);
      Zo = !!(h.flags & 131072);
    }
    else Zo = !1, zr && p.flags & 1048576 && Vw(p, Bp, p.index);
    switch (p.lanes = 0, p.tag) {
      case 2:
        var k = p.type;
        fv(h, p), h = p.pendingProps;
        var L = rl(p, nn.current);
        Vp(p, x), L = Ue(null, p, k, h, L, x);
        var z = Ni();
        return p.flags |= 1, typeof L == "object" && L !== null && typeof L.render == "function" && L.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, qr(k) ? (z = !0, FS(p)) : z = !1, p.memoizedState = L.state !== null && L.state !== void 0 ? L.state : null, WS(p), L.updater = nf, p.stateNode = L, L._reactInternals = p, tC(p, k, h, x), p = fb(null, p, k, !0, z, x)) : (p.tag = 0, zr && z && $S(p), Ei(null, p, L, x), p = p.child), p;
      case 16:
        k = p.elementType;
        e: {
          switch (fv(h, p), h = p.pendingProps, L = k._init, k = L(k._payload), p.type = k, L = p.tag = nO(k), h = qo(k, h), L) {
            case 0:
              p = dn(null, p, k, h, x);
              break e;
            case 1:
              p = dv(null, p, k, h, x);
              break e;
            case 11:
              p = tg(null, p, k, h, x);
              break e;
            case 14:
              p = Md(null, p, k, qo(k.type, h), x);
              break e;
          }
          throw Error(e(
            306,
            k,
            ""
          ));
        }
        return p;
      case 0:
        return k = p.type, L = p.pendingProps, L = p.elementType === k ? L : qo(k, L), dn(h, p, k, L, x);
      case 1:
        return k = p.type, L = p.pendingProps, L = p.elementType === k ? L : qo(k, L), dv(h, p, k, L, x);
      case 3:
        e: {
          if (WD(p), h === null) throw Error(e(387));
          k = p.pendingProps, z = p.memoizedState, L = z.element, Wp(h, p), KS(p, k, null, x);
          var Y = p.memoizedState;
          if (k = Y.element, z.isDehydrated) if (z = { element: k, isDehydrated: !1, cache: Y.cache, pendingSuspenseBoundaries: Y.pendingSuspenseBoundaries, transitions: Y.transitions }, p.updateQueue.baseState = z, p.memoizedState = z, p.flags & 256) {
            L = Rd(Error(e(423)), p), p = tA(h, p, k, x, L);
            break e;
          } else if (k !== L) {
            L = Rd(Error(e(424)), p), p = tA(h, p, k, x, L);
            break e;
          } else for (Yo = Xl(p.stateNode.containerInfo.firstChild), Pa = p, zr = !0, ol = null, x = UP(p, null, k, x), p.child = x; x; ) x.flags = x.flags & -3 | 4096, x = x.sibling;
          else {
            if (ai(), k === L) {
              p = _i(h, p, x);
              break e;
            }
            Ei(h, p, k, x);
          }
          p = p.child;
        }
        return p;
      case 5:
        return WP(p), h === null && US(p), k = p.type, L = p.pendingProps, z = h !== null ? h.memoizedProps : null, Y = L.children, Zm(k, L) ? Y = null : z !== null && Zm(k, z) && (p.flags |= 32), rf(h, p), Ei(h, p, Y, x), p.child;
      case 6:
        return h === null && US(p), null;
      case 13:
        return nA(h, p, x);
      case 4:
        return qw(p, p.stateNode.containerInfo), k = p.pendingProps, h === null ? p.child = Hp(p, null, k, x) : Ei(h, p, k, x), p.child;
      case 11:
        return k = p.type, L = p.pendingProps, L = p.elementType === k ? L : qo(k, L), tg(h, p, k, L, x);
      case 7:
        return Ei(h, p, p.pendingProps, x), p.child;
      case 8:
        return Ei(h, p, p.pendingProps.children, x), p.child;
      case 12:
        return Ei(h, p, p.pendingProps.children, x), p.child;
      case 10:
        e: {
          if (k = p.type._context, L = p.pendingProps, z = p.memoizedProps, Y = L.value, ur(Cu, k._currentValue), k._currentValue = Y, z !== null) if (tl(z.value, Y)) {
            if (z.children === L.children && !mi.current) {
              p = _i(h, p, x);
              break e;
            }
          } else for (z = p.child, z !== null && (z.return = p); z !== null; ) {
            var ae = z.dependencies;
            if (ae !== null) {
              Y = z.child;
              for (var he = ae.firstContext; he !== null; ) {
                if (he.context === k) {
                  if (z.tag === 1) {
                    he = Xo(-1, x & -x), he.tag = 2;
                    var Ie = z.updateQueue;
                    if (Ie !== null) {
                      Ie = Ie.shared;
                      var We = Ie.pending;
                      We === null ? he.next = he : (he.next = We.next, We.next = he), Ie.pending = he;
                    }
                  }
                  z.lanes |= x, he = z.alternate, he !== null && (he.lanes |= x), Xw(
                    z.return,
                    x,
                    p
                  ), ae.lanes |= x;
                  break;
                }
                he = he.next;
              }
            } else if (z.tag === 10) Y = z.type === p.type ? null : z.child;
            else if (z.tag === 18) {
              if (Y = z.return, Y === null) throw Error(e(341));
              Y.lanes |= x, ae = Y.alternate, ae !== null && (ae.lanes |= x), Xw(Y, x, p), Y = z.sibling;
            } else Y = z.child;
            if (Y !== null) Y.return = z;
            else for (Y = z; Y !== null; ) {
              if (Y === p) {
                Y = null;
                break;
              }
              if (z = Y.sibling, z !== null) {
                z.return = Y.return, Y = z;
                break;
              }
              Y = Y.return;
            }
            z = Y;
          }
          Ei(h, p, L.children, x), p = p.child;
        }
        return p;
      case 9:
        return L = p.type, k = p.pendingProps.children, Vp(p, x), L = ll(L), k = k(L), p.flags |= 1, Ei(h, p, k, x), p.child;
      case 14:
        return k = p.type, L = qo(k, p.pendingProps), L = qo(k.type, L), Md(h, p, k, L, x);
      case 15:
        return hb(h, p, p.type, p.pendingProps, x);
      case 17:
        return k = p.type, L = p.pendingProps, L = p.elementType === k ? L : qo(k, L), fv(h, p), p.tag = 1, qr(k) ? (h = !0, FS(p)) : h = !1, Vp(p, x), YP(p, k, L), tC(p, k, L, x), fb(null, p, k, !0, h, x);
      case 19:
        return sC(h, p, x);
      case 22:
        return Qo(h, p, x);
    }
    throw Error(e(156, p.tag));
  };
  function gA(h, p) {
    return fr(h, p);
  }
  function mA(h, p, x, k) {
    this.tag = h, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function pl(h, p, x, k) {
    return new mA(h, p, x, k);
  }
  function mC(h) {
    return h = h.prototype, !(!h || !h.isReactComponent);
  }
  function nO(h) {
    if (typeof h == "function") return mC(h) ? 1 : 0;
    if (h != null) {
      if (h = h.$$typeof, h === ne) return 11;
      if (h === oe) return 14;
    }
    return 2;
  }
  function Ld(h, p) {
    var x = h.alternate;
    return x === null ? (x = pl(h.tag, p, h.key, h.mode), x.elementType = h.elementType, x.type = h.type, x.stateNode = h.stateNode, x.alternate = h, h.alternate = x) : (x.pendingProps = p, x.type = h.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = h.flags & 14680064, x.childLanes = h.childLanes, x.lanes = h.lanes, x.child = h.child, x.memoizedProps = h.memoizedProps, x.memoizedState = h.memoizedState, x.updateQueue = h.updateQueue, p = h.dependencies, x.dependencies = p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }, x.sibling = h.sibling, x.index = h.index, x.ref = h.ref, x;
  }
  function kb(h, p, x, k, L, z) {
    var Y = 2;
    if (k = h, typeof h == "function") mC(h) && (Y = 1);
    else if (typeof h == "string") Y = 5;
    else e: switch (h) {
      case F:
        return df(x.children, L, z, p);
      case B:
        Y = 8, L |= 8;
        break;
      case G:
        return h = pl(12, x, p, L | 2), h.elementType = G, h.lanes = z, h;
      case K:
        return h = pl(13, x, p, L), h.elementType = K, h.lanes = z, h;
      case Z:
        return h = pl(19, x, p, L), h.elementType = Z, h.lanes = z, h;
      case ie:
        return Ib(x, L, z, p);
      default:
        if (typeof h == "object" && h !== null) switch (h.$$typeof) {
          case X:
            Y = 10;
            break e;
          case te:
            Y = 9;
            break e;
          case ne:
            Y = 11;
            break e;
          case oe:
            Y = 14;
            break e;
          case fe:
            Y = 16, k = null;
            break e;
        }
        throw Error(e(130, h == null ? h : typeof h, ""));
    }
    return p = pl(Y, x, p, L), p.elementType = h, p.type = k, p.lanes = z, p;
  }
  function df(h, p, x, k) {
    return h = pl(7, h, k, p), h.lanes = x, h;
  }
  function Ib(h, p, x, k) {
    return h = pl(22, h, k, p), h.elementType = ie, h.lanes = x, h.stateNode = { isHidden: !1 }, h;
  }
  function Rb(h, p, x) {
    return h = pl(6, h, null, p), h.lanes = x, h;
  }
  function Sv(h, p, x) {
    return p = pl(4, h.children !== null ? h.children : [], h.key, p), p.lanes = x, p.stateNode = { containerInfo: h.containerInfo, pendingChildren: null, implementation: h.implementation }, p;
  }
  function bv(h, p, x, k, L) {
    this.tag = p, this.containerInfo = h, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = hu(0), this.expirationTimes = hu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = hu(0), this.identifierPrefix = k, this.onRecoverableError = L, this.mutableSourceEagerHydrationData = null;
  }
  function vC(h, p, x, k, L, z, Y, ae, he) {
    return h = new bv(h, p, x, ae, he), p === 1 ? (p = 1, z === !0 && (p |= 8)) : p = 0, z = pl(3, null, null, p), h.current = z, z.stateNode = h, z.memoizedState = { element: k, isDehydrated: x, cache: null, transitions: null, pendingSuspenseBoundaries: null }, WS(z), h;
  }
  function vA(h, p, x) {
    var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: U, key: k == null ? null : "" + k, children: h, containerInfo: p, implementation: x };
  }
  function yC(h) {
    if (!h) return Oc;
    h = h._reactInternals;
    e: {
      if (Pt(h) !== h || h.tag !== 1) throw Error(e(170));
      var p = h;
      do {
        switch (p.tag) {
          case 3:
            p = p.stateNode.context;
            break e;
          case 1:
            if (qr(p.type)) {
              p = p.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        p = p.return;
      } while (p !== null);
      throw Error(e(171));
    }
    if (h.tag === 1) {
      var x = h.type;
      if (qr(x)) return ev(h, x, p);
    }
    return p;
  }
  function SC(h, p, x, k, L, z, Y, ae, he) {
    return h = vC(x, k, !0, h, L, z, Y, ae, he), h.context = yC(null), x = h.current, k = gs(), L = Au(x), z = Xo(k, L), z.callback = p ?? null, kd(x, z, L), h.current.lanes = L, Vl(h, L, k), Wi(h, k), h;
  }
  function Mb(h, p, x, k) {
    var L = p.current, z = gs(), Y = Au(L);
    return x = yC(x), p.context === null ? p.context = x : p.pendingContext = x, p = Xo(z, Y), p.payload = { element: h }, k = k === void 0 ? null : k, k !== null && (p.callback = k), h = kd(L, p, Y), h !== null && (li(h, L, Y, z), GS(h, L, Y)), Y;
  }
  function xv(h) {
    if (h = h.current, !h.child) return null;
    switch (h.child.tag) {
      case 5:
        return h.child.stateNode;
      default:
        return h.child.stateNode;
    }
  }
  function yA(h, p) {
    if (h = h.memoizedState, h !== null && h.dehydrated !== null) {
      var x = h.retryLane;
      h.retryLane = x !== 0 && x < p ? x : p;
    }
  }
  function bC(h, p) {
    yA(h, p), (h = h.alternate) && yA(h, p);
  }
  function rO() {
    return null;
  }
  var xC = typeof reportError == "function" ? reportError : function(h) {
    console.error(h);
  };
  function Db(h) {
    this._internalRoot = h;
  }
  wv.prototype.render = Db.prototype.render = function(h) {
    var p = this._internalRoot;
    if (p === null) throw Error(e(409));
    Mb(h, p, null, null);
  }, wv.prototype.unmount = Db.prototype.unmount = function() {
    var h = this._internalRoot;
    if (h !== null) {
      this._internalRoot = null;
      var p = h.containerInfo;
      $c(function() {
        Mb(null, h, null, null);
      }), p[xu] = null;
    }
  };
  function wv(h) {
    this._internalRoot = h;
  }
  wv.prototype.unstable_scheduleHydration = function(h) {
    if (h) {
      var p = Sd();
      h = { blockedOn: null, target: h, priority: p };
      for (var x = 0; x < Jn.length && p !== 0 && p < Jn[x].priority; x++) ;
      Jn.splice(x, 0, h), x === 0 && zh(h);
    }
  };
  function jd(h) {
    return !(!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11);
  }
  function Ob(h) {
    return !(!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11 && (h.nodeType !== 8 || h.nodeValue !== " react-mount-point-unstable "));
  }
  function SA() {
  }
  function iO(h, p, x, k, L) {
    if (L) {
      if (typeof k == "function") {
        var z = k;
        k = function() {
          var Ie = xv(Y);
          z.call(Ie);
        };
      }
      var Y = SC(p, k, h, 0, null, !1, !1, "", SA);
      return h._reactRootContainer = Y, h[xu] = Y.current, zp(h.nodeType === 8 ? h.parentNode : h), $c(), Y;
    }
    for (; L = h.lastChild; ) h.removeChild(L);
    if (typeof k == "function") {
      var ae = k;
      k = function() {
        var Ie = xv(he);
        ae.call(Ie);
      };
    }
    var he = vC(h, 0, !1, null, null, !1, !1, "", SA);
    return h._reactRootContainer = he, h[xu] = he.current, zp(h.nodeType === 8 ? h.parentNode : h), $c(function() {
      Mb(p, he, x, k);
    }), he;
  }
  function Lb(h, p, x, k, L) {
    var z = x._reactRootContainer;
    if (z) {
      var Y = z;
      if (typeof L == "function") {
        var ae = L;
        L = function() {
          var he = xv(Y);
          ae.call(he);
        };
      }
      Mb(p, Y, h, L);
    } else Y = iO(x, p, h, L, k);
    return xv(Y);
  }
  fu = function(h) {
    switch (h.tag) {
      case 3:
        var p = h.stateNode;
        if (p.current.memoizedState.isDehydrated) {
          var x = Uo(p.pendingLanes);
          x !== 0 && (wa(p, x | 1), Wi(p, Hn()), !(_n & 6) && (fg = Hn() + 500, Wo()));
        }
        break;
      case 13:
        $c(function() {
          var k = Eu(h, 1);
          if (k !== null) {
            var L = gs();
            li(k, h, 1, L);
          }
        }), bC(h, 1);
    }
  }, yd = function(h) {
    if (h.tag === 13) {
      var p = Eu(h, 134217728);
      if (p !== null) {
        var x = gs();
        li(p, h, 134217728, x);
      }
      bC(h, 134217728);
    }
  }, ln = function(h) {
    if (h.tag === 13) {
      var p = Au(h), x = Eu(h, p);
      if (x !== null) {
        var k = gs();
        li(x, h, p, k);
      }
      bC(h, p);
    }
  }, Sd = function() {
    return Cn;
  }, bd = function(h, p) {
    var x = Cn;
    try {
      return Cn = h, p();
    } finally {
      Cn = x;
    }
  }, is = function(h, p, x) {
    switch (p) {
      case "input":
        if (yn(h, x), p = x.name, x.type === "radio" && p != null) {
          for (x = h; x.parentNode; ) x = x.parentNode;
          for (x = x.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), p = 0; p < x.length; p++) {
            var k = x[p];
            if (k !== h && k.form === h.form) {
              var L = zt(k);
              if (!L) throw Error(e(90));
              Un(k), yn(k, L);
            }
          }
        }
        break;
      case "textarea":
        Ss(h, x);
        break;
      case "select":
        p = x.value, p != null && oi(h, !!x.multiple, p, !1);
    }
  }, Hl = pC, Ec = $c;
  var sO = { usingClientEntryPoint: !1, Events: [Jm, Up, zt, ss, Za, pC] }, Cv = { findFiberByHostInstance: nl, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, bA = { bundleType: Cv.bundleType, version: Cv.version, rendererPackageName: Cv.rendererPackageName, rendererConfig: Cv.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: j.ReactCurrentDispatcher, findHostInstanceByFiber: function(h) {
    return h = fn(h), h === null ? null : h.stateNode;
  }, findFiberByHostInstance: Cv.findFiberByHostInstance || rO, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var jb = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!jb.isDisabled && jb.supportsFiber) try {
      Pc = jb.inject(bA), Us = jb;
    } catch {
    }
  }
  return bl.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sO, bl.createPortal = function(h, p) {
    var x = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!jd(p)) throw Error(e(200));
    return vA(h, p, null, x);
  }, bl.createRoot = function(h, p) {
    if (!jd(h)) throw Error(e(299));
    var x = !1, k = "", L = xC;
    return p != null && (p.unstable_strictMode === !0 && (x = !0), p.identifierPrefix !== void 0 && (k = p.identifierPrefix), p.onRecoverableError !== void 0 && (L = p.onRecoverableError)), p = vC(h, 1, !1, null, null, x, !1, k, L), h[xu] = p.current, zp(h.nodeType === 8 ? h.parentNode : h), new Db(p);
  }, bl.findDOMNode = function(h) {
    if (h == null) return null;
    if (h.nodeType === 1) return h;
    var p = h._reactInternals;
    if (p === void 0)
      throw typeof h.render == "function" ? Error(e(188)) : (h = Object.keys(h).join(","), Error(e(268, h)));
    return h = fn(p), h = h === null ? null : h.stateNode, h;
  }, bl.flushSync = function(h) {
    return $c(h);
  }, bl.hydrate = function(h, p, x) {
    if (!Ob(p)) throw Error(e(200));
    return Lb(null, h, p, !0, x);
  }, bl.hydrateRoot = function(h, p, x) {
    if (!jd(h)) throw Error(e(405));
    var k = x != null && x.hydratedSources || null, L = !1, z = "", Y = xC;
    if (x != null && (x.unstable_strictMode === !0 && (L = !0), x.identifierPrefix !== void 0 && (z = x.identifierPrefix), x.onRecoverableError !== void 0 && (Y = x.onRecoverableError)), p = SC(p, null, h, 1, x ?? null, L, !1, z, Y), h[xu] = p.current, zp(h), k) for (h = 0; h < k.length; h++) x = k[h], L = x._getVersion, L = L(x._source), p.mutableSourceEagerHydrationData == null ? p.mutableSourceEagerHydrationData = [x, L] : p.mutableSourceEagerHydrationData.push(
      x,
      L
    );
    return new wv(p);
  }, bl.render = function(h, p, x) {
    if (!Ob(p)) throw Error(e(200));
    return Lb(null, h, p, !1, x);
  }, bl.unmountComponentAtNode = function(h) {
    if (!Ob(h)) throw Error(e(40));
    return h._reactRootContainer ? ($c(function() {
      Lb(null, null, h, !1, function() {
        h._reactRootContainer = null, h[xu] = null;
      });
    }), !0) : !1;
  }, bl.unstable_batchedUpdates = pC, bl.unstable_renderSubtreeIntoContainer = function(h, p, x, k) {
    if (!Ob(x)) throw Error(e(200));
    if (h == null || h._reactInternals === void 0) throw Error(e(38));
    return Lb(h, p, x, !1, k);
  }, bl.version = "18.3.1-next-f1338f8080-20240426", bl;
}
var xl = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var U9;
function Xbe() {
  return U9 || (U9 = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = D, t = oY(), e = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function i(a) {
      r = a;
    }
    function s(a) {
      if (!r) {
        for (var c = arguments.length, g = new Array(c > 1 ? c - 1 : 0), b = 1; b < c; b++)
          g[b - 1] = arguments[b];
        l("warn", a, g);
      }
    }
    function o(a) {
      if (!r) {
        for (var c = arguments.length, g = new Array(c > 1 ? c - 1 : 0), b = 1; b < c; b++)
          g[b - 1] = arguments[b];
        l("error", a, g);
      }
    }
    function l(a, c, g) {
      {
        var b = e.ReactDebugCurrentFrame, C = b.getStackAddendum();
        C !== "" && (c += "%s", g = g.concat([C]));
        var I = g.map(function(N) {
          return String(N);
        });
        I.unshift("Warning: " + c), Function.prototype.apply.call(console[a], console, I);
      }
    }
    var u = 0, d = 1, f = 2, m = 3, v = 4, S = 5, w = 6, E = 7, A = 8, P = 9, R = 10, M = 11, j = 12, $ = 13, U = 14, F = 15, B = 16, G = 17, X = 18, te = 19, ne = 21, K = 22, Z = 23, oe = 24, fe = 25, ie = !0, ue = !1, Se = !1, ke = !1, ce = !1, ye = !0, Fe = !1, Xe = !0, je = !0, nt = !0, Ze = !0, tt = /* @__PURE__ */ new Set(), et = {}, at = {};
    function Yt(a, c) {
      Un(a, c), Un(a + "Capture", c);
    }
    function Un(a, c) {
      et[a] && o("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", a), et[a] = c;
      {
        var g = a.toLowerCase();
        at[g] = a, a === "onDoubleClick" && (at.ondblclick = a);
      }
      for (var b = 0; b < c.length; b++)
        tt.add(c[b]);
    }
    var pt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ut = Object.prototype.hasOwnProperty;
    function jt(a) {
      {
        var c = typeof Symbol == "function" && Symbol.toStringTag, g = c && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return g;
      }
    }
    function $t(a) {
      try {
        return yn(a), !1;
      } catch {
        return !0;
      }
    }
    function yn(a) {
      return "" + a;
    }
    function hi(a, c) {
      if ($t(a))
        return o("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", c, jt(a)), yn(a);
    }
    function Nr(a) {
      if ($t(a))
        return o("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", jt(a)), yn(a);
    }
    function fi(a, c) {
      if ($t(a))
        return o("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", c, jt(a)), yn(a);
    }
    function oi(a, c) {
      if ($t(a))
        return o("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", c, jt(a)), yn(a);
    }
    function es(a) {
      if ($t(a))
        return o("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", jt(a)), yn(a);
    }
    function Di(a) {
      if ($t(a))
        return o("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", jt(a)), yn(a);
    }
    var Ss = 0, wi = 1, ts = 2, On = 3, Kr = 4, ns = 5, vr = 6, Je = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", It = Je + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", hn = new RegExp("^[" + Je + "][" + It + "]*$"), Bn = {}, Ln = {};
    function Yr(a) {
      return Ut.call(Ln, a) ? !0 : Ut.call(Bn, a) ? !1 : hn.test(a) ? (Ln[a] = !0, !0) : (Bn[a] = !0, o("Invalid attribute name: `%s`", a), !1);
    }
    function kr(a, c, g) {
      return c !== null ? c.type === Ss : g ? !1 : a.length > 2 && (a[0] === "o" || a[0] === "O") && (a[1] === "n" || a[1] === "N");
    }
    function rs(a, c, g, b) {
      if (g !== null && g.type === Ss)
        return !1;
      switch (typeof c) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (b)
            return !1;
          if (g !== null)
            return !g.acceptsBooleans;
          var C = a.toLowerCase().slice(0, 5);
          return C !== "data-" && C !== "aria-";
        }
        default:
          return !1;
      }
    }
    function wn(a, c, g, b) {
      if (c === null || typeof c > "u" || rs(a, c, g, b))
        return !0;
      if (b)
        return !1;
      if (g !== null)
        switch (g.type) {
          case On:
            return !c;
          case Kr:
            return c === !1;
          case ns:
            return isNaN(c);
          case vr:
            return isNaN(c) || c < 1;
        }
      return !1;
    }
    function is(a) {
      return Qn.hasOwnProperty(a) ? Qn[a] : null;
    }
    function Zn(a, c, g, b, C, I, N) {
      this.acceptsBooleans = c === ts || c === On || c === Kr, this.attributeName = b, this.attributeNamespace = C, this.mustUseProperty = g, this.propertyName = a, this.type = c, this.sanitizeURL = I, this.removeEmptyString = N;
    }
    var Qn = {}, so = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    so.forEach(function(a) {
      Qn[a] = new Zn(
        a,
        Ss,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var c = a[0], g = a[1];
      Qn[c] = new Zn(
        c,
        wi,
        !1,
        // mustUseProperty
        g,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        ts,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        ts,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        On,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        On,
        !0,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        Kr,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        vr,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        ns,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ss = /[\-\:]([a-z])/g, Za = function(a) {
      return a[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var c = a.replace(ss, Za);
      Qn[c] = new Zn(
        c,
        wi,
        !1,
        // mustUseProperty
        a,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var c = a.replace(ss, Za);
      Qn[c] = new Zn(
        c,
        wi,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var c = a.replace(ss, Za);
      Qn[c] = new Zn(
        c,
        wi,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        wi,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Hl = "xlinkHref";
    Qn[Hl] = new Zn(
      "xlinkHref",
      wi,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(a) {
      Qn[a] = new Zn(
        a,
        wi,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ec = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, oo = !1;
    function _c(a) {
      !oo && Ec.test(a) && (oo = !0, o("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(a)));
    }
    function ao(a, c, g, b) {
      if (b.mustUseProperty) {
        var C = b.propertyName;
        return a[C];
      } else {
        hi(g, c), b.sanitizeURL && _c("" + g);
        var I = b.attributeName, N = null;
        if (b.type === Kr) {
          if (a.hasAttribute(I)) {
            var H = a.getAttribute(I);
            return H === "" ? !0 : wn(c, g, b, !1) ? H : H === "" + g ? g : H;
          }
        } else if (a.hasAttribute(I)) {
          if (wn(c, g, b, !1))
            return a.getAttribute(I);
          if (b.type === On)
            return g;
          N = a.getAttribute(I);
        }
        return wn(c, g, b, !1) ? N === null ? g : N : N === "" + g ? g : N;
      }
    }
    function Qa(a, c, g, b) {
      {
        if (!Yr(c))
          return;
        if (!a.hasAttribute(c))
          return g === void 0 ? void 0 : null;
        var C = a.getAttribute(c);
        return hi(g, c), C === "" + g ? g : C;
      }
    }
    function lo(a, c, g, b) {
      var C = is(c);
      if (!kr(c, C, b)) {
        if (wn(c, g, C, b) && (g = null), b || C === null) {
          if (Yr(c)) {
            var I = c;
            g === null ? a.removeAttribute(I) : (hi(g, c), a.setAttribute(I, "" + g));
          }
          return;
        }
        var N = C.mustUseProperty;
        if (N) {
          var H = C.propertyName;
          if (g === null) {
            var V = C.type;
            a[H] = V === On ? !1 : "";
          } else
            a[H] = g;
          return;
        }
        var ee = C.attributeName, re = C.attributeNamespace;
        if (g === null)
          a.removeAttribute(ee);
        else {
          var me = C.type, pe;
          me === On || me === Kr && g === !0 ? pe = "" : (hi(g, ee), pe = "" + g, C.sanitizeURL && _c(pe.toString())), re ? a.setAttributeNS(re, ee, pe) : a.setAttribute(ee, pe);
        }
      }
    }
    var xa = Symbol.for("react.element"), os = Symbol.for("react.portal"), bs = Symbol.for("react.fragment"), as = Symbol.for("react.strict_mode"), Ja = Symbol.for("react.profiler"), de = Symbol.for("react.provider"), Be = Symbol.for("react.context"), Ke = Symbol.for("react.forward_ref"), Pt = Symbol.for("react.suspense"), en = Symbol.for("react.suspense_list"), bn = Symbol.for("react.memo"), Bt = Symbol.for("react.lazy"), fn = Symbol.for("react.scope"), pi = Symbol.for("react.debug_trace_mode"), fr = Symbol.for("react.offscreen"), Yn = Symbol.for("react.legacy_hidden"), ls = Symbol.for("react.cache"), el = Symbol.for("react.tracing_marker"), Hn = Symbol.iterator, Oi = "@@iterator";
    function xs(a) {
      if (a === null || typeof a != "object")
        return null;
      var c = Hn && a[Hn] || a[Oi];
      return typeof c == "function" ? c : null;
    }
    var on = Object.assign, $o = 0, Tc, co, Pc, Us, Nh, ws, Fh;
    function $h() {
    }
    $h.__reactDisabledLog = !0;
    function du() {
      {
        if ($o === 0) {
          Tc = console.log, co = console.info, Pc = console.warn, Us = console.error, Nh = console.group, ws = console.groupCollapsed, Fh = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: $h,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        $o++;
      }
    }
    function md() {
      {
        if ($o--, $o === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: on({}, a, {
              value: Tc
            }),
            info: on({}, a, {
              value: co
            }),
            warn: on({}, a, {
              value: Pc
            }),
            error: on({}, a, {
              value: Us
            }),
            group: on({}, a, {
              value: Nh
            }),
            groupCollapsed: on({}, a, {
              value: ws
            }),
            groupEnd: on({}, a, {
              value: Fh
            })
          });
        }
        $o < 0 && o("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var zo = e.ReactCurrentDispatcher, Uo;
    function cs(a, c, g) {
      {
        if (Uo === void 0)
          try {
            throw Error();
          } catch (C) {
            var b = C.stack.trim().match(/\n( *(at )?)/);
            Uo = b && b[1] || "";
          }
        return `
` + Uo + a;
      }
    }
    var Ac = !1, kc;
    {
      var Ic = typeof WeakMap == "function" ? WeakMap : Map;
      kc = new Ic();
    }
    function vd(a, c) {
      if (!a || Ac)
        return "";
      {
        var g = kc.get(a);
        if (g !== void 0)
          return g;
      }
      var b;
      Ac = !0;
      var C = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var I;
      I = zo.current, zo.current = null, du();
      try {
        if (c) {
          var N = function() {
            throw Error();
          };
          if (Object.defineProperty(N.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(N, []);
            } catch (Re) {
              b = Re;
            }
            Reflect.construct(a, [], N);
          } else {
            try {
              N.call();
            } catch (Re) {
              b = Re;
            }
            a.call(N.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            b = Re;
          }
          a();
        }
      } catch (Re) {
        if (Re && b && typeof Re.stack == "string") {
          for (var H = Re.stack.split(`
`), V = b.stack.split(`
`), ee = H.length - 1, re = V.length - 1; ee >= 1 && re >= 0 && H[ee] !== V[re]; )
            re--;
          for (; ee >= 1 && re >= 0; ee--, re--)
            if (H[ee] !== V[re]) {
              if (ee !== 1 || re !== 1)
                do
                  if (ee--, re--, re < 0 || H[ee] !== V[re]) {
                    var me = `
` + H[ee].replace(" at new ", " at ");
                    return a.displayName && me.includes("<anonymous>") && (me = me.replace("<anonymous>", a.displayName)), typeof a == "function" && kc.set(a, me), me;
                  }
                while (ee >= 1 && re >= 0);
              break;
            }
        }
      } finally {
        Ac = !1, zo.current = I, md(), Error.prepareStackTrace = C;
      }
      var pe = a ? a.displayName || a.name : "", Ae = pe ? cs(pe) : "";
      return typeof a == "function" && kc.set(a, Ae), Ae;
    }
    function hu(a, c, g) {
      return vd(a, !0);
    }
    function Vl(a, c, g) {
      return vd(a, !1);
    }
    function $m(a) {
      var c = a.prototype;
      return !!(c && c.isReactComponent);
    }
    function wa(a, c, g) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return vd(a, $m(a));
      if (typeof a == "string")
        return cs(a);
      switch (a) {
        case Pt:
          return cs("Suspense");
        case en:
          return cs("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Ke:
            return Vl(a.render);
          case bn:
            return wa(a.type, c, g);
          case Bt: {
            var b = a, C = b._payload, I = b._init;
            try {
              return wa(I(C), c, g);
            } catch {
            }
          }
        }
      return "";
    }
    function Cn(a) {
      switch (a._debugOwner && a._debugOwner.type, a._debugSource, a.tag) {
        case S:
          return cs(a.type);
        case B:
          return cs("Lazy");
        case $:
          return cs("Suspense");
        case te:
          return cs("SuspenseList");
        case u:
        case f:
        case F:
          return Vl(a.type);
        case M:
          return Vl(a.type.render);
        case d:
          return hu(a.type);
        default:
          return "";
      }
    }
    function Ca(a) {
      try {
        var c = "", g = a;
        do
          c += Cn(g), g = g.return;
        while (g);
        return c;
      } catch (b) {
        return `
Error generating stack: ` + b.message + `
` + b.stack;
      }
    }
    function fu(a, c, g) {
      var b = a.displayName;
      if (b)
        return b;
      var C = c.displayName || c.name || "";
      return C !== "" ? g + "(" + C + ")" : g;
    }
    function yd(a) {
      return a.displayName || "Context";
    }
    function ln(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && o("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case bs:
          return "Fragment";
        case os:
          return "Portal";
        case Ja:
          return "Profiler";
        case as:
          return "StrictMode";
        case Pt:
          return "Suspense";
        case en:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Be:
            var c = a;
            return yd(c) + ".Consumer";
          case de:
            var g = a;
            return yd(g._context) + ".Provider";
          case Ke:
            return fu(a, a.render, "ForwardRef");
          case bn:
            var b = a.displayName || null;
            return b !== null ? b : ln(a.type) || "Memo";
          case Bt: {
            var C = a, I = C._payload, N = C._init;
            try {
              return ln(N(I));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Sd(a, c, g) {
      var b = c.displayName || c.name || "";
      return a.displayName || (b !== "" ? g + "(" + b + ")" : g);
    }
    function bd(a) {
      return a.displayName || "Context";
    }
    function tn(a) {
      var c = a.tag, g = a.type;
      switch (c) {
        case oe:
          return "Cache";
        case P:
          var b = g;
          return bd(b) + ".Consumer";
        case R:
          var C = g;
          return bd(C._context) + ".Provider";
        case X:
          return "DehydratedFragment";
        case M:
          return Sd(g, g.render, "ForwardRef");
        case E:
          return "Fragment";
        case S:
          return g;
        case v:
          return "Portal";
        case m:
          return "Root";
        case w:
          return "Text";
        case B:
          return ln(g);
        case A:
          return g === as ? "StrictMode" : "Mode";
        case K:
          return "Offscreen";
        case j:
          return "Profiler";
        case ne:
          return "Scope";
        case $:
          return "Suspense";
        case te:
          return "SuspenseList";
        case fe:
          return "TracingMarker";
        case d:
        case u:
        case G:
        case f:
        case U:
        case F:
          if (typeof g == "function")
            return g.displayName || g.name || null;
          if (typeof g == "string")
            return g;
          break;
      }
      return null;
    }
    var pu = e.ReactDebugCurrentFrame, Fr = null, gi = !1;
    function us() {
      {
        if (Fr === null)
          return null;
        var a = Fr._debugOwner;
        if (a !== null && typeof a < "u")
          return tn(a);
      }
      return null;
    }
    function Rc() {
      return Fr === null ? "" : Ca(Fr);
    }
    function Cr() {
      pu.getCurrentStack = null, Fr = null, gi = !1;
    }
    function Jn(a) {
      pu.getCurrentStack = a === null ? null : Rc, Fr = a, gi = !1;
    }
    function xd() {
      return Fr;
    }
    function Bs(a) {
      gi = a;
    }
    function Ci(a) {
      return "" + a;
    }
    function Ea(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return Di(a), a;
        default:
          return "";
      }
    }
    var zh = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function uo(a, c) {
      zh[c.type] || c.onChange || c.onInput || c.readOnly || c.disabled || c.value == null || o("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), c.onChange || c.readOnly || c.disabled || c.checked == null || o("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Wl(a) {
      var c = a.type, g = a.nodeName;
      return g && g.toLowerCase() === "input" && (c === "checkbox" || c === "radio");
    }
    function Dp(a) {
      return a._valueTracker;
    }
    function Bo(a) {
      a._valueTracker = null;
    }
    function Mc(a) {
      var c = "";
      return a && (Wl(a) ? c = a.checked ? "true" : "false" : c = a.value), c;
    }
    function se(a) {
      var c = Wl(a) ? "checked" : "value", g = Object.getOwnPropertyDescriptor(a.constructor.prototype, c);
      Di(a[c]);
      var b = "" + a[c];
      if (!(a.hasOwnProperty(c) || typeof g > "u" || typeof g.get != "function" || typeof g.set != "function")) {
        var C = g.get, I = g.set;
        Object.defineProperty(a, c, {
          configurable: !0,
          get: function() {
            return C.call(this);
          },
          set: function(H) {
            Di(H), b = "" + H, I.call(this, H);
          }
        }), Object.defineProperty(a, c, {
          enumerable: g.enumerable
        });
        var N = {
          getValue: function() {
            return b;
          },
          setValue: function(H) {
            Di(H), b = "" + H;
          },
          stopTracking: function() {
            Bo(a), delete a[c];
          }
        };
        return N;
      }
    }
    function ve(a) {
      Dp(a) || (a._valueTracker = se(a));
    }
    function $e(a) {
      if (!a)
        return !1;
      var c = Dp(a);
      if (!c)
        return !0;
      var g = c.getValue(), b = Mc(a);
      return b !== g ? (c.setValue(b), !0) : !1;
    }
    function st(a) {
      if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
        return null;
      try {
        return a.activeElement || a.body;
      } catch {
        return a.body;
      }
    }
    var Vn = !1, Zt = !1, pr = !1, Xr = !1;
    function gr(a) {
      var c = a.type === "checkbox" || a.type === "radio";
      return c ? a.checked != null : a.value != null;
    }
    function W(a, c) {
      var g = a, b = c.checked, C = on({}, c, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: b ?? g._wrapperState.initialChecked
      });
      return C;
    }
    function le(a, c) {
      uo("input", c), c.checked !== void 0 && c.defaultChecked !== void 0 && !Zt && (o("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", us() || "A component", c.type), Zt = !0), c.value !== void 0 && c.defaultValue !== void 0 && !Vn && (o("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", us() || "A component", c.type), Vn = !0);
      var g = a, b = c.defaultValue == null ? "" : c.defaultValue;
      g._wrapperState = {
        initialChecked: c.checked != null ? c.checked : c.defaultChecked,
        initialValue: Ea(c.value != null ? c.value : b),
        controlled: gr(c)
      };
    }
    function Ce(a, c) {
      var g = a, b = c.checked;
      b != null && lo(g, "checked", b, !1);
    }
    function Pe(a, c) {
      var g = a;
      {
        var b = gr(c);
        !g._wrapperState.controlled && b && !Xr && (o("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Xr = !0), g._wrapperState.controlled && !b && !pr && (o("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), pr = !0);
      }
      Ce(a, c);
      var C = Ea(c.value), I = c.type;
      if (C != null)
        I === "number" ? (C === 0 && g.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        g.value != C) && (g.value = Ci(C)) : g.value !== Ci(C) && (g.value = Ci(C));
      else if (I === "submit" || I === "reset") {
        g.removeAttribute("value");
        return;
      }
      c.hasOwnProperty("value") ? Ct(g, c.type, C) : c.hasOwnProperty("defaultValue") && Ct(g, c.type, Ea(c.defaultValue)), c.checked == null && c.defaultChecked != null && (g.defaultChecked = !!c.defaultChecked);
    }
    function He(a, c, g) {
      var b = a;
      if (c.hasOwnProperty("value") || c.hasOwnProperty("defaultValue")) {
        var C = c.type, I = C === "submit" || C === "reset";
        if (I && (c.value === void 0 || c.value === null))
          return;
        var N = Ci(b._wrapperState.initialValue);
        g || N !== b.value && (b.value = N), b.defaultValue = N;
      }
      var H = b.name;
      H !== "" && (b.name = ""), b.defaultChecked = !b.defaultChecked, b.defaultChecked = !!b._wrapperState.initialChecked, H !== "" && (b.name = H);
    }
    function yt(a, c) {
      var g = a;
      Pe(g, c), Qe(g, c);
    }
    function Qe(a, c) {
      var g = c.name;
      if (c.type === "radio" && g != null) {
        for (var b = a; b.parentNode; )
          b = b.parentNode;
        hi(g, "name");
        for (var C = b.querySelectorAll("input[name=" + JSON.stringify("" + g) + '][type="radio"]'), I = 0; I < C.length; I++) {
          var N = C[I];
          if (!(N === a || N.form !== a.form)) {
            var H = NA(N);
            if (!H)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            $e(N), Pe(N, H);
          }
        }
      }
    }
    function Ct(a, c, g) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (c !== "number" || st(a.ownerDocument) !== a) && (g == null ? a.defaultValue = Ci(a._wrapperState.initialValue) : a.defaultValue !== Ci(g) && (a.defaultValue = Ci(g)));
    }
    var sn = !1, En = !1, er = !1;
    function Wn(a, c) {
      c.value == null && (typeof c.children == "object" && c.children !== null ? n.Children.forEach(c.children, function(g) {
        g != null && (typeof g == "string" || typeof g == "number" || En || (En = !0, o("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : c.dangerouslySetInnerHTML != null && (er || (er = !0, o("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), c.selected != null && !sn && (o("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), sn = !0);
    }
    function Er(a, c) {
      c.value != null && a.setAttribute("value", Ci(Ea(c.value)));
    }
    var Ir = Array.isArray;
    function Pn(a) {
      return Ir(a);
    }
    var gu;
    gu = !1;
    function Op() {
      var a = us();
      return a ? `

Check the render method of \`` + a + "`." : "";
    }
    var zm = ["value", "defaultValue"];
    function Sw(a) {
      {
        uo("select", a);
        for (var c = 0; c < zm.length; c++) {
          var g = zm[c];
          if (a[g] != null) {
            var b = Pn(a[g]);
            a.multiple && !b ? o("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", g, Op()) : !a.multiple && b && o("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", g, Op());
          }
        }
      }
    }
    function Gl(a, c, g, b) {
      var C = a.options;
      if (c) {
        for (var I = g, N = {}, H = 0; H < I.length; H++)
          N["$" + I[H]] = !0;
        for (var V = 0; V < C.length; V++) {
          var ee = N.hasOwnProperty("$" + C[V].value);
          C[V].selected !== ee && (C[V].selected = ee), ee && b && (C[V].defaultSelected = !0);
        }
      } else {
        for (var re = Ci(Ea(g)), me = null, pe = 0; pe < C.length; pe++) {
          if (C[pe].value === re) {
            C[pe].selected = !0, b && (C[pe].defaultSelected = !0);
            return;
          }
          me === null && !C[pe].disabled && (me = C[pe]);
        }
        me !== null && (me.selected = !0);
      }
    }
    function Um(a, c) {
      return on({}, c, {
        value: void 0
      });
    }
    function Bm(a, c) {
      var g = a;
      Sw(c), g._wrapperState = {
        wasMultiple: !!c.multiple
      }, c.value !== void 0 && c.defaultValue !== void 0 && !gu && (o("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), gu = !0);
    }
    function bw(a, c) {
      var g = a;
      g.multiple = !!c.multiple;
      var b = c.value;
      b != null ? Gl(g, !!c.multiple, b, !1) : c.defaultValue != null && Gl(g, !!c.multiple, c.defaultValue, !0);
    }
    function AD(a, c) {
      var g = a, b = g._wrapperState.wasMultiple;
      g._wrapperState.wasMultiple = !!c.multiple;
      var C = c.value;
      C != null ? Gl(g, !!c.multiple, C, !1) : b !== !!c.multiple && (c.defaultValue != null ? Gl(g, !!c.multiple, c.defaultValue, !0) : Gl(g, !!c.multiple, c.multiple ? [] : "", !1));
    }
    function kD(a, c) {
      var g = a, b = c.value;
      b != null && Gl(g, !!c.multiple, b, !1);
    }
    var xw = !1;
    function ww(a, c) {
      var g = a;
      if (c.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var b = on({}, c, {
        value: void 0,
        defaultValue: void 0,
        children: Ci(g._wrapperState.initialValue)
      });
      return b;
    }
    function lP(a, c) {
      var g = a;
      uo("textarea", c), c.value !== void 0 && c.defaultValue !== void 0 && !xw && (o("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", us() || "A component"), xw = !0);
      var b = c.value;
      if (b == null) {
        var C = c.children, I = c.defaultValue;
        if (C != null) {
          o("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (I != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Pn(C)) {
              if (C.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              C = C[0];
            }
            I = C;
          }
        }
        I == null && (I = ""), b = I;
      }
      g._wrapperState = {
        initialValue: Ea(b)
      };
    }
    function cP(a, c) {
      var g = a, b = Ea(c.value), C = Ea(c.defaultValue);
      if (b != null) {
        var I = Ci(b);
        I !== g.value && (g.value = I), c.defaultValue == null && g.defaultValue !== I && (g.defaultValue = I);
      }
      C != null && (g.defaultValue = Ci(C));
    }
    function uP(a, c) {
      var g = a, b = g.textContent;
      b === g._wrapperState.initialValue && b !== "" && b !== null && (g.value = b);
    }
    function Cw(a, c) {
      cP(a, c);
    }
    var mu = "http://www.w3.org/1999/xhtml", ID = "http://www.w3.org/1998/Math/MathML", Ew = "http://www.w3.org/2000/svg";
    function PS(a) {
      switch (a) {
        case "svg":
          return Ew;
        case "math":
          return ID;
        default:
          return mu;
      }
    }
    function _w(a, c) {
      return a == null || a === mu ? PS(c) : a === Ew && c === "foreignObject" ? mu : a;
    }
    var RD = function(a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(c, g, b, C) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(c, g, b, C);
        });
      } : a;
    }, AS, dP = RD(function(a, c) {
      if (a.namespaceURI === Ew && !("innerHTML" in a)) {
        AS = AS || document.createElement("div"), AS.innerHTML = "<svg>" + c.valueOf().toString() + "</svg>";
        for (var g = AS.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; g.firstChild; )
          a.appendChild(g.firstChild);
        return;
      }
      a.innerHTML = c;
    }), Ho = 1, vu = 3, Li = 8, Kl = 9, Uh = 11, kS = function(a, c) {
      if (c) {
        var g = a.firstChild;
        if (g && g === a.lastChild && g.nodeType === vu) {
          g.nodeValue = c;
          return;
        }
      }
      a.textContent = c;
    }, hP = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Lp = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function fP(a, c) {
      return a + c.charAt(0).toUpperCase() + c.substring(1);
    }
    var pP = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Lp).forEach(function(a) {
      pP.forEach(function(c) {
        Lp[fP(c, a)] = Lp[a];
      });
    });
    function IS(a, c, g) {
      var b = c == null || typeof c == "boolean" || c === "";
      return b ? "" : !g && typeof c == "number" && c !== 0 && !(Lp.hasOwnProperty(a) && Lp[a]) ? c + "px" : (oi(c, a), ("" + c).trim());
    }
    var jp = /([A-Z])/g, MD = /^ms-/;
    function DD(a) {
      return a.replace(jp, "-$1").toLowerCase().replace(MD, "-ms-");
    }
    var gP = function() {
    };
    {
      var mP = /^(?:webkit|moz|o)[A-Z]/, vP = /^-ms-/, Hm = /-(.)/g, Np = /;\s*$/, Fp = {}, $p = {}, yP = !1, Tw = !1, Pw = function(a) {
        return a.replace(Hm, function(c, g) {
          return g.toUpperCase();
        });
      }, Aw = function(a) {
        Fp.hasOwnProperty(a) && Fp[a] || (Fp[a] = !0, o(
          "Unsupported style property %s. Did you mean %s?",
          a,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Pw(a.replace(vP, "ms-"))
        ));
      }, SP = function(a) {
        Fp.hasOwnProperty(a) && Fp[a] || (Fp[a] = !0, o("Unsupported vendor-prefixed style property %s. Did you mean %s?", a, a.charAt(0).toUpperCase() + a.slice(1)));
      }, bP = function(a, c) {
        $p.hasOwnProperty(c) && $p[c] || ($p[c] = !0, o(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, a, c.replace(Np, "")));
      }, xP = function(a, c) {
        yP || (yP = !0, o("`NaN` is an invalid value for the `%s` css style property.", a));
      }, OD = function(a, c) {
        Tw || (Tw = !0, o("`Infinity` is an invalid value for the `%s` css style property.", a));
      };
      gP = function(a, c) {
        a.indexOf("-") > -1 ? Aw(a) : mP.test(a) ? SP(a) : Np.test(c) && bP(a, c), typeof c == "number" && (isNaN(c) ? xP(a, c) : isFinite(c) || OD(a, c));
      };
    }
    var LD = gP;
    function jD(a) {
      {
        var c = "", g = "";
        for (var b in a)
          if (a.hasOwnProperty(b)) {
            var C = a[b];
            if (C != null) {
              var I = b.indexOf("--") === 0;
              c += g + (I ? b : DD(b)) + ":", c += IS(b, C, I), g = ";";
            }
          }
        return c || null;
      }
    }
    function wP(a, c) {
      var g = a.style;
      for (var b in c)
        if (c.hasOwnProperty(b)) {
          var C = b.indexOf("--") === 0;
          C || LD(b, c[b]);
          var I = IS(b, c[b], C);
          b === "float" && (b = "cssFloat"), C ? g.setProperty(b, I) : g[b] = I;
        }
    }
    function ND(a) {
      return a == null || typeof a == "boolean" || a === "";
    }
    function tl(a) {
      var c = {};
      for (var g in a)
        for (var b = hP[g] || [g], C = 0; C < b.length; C++)
          c[b[C]] = g;
      return c;
    }
    function Vm(a, c) {
      {
        if (!c)
          return;
        var g = tl(a), b = tl(c), C = {};
        for (var I in g) {
          var N = g[I], H = b[I];
          if (H && N !== H) {
            var V = N + "," + H;
            if (C[V])
              continue;
            C[V] = !0, o("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", ND(a[N]) ? "Removing" : "Updating", N, H);
          }
        }
      }
    }
    var CP = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, EP = on({
      menuitem: !0
    }, CP), _P = "__html";
    function RS(a, c) {
      if (c) {
        if (EP[a] && (c.children != null || c.dangerouslySetInnerHTML != null))
          throw new Error(a + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (c.dangerouslySetInnerHTML != null) {
          if (c.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof c.dangerouslySetInnerHTML != "object" || !(_P in c.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!c.suppressContentEditableWarning && c.contentEditable && c.children != null && o("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), c.style != null && typeof c.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function yu(a, c) {
      if (a.indexOf("-") === -1)
        return typeof c.is == "string";
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var MS = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, TP = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Yl = {}, kw = new RegExp("^(aria)-[" + It + "]*$"), Wm = new RegExp("^(aria)[A-Z][" + It + "]*$");
    function Iw(a, c) {
      {
        if (Ut.call(Yl, c) && Yl[c])
          return !0;
        if (Wm.test(c)) {
          var g = "aria-" + c.slice(4).toLowerCase(), b = TP.hasOwnProperty(g) ? g : null;
          if (b == null)
            return o("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", c), Yl[c] = !0, !0;
          if (c !== b)
            return o("Invalid ARIA attribute `%s`. Did you mean `%s`?", c, b), Yl[c] = !0, !0;
        }
        if (kw.test(c)) {
          var C = c.toLowerCase(), I = TP.hasOwnProperty(C) ? C : null;
          if (I == null)
            return Yl[c] = !0, !1;
          if (c !== I)
            return o("Unknown ARIA attribute `%s`. Did you mean `%s`?", c, I), Yl[c] = !0, !0;
        }
      }
      return !0;
    }
    function PP(a, c) {
      {
        var g = [];
        for (var b in c) {
          var C = Iw(a, b);
          C || g.push(b);
        }
        var I = g.map(function(N) {
          return "`" + N + "`";
        }).join(", ");
        g.length === 1 ? o("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", I, a) : g.length > 1 && o("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", I, a);
      }
    }
    function DS(a, c) {
      yu(a, c) || PP(a, c);
    }
    var Bh = !1;
    function Rw(a, c) {
      {
        if (a !== "input" && a !== "textarea" && a !== "select")
          return;
        c != null && c.value === null && !Bh && (Bh = !0, a === "select" && c.multiple ? o("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", a) : o("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", a));
      }
    }
    var Mw = function() {
    };
    {
      var ds = {}, Dw = /^on./, AP = /^on[^A-Z]/, kP = new RegExp("^(aria)-[" + It + "]*$"), IP = new RegExp("^(aria)[A-Z][" + It + "]*$");
      Mw = function(a, c, g, b) {
        if (Ut.call(ds, c) && ds[c])
          return !0;
        var C = c.toLowerCase();
        if (C === "onfocusin" || C === "onfocusout")
          return o("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ds[c] = !0, !0;
        if (b != null) {
          var I = b.registrationNameDependencies, N = b.possibleRegistrationNames;
          if (I.hasOwnProperty(c))
            return !0;
          var H = N.hasOwnProperty(C) ? N[C] : null;
          if (H != null)
            return o("Invalid event handler property `%s`. Did you mean `%s`?", c, H), ds[c] = !0, !0;
          if (Dw.test(c))
            return o("Unknown event handler property `%s`. It will be ignored.", c), ds[c] = !0, !0;
        } else if (Dw.test(c))
          return AP.test(c) && o("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", c), ds[c] = !0, !0;
        if (kP.test(c) || IP.test(c))
          return !0;
        if (C === "innerhtml")
          return o("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ds[c] = !0, !0;
        if (C === "aria")
          return o("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ds[c] = !0, !0;
        if (C === "is" && g !== null && g !== void 0 && typeof g != "string")
          return o("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof g), ds[c] = !0, !0;
        if (typeof g == "number" && isNaN(g))
          return o("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", c), ds[c] = !0, !0;
        var V = is(c), ee = V !== null && V.type === Ss;
        if (MS.hasOwnProperty(C)) {
          var re = MS[C];
          if (re !== c)
            return o("Invalid DOM property `%s`. Did you mean `%s`?", c, re), ds[c] = !0, !0;
        } else if (!ee && c !== C)
          return o("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", c, C), ds[c] = !0, !0;
        return typeof g == "boolean" && rs(c, g, V, !1) ? (g ? o('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', g, c, c, g, c) : o('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', g, c, c, g, c, c, c), ds[c] = !0, !0) : ee ? !0 : rs(c, g, V, !1) ? (ds[c] = !0, !1) : ((g === "false" || g === "true") && V !== null && V.type === On && (o("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", g, c, g === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', c, g), ds[c] = !0), !0);
      };
    }
    var RP = function(a, c, g) {
      {
        var b = [];
        for (var C in c) {
          var I = Mw(a, C, c[C], g);
          I || b.push(C);
        }
        var N = b.map(function(H) {
          return "`" + H + "`";
        }).join(", ");
        b.length === 1 ? o("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", N, a) : b.length > 1 && o("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", N, a);
      }
    };
    function MP(a, c, g) {
      yu(a, c) || RP(a, c, g);
    }
    var Su = 1, Gm = 2, Hh = 4, FD = Su | Gm | Hh, Km = null;
    function Ym(a) {
      Km !== null && o("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Km = a;
    }
    function $D() {
      Km === null && o("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Km = null;
    }
    function DP(a) {
      return a === Km;
    }
    function OS(a) {
      var c = a.target || a.srcElement || window;
      return c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === vu ? c.parentNode : c;
    }
    var _r = null, wd = null, bu = null;
    function zp(a) {
      var c = Sg(a);
      if (c) {
        if (typeof _r != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var g = c.stateNode;
        if (g) {
          var b = NA(g);
          _r(c.stateNode, c.type, b);
        }
      }
    }
    function OP(a) {
      _r = a;
    }
    function LS(a) {
      wd ? bu ? bu.push(a) : bu = [a] : wd = a;
    }
    function Xm() {
      return wd !== null || bu !== null;
    }
    function qm() {
      if (wd) {
        var a = wd, c = bu;
        if (wd = null, bu = null, zp(a), c)
          for (var g = 0; g < c.length; g++)
            zp(c[g]);
      }
    }
    var Vh = function(a, c) {
      return a(c);
    }, Ow = function() {
    }, Lw = !1;
    function zD() {
      var a = Xm();
      a && (Ow(), qm());
    }
    function jw(a, c, g) {
      if (Lw)
        return a(c, g);
      Lw = !0;
      try {
        return Vh(a, c, g);
      } finally {
        Lw = !1, zD();
      }
    }
    function jS(a, c, g) {
      Vh = a, Ow = g;
    }
    function NS(a) {
      return a === "button" || a === "input" || a === "select" || a === "textarea";
    }
    function Nw(a, c, g) {
      switch (a) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(g.disabled && NS(c));
        default:
          return !1;
      }
    }
    function Wh(a, c) {
      var g = a.stateNode;
      if (g === null)
        return null;
      var b = NA(g);
      if (b === null)
        return null;
      var C = b[c];
      if (Nw(c, a.type, b))
        return null;
      if (C && typeof C != "function")
        throw new Error("Expected `" + c + "` listener to be a function, instead got a value of `" + typeof C + "` type.");
      return C;
    }
    var Zm = !1;
    if (pt)
      try {
        var Gh = {};
        Object.defineProperty(Gh, "passive", {
          get: function() {
            Zm = !0;
          }
        }), window.addEventListener("test", Gh, Gh), window.removeEventListener("test", Gh, Gh);
      } catch {
        Zm = !1;
      }
    function LP(a, c, g, b, C, I, N, H, V) {
      var ee = Array.prototype.slice.call(arguments, 3);
      try {
        c.apply(g, ee);
      } catch (re) {
        this.onError(re);
      }
    }
    var Fw = LP;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var $w = document.createElement("react");
      Fw = function(c, g, b, C, I, N, H, V, ee) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var re = document.createEvent("Event"), me = !1, pe = !0, Ae = window.event, Re = Object.getOwnPropertyDescriptor(window, "event");
        function Oe() {
          $w.removeEventListener(Le, Ht, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ae);
        }
        var ot = Array.prototype.slice.call(arguments, 3);
        function Ht() {
          me = !0, Oe(), g.apply(b, ot), pe = !1;
        }
        var Lt, Nn = !1, Tn = !1;
        function Ee(_e) {
          if (Lt = _e.error, Nn = !0, Lt === null && _e.colno === 0 && _e.lineno === 0 && (Tn = !0), _e.defaultPrevented && Lt != null && typeof Lt == "object")
            try {
              Lt._suppressLogging = !0;
            } catch {
            }
        }
        var Le = "react-" + (c || "invokeguardedcallback");
        if (window.addEventListener("error", Ee), $w.addEventListener(Le, Ht, !1), re.initEvent(Le, !1, !1), $w.dispatchEvent(re), Re && Object.defineProperty(window, "event", Re), me && pe && (Nn ? Tn && (Lt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Lt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Lt)), window.removeEventListener("error", Ee), !me)
          return Oe(), LP.apply(this, arguments);
      };
    }
    var UD = Fw, Cd = !1, Xl = null, Qm = !1, Ed = null, Dc = {
      onError: function(a) {
        Cd = !0, Xl = a;
      }
    };
    function Kh(a, c, g, b, C, I, N, H, V) {
      Cd = !1, Xl = null, UD.apply(Dc, arguments);
    }
    function xu(a, c, g, b, C, I, N, H, V) {
      if (Kh.apply(this, arguments), Cd) {
        var ee = Uw();
        Qm || (Qm = !0, Ed = ee);
      }
    }
    function zw() {
      if (Qm) {
        var a = Ed;
        throw Qm = !1, Ed = null, a;
      }
    }
    function BD() {
      return Cd;
    }
    function Uw() {
      if (Cd) {
        var a = Xl;
        return Cd = !1, Xl = null, a;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function nl(a) {
      return a._reactInternals;
    }
    function Jm(a) {
      return a._reactInternals !== void 0;
    }
    function Up(a, c) {
      a._reactInternals = c;
    }
    var zt = (
      /*                      */
      0
    ), _d = (
      /*                */
      1
    ), $r = (
      /*                    */
      2
    ), pn = (
      /*                       */
      4
    ), or = (
      /*                */
      16
    ), ur = (
      /*                 */
      32
    ), Oc = (
      /*                     */
      64
    ), nn = (
      /*                   */
      128
    ), mi = (
      /*            */
      256
    ), Vo = (
      /*                          */
      512
    ), rl = (
      /*                     */
      1024
    ), qr = (
      /*                      */
      2048
    ), il = (
      /*                    */
      4096
    ), Td = (
      /*                   */
      8192
    ), ev = (
      /*             */
      16384
    ), FS = qr | pn | Oc | Vo | rl | ev, jP = (
      /*               */
      32767
    ), _a = (
      /*                   */
      32768
    ), hs = (
      /*                */
      65536
    ), tv = (
      /* */
      131072
    ), Bw = (
      /*                       */
      1048576
    ), Hw = (
      /*                    */
      2097152
    ), Wo = (
      /*                 */
      4194304
    ), Pd = (
      /*                */
      8388608
    ), Go = (
      /*               */
      16777216
    ), Yh = (
      /*              */
      33554432
    ), Bp = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      pn | rl | 0
    ), Ko = $r | pn | or | ur | Vo | il | Td, Hs = pn | Oc | Vo | Td, sl = qr | or, Cs = Wo | Pd | Hw, wu = e.ReactCurrentOwner;
    function Ta(a) {
      var c = a, g = a;
      if (a.alternate)
        for (; c.return; )
          c = c.return;
      else {
        var b = c;
        do
          c = b, (c.flags & ($r | il)) !== zt && (g = c.return), b = c.return;
        while (b);
      }
      return c.tag === m ? g : null;
    }
    function Vw(a) {
      if (a.tag === $) {
        var c = a.memoizedState;
        if (c === null) {
          var g = a.alternate;
          g !== null && (c = g.memoizedState);
        }
        if (c !== null)
          return c.dehydrated;
      }
      return null;
    }
    function $S(a) {
      return a.tag === m ? a.stateNode.containerInfo : null;
    }
    function Ww(a) {
      return Ta(a) === a;
    }
    function Pa(a) {
      {
        var c = wu.current;
        if (c !== null && c.tag === d) {
          var g = c, b = g.stateNode;
          b._warnedAboutRefsInRender || o("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", tn(g) || "A component"), b._warnedAboutRefsInRender = !0;
        }
      }
      var C = nl(a);
      return C ? Ta(C) === C : !1;
    }
    function Yo(a) {
      if (Ta(a) !== a)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function zr(a) {
      var c = a.alternate;
      if (!c) {
        var g = Ta(a);
        if (g === null)
          throw new Error("Unable to find node on an unmounted component.");
        return g !== a ? null : a;
      }
      for (var b = a, C = c; ; ) {
        var I = b.return;
        if (I === null)
          break;
        var N = I.alternate;
        if (N === null) {
          var H = I.return;
          if (H !== null) {
            b = C = H;
            continue;
          }
          break;
        }
        if (I.child === N.child) {
          for (var V = I.child; V; ) {
            if (V === b)
              return Yo(I), a;
            if (V === C)
              return Yo(I), c;
            V = V.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (b.return !== C.return)
          b = I, C = N;
        else {
          for (var ee = !1, re = I.child; re; ) {
            if (re === b) {
              ee = !0, b = I, C = N;
              break;
            }
            if (re === C) {
              ee = !0, C = I, b = N;
              break;
            }
            re = re.sibling;
          }
          if (!ee) {
            for (re = N.child; re; ) {
              if (re === b) {
                ee = !0, b = N, C = I;
                break;
              }
              if (re === C) {
                ee = !0, C = N, b = I;
                break;
              }
              re = re.sibling;
            }
            if (!ee)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (b.alternate !== C)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (b.tag !== m)
        throw new Error("Unable to find node on an unmounted component.");
      return b.stateNode.current === b ? a : c;
    }
    function ol(a) {
      var c = zr(a);
      return c !== null ? Gw(c) : null;
    }
    function Gw(a) {
      if (a.tag === S || a.tag === w)
        return a;
      for (var c = a.child; c !== null; ) {
        var g = Gw(c);
        if (g !== null)
          return g;
        c = c.sibling;
      }
      return null;
    }
    function NP(a) {
      var c = zr(a);
      return c !== null ? zS(c) : null;
    }
    function zS(a) {
      if (a.tag === S || a.tag === w)
        return a;
      for (var c = a.child; c !== null; ) {
        if (c.tag !== v) {
          var g = zS(c);
          if (g !== null)
            return g;
        }
        c = c.sibling;
      }
      return null;
    }
    var US = t.unstable_scheduleCallback, FP = t.unstable_cancelCallback, BS = t.unstable_shouldYield, $P = t.unstable_requestPaint, ai = t.unstable_now, Kw = t.unstable_getCurrentPriorityLevel, HS = t.unstable_ImmediatePriority, Xh = t.unstable_UserBlockingPriority, Lc = t.unstable_NormalPriority, zP = t.unstable_LowPriority, VS = t.unstable_IdlePriority, Hp = t.unstable_yieldValue, UP = t.unstable_setDisableYieldValue, Cu = null, Bi = null, rt = null, al = !1, Aa = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Yw(a) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (c.isDisabled)
        return !0;
      if (!c.supportsFiber)
        return o("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        je && (a = on({}, a, {
          getLaneLabelMap: Eu,
          injectProfilingHooks: BP
        })), Cu = c.inject(a), Bi = c;
      } catch (g) {
        o("React instrumentation encountered an error: %s.", g);
      }
      return !!c.checkDCE;
    }
    function Xw(a, c) {
      if (Bi && typeof Bi.onScheduleFiberRoot == "function")
        try {
          Bi.onScheduleFiberRoot(Cu, a, c);
        } catch (g) {
          al || (al = !0, o("React instrumentation encountered an error: %s", g));
        }
    }
    function Vp(a, c) {
      if (Bi && typeof Bi.onCommitFiberRoot == "function")
        try {
          var g = (a.current.flags & nn) === nn;
          if (nt) {
            var b;
            switch (c) {
              case _i:
                b = HS;
                break;
              case Tu:
                b = Xh;
                break;
              case jc:
                b = Lc;
                break;
              case ng:
                b = VS;
                break;
              default:
                b = Lc;
                break;
            }
            Bi.onCommitFiberRoot(Cu, a, b, g);
          }
        } catch (C) {
          al || (al = !0, o("React instrumentation encountered an error: %s", C));
        }
    }
    function ll(a) {
      if (Bi && typeof Bi.onPostCommitFiberRoot == "function")
        try {
          Bi.onPostCommitFiberRoot(Cu, a);
        } catch (c) {
          al || (al = !0, o("React instrumentation encountered an error: %s", c));
        }
    }
    function qh(a) {
      if (Bi && typeof Bi.onCommitFiberUnmount == "function")
        try {
          Bi.onCommitFiberUnmount(Cu, a);
        } catch (c) {
          al || (al = !0, o("React instrumentation encountered an error: %s", c));
        }
    }
    function ji(a) {
      if (typeof Hp == "function" && (UP(a), i(a)), Bi && typeof Bi.setStrictMode == "function")
        try {
          Bi.setStrictMode(Cu, a);
        } catch (c) {
          al || (al = !0, o("React instrumentation encountered an error: %s", c));
        }
    }
    function BP(a) {
      rt = a;
    }
    function Eu() {
      {
        for (var a = /* @__PURE__ */ new Map(), c = 1, g = 0; g < ov; g++) {
          var b = VD(c);
          a.set(c, b), c *= 2;
        }
        return a;
      }
    }
    function Ad(a) {
      rt !== null && typeof rt.markCommitStarted == "function" && rt.markCommitStarted(a);
    }
    function WS() {
      rt !== null && typeof rt.markCommitStopped == "function" && rt.markCommitStopped();
    }
    function Wp(a) {
      rt !== null && typeof rt.markComponentRenderStarted == "function" && rt.markComponentRenderStarted(a);
    }
    function Xo() {
      rt !== null && typeof rt.markComponentRenderStopped == "function" && rt.markComponentRenderStopped();
    }
    function kd(a) {
      rt !== null && typeof rt.markComponentPassiveEffectMountStarted == "function" && rt.markComponentPassiveEffectMountStarted(a);
    }
    function GS() {
      rt !== null && typeof rt.markComponentPassiveEffectMountStopped == "function" && rt.markComponentPassiveEffectMountStopped();
    }
    function HP(a) {
      rt !== null && typeof rt.markComponentPassiveEffectUnmountStarted == "function" && rt.markComponentPassiveEffectUnmountStarted(a);
    }
    function KS() {
      rt !== null && typeof rt.markComponentPassiveEffectUnmountStopped == "function" && rt.markComponentPassiveEffectUnmountStopped();
    }
    function VP(a) {
      rt !== null && typeof rt.markComponentLayoutEffectMountStarted == "function" && rt.markComponentLayoutEffectMountStarted(a);
    }
    function nv() {
      rt !== null && typeof rt.markComponentLayoutEffectMountStopped == "function" && rt.markComponentLayoutEffectMountStopped();
    }
    function ql(a) {
      rt !== null && typeof rt.markComponentLayoutEffectUnmountStarted == "function" && rt.markComponentLayoutEffectUnmountStarted(a);
    }
    function Gp() {
      rt !== null && typeof rt.markComponentLayoutEffectUnmountStopped == "function" && rt.markComponentLayoutEffectUnmountStopped();
    }
    function rv(a, c, g) {
      rt !== null && typeof rt.markComponentErrored == "function" && rt.markComponentErrored(a, c, g);
    }
    function Zh(a, c, g) {
      rt !== null && typeof rt.markComponentSuspended == "function" && rt.markComponentSuspended(a, c, g);
    }
    function qw(a) {
      rt !== null && typeof rt.markLayoutEffectsStarted == "function" && rt.markLayoutEffectsStarted(a);
    }
    function Kp() {
      rt !== null && typeof rt.markLayoutEffectsStopped == "function" && rt.markLayoutEffectsStopped();
    }
    function WP(a) {
      rt !== null && typeof rt.markPassiveEffectsStarted == "function" && rt.markPassiveEffectsStarted(a);
    }
    function Zw() {
      rt !== null && typeof rt.markPassiveEffectsStopped == "function" && rt.markPassiveEffectsStopped();
    }
    function Zr(a) {
      rt !== null && typeof rt.markRenderStarted == "function" && rt.markRenderStarted(a);
    }
    function YS() {
      rt !== null && typeof rt.markRenderYielded == "function" && rt.markRenderYielded();
    }
    function XS() {
      rt !== null && typeof rt.markRenderStopped == "function" && rt.markRenderStopped();
    }
    function Qw(a) {
      rt !== null && typeof rt.markRenderScheduled == "function" && rt.markRenderScheduled(a);
    }
    function qS(a, c) {
      rt !== null && typeof rt.markForceUpdateScheduled == "function" && rt.markForceUpdateScheduled(a, c);
    }
    function iv(a, c) {
      rt !== null && typeof rt.markStateUpdateScheduled == "function" && rt.markStateUpdateScheduled(a, c);
    }
    var Rt = (
      /*                         */
      0
    ), Ot = (
      /*                 */
      1
    ), rn = (
      /*                    */
      2
    ), Sn = (
      /*               */
      8
    ), ka = (
      /*              */
      16
    ), Yp = Math.clz32 ? Math.clz32 : Vs, sv = Math.log, HD = Math.LN2;
    function Vs(a) {
      var c = a >>> 0;
      return c === 0 ? 32 : 31 - (sv(c) / HD | 0) | 0;
    }
    var ov = 31, Ue = (
      /*                        */
      0
    ), Ni = (
      /*                          */
      0
    ), Nt = (
      /*                        */
      1
    ), Es = (
      /*    */
      2
    ), Ia = (
      /*             */
      4
    ), _u = (
      /*            */
      8
    ), cl = (
      /*                     */
      16
    ), Xp = (
      /*                */
      32
    ), Qh = (
      /*                       */
      4194240
    ), qp = (
      /*                        */
      64
    ), ZS = (
      /*                        */
      128
    ), QS = (
      /*                        */
      256
    ), JS = (
      /*                        */
      512
    ), eb = (
      /*                        */
      1024
    ), tb = (
      /*                        */
      2048
    ), Jh = (
      /*                        */
      4096
    ), nb = (
      /*                        */
      8192
    ), Zp = (
      /*                        */
      16384
    ), Qp = (
      /*                       */
      32768
    ), rb = (
      /*                       */
      65536
    ), av = (
      /*                       */
      131072
    ), ib = (
      /*                       */
      262144
    ), sb = (
      /*                       */
      524288
    ), ob = (
      /*                       */
      1048576
    ), ab = (
      /*                       */
      2097152
    ), Jp = (
      /*                            */
      130023424
    ), ef = (
      /*                             */
      4194304
    ), lb = (
      /*                             */
      8388608
    ), cb = (
      /*                             */
      16777216
    ), Jw = (
      /*                             */
      33554432
    ), ub = (
      /*                             */
      67108864
    ), GP = ef, lv = (
      /*          */
      134217728
    ), eC = (
      /*                          */
      268435455
    ), eg = (
      /*               */
      268435456
    ), Id = (
      /*                        */
      536870912
    ), Ws = (
      /*                   */
      1073741824
    );
    function VD(a) {
      {
        if (a & Nt)
          return "Sync";
        if (a & Es)
          return "InputContinuousHydration";
        if (a & Ia)
          return "InputContinuous";
        if (a & _u)
          return "DefaultHydration";
        if (a & cl)
          return "Default";
        if (a & Xp)
          return "TransitionHydration";
        if (a & Qh)
          return "Transition";
        if (a & Jp)
          return "Retry";
        if (a & lv)
          return "SelectiveHydration";
        if (a & eg)
          return "IdleHydration";
        if (a & Id)
          return "Idle";
        if (a & Ws)
          return "Offscreen";
      }
    }
    var Rr = -1, db = qp, qo = ef;
    function tf(a) {
      switch (Ei(a)) {
        case Nt:
          return Nt;
        case Es:
          return Es;
        case Ia:
          return Ia;
        case _u:
          return _u;
        case cl:
          return cl;
        case Xp:
          return Xp;
        case qp:
        case ZS:
        case QS:
        case JS:
        case eb:
        case tb:
        case Jh:
        case nb:
        case Zp:
        case Qp:
        case rb:
        case av:
        case ib:
        case sb:
        case ob:
        case ab:
          return a & Qh;
        case ef:
        case lb:
        case cb:
        case Jw:
        case ub:
          return a & Jp;
        case lv:
          return lv;
        case eg:
          return eg;
        case Id:
          return Id;
        case Ws:
          return Ws;
        default:
          return o("Should have found matching lanes. This is a bug in React."), a;
      }
    }
    function nf(a, c) {
      var g = a.pendingLanes;
      if (g === Ue)
        return Ue;
      var b = Ue, C = a.suspendedLanes, I = a.pingedLanes, N = g & eC;
      if (N !== Ue) {
        var H = N & ~C;
        if (H !== Ue)
          b = tf(H);
        else {
          var V = N & I;
          V !== Ue && (b = tf(V));
        }
      } else {
        var ee = g & ~C;
        ee !== Ue ? b = tf(ee) : I !== Ue && (b = tf(I));
      }
      if (b === Ue)
        return Ue;
      if (c !== Ue && c !== b && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (c & C) === Ue) {
        var re = Ei(b), me = Ei(c);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          re >= me || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          re === cl && (me & Qh) !== Ue
        )
          return c;
      }
      (b & Ia) !== Ue && (b |= g & cl);
      var pe = a.entangledLanes;
      if (pe !== Ue)
        for (var Ae = a.entanglements, Re = b & pe; Re > 0; ) {
          var Oe = Md(Re), ot = 1 << Oe;
          b |= Ae[Oe], Re &= ~ot;
        }
      return b;
    }
    function KP(a, c) {
      for (var g = a.eventTimes, b = Rr; c > 0; ) {
        var C = Md(c), I = 1 << C, N = g[C];
        N > b && (b = N), c &= ~I;
      }
      return b;
    }
    function YP(a, c) {
      switch (a) {
        case Nt:
        case Es:
        case Ia:
          return c + 250;
        case _u:
        case cl:
        case Xp:
        case qp:
        case ZS:
        case QS:
        case JS:
        case eb:
        case tb:
        case Jh:
        case nb:
        case Zp:
        case Qp:
        case rb:
        case av:
        case ib:
        case sb:
        case ob:
        case ab:
          return c + 5e3;
        case ef:
        case lb:
        case cb:
        case Jw:
        case ub:
          return Rr;
        case lv:
        case eg:
        case Id:
        case Ws:
          return Rr;
        default:
          return o("Should have found matching lanes. This is a bug in React."), Rr;
      }
    }
    function XP(a, c) {
      for (var g = a.pendingLanes, b = a.suspendedLanes, C = a.pingedLanes, I = a.expirationTimes, N = g; N > 0; ) {
        var H = Md(N), V = 1 << H, ee = I[H];
        ee === Rr ? ((V & b) === Ue || (V & C) !== Ue) && (I[H] = YP(V, c)) : ee <= c && (a.expiredLanes |= V), N &= ~V;
      }
    }
    function tC(a) {
      return tf(a.pendingLanes);
    }
    function Rd(a) {
      var c = a.pendingLanes & ~Ws;
      return c !== Ue ? c : c & Ws ? Ws : Ue;
    }
    function nC(a) {
      return (a & Nt) !== Ue;
    }
    function cv(a) {
      return (a & eC) !== Ue;
    }
    function qP(a) {
      return (a & Jp) === a;
    }
    function ZP(a) {
      var c = Nt | Ia | cl;
      return (a & c) === Ue;
    }
    function QP(a) {
      return (a & Qh) === a;
    }
    function uv(a, c) {
      var g = Es | Ia | _u | cl;
      return (c & g) !== Ue;
    }
    function JP(a, c) {
      return (c & a.expiredLanes) !== Ue;
    }
    function rC(a) {
      return (a & Qh) !== Ue;
    }
    function eA() {
      var a = db;
      return db <<= 1, (db & Qh) === Ue && (db = qp), a;
    }
    function Zo() {
      var a = qo;
      return qo <<= 1, (qo & Jp) === Ue && (qo = ef), a;
    }
    function Ei(a) {
      return a & -a;
    }
    function tg(a) {
      return Ei(a);
    }
    function Md(a) {
      return 31 - Yp(a);
    }
    function hb(a) {
      return Md(a);
    }
    function Qo(a, c) {
      return (a & c) !== Ue;
    }
    function rf(a, c) {
      return (a & c) === c;
    }
    function dn(a, c) {
      return a | c;
    }
    function dv(a, c) {
      return a & ~c;
    }
    function fb(a, c) {
      return a & c;
    }
    function WD(a) {
      return a;
    }
    function tA(a, c) {
      return a !== Ni && a < c ? a : c;
    }
    function hv(a) {
      for (var c = [], g = 0; g < ov; g++)
        c.push(a);
      return c;
    }
    function sf(a, c, g) {
      a.pendingLanes |= c, c !== Id && (a.suspendedLanes = Ue, a.pingedLanes = Ue);
      var b = a.eventTimes, C = hb(c);
      b[C] = g;
    }
    function nA(a, c) {
      a.suspendedLanes |= c, a.pingedLanes &= ~c;
      for (var g = a.expirationTimes, b = c; b > 0; ) {
        var C = Md(b), I = 1 << C;
        g[C] = Rr, b &= ~I;
      }
    }
    function pb(a, c, g) {
      a.pingedLanes |= a.suspendedLanes & c;
    }
    function gb(a, c) {
      var g = a.pendingLanes & ~c;
      a.pendingLanes = c, a.suspendedLanes = Ue, a.pingedLanes = Ue, a.expiredLanes &= c, a.mutableReadLanes &= c, a.entangledLanes &= c;
      for (var b = a.entanglements, C = a.eventTimes, I = a.expirationTimes, N = g; N > 0; ) {
        var H = Md(N), V = 1 << H;
        b[H] = Ue, C[H] = Rr, I[H] = Rr, N &= ~V;
      }
    }
    function iC(a, c) {
      for (var g = a.entangledLanes |= c, b = a.entanglements, C = g; C; ) {
        var I = Md(C), N = 1 << I;
        // Is this one of the newly entangled lanes?
        N & c | // Is this lane transitively entangled with the newly entangled lanes?
        b[I] & c && (b[I] |= c), C &= ~N;
      }
    }
    function rA(a, c) {
      var g = Ei(c), b;
      switch (g) {
        case Ia:
          b = Es;
          break;
        case cl:
          b = _u;
          break;
        case qp:
        case ZS:
        case QS:
        case JS:
        case eb:
        case tb:
        case Jh:
        case nb:
        case Zp:
        case Qp:
        case rb:
        case av:
        case ib:
        case sb:
        case ob:
        case ab:
        case ef:
        case lb:
        case cb:
        case Jw:
        case ub:
          b = Xp;
          break;
        case Id:
          b = eg;
          break;
        default:
          b = Ni;
          break;
      }
      return (b & (a.suspendedLanes | c)) !== Ni ? Ni : b;
    }
    function mb(a, c, g) {
      if (Aa)
        for (var b = a.pendingUpdatersLaneMap; g > 0; ) {
          var C = hb(g), I = 1 << C, N = b[C];
          N.add(c), g &= ~I;
        }
    }
    function sC(a, c) {
      if (Aa)
        for (var g = a.pendingUpdatersLaneMap, b = a.memoizedUpdaters; c > 0; ) {
          var C = hb(c), I = 1 << C, N = g[C];
          N.size > 0 && (N.forEach(function(H) {
            var V = H.alternate;
            (V === null || !b.has(V)) && b.add(H);
          }), N.clear()), c &= ~I;
        }
    }
    function fv(a, c) {
      return null;
    }
    var _i = Nt, Tu = Ia, jc = cl, ng = Id, rg = Ni;
    function ul() {
      return rg;
    }
    function vi(a) {
      rg = a;
    }
    function Gs(a, c) {
      var g = rg;
      try {
        return rg = a, c();
      } finally {
        rg = g;
      }
    }
    function GD(a, c) {
      return a !== 0 && a < c ? a : c;
    }
    function KD(a, c) {
      return a > c ? a : c;
    }
    function ig(a, c) {
      return a !== 0 && a < c;
    }
    function _s(a) {
      var c = Ei(a);
      return ig(_i, c) ? ig(Tu, c) ? cv(c) ? jc : ng : Tu : _i;
    }
    function vb(a) {
      var c = a.current.memoizedState;
      return c.isDehydrated;
    }
    var gt;
    function sg(a) {
      gt = a;
    }
    function oC(a) {
      gt(a);
    }
    var yb;
    function YD(a) {
      yb = a;
    }
    var og;
    function Sb(a) {
      og = a;
    }
    var bb;
    function iA(a) {
      bb = a;
    }
    var aC;
    function sA(a) {
      aC = a;
    }
    var pv = !1, ag = [], Qr = null, fs = null, ho = null, lg = /* @__PURE__ */ new Map(), cg = /* @__PURE__ */ new Map(), ps = [], oA = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Nc(a) {
      return oA.indexOf(a) > -1;
    }
    function XD(a, c, g, b, C) {
      return {
        blockedOn: a,
        domEventName: c,
        eventSystemFlags: g,
        nativeEvent: C,
        targetContainers: [b]
      };
    }
    function lC(a, c) {
      switch (a) {
        case "focusin":
        case "focusout":
          Qr = null;
          break;
        case "dragenter":
        case "dragleave":
          fs = null;
          break;
        case "mouseover":
        case "mouseout":
          ho = null;
          break;
        case "pointerover":
        case "pointerout": {
          var g = c.pointerId;
          lg.delete(g);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var b = c.pointerId;
          cg.delete(b);
          break;
        }
      }
    }
    function ug(a, c, g, b, C, I) {
      if (a === null || a.nativeEvent !== I) {
        var N = XD(c, g, b, C, I);
        if (c !== null) {
          var H = Sg(c);
          H !== null && yb(H);
        }
        return N;
      }
      a.eventSystemFlags |= b;
      var V = a.targetContainers;
      return C !== null && V.indexOf(C) === -1 && V.push(C), a;
    }
    function aA(a, c, g, b, C) {
      switch (c) {
        case "focusin": {
          var I = C;
          return Qr = ug(Qr, a, c, g, b, I), !0;
        }
        case "dragenter": {
          var N = C;
          return fs = ug(fs, a, c, g, b, N), !0;
        }
        case "mouseover": {
          var H = C;
          return ho = ug(ho, a, c, g, b, H), !0;
        }
        case "pointerover": {
          var V = C, ee = V.pointerId;
          return lg.set(ee, ug(lg.get(ee) || null, a, c, g, b, V)), !0;
        }
        case "gotpointercapture": {
          var re = C, me = re.pointerId;
          return cg.set(me, ug(cg.get(me) || null, a, c, g, b, re)), !0;
        }
      }
      return !1;
    }
    function cC(a) {
      var c = Tv(a.target);
      if (c !== null) {
        var g = Ta(c);
        if (g !== null) {
          var b = g.tag;
          if (b === $) {
            var C = Vw(g);
            if (C !== null) {
              a.blockedOn = C, aC(a.priority, function() {
                og(g);
              });
              return;
            }
          } else if (b === m) {
            var I = g.stateNode;
            if (vb(I)) {
              a.blockedOn = $S(g);
              return;
            }
          }
        }
      }
      a.blockedOn = null;
    }
    function qD(a) {
      for (var c = bb(), g = {
        blockedOn: null,
        target: a,
        priority: c
      }, b = 0; b < ps.length && ig(c, ps[b].priority); b++)
        ;
      ps.splice(b, 0, g), b === 0 && cC(g);
    }
    function of(a) {
      if (a.blockedOn !== null)
        return !1;
      for (var c = a.targetContainers; c.length > 0; ) {
        var g = c[0], b = Ks(a.domEventName, a.eventSystemFlags, g, a.nativeEvent);
        if (b === null) {
          var C = a.nativeEvent, I = new C.constructor(C.type, C);
          Ym(I), C.target.dispatchEvent(I), $D();
        } else {
          var N = Sg(b);
          return N !== null && yb(N), a.blockedOn = b, !1;
        }
        c.shift();
      }
      return !0;
    }
    function xb(a, c, g) {
      of(a) && g.delete(c);
    }
    function dl() {
      pv = !1, Qr !== null && of(Qr) && (Qr = null), fs !== null && of(fs) && (fs = null), ho !== null && of(ho) && (ho = null), lg.forEach(xb), cg.forEach(xb);
    }
    function _n(a, c) {
      a.blockedOn === c && (a.blockedOn = null, pv || (pv = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, dl)));
    }
    function yi(a) {
      if (ag.length > 0) {
        _n(ag[0], a);
        for (var c = 1; c < ag.length; c++) {
          var g = ag[c];
          g.blockedOn === a && (g.blockedOn = null);
        }
      }
      Qr !== null && _n(Qr, a), fs !== null && _n(fs, a), ho !== null && _n(ho, a);
      var b = function(H) {
        return _n(H, a);
      };
      lg.forEach(b), cg.forEach(b);
      for (var C = 0; C < ps.length; C++) {
        var I = ps[C];
        I.blockedOn === a && (I.blockedOn = null);
      }
      for (; ps.length > 0; ) {
        var N = ps[0];
        if (N.blockedOn !== null)
          break;
        cC(N), N.blockedOn === null && ps.shift();
      }
    }
    var Ur = e.ReactCurrentBatchConfig, Hi = !0;
    function Jo(a) {
      Hi = !!a;
    }
    function dg() {
      return Hi;
    }
    function Vi(a, c, g) {
      var b = wb(c), C;
      switch (b) {
        case _i:
          C = gv;
          break;
        case Tu:
          C = af;
          break;
        case jc:
        default:
          C = hg;
          break;
      }
      return C.bind(null, c, g, a);
    }
    function gv(a, c, g, b) {
      var C = ul(), I = Ur.transition;
      Ur.transition = null;
      try {
        vi(_i), hg(a, c, g, b);
      } finally {
        vi(C), Ur.transition = I;
      }
    }
    function af(a, c, g, b) {
      var C = ul(), I = Ur.transition;
      Ur.transition = null;
      try {
        vi(Tu), hg(a, c, g, b);
      } finally {
        vi(C), Ur.transition = I;
      }
    }
    function hg(a, c, g, b) {
      Hi && uC(a, c, g, b);
    }
    function uC(a, c, g, b) {
      var C = Ks(a, c, g, b);
      if (C === null) {
        fO(a, c, b, Dd, g), lC(a, b);
        return;
      }
      if (aA(C, a, c, g, b)) {
        b.stopPropagation();
        return;
      }
      if (lC(a, b), c & Hh && Nc(a)) {
        for (; C !== null; ) {
          var I = Sg(C);
          I !== null && oC(I);
          var N = Ks(a, c, g, b);
          if (N === null && fO(a, c, b, Dd, g), N === C)
            break;
          C = N;
        }
        C !== null && b.stopPropagation();
        return;
      }
      fO(a, c, b, null, g);
    }
    var Dd = null;
    function Ks(a, c, g, b) {
      Dd = null;
      var C = OS(b), I = Tv(C);
      if (I !== null) {
        var N = Ta(I);
        if (N === null)
          I = null;
        else {
          var H = N.tag;
          if (H === $) {
            var V = Vw(N);
            if (V !== null)
              return V;
            I = null;
          } else if (H === m) {
            var ee = N.stateNode;
            if (vb(ee))
              return $S(N);
            I = null;
          } else N !== I && (I = null);
        }
      }
      return Dd = I, null;
    }
    function wb(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return _i;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Tu;
        case "message": {
          var c = Kw();
          switch (c) {
            case HS:
              return _i;
            case Xh:
              return Tu;
            case Lc:
            case zP:
              return jc;
            case VS:
              return ng;
            default:
              return jc;
          }
        }
        default:
          return jc;
      }
    }
    function fg(a, c, g) {
      return a.addEventListener(c, g, !1), g;
    }
    function Pu(a, c, g) {
      return a.addEventListener(c, g, !0), g;
    }
    function Cb(a, c, g, b) {
      return a.addEventListener(c, g, {
        capture: !0,
        passive: b
      }), g;
    }
    function dC(a, c, g, b) {
      return a.addEventListener(c, g, {
        passive: b
      }), g;
    }
    var hl = null, pg = null, fl = null;
    function Eb(a) {
      return hl = a, pg = vv(), !0;
    }
    function mv() {
      hl = null, pg = null, fl = null;
    }
    function _b() {
      if (fl)
        return fl;
      var a, c = pg, g = c.length, b, C = vv(), I = C.length;
      for (a = 0; a < g && c[a] === C[a]; a++)
        ;
      var N = g - a;
      for (b = 1; b <= N && c[g - b] === C[I - b]; b++)
        ;
      var H = b > 1 ? 1 - b : void 0;
      return fl = C.slice(a, H), fl;
    }
    function vv() {
      return "value" in hl ? hl.value : hl.textContent;
    }
    function lf(a) {
      var c, g = a.keyCode;
      return "charCode" in a ? (c = a.charCode, c === 0 && g === 13 && (c = 13)) : c = g, c === 10 && (c = 13), c >= 32 || c === 13 ? c : 0;
    }
    function gs() {
      return !0;
    }
    function Au() {
      return !1;
    }
    function li(a) {
      function c(g, b, C, I, N) {
        this._reactName = g, this._targetInst = C, this.type = b, this.nativeEvent = I, this.target = N, this.currentTarget = null;
        for (var H in a)
          if (a.hasOwnProperty(H)) {
            var V = a[H];
            V ? this[H] = V(I) : this[H] = I[H];
          }
        var ee = I.defaultPrevented != null ? I.defaultPrevented : I.returnValue === !1;
        return ee ? this.isDefaultPrevented = gs : this.isDefaultPrevented = Au, this.isPropagationStopped = Au, this;
      }
      return on(c.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var g = this.nativeEvent;
          g && (g.preventDefault ? g.preventDefault() : typeof g.returnValue != "unknown" && (g.returnValue = !1), this.isDefaultPrevented = gs);
        },
        stopPropagation: function() {
          var g = this.nativeEvent;
          g && (g.stopPropagation ? g.stopPropagation() : typeof g.cancelBubble != "unknown" && (g.cancelBubble = !0), this.isPropagationStopped = gs);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: gs
      }), c;
    }
    var Wi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Tb = li(Wi), cf = on({}, Wi, {
      view: 0,
      detail: 0
    }), hC = li(cf), fC, Fc, gg;
    function pC(a) {
      a !== gg && (gg && a.type === "mousemove" ? (fC = a.screenX - gg.screenX, Fc = a.screenY - gg.screenY) : (fC = 0, Fc = 0), gg = a);
    }
    var $c = on({}, cf, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: gC,
      button: 0,
      buttons: 0,
      relatedTarget: function(a) {
        return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      },
      movementX: function(a) {
        return "movementX" in a ? a.movementX : (pC(a), fC);
      },
      movementY: function(a) {
        return "movementY" in a ? a.movementY : Fc;
      }
    }), Pb = li($c), uf = on({}, $c, {
      dataTransfer: 0
    }), lA = li(uf), cA = on({}, cf, {
      relatedTarget: 0
    }), yv = li(cA), Ab = on({}, Wi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), ZD = li(Ab), QD = on({}, Wi, {
      clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      }
    }), uA = li(QD), dA = on({}, Wi, {
      data: 0
    }), Od = li(dA), JD = Od, mg = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, hA = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Si(a) {
      if (a.key) {
        var c = mg[a.key] || a.key;
        if (c !== "Unidentified")
          return c;
      }
      if (a.type === "keypress") {
        var g = lf(a);
        return g === 13 ? "Enter" : String.fromCharCode(g);
      }
      return a.type === "keydown" || a.type === "keyup" ? hA[a.keyCode] || "Unidentified" : "";
    }
    var eO = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function fA(a) {
      var c = this, g = c.nativeEvent;
      if (g.getModifierState)
        return g.getModifierState(a);
      var b = eO[a];
      return b ? !!g[b] : !1;
    }
    function gC(a) {
      return fA;
    }
    var tO = on({}, cf, {
      key: Si,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: gC,
      // Legacy Interface
      charCode: function(a) {
        return a.type === "keypress" ? lf(a) : 0;
      },
      keyCode: function(a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function(a) {
        return a.type === "keypress" ? lf(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      }
    }), pA = li(tO), gA = on({}, $c, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), mA = li(gA), pl = on({}, cf, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: gC
    }), mC = li(pl), nO = on({}, Wi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Ld = li(nO), kb = on({}, $c, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in a ? -a.wheelDeltaX : 0
        );
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in a ? -a.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in a ? -a.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), df = li(kb), Ib = [9, 13, 27, 32], Rb = 229, Sv = pt && "CompositionEvent" in window, bv = null;
    pt && "documentMode" in document && (bv = document.documentMode);
    var vC = pt && "TextEvent" in window && !bv, vA = pt && (!Sv || bv && bv > 8 && bv <= 11), yC = 32, SC = String.fromCharCode(yC);
    function Mb() {
      Yt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Yt("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Yt("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Yt("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var xv = !1;
    function yA(a) {
      return (a.ctrlKey || a.altKey || a.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(a.ctrlKey && a.altKey);
    }
    function bC(a) {
      switch (a) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function rO(a, c) {
      return a === "keydown" && c.keyCode === Rb;
    }
    function xC(a, c) {
      switch (a) {
        case "keyup":
          return Ib.indexOf(c.keyCode) !== -1;
        case "keydown":
          return c.keyCode !== Rb;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Db(a) {
      var c = a.detail;
      return typeof c == "object" && "data" in c ? c.data : null;
    }
    function wv(a) {
      return a.locale === "ko";
    }
    var jd = !1;
    function Ob(a, c, g, b, C) {
      var I, N;
      if (Sv ? I = bC(c) : jd ? xC(c, b) && (I = "onCompositionEnd") : rO(c, b) && (I = "onCompositionStart"), !I)
        return null;
      vA && !wv(b) && (!jd && I === "onCompositionStart" ? jd = Eb(C) : I === "onCompositionEnd" && jd && (N = _b()));
      var H = EA(g, I);
      if (H.length > 0) {
        var V = new Od(I, c, null, b, C);
        if (a.push({
          event: V,
          listeners: H
        }), N)
          V.data = N;
        else {
          var ee = Db(b);
          ee !== null && (V.data = ee);
        }
      }
    }
    function SA(a, c) {
      switch (a) {
        case "compositionend":
          return Db(c);
        case "keypress":
          var g = c.which;
          return g !== yC ? null : (xv = !0, SC);
        case "textInput":
          var b = c.data;
          return b === SC && xv ? null : b;
        default:
          return null;
      }
    }
    function iO(a, c) {
      if (jd) {
        if (a === "compositionend" || !Sv && xC(a, c)) {
          var g = _b();
          return mv(), jd = !1, g;
        }
        return null;
      }
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!yA(c)) {
            if (c.char && c.char.length > 1)
              return c.char;
            if (c.which)
              return String.fromCharCode(c.which);
          }
          return null;
        case "compositionend":
          return vA && !wv(c) ? null : c.data;
        default:
          return null;
      }
    }
    function Lb(a, c, g, b, C) {
      var I;
      if (vC ? I = SA(c, b) : I = iO(c, b), !I)
        return null;
      var N = EA(g, "onBeforeInput");
      if (N.length > 0) {
        var H = new JD("onBeforeInput", "beforeinput", null, b, C);
        a.push({
          event: H,
          listeners: N
        }), H.data = I;
      }
    }
    function sO(a, c, g, b, C, I, N) {
      Ob(a, c, g, b, C), Lb(a, c, g, b, C);
    }
    var Cv = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function bA(a) {
      var c = a && a.nodeName && a.nodeName.toLowerCase();
      return c === "input" ? !!Cv[a.type] : c === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function jb(a) {
      if (!pt)
        return !1;
      var c = "on" + a, g = c in document;
      if (!g) {
        var b = document.createElement("div");
        b.setAttribute(c, "return;"), g = typeof b[c] == "function";
      }
      return g;
    }
    function h() {
      Yt("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function p(a, c, g, b) {
      LS(b);
      var C = EA(c, "onChange");
      if (C.length > 0) {
        var I = new Tb("onChange", "change", null, g, b);
        a.push({
          event: I,
          listeners: C
        });
      }
    }
    var x = null, k = null;
    function L(a) {
      var c = a.nodeName && a.nodeName.toLowerCase();
      return c === "select" || c === "input" && a.type === "file";
    }
    function z(a) {
      var c = [];
      p(c, k, a, OS(a)), jw(Y, c);
    }
    function Y(a) {
      vB(a, 0);
    }
    function ae(a) {
      var c = Bb(a);
      if ($e(c))
        return a;
    }
    function he(a, c) {
      if (a === "change")
        return c;
    }
    var Ie = !1;
    pt && (Ie = jb("input") && (!document.documentMode || document.documentMode > 9));
    function We(a, c) {
      x = a, k = c, x.attachEvent("onpropertychange", Ve);
    }
    function Ge() {
      x && (x.detachEvent("onpropertychange", Ve), x = null, k = null);
    }
    function Ve(a) {
      a.propertyName === "value" && ae(k) && z(a);
    }
    function dt(a, c, g) {
      a === "focusin" ? (Ge(), We(c, g)) : a === "focusout" && Ge();
    }
    function St(a, c) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return ae(k);
    }
    function _t(a) {
      var c = a.nodeName;
      return c && c.toLowerCase() === "input" && (a.type === "checkbox" || a.type === "radio");
    }
    function Ti(a, c) {
      if (a === "click")
        return ae(c);
    }
    function xe(a, c) {
      if (a === "input" || a === "change")
        return ae(c);
    }
    function ge(a) {
      var c = a._wrapperState;
      !c || !c.controlled || a.type !== "number" || Ct(a, "number", a.value);
    }
    function Te(a, c, g, b, C, I, N) {
      var H = g ? Bb(g) : window, V, ee;
      if (L(H) ? V = he : bA(H) ? Ie ? V = xe : (V = St, ee = dt) : _t(H) && (V = Ti), V) {
        var re = V(c, g);
        if (re) {
          p(a, re, b, C);
          return;
        }
      }
      ee && ee(c, H, g), c === "focusout" && ge(H);
    }
    function qe() {
      Un("onMouseEnter", ["mouseout", "mouseover"]), Un("onMouseLeave", ["mouseout", "mouseover"]), Un("onPointerEnter", ["pointerout", "pointerover"]), Un("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Mt(a, c, g, b, C, I, N) {
      var H = c === "mouseover" || c === "pointerover", V = c === "mouseout" || c === "pointerout";
      if (H && !DP(b)) {
        var ee = b.relatedTarget || b.fromElement;
        if (ee && (Tv(ee) || LC(ee)))
          return;
      }
      if (!(!V && !H)) {
        var re;
        if (C.window === C)
          re = C;
        else {
          var me = C.ownerDocument;
          me ? re = me.defaultView || me.parentWindow : re = window;
        }
        var pe, Ae;
        if (V) {
          var Re = b.relatedTarget || b.toElement;
          if (pe = g, Ae = Re ? Tv(Re) : null, Ae !== null) {
            var Oe = Ta(Ae);
            (Ae !== Oe || Ae.tag !== S && Ae.tag !== w) && (Ae = null);
          }
        } else
          pe = null, Ae = g;
        if (pe !== Ae) {
          var ot = Pb, Ht = "onMouseLeave", Lt = "onMouseEnter", Nn = "mouse";
          (c === "pointerout" || c === "pointerover") && (ot = mA, Ht = "onPointerLeave", Lt = "onPointerEnter", Nn = "pointer");
          var Tn = pe == null ? re : Bb(pe), Ee = Ae == null ? re : Bb(Ae), Le = new ot(Ht, Nn + "leave", pe, b, C);
          Le.target = Tn, Le.relatedTarget = Ee;
          var _e = null, Ye = Tv(C);
          if (Ye === g) {
            var ft = new ot(Lt, Nn + "enter", Ae, b, C);
            ft.target = Ee, ft.relatedTarget = Tn, _e = ft;
          }
          xne(a, Le, _e, pe, Ae);
        }
      }
    }
    function Kt(a, c) {
      return a === c && (a !== 0 || 1 / a === 1 / c) || a !== a && c !== c;
    }
    var bt = typeof Object.is == "function" ? Object.is : Kt;
    function Xt(a, c) {
      if (bt(a, c))
        return !0;
      if (typeof a != "object" || a === null || typeof c != "object" || c === null)
        return !1;
      var g = Object.keys(a), b = Object.keys(c);
      if (g.length !== b.length)
        return !1;
      for (var C = 0; C < g.length; C++) {
        var I = g[C];
        if (!Ut.call(c, I) || !bt(a[I], c[I]))
          return !1;
      }
      return !0;
    }
    function Gi(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function tr(a) {
      for (; a; ) {
        if (a.nextSibling)
          return a.nextSibling;
        a = a.parentNode;
      }
    }
    function ku(a, c) {
      for (var g = Gi(a), b = 0, C = 0; g; ) {
        if (g.nodeType === vu) {
          if (C = b + g.textContent.length, b <= c && C >= c)
            return {
              node: g,
              offset: c - b
            };
          b = C;
        }
        g = Gi(tr(g));
      }
    }
    function oO(a) {
      var c = a.ownerDocument, g = c && c.defaultView || window, b = g.getSelection && g.getSelection();
      if (!b || b.rangeCount === 0)
        return null;
      var C = b.anchorNode, I = b.anchorOffset, N = b.focusNode, H = b.focusOffset;
      try {
        C.nodeType, N.nodeType;
      } catch {
        return null;
      }
      return tne(a, C, I, N, H);
    }
    function tne(a, c, g, b, C) {
      var I = 0, N = -1, H = -1, V = 0, ee = 0, re = a, me = null;
      e: for (; ; ) {
        for (var pe = null; re === c && (g === 0 || re.nodeType === vu) && (N = I + g), re === b && (C === 0 || re.nodeType === vu) && (H = I + C), re.nodeType === vu && (I += re.nodeValue.length), (pe = re.firstChild) !== null; )
          me = re, re = pe;
        for (; ; ) {
          if (re === a)
            break e;
          if (me === c && ++V === g && (N = I), me === b && ++ee === C && (H = I), (pe = re.nextSibling) !== null)
            break;
          re = me, me = re.parentNode;
        }
        re = pe;
      }
      return N === -1 || H === -1 ? null : {
        start: N,
        end: H
      };
    }
    function nne(a, c) {
      var g = a.ownerDocument || document, b = g && g.defaultView || window;
      if (b.getSelection) {
        var C = b.getSelection(), I = a.textContent.length, N = Math.min(c.start, I), H = c.end === void 0 ? N : Math.min(c.end, I);
        if (!C.extend && N > H) {
          var V = H;
          H = N, N = V;
        }
        var ee = ku(a, N), re = ku(a, H);
        if (ee && re) {
          if (C.rangeCount === 1 && C.anchorNode === ee.node && C.anchorOffset === ee.offset && C.focusNode === re.node && C.focusOffset === re.offset)
            return;
          var me = g.createRange();
          me.setStart(ee.node, ee.offset), C.removeAllRanges(), N > H ? (C.addRange(me), C.extend(re.node, re.offset)) : (me.setEnd(re.node, re.offset), C.addRange(me));
        }
      }
    }
    function sB(a) {
      return a && a.nodeType === vu;
    }
    function oB(a, c) {
      return !a || !c ? !1 : a === c ? !0 : sB(a) ? !1 : sB(c) ? oB(a, c.parentNode) : "contains" in a ? a.contains(c) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(c) & 16) : !1;
    }
    function rne(a) {
      return a && a.ownerDocument && oB(a.ownerDocument.documentElement, a);
    }
    function ine(a) {
      try {
        return typeof a.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function aB() {
      for (var a = window, c = st(); c instanceof a.HTMLIFrameElement; ) {
        if (ine(c))
          a = c.contentWindow;
        else
          return c;
        c = st(a.document);
      }
      return c;
    }
    function aO(a) {
      var c = a && a.nodeName && a.nodeName.toLowerCase();
      return c && (c === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || c === "textarea" || a.contentEditable === "true");
    }
    function sne() {
      var a = aB();
      return {
        focusedElem: a,
        selectionRange: aO(a) ? ane(a) : null
      };
    }
    function one(a) {
      var c = aB(), g = a.focusedElem, b = a.selectionRange;
      if (c !== g && rne(g)) {
        b !== null && aO(g) && lne(g, b);
        for (var C = [], I = g; I = I.parentNode; )
          I.nodeType === Ho && C.push({
            element: I,
            left: I.scrollLeft,
            top: I.scrollTop
          });
        typeof g.focus == "function" && g.focus();
        for (var N = 0; N < C.length; N++) {
          var H = C[N];
          H.element.scrollLeft = H.left, H.element.scrollTop = H.top;
        }
      }
    }
    function ane(a) {
      var c;
      return "selectionStart" in a ? c = {
        start: a.selectionStart,
        end: a.selectionEnd
      } : c = oO(a), c || {
        start: 0,
        end: 0
      };
    }
    function lne(a, c) {
      var g = c.start, b = c.end;
      b === void 0 && (b = g), "selectionStart" in a ? (a.selectionStart = g, a.selectionEnd = Math.min(b, a.value.length)) : nne(a, c);
    }
    var cne = pt && "documentMode" in document && document.documentMode <= 11;
    function une() {
      Yt("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Nb = null, lO = null, wC = null, cO = !1;
    function dne(a) {
      if ("selectionStart" in a && aO(a))
        return {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      var c = a.ownerDocument && a.ownerDocument.defaultView || window, g = c.getSelection();
      return {
        anchorNode: g.anchorNode,
        anchorOffset: g.anchorOffset,
        focusNode: g.focusNode,
        focusOffset: g.focusOffset
      };
    }
    function hne(a) {
      return a.window === a ? a.document : a.nodeType === Kl ? a : a.ownerDocument;
    }
    function lB(a, c, g) {
      var b = hne(g);
      if (!(cO || Nb == null || Nb !== st(b))) {
        var C = dne(Nb);
        if (!wC || !Xt(wC, C)) {
          wC = C;
          var I = EA(lO, "onSelect");
          if (I.length > 0) {
            var N = new Tb("onSelect", "select", null, c, g);
            a.push({
              event: N,
              listeners: I
            }), N.target = Nb;
          }
        }
      }
    }
    function fne(a, c, g, b, C, I, N) {
      var H = g ? Bb(g) : window;
      switch (c) {
        case "focusin":
          (bA(H) || H.contentEditable === "true") && (Nb = H, lO = g, wC = null);
          break;
        case "focusout":
          Nb = null, lO = null, wC = null;
          break;
        case "mousedown":
          cO = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          cO = !1, lB(a, b, C);
          break;
        case "selectionchange":
          if (cne)
            break;
        case "keydown":
        case "keyup":
          lB(a, b, C);
      }
    }
    function xA(a, c) {
      var g = {};
      return g[a.toLowerCase()] = c.toLowerCase(), g["Webkit" + a] = "webkit" + c, g["Moz" + a] = "moz" + c, g;
    }
    var Fb = {
      animationend: xA("Animation", "AnimationEnd"),
      animationiteration: xA("Animation", "AnimationIteration"),
      animationstart: xA("Animation", "AnimationStart"),
      transitionend: xA("Transition", "TransitionEnd")
    }, uO = {}, cB = {};
    pt && (cB = document.createElement("div").style, "AnimationEvent" in window || (delete Fb.animationend.animation, delete Fb.animationiteration.animation, delete Fb.animationstart.animation), "TransitionEvent" in window || delete Fb.transitionend.transition);
    function wA(a) {
      if (uO[a])
        return uO[a];
      if (!Fb[a])
        return a;
      var c = Fb[a];
      for (var g in c)
        if (c.hasOwnProperty(g) && g in cB)
          return uO[a] = c[g];
      return a;
    }
    var uB = wA("animationend"), dB = wA("animationiteration"), hB = wA("animationstart"), fB = wA("transitionend"), pB = /* @__PURE__ */ new Map(), gB = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function vg(a, c) {
      pB.set(a, c), Yt(c, [a]);
    }
    function pne() {
      for (var a = 0; a < gB.length; a++) {
        var c = gB[a], g = c.toLowerCase(), b = c[0].toUpperCase() + c.slice(1);
        vg(g, "on" + b);
      }
      vg(uB, "onAnimationEnd"), vg(dB, "onAnimationIteration"), vg(hB, "onAnimationStart"), vg("dblclick", "onDoubleClick"), vg("focusin", "onFocus"), vg("focusout", "onBlur"), vg(fB, "onTransitionEnd");
    }
    function gne(a, c, g, b, C, I, N) {
      var H = pB.get(c);
      if (H !== void 0) {
        var V = Tb, ee = c;
        switch (c) {
          case "keypress":
            if (lf(b) === 0)
              return;
          case "keydown":
          case "keyup":
            V = pA;
            break;
          case "focusin":
            ee = "focus", V = yv;
            break;
          case "focusout":
            ee = "blur", V = yv;
            break;
          case "beforeblur":
          case "afterblur":
            V = yv;
            break;
          case "click":
            if (b.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            V = Pb;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            V = lA;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            V = mC;
            break;
          case uB:
          case dB:
          case hB:
            V = ZD;
            break;
          case fB:
            V = Ld;
            break;
          case "scroll":
            V = hC;
            break;
          case "wheel":
            V = df;
            break;
          case "copy":
          case "cut":
          case "paste":
            V = uA;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            V = mA;
            break;
        }
        var re = (I & Hh) !== 0;
        {
          var me = !re && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          c === "scroll", pe = Sne(g, H, b.type, re, me);
          if (pe.length > 0) {
            var Ae = new V(H, ee, null, b, C);
            a.push({
              event: Ae,
              listeners: pe
            });
          }
        }
      }
    }
    pne(), qe(), h(), une(), Mb();
    function mne(a, c, g, b, C, I, N) {
      gne(a, c, g, b, C, I);
      var H = (I & FD) === 0;
      H && (Mt(a, c, g, b, C), Te(a, c, g, b, C), fne(a, c, g, b, C), sO(a, c, g, b, C));
    }
    var CC = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], dO = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(CC));
    function mB(a, c, g) {
      var b = a.type || "unknown-event";
      a.currentTarget = g, xu(b, c, void 0, a), a.currentTarget = null;
    }
    function vne(a, c, g) {
      var b;
      if (g)
        for (var C = c.length - 1; C >= 0; C--) {
          var I = c[C], N = I.instance, H = I.currentTarget, V = I.listener;
          if (N !== b && a.isPropagationStopped())
            return;
          mB(a, V, H), b = N;
        }
      else
        for (var ee = 0; ee < c.length; ee++) {
          var re = c[ee], me = re.instance, pe = re.currentTarget, Ae = re.listener;
          if (me !== b && a.isPropagationStopped())
            return;
          mB(a, Ae, pe), b = me;
        }
    }
    function vB(a, c) {
      for (var g = (c & Hh) !== 0, b = 0; b < a.length; b++) {
        var C = a[b], I = C.event, N = C.listeners;
        vne(I, N, g);
      }
      zw();
    }
    function yne(a, c, g, b, C) {
      var I = OS(g), N = [];
      mne(N, a, b, g, I, c), vB(N, c);
    }
    function ci(a, c) {
      dO.has(a) || o('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', a);
      var g = !1, b = Yre(c), C = wne(a);
      b.has(C) || (yB(c, a, Gm, g), b.add(C));
    }
    function hO(a, c, g) {
      dO.has(a) && !c && o('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', a);
      var b = 0;
      c && (b |= Hh), yB(g, a, b, c);
    }
    var CA = "_reactListening" + Math.random().toString(36).slice(2);
    function EC(a) {
      if (!a[CA]) {
        a[CA] = !0, tt.forEach(function(g) {
          g !== "selectionchange" && (dO.has(g) || hO(g, !1, a), hO(g, !0, a));
        });
        var c = a.nodeType === Kl ? a : a.ownerDocument;
        c !== null && (c[CA] || (c[CA] = !0, hO("selectionchange", !1, c)));
      }
    }
    function yB(a, c, g, b, C) {
      var I = Vi(a, c, g), N = void 0;
      Zm && (c === "touchstart" || c === "touchmove" || c === "wheel") && (N = !0), a = a, b ? N !== void 0 ? Cb(a, c, I, N) : Pu(a, c, I) : N !== void 0 ? dC(a, c, I, N) : fg(a, c, I);
    }
    function SB(a, c) {
      return a === c || a.nodeType === Li && a.parentNode === c;
    }
    function fO(a, c, g, b, C) {
      var I = b;
      if (!(c & Su) && !(c & Gm)) {
        var N = C;
        if (b !== null) {
          var H = b;
          e: for (; ; ) {
            if (H === null)
              return;
            var V = H.tag;
            if (V === m || V === v) {
              var ee = H.stateNode.containerInfo;
              if (SB(ee, N))
                break;
              if (V === v)
                for (var re = H.return; re !== null; ) {
                  var me = re.tag;
                  if (me === m || me === v) {
                    var pe = re.stateNode.containerInfo;
                    if (SB(pe, N))
                      return;
                  }
                  re = re.return;
                }
              for (; ee !== null; ) {
                var Ae = Tv(ee);
                if (Ae === null)
                  return;
                var Re = Ae.tag;
                if (Re === S || Re === w) {
                  H = I = Ae;
                  continue e;
                }
                ee = ee.parentNode;
              }
            }
            H = H.return;
          }
        }
      }
      jw(function() {
        return yne(a, c, g, I);
      });
    }
    function _C(a, c, g) {
      return {
        instance: a,
        listener: c,
        currentTarget: g
      };
    }
    function Sne(a, c, g, b, C, I) {
      for (var N = c !== null ? c + "Capture" : null, H = b ? N : c, V = [], ee = a, re = null; ee !== null; ) {
        var me = ee, pe = me.stateNode, Ae = me.tag;
        if (Ae === S && pe !== null && (re = pe, H !== null)) {
          var Re = Wh(ee, H);
          Re != null && V.push(_C(ee, Re, re));
        }
        if (C)
          break;
        ee = ee.return;
      }
      return V;
    }
    function EA(a, c) {
      for (var g = c + "Capture", b = [], C = a; C !== null; ) {
        var I = C, N = I.stateNode, H = I.tag;
        if (H === S && N !== null) {
          var V = N, ee = Wh(C, g);
          ee != null && b.unshift(_C(C, ee, V));
          var re = Wh(C, c);
          re != null && b.push(_C(C, re, V));
        }
        C = C.return;
      }
      return b;
    }
    function $b(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== S);
      return a || null;
    }
    function bne(a, c) {
      for (var g = a, b = c, C = 0, I = g; I; I = $b(I))
        C++;
      for (var N = 0, H = b; H; H = $b(H))
        N++;
      for (; C - N > 0; )
        g = $b(g), C--;
      for (; N - C > 0; )
        b = $b(b), N--;
      for (var V = C; V--; ) {
        if (g === b || b !== null && g === b.alternate)
          return g;
        g = $b(g), b = $b(b);
      }
      return null;
    }
    function bB(a, c, g, b, C) {
      for (var I = c._reactName, N = [], H = g; H !== null && H !== b; ) {
        var V = H, ee = V.alternate, re = V.stateNode, me = V.tag;
        if (ee !== null && ee === b)
          break;
        if (me === S && re !== null) {
          var pe = re;
          if (C) {
            var Ae = Wh(H, I);
            Ae != null && N.unshift(_C(H, Ae, pe));
          } else if (!C) {
            var Re = Wh(H, I);
            Re != null && N.push(_C(H, Re, pe));
          }
        }
        H = H.return;
      }
      N.length !== 0 && a.push({
        event: c,
        listeners: N
      });
    }
    function xne(a, c, g, b, C) {
      var I = b && C ? bne(b, C) : null;
      b !== null && bB(a, c, b, I, !1), C !== null && g !== null && bB(a, g, C, I, !0);
    }
    function wne(a, c) {
      return a + "__bubble";
    }
    var gl = !1, TC = "dangerouslySetInnerHTML", _A = "suppressContentEditableWarning", yg = "suppressHydrationWarning", xB = "autoFocus", Ev = "children", _v = "style", TA = "__html", pO, PA, PC, wB, AA, CB, EB;
    pO = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, PA = function(a, c) {
      DS(a, c), Rw(a, c), MP(a, c, {
        registrationNameDependencies: et,
        possibleRegistrationNames: at
      });
    }, CB = pt && !document.documentMode, PC = function(a, c, g) {
      if (!gl) {
        var b = kA(g), C = kA(c);
        C !== b && (gl = !0, o("Prop `%s` did not match. Server: %s Client: %s", a, JSON.stringify(C), JSON.stringify(b)));
      }
    }, wB = function(a) {
      if (!gl) {
        gl = !0;
        var c = [];
        a.forEach(function(g) {
          c.push(g);
        }), o("Extra attributes from the server: %s", c);
      }
    }, AA = function(a, c) {
      c === !1 ? o("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", a, a, a) : o("Expected `%s` listener to be a function, instead got a value of `%s` type.", a, typeof c);
    }, EB = function(a, c) {
      var g = a.namespaceURI === mu ? a.ownerDocument.createElement(a.tagName) : a.ownerDocument.createElementNS(a.namespaceURI, a.tagName);
      return g.innerHTML = c, g.innerHTML;
    };
    var Cne = /\r\n?/g, Ene = /\u0000|\uFFFD/g;
    function kA(a) {
      es(a);
      var c = typeof a == "string" ? a : "" + a;
      return c.replace(Cne, `
`).replace(Ene, "");
    }
    function IA(a, c, g, b) {
      var C = kA(c), I = kA(a);
      if (I !== C && (b && (gl || (gl = !0, o('Text content did not match. Server: "%s" Client: "%s"', I, C))), g && ie))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function _B(a) {
      return a.nodeType === Kl ? a : a.ownerDocument;
    }
    function _ne() {
    }
    function RA(a) {
      a.onclick = _ne;
    }
    function Tne(a, c, g, b, C) {
      for (var I in b)
        if (b.hasOwnProperty(I)) {
          var N = b[I];
          if (I === _v)
            N && Object.freeze(N), wP(c, N);
          else if (I === TC) {
            var H = N ? N[TA] : void 0;
            H != null && dP(c, H);
          } else if (I === Ev)
            if (typeof N == "string") {
              var V = a !== "textarea" || N !== "";
              V && kS(c, N);
            } else typeof N == "number" && kS(c, "" + N);
          else I === _A || I === yg || I === xB || (et.hasOwnProperty(I) ? N != null && (typeof N != "function" && AA(I, N), I === "onScroll" && ci("scroll", c)) : N != null && lo(c, I, N, C));
        }
    }
    function Pne(a, c, g, b) {
      for (var C = 0; C < c.length; C += 2) {
        var I = c[C], N = c[C + 1];
        I === _v ? wP(a, N) : I === TC ? dP(a, N) : I === Ev ? kS(a, N) : lo(a, I, N, b);
      }
    }
    function Ane(a, c, g, b) {
      var C, I = _B(g), N, H = b;
      if (H === mu && (H = PS(a)), H === mu) {
        if (C = yu(a, c), !C && a !== a.toLowerCase() && o("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", a), a === "script") {
          var V = I.createElement("div");
          V.innerHTML = "<script><\/script>";
          var ee = V.firstChild;
          N = V.removeChild(ee);
        } else if (typeof c.is == "string")
          N = I.createElement(a, {
            is: c.is
          });
        else if (N = I.createElement(a), a === "select") {
          var re = N;
          c.multiple ? re.multiple = !0 : c.size && (re.size = c.size);
        }
      } else
        N = I.createElementNS(H, a);
      return H === mu && !C && Object.prototype.toString.call(N) === "[object HTMLUnknownElement]" && !Ut.call(pO, a) && (pO[a] = !0, o("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", a)), N;
    }
    function kne(a, c) {
      return _B(c).createTextNode(a);
    }
    function Ine(a, c, g, b) {
      var C = yu(c, g);
      PA(c, g);
      var I;
      switch (c) {
        case "dialog":
          ci("cancel", a), ci("close", a), I = g;
          break;
        case "iframe":
        case "object":
        case "embed":
          ci("load", a), I = g;
          break;
        case "video":
        case "audio":
          for (var N = 0; N < CC.length; N++)
            ci(CC[N], a);
          I = g;
          break;
        case "source":
          ci("error", a), I = g;
          break;
        case "img":
        case "image":
        case "link":
          ci("error", a), ci("load", a), I = g;
          break;
        case "details":
          ci("toggle", a), I = g;
          break;
        case "input":
          le(a, g), I = W(a, g), ci("invalid", a);
          break;
        case "option":
          Wn(a, g), I = g;
          break;
        case "select":
          Bm(a, g), I = Um(a, g), ci("invalid", a);
          break;
        case "textarea":
          lP(a, g), I = ww(a, g), ci("invalid", a);
          break;
        default:
          I = g;
      }
      switch (RS(c, I), Tne(c, a, b, I, C), c) {
        case "input":
          ve(a), He(a, g, !1);
          break;
        case "textarea":
          ve(a), uP(a);
          break;
        case "option":
          Er(a, g);
          break;
        case "select":
          bw(a, g);
          break;
        default:
          typeof I.onClick == "function" && RA(a);
          break;
      }
    }
    function Rne(a, c, g, b, C) {
      PA(c, b);
      var I = null, N, H;
      switch (c) {
        case "input":
          N = W(a, g), H = W(a, b), I = [];
          break;
        case "select":
          N = Um(a, g), H = Um(a, b), I = [];
          break;
        case "textarea":
          N = ww(a, g), H = ww(a, b), I = [];
          break;
        default:
          N = g, H = b, typeof N.onClick != "function" && typeof H.onClick == "function" && RA(a);
          break;
      }
      RS(c, H);
      var V, ee, re = null;
      for (V in N)
        if (!(H.hasOwnProperty(V) || !N.hasOwnProperty(V) || N[V] == null))
          if (V === _v) {
            var me = N[V];
            for (ee in me)
              me.hasOwnProperty(ee) && (re || (re = {}), re[ee] = "");
          } else V === TC || V === Ev || V === _A || V === yg || V === xB || (et.hasOwnProperty(V) ? I || (I = []) : (I = I || []).push(V, null));
      for (V in H) {
        var pe = H[V], Ae = N != null ? N[V] : void 0;
        if (!(!H.hasOwnProperty(V) || pe === Ae || pe == null && Ae == null))
          if (V === _v)
            if (pe && Object.freeze(pe), Ae) {
              for (ee in Ae)
                Ae.hasOwnProperty(ee) && (!pe || !pe.hasOwnProperty(ee)) && (re || (re = {}), re[ee] = "");
              for (ee in pe)
                pe.hasOwnProperty(ee) && Ae[ee] !== pe[ee] && (re || (re = {}), re[ee] = pe[ee]);
            } else
              re || (I || (I = []), I.push(V, re)), re = pe;
          else if (V === TC) {
            var Re = pe ? pe[TA] : void 0, Oe = Ae ? Ae[TA] : void 0;
            Re != null && Oe !== Re && (I = I || []).push(V, Re);
          } else V === Ev ? (typeof pe == "string" || typeof pe == "number") && (I = I || []).push(V, "" + pe) : V === _A || V === yg || (et.hasOwnProperty(V) ? (pe != null && (typeof pe != "function" && AA(V, pe), V === "onScroll" && ci("scroll", a)), !I && Ae !== pe && (I = [])) : (I = I || []).push(V, pe));
      }
      return re && (Vm(re, H[_v]), (I = I || []).push(_v, re)), I;
    }
    function Mne(a, c, g, b, C) {
      g === "input" && C.type === "radio" && C.name != null && Ce(a, C);
      var I = yu(g, b), N = yu(g, C);
      switch (Pne(a, c, I, N), g) {
        case "input":
          Pe(a, C);
          break;
        case "textarea":
          cP(a, C);
          break;
        case "select":
          AD(a, C);
          break;
      }
    }
    function Dne(a) {
      {
        var c = a.toLowerCase();
        return MS.hasOwnProperty(c) && MS[c] || null;
      }
    }
    function One(a, c, g, b, C, I, N) {
      var H, V;
      switch (H = yu(c, g), PA(c, g), c) {
        case "dialog":
          ci("cancel", a), ci("close", a);
          break;
        case "iframe":
        case "object":
        case "embed":
          ci("load", a);
          break;
        case "video":
        case "audio":
          for (var ee = 0; ee < CC.length; ee++)
            ci(CC[ee], a);
          break;
        case "source":
          ci("error", a);
          break;
        case "img":
        case "image":
        case "link":
          ci("error", a), ci("load", a);
          break;
        case "details":
          ci("toggle", a);
          break;
        case "input":
          le(a, g), ci("invalid", a);
          break;
        case "option":
          Wn(a, g);
          break;
        case "select":
          Bm(a, g), ci("invalid", a);
          break;
        case "textarea":
          lP(a, g), ci("invalid", a);
          break;
      }
      RS(c, g);
      {
        V = /* @__PURE__ */ new Set();
        for (var re = a.attributes, me = 0; me < re.length; me++) {
          var pe = re[me].name.toLowerCase();
          switch (pe) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              V.add(re[me].name);
          }
        }
      }
      var Ae = null;
      for (var Re in g)
        if (g.hasOwnProperty(Re)) {
          var Oe = g[Re];
          if (Re === Ev)
            typeof Oe == "string" ? a.textContent !== Oe && (g[yg] !== !0 && IA(a.textContent, Oe, I, N), Ae = [Ev, Oe]) : typeof Oe == "number" && a.textContent !== "" + Oe && (g[yg] !== !0 && IA(a.textContent, Oe, I, N), Ae = [Ev, "" + Oe]);
          else if (et.hasOwnProperty(Re))
            Oe != null && (typeof Oe != "function" && AA(Re, Oe), Re === "onScroll" && ci("scroll", a));
          else if (N && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof H == "boolean") {
            var ot = void 0, Ht = H && Fe ? null : is(Re);
            if (g[yg] !== !0) {
              if (!(Re === _A || Re === yg || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Re === "value" || Re === "checked" || Re === "selected")) {
                if (Re === TC) {
                  var Lt = a.innerHTML, Nn = Oe ? Oe[TA] : void 0;
                  if (Nn != null) {
                    var Tn = EB(a, Nn);
                    Tn !== Lt && PC(Re, Lt, Tn);
                  }
                } else if (Re === _v) {
                  if (V.delete(Re), CB) {
                    var Ee = jD(Oe);
                    ot = a.getAttribute("style"), Ee !== ot && PC(Re, ot, Ee);
                  }
                } else if (H && !Fe)
                  V.delete(Re.toLowerCase()), ot = Qa(a, Re, Oe), Oe !== ot && PC(Re, ot, Oe);
                else if (!kr(Re, Ht, H) && !wn(Re, Oe, Ht, H)) {
                  var Le = !1;
                  if (Ht !== null)
                    V.delete(Ht.attributeName), ot = ao(a, Re, Oe, Ht);
                  else {
                    var _e = b;
                    if (_e === mu && (_e = PS(c)), _e === mu)
                      V.delete(Re.toLowerCase());
                    else {
                      var Ye = Dne(Re);
                      Ye !== null && Ye !== Re && (Le = !0, V.delete(Ye)), V.delete(Re);
                    }
                    ot = Qa(a, Re, Oe);
                  }
                  var ft = Fe;
                  !ft && Oe !== ot && !Le && PC(Re, ot, Oe);
                }
              }
            }
          }
        }
      switch (N && // $FlowFixMe - Should be inferred as not undefined.
      V.size > 0 && g[yg] !== !0 && wB(V), c) {
        case "input":
          ve(a), He(a, g, !0);
          break;
        case "textarea":
          ve(a), uP(a);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof g.onClick == "function" && RA(a);
          break;
      }
      return Ae;
    }
    function Lne(a, c, g) {
      var b = a.nodeValue !== c;
      return b;
    }
    function gO(a, c) {
      {
        if (gl)
          return;
        gl = !0, o("Did not expect server HTML to contain a <%s> in <%s>.", c.nodeName.toLowerCase(), a.nodeName.toLowerCase());
      }
    }
    function mO(a, c) {
      {
        if (gl)
          return;
        gl = !0, o('Did not expect server HTML to contain the text node "%s" in <%s>.', c.nodeValue, a.nodeName.toLowerCase());
      }
    }
    function vO(a, c, g) {
      {
        if (gl)
          return;
        gl = !0, o("Expected server HTML to contain a matching <%s> in <%s>.", c, a.nodeName.toLowerCase());
      }
    }
    function yO(a, c) {
      {
        if (c === "" || gl)
          return;
        gl = !0, o('Expected server HTML to contain a matching text node for "%s" in <%s>.', c, a.nodeName.toLowerCase());
      }
    }
    function jne(a, c, g) {
      switch (c) {
        case "input":
          yt(a, g);
          return;
        case "textarea":
          Cw(a, g);
          return;
        case "select":
          kD(a, g);
          return;
      }
    }
    var AC = function() {
    }, kC = function() {
    };
    {
      var Nne = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], TB = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], Fne = TB.concat(["button"]), $ne = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], PB = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      kC = function(a, c) {
        var g = on({}, a || PB), b = {
          tag: c
        };
        return TB.indexOf(c) !== -1 && (g.aTagInScope = null, g.buttonTagInScope = null, g.nobrTagInScope = null), Fne.indexOf(c) !== -1 && (g.pTagInButtonScope = null), Nne.indexOf(c) !== -1 && c !== "address" && c !== "div" && c !== "p" && (g.listItemTagAutoclosing = null, g.dlItemTagAutoclosing = null), g.current = b, c === "form" && (g.formTag = b), c === "a" && (g.aTagInScope = b), c === "button" && (g.buttonTagInScope = b), c === "nobr" && (g.nobrTagInScope = b), c === "p" && (g.pTagInButtonScope = b), c === "li" && (g.listItemTagAutoclosing = b), (c === "dd" || c === "dt") && (g.dlItemTagAutoclosing = b), g;
      };
      var zne = function(a, c) {
        switch (c) {
          case "select":
            return a === "option" || a === "optgroup" || a === "#text";
          case "optgroup":
            return a === "option" || a === "#text";
          case "option":
            return a === "#text";
          case "tr":
            return a === "th" || a === "td" || a === "style" || a === "script" || a === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return a === "tr" || a === "style" || a === "script" || a === "template";
          case "colgroup":
            return a === "col" || a === "template";
          case "table":
            return a === "caption" || a === "colgroup" || a === "tbody" || a === "tfoot" || a === "thead" || a === "style" || a === "script" || a === "template";
          case "head":
            return a === "base" || a === "basefont" || a === "bgsound" || a === "link" || a === "meta" || a === "title" || a === "noscript" || a === "noframes" || a === "style" || a === "script" || a === "template";
          case "html":
            return a === "head" || a === "body" || a === "frameset";
          case "frameset":
            return a === "frame";
          case "#document":
            return a === "html";
        }
        switch (a) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return c !== "h1" && c !== "h2" && c !== "h3" && c !== "h4" && c !== "h5" && c !== "h6";
          case "rp":
          case "rt":
            return $ne.indexOf(c) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return c == null;
        }
        return !0;
      }, Une = function(a, c) {
        switch (a) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return c.pTagInButtonScope;
          case "form":
            return c.formTag || c.pTagInButtonScope;
          case "li":
            return c.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return c.dlItemTagAutoclosing;
          case "button":
            return c.buttonTagInScope;
          case "a":
            return c.aTagInScope;
          case "nobr":
            return c.nobrTagInScope;
        }
        return null;
      }, AB = {};
      AC = function(a, c, g) {
        g = g || PB;
        var b = g.current, C = b && b.tag;
        c != null && (a != null && o("validateDOMNesting: when childText is passed, childTag should be null"), a = "#text");
        var I = zne(a, C) ? null : b, N = I ? null : Une(a, g), H = I || N;
        if (H) {
          var V = H.tag, ee = !!I + "|" + a + "|" + V;
          if (!AB[ee]) {
            AB[ee] = !0;
            var re = a, me = "";
            if (a === "#text" ? /\S/.test(c) ? re = "Text nodes" : (re = "Whitespace text nodes", me = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : re = "<" + a + ">", I) {
              var pe = "";
              V === "table" && a === "tr" && (pe += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), o("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", re, V, me, pe);
            } else
              o("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", re, V);
          }
        }
      };
    }
    var MA = "suppressHydrationWarning", DA = "$", OA = "/$", IC = "$?", RC = "$!", Bne = "style", SO = null, bO = null;
    function Hne(a) {
      var c, g, b = a.nodeType;
      switch (b) {
        case Kl:
        case Uh: {
          c = b === Kl ? "#document" : "#fragment";
          var C = a.documentElement;
          g = C ? C.namespaceURI : _w(null, "");
          break;
        }
        default: {
          var I = b === Li ? a.parentNode : a, N = I.namespaceURI || null;
          c = I.tagName, g = _w(N, c);
          break;
        }
      }
      {
        var H = c.toLowerCase(), V = kC(null, H);
        return {
          namespace: g,
          ancestorInfo: V
        };
      }
    }
    function Vne(a, c, g) {
      {
        var b = a, C = _w(b.namespace, c), I = kC(b.ancestorInfo, c);
        return {
          namespace: C,
          ancestorInfo: I
        };
      }
    }
    function aNe(a) {
      return a;
    }
    function Wne(a) {
      SO = dg(), bO = sne();
      var c = null;
      return Jo(!1), c;
    }
    function Gne(a) {
      one(bO), Jo(SO), SO = null, bO = null;
    }
    function Kne(a, c, g, b, C) {
      var I;
      {
        var N = b;
        if (AC(a, null, N.ancestorInfo), typeof c.children == "string" || typeof c.children == "number") {
          var H = "" + c.children, V = kC(N.ancestorInfo, a);
          AC(null, H, V);
        }
        I = N.namespace;
      }
      var ee = Ane(a, c, g, I);
      return OC(C, ee), AO(ee, c), ee;
    }
    function Yne(a, c) {
      a.appendChild(c);
    }
    function Xne(a, c, g, b, C) {
      switch (Ine(a, c, g, b), c) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!g.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function qne(a, c, g, b, C, I) {
      {
        var N = I;
        if (typeof b.children != typeof g.children && (typeof b.children == "string" || typeof b.children == "number")) {
          var H = "" + b.children, V = kC(N.ancestorInfo, c);
          AC(null, H, V);
        }
      }
      return Rne(a, c, g, b);
    }
    function xO(a, c) {
      return a === "textarea" || a === "noscript" || typeof c.children == "string" || typeof c.children == "number" || typeof c.dangerouslySetInnerHTML == "object" && c.dangerouslySetInnerHTML !== null && c.dangerouslySetInnerHTML.__html != null;
    }
    function Zne(a, c, g, b) {
      {
        var C = g;
        AC(null, a, C.ancestorInfo);
      }
      var I = kne(a, c);
      return OC(b, I), I;
    }
    function Qne() {
      var a = window.event;
      return a === void 0 ? jc : wb(a.type);
    }
    var wO = typeof setTimeout == "function" ? setTimeout : void 0, Jne = typeof clearTimeout == "function" ? clearTimeout : void 0, CO = -1, kB = typeof Promise == "function" ? Promise : void 0, ere = typeof queueMicrotask == "function" ? queueMicrotask : typeof kB < "u" ? function(a) {
      return kB.resolve(null).then(a).catch(tre);
    } : wO;
    function tre(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function nre(a, c, g, b) {
      switch (c) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          g.autoFocus && a.focus();
          return;
        case "img": {
          g.src && (a.src = g.src);
          return;
        }
      }
    }
    function rre(a, c, g, b, C, I) {
      Mne(a, c, g, b, C), AO(a, C);
    }
    function IB(a) {
      kS(a, "");
    }
    function ire(a, c, g) {
      a.nodeValue = g;
    }
    function sre(a, c) {
      a.appendChild(c);
    }
    function ore(a, c) {
      var g;
      a.nodeType === Li ? (g = a.parentNode, g.insertBefore(c, a)) : (g = a, g.appendChild(c));
      var b = a._reactRootContainer;
      b == null && g.onclick === null && RA(g);
    }
    function are(a, c, g) {
      a.insertBefore(c, g);
    }
    function lre(a, c, g) {
      a.nodeType === Li ? a.parentNode.insertBefore(c, g) : a.insertBefore(c, g);
    }
    function cre(a, c) {
      a.removeChild(c);
    }
    function ure(a, c) {
      a.nodeType === Li ? a.parentNode.removeChild(c) : a.removeChild(c);
    }
    function EO(a, c) {
      var g = c, b = 0;
      do {
        var C = g.nextSibling;
        if (a.removeChild(g), C && C.nodeType === Li) {
          var I = C.data;
          if (I === OA)
            if (b === 0) {
              a.removeChild(C), yi(c);
              return;
            } else
              b--;
          else (I === DA || I === IC || I === RC) && b++;
        }
        g = C;
      } while (g);
      yi(c);
    }
    function dre(a, c) {
      a.nodeType === Li ? EO(a.parentNode, c) : a.nodeType === Ho && EO(a, c), yi(a);
    }
    function hre(a) {
      a = a;
      var c = a.style;
      typeof c.setProperty == "function" ? c.setProperty("display", "none", "important") : c.display = "none";
    }
    function fre(a) {
      a.nodeValue = "";
    }
    function pre(a, c) {
      a = a;
      var g = c[Bne], b = g != null && g.hasOwnProperty("display") ? g.display : null;
      a.style.display = IS("display", b);
    }
    function gre(a, c) {
      a.nodeValue = c;
    }
    function mre(a) {
      a.nodeType === Ho ? a.textContent = "" : a.nodeType === Kl && a.documentElement && a.removeChild(a.documentElement);
    }
    function vre(a, c, g) {
      return a.nodeType !== Ho || c.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }
    function yre(a, c) {
      return c === "" || a.nodeType !== vu ? null : a;
    }
    function Sre(a) {
      return a.nodeType !== Li ? null : a;
    }
    function RB(a) {
      return a.data === IC;
    }
    function _O(a) {
      return a.data === RC;
    }
    function bre(a) {
      var c = a.nextSibling && a.nextSibling.dataset, g, b, C;
      return c && (g = c.dgst, b = c.msg, C = c.stck), {
        message: b,
        digest: g,
        stack: C
      };
    }
    function xre(a, c) {
      a._reactRetry = c;
    }
    function LA(a) {
      for (; a != null; a = a.nextSibling) {
        var c = a.nodeType;
        if (c === Ho || c === vu)
          break;
        if (c === Li) {
          var g = a.data;
          if (g === DA || g === RC || g === IC)
            break;
          if (g === OA)
            return null;
        }
      }
      return a;
    }
    function MC(a) {
      return LA(a.nextSibling);
    }
    function wre(a) {
      return LA(a.firstChild);
    }
    function Cre(a) {
      return LA(a.firstChild);
    }
    function Ere(a) {
      return LA(a.nextSibling);
    }
    function _re(a, c, g, b, C, I, N) {
      OC(I, a), AO(a, g);
      var H;
      {
        var V = C;
        H = V.namespace;
      }
      var ee = (I.mode & Ot) !== Rt;
      return One(a, c, g, H, b, ee, N);
    }
    function Tre(a, c, g, b) {
      return OC(g, a), g.mode & Ot, Lne(a, c);
    }
    function Pre(a, c) {
      OC(c, a);
    }
    function Are(a) {
      for (var c = a.nextSibling, g = 0; c; ) {
        if (c.nodeType === Li) {
          var b = c.data;
          if (b === OA) {
            if (g === 0)
              return MC(c);
            g--;
          } else (b === DA || b === RC || b === IC) && g++;
        }
        c = c.nextSibling;
      }
      return null;
    }
    function MB(a) {
      for (var c = a.previousSibling, g = 0; c; ) {
        if (c.nodeType === Li) {
          var b = c.data;
          if (b === DA || b === RC || b === IC) {
            if (g === 0)
              return c;
            g--;
          } else b === OA && g++;
        }
        c = c.previousSibling;
      }
      return null;
    }
    function kre(a) {
      yi(a);
    }
    function Ire(a) {
      yi(a);
    }
    function Rre(a) {
      return a !== "head" && a !== "body";
    }
    function Mre(a, c, g, b) {
      var C = !0;
      IA(c.nodeValue, g, b, C);
    }
    function Dre(a, c, g, b, C, I) {
      if (c[MA] !== !0) {
        var N = !0;
        IA(b.nodeValue, C, I, N);
      }
    }
    function Ore(a, c) {
      c.nodeType === Ho ? gO(a, c) : c.nodeType === Li || mO(a, c);
    }
    function Lre(a, c) {
      {
        var g = a.parentNode;
        g !== null && (c.nodeType === Ho ? gO(g, c) : c.nodeType === Li || mO(g, c));
      }
    }
    function jre(a, c, g, b, C) {
      (C || c[MA] !== !0) && (b.nodeType === Ho ? gO(g, b) : b.nodeType === Li || mO(g, b));
    }
    function Nre(a, c, g) {
      vO(a, c);
    }
    function Fre(a, c) {
      yO(a, c);
    }
    function $re(a, c, g) {
      {
        var b = a.parentNode;
        b !== null && vO(b, c);
      }
    }
    function zre(a, c) {
      {
        var g = a.parentNode;
        g !== null && yO(g, c);
      }
    }
    function Ure(a, c, g, b, C, I) {
      (I || c[MA] !== !0) && vO(g, b);
    }
    function Bre(a, c, g, b, C) {
      (C || c[MA] !== !0) && yO(g, b);
    }
    function Hre(a) {
      o("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", a.nodeName.toLowerCase());
    }
    function Vre(a) {
      EC(a);
    }
    var zb = Math.random().toString(36).slice(2), Ub = "__reactFiber$" + zb, TO = "__reactProps$" + zb, DC = "__reactContainer$" + zb, PO = "__reactEvents$" + zb, Wre = "__reactListeners$" + zb, Gre = "__reactHandles$" + zb;
    function Kre(a) {
      delete a[Ub], delete a[TO], delete a[PO], delete a[Wre], delete a[Gre];
    }
    function OC(a, c) {
      c[Ub] = a;
    }
    function jA(a, c) {
      c[DC] = a;
    }
    function DB(a) {
      a[DC] = null;
    }
    function LC(a) {
      return !!a[DC];
    }
    function Tv(a) {
      var c = a[Ub];
      if (c)
        return c;
      for (var g = a.parentNode; g; ) {
        if (c = g[DC] || g[Ub], c) {
          var b = c.alternate;
          if (c.child !== null || b !== null && b.child !== null)
            for (var C = MB(a); C !== null; ) {
              var I = C[Ub];
              if (I)
                return I;
              C = MB(C);
            }
          return c;
        }
        a = g, g = a.parentNode;
      }
      return null;
    }
    function Sg(a) {
      var c = a[Ub] || a[DC];
      return c && (c.tag === S || c.tag === w || c.tag === $ || c.tag === m) ? c : null;
    }
    function Bb(a) {
      if (a.tag === S || a.tag === w)
        return a.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function NA(a) {
      return a[TO] || null;
    }
    function AO(a, c) {
      a[TO] = c;
    }
    function Yre(a) {
      var c = a[PO];
      return c === void 0 && (c = a[PO] = /* @__PURE__ */ new Set()), c;
    }
    var OB = {}, LB = e.ReactDebugCurrentFrame;
    function FA(a) {
      if (a) {
        var c = a._owner, g = wa(a.type, a._source, c ? c.type : null);
        LB.setExtraStackFrame(g);
      } else
        LB.setExtraStackFrame(null);
    }
    function Iu(a, c, g, b, C) {
      {
        var I = Function.call.bind(Ut);
        for (var N in a)
          if (I(a, N)) {
            var H = void 0;
            try {
              if (typeof a[N] != "function") {
                var V = Error((b || "React class") + ": " + g + " type `" + N + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[N] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw V.name = "Invariant Violation", V;
              }
              H = a[N](c, N, b, g, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ee) {
              H = ee;
            }
            H && !(H instanceof Error) && (FA(C), o("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", b || "React class", g, N, typeof H), FA(null)), H instanceof Error && !(H.message in OB) && (OB[H.message] = !0, FA(C), o("Failed %s type: %s", g, H.message), FA(null));
          }
      }
    }
    var kO = [], $A;
    $A = [];
    var hf = -1;
    function bg(a) {
      return {
        current: a
      };
    }
    function ea(a, c) {
      if (hf < 0) {
        o("Unexpected pop.");
        return;
      }
      c !== $A[hf] && o("Unexpected Fiber popped."), a.current = kO[hf], kO[hf] = null, $A[hf] = null, hf--;
    }
    function ta(a, c, g) {
      hf++, kO[hf] = a.current, $A[hf] = g, a.current = c;
    }
    var IO;
    IO = {};
    var Zl = {};
    Object.freeze(Zl);
    var ff = bg(Zl), Nd = bg(!1), RO = Zl;
    function Hb(a, c, g) {
      return g && Fd(c) ? RO : ff.current;
    }
    function jB(a, c, g) {
      {
        var b = a.stateNode;
        b.__reactInternalMemoizedUnmaskedChildContext = c, b.__reactInternalMemoizedMaskedChildContext = g;
      }
    }
    function Vb(a, c) {
      {
        var g = a.type, b = g.contextTypes;
        if (!b)
          return Zl;
        var C = a.stateNode;
        if (C && C.__reactInternalMemoizedUnmaskedChildContext === c)
          return C.__reactInternalMemoizedMaskedChildContext;
        var I = {};
        for (var N in b)
          I[N] = c[N];
        {
          var H = tn(a) || "Unknown";
          Iu(b, I, "context", H);
        }
        return C && jB(a, c, I), I;
      }
    }
    function zA() {
      return Nd.current;
    }
    function Fd(a) {
      {
        var c = a.childContextTypes;
        return c != null;
      }
    }
    function UA(a) {
      ea(Nd, a), ea(ff, a);
    }
    function MO(a) {
      ea(Nd, a), ea(ff, a);
    }
    function NB(a, c, g) {
      {
        if (ff.current !== Zl)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        ta(ff, c, a), ta(Nd, g, a);
      }
    }
    function FB(a, c, g) {
      {
        var b = a.stateNode, C = c.childContextTypes;
        if (typeof b.getChildContext != "function") {
          {
            var I = tn(a) || "Unknown";
            IO[I] || (IO[I] = !0, o("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", I, I));
          }
          return g;
        }
        var N = b.getChildContext();
        for (var H in N)
          if (!(H in C))
            throw new Error((tn(a) || "Unknown") + '.getChildContext(): key "' + H + '" is not defined in childContextTypes.');
        {
          var V = tn(a) || "Unknown";
          Iu(C, N, "child context", V);
        }
        return on({}, g, N);
      }
    }
    function BA(a) {
      {
        var c = a.stateNode, g = c && c.__reactInternalMemoizedMergedChildContext || Zl;
        return RO = ff.current, ta(ff, g, a), ta(Nd, Nd.current, a), !0;
      }
    }
    function $B(a, c, g) {
      {
        var b = a.stateNode;
        if (!b)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (g) {
          var C = FB(a, c, RO);
          b.__reactInternalMemoizedMergedChildContext = C, ea(Nd, a), ea(ff, a), ta(ff, C, a), ta(Nd, g, a);
        } else
          ea(Nd, a), ta(Nd, g, a);
      }
    }
    function Xre(a) {
      {
        if (!Ww(a) || a.tag !== d)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var c = a;
        do {
          switch (c.tag) {
            case m:
              return c.stateNode.context;
            case d: {
              var g = c.type;
              if (Fd(g))
                return c.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          c = c.return;
        } while (c !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var xg = 0, HA = 1, pf = null, DO = !1, OO = !1;
    function zB(a) {
      pf === null ? pf = [a] : pf.push(a);
    }
    function qre(a) {
      DO = !0, zB(a);
    }
    function UB() {
      DO && wg();
    }
    function wg() {
      if (!OO && pf !== null) {
        OO = !0;
        var a = 0, c = ul();
        try {
          var g = !0, b = pf;
          for (vi(_i); a < b.length; a++) {
            var C = b[a];
            do
              C = C(g);
            while (C !== null);
          }
          pf = null, DO = !1;
        } catch (I) {
          throw pf !== null && (pf = pf.slice(a + 1)), US(HS, wg), I;
        } finally {
          vi(c), OO = !1;
        }
      }
      return null;
    }
    var Wb = [], Gb = 0, VA = null, WA = 0, zc = [], Uc = 0, Pv = null, gf = 1, mf = "";
    function Zre(a) {
      return kv(), (a.flags & Bw) !== zt;
    }
    function Qre(a) {
      return kv(), WA;
    }
    function Jre() {
      var a = mf, c = gf, g = c & ~eie(c);
      return g.toString(32) + a;
    }
    function Av(a, c) {
      kv(), Wb[Gb++] = WA, Wb[Gb++] = VA, VA = a, WA = c;
    }
    function BB(a, c, g) {
      kv(), zc[Uc++] = gf, zc[Uc++] = mf, zc[Uc++] = Pv, Pv = a;
      var b = gf, C = mf, I = GA(b) - 1, N = b & ~(1 << I), H = g + 1, V = GA(c) + I;
      if (V > 30) {
        var ee = I - I % 5, re = (1 << ee) - 1, me = (N & re).toString(32), pe = N >> ee, Ae = I - ee, Re = GA(c) + Ae, Oe = H << Ae, ot = Oe | pe, Ht = me + C;
        gf = 1 << Re | ot, mf = Ht;
      } else {
        var Lt = H << I, Nn = Lt | N, Tn = C;
        gf = 1 << V | Nn, mf = Tn;
      }
    }
    function LO(a) {
      kv();
      var c = a.return;
      if (c !== null) {
        var g = 1, b = 0;
        Av(a, g), BB(a, g, b);
      }
    }
    function GA(a) {
      return 32 - Yp(a);
    }
    function eie(a) {
      return 1 << GA(a) - 1;
    }
    function jO(a) {
      for (; a === VA; )
        VA = Wb[--Gb], Wb[Gb] = null, WA = Wb[--Gb], Wb[Gb] = null;
      for (; a === Pv; )
        Pv = zc[--Uc], zc[Uc] = null, mf = zc[--Uc], zc[Uc] = null, gf = zc[--Uc], zc[Uc] = null;
    }
    function tie() {
      return kv(), Pv !== null ? {
        id: gf,
        overflow: mf
      } : null;
    }
    function nie(a, c) {
      kv(), zc[Uc++] = gf, zc[Uc++] = mf, zc[Uc++] = Pv, gf = c.id, mf = c.overflow, Pv = a;
    }
    function kv() {
      po() || o("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var fo = null, Bc = null, Ru = !1, Iv = !1, Cg = null;
    function rie() {
      Ru && o("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function HB() {
      Iv = !0;
    }
    function iie() {
      return Iv;
    }
    function sie(a) {
      var c = a.stateNode.containerInfo;
      return Bc = Cre(c), fo = a, Ru = !0, Cg = null, Iv = !1, !0;
    }
    function oie(a, c, g) {
      return Bc = Ere(c), fo = a, Ru = !0, Cg = null, Iv = !1, g !== null && nie(a, g), !0;
    }
    function VB(a, c) {
      switch (a.tag) {
        case m: {
          Ore(a.stateNode.containerInfo, c);
          break;
        }
        case S: {
          var g = (a.mode & Ot) !== Rt;
          jre(
            a.type,
            a.memoizedProps,
            a.stateNode,
            c,
            // TODO: Delete this argument when we remove the legacy root API.
            g
          );
          break;
        }
        case $: {
          var b = a.memoizedState;
          b.dehydrated !== null && Lre(b.dehydrated, c);
          break;
        }
      }
    }
    function WB(a, c) {
      VB(a, c);
      var g = uae();
      g.stateNode = c, g.return = a;
      var b = a.deletions;
      b === null ? (a.deletions = [g], a.flags |= or) : b.push(g);
    }
    function NO(a, c) {
      {
        if (Iv)
          return;
        switch (a.tag) {
          case m: {
            var g = a.stateNode.containerInfo;
            switch (c.tag) {
              case S:
                var b = c.type;
                c.pendingProps, Nre(g, b);
                break;
              case w:
                var C = c.pendingProps;
                Fre(g, C);
                break;
            }
            break;
          }
          case S: {
            var I = a.type, N = a.memoizedProps, H = a.stateNode;
            switch (c.tag) {
              case S: {
                var V = c.type, ee = c.pendingProps, re = (a.mode & Ot) !== Rt;
                Ure(
                  I,
                  N,
                  H,
                  V,
                  ee,
                  // TODO: Delete this argument when we remove the legacy root API.
                  re
                );
                break;
              }
              case w: {
                var me = c.pendingProps, pe = (a.mode & Ot) !== Rt;
                Bre(
                  I,
                  N,
                  H,
                  me,
                  // TODO: Delete this argument when we remove the legacy root API.
                  pe
                );
                break;
              }
            }
            break;
          }
          case $: {
            var Ae = a.memoizedState, Re = Ae.dehydrated;
            if (Re !== null) switch (c.tag) {
              case S:
                var Oe = c.type;
                c.pendingProps, $re(Re, Oe);
                break;
              case w:
                var ot = c.pendingProps;
                zre(Re, ot);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function GB(a, c) {
      c.flags = c.flags & ~il | $r, NO(a, c);
    }
    function KB(a, c) {
      switch (a.tag) {
        case S: {
          var g = a.type;
          a.pendingProps;
          var b = vre(c, g);
          return b !== null ? (a.stateNode = b, fo = a, Bc = wre(b), !0) : !1;
        }
        case w: {
          var C = a.pendingProps, I = yre(c, C);
          return I !== null ? (a.stateNode = I, fo = a, Bc = null, !0) : !1;
        }
        case $: {
          var N = Sre(c);
          if (N !== null) {
            var H = {
              dehydrated: N,
              treeContext: tie(),
              retryLane: Ws
            };
            a.memoizedState = H;
            var V = dae(N);
            return V.return = a, a.child = V, fo = a, Bc = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function FO(a) {
      return (a.mode & Ot) !== Rt && (a.flags & nn) === zt;
    }
    function $O(a) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function zO(a) {
      if (Ru) {
        var c = Bc;
        if (!c) {
          FO(a) && (NO(fo, a), $O()), GB(fo, a), Ru = !1, fo = a;
          return;
        }
        var g = c;
        if (!KB(a, c)) {
          FO(a) && (NO(fo, a), $O()), c = MC(g);
          var b = fo;
          if (!c || !KB(a, c)) {
            GB(fo, a), Ru = !1, fo = a;
            return;
          }
          WB(b, g);
        }
      }
    }
    function aie(a, c, g) {
      var b = a.stateNode, C = !Iv, I = _re(b, a.type, a.memoizedProps, c, g, a, C);
      return a.updateQueue = I, I !== null;
    }
    function lie(a) {
      var c = a.stateNode, g = a.memoizedProps, b = Tre(c, g, a);
      if (b) {
        var C = fo;
        if (C !== null)
          switch (C.tag) {
            case m: {
              var I = C.stateNode.containerInfo, N = (C.mode & Ot) !== Rt;
              Mre(
                I,
                c,
                g,
                // TODO: Delete this argument when we remove the legacy root API.
                N
              );
              break;
            }
            case S: {
              var H = C.type, V = C.memoizedProps, ee = C.stateNode, re = (C.mode & Ot) !== Rt;
              Dre(
                H,
                V,
                ee,
                c,
                g,
                // TODO: Delete this argument when we remove the legacy root API.
                re
              );
              break;
            }
          }
      }
      return b;
    }
    function cie(a) {
      var c = a.memoizedState, g = c !== null ? c.dehydrated : null;
      if (!g)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Pre(g, a);
    }
    function uie(a) {
      var c = a.memoizedState, g = c !== null ? c.dehydrated : null;
      if (!g)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return Are(g);
    }
    function YB(a) {
      for (var c = a.return; c !== null && c.tag !== S && c.tag !== m && c.tag !== $; )
        c = c.return;
      fo = c;
    }
    function KA(a) {
      if (a !== fo)
        return !1;
      if (!Ru)
        return YB(a), Ru = !0, !1;
      if (a.tag !== m && (a.tag !== S || Rre(a.type) && !xO(a.type, a.memoizedProps))) {
        var c = Bc;
        if (c)
          if (FO(a))
            XB(a), $O();
          else
            for (; c; )
              WB(a, c), c = MC(c);
      }
      return YB(a), a.tag === $ ? Bc = uie(a) : Bc = fo ? MC(a.stateNode) : null, !0;
    }
    function die() {
      return Ru && Bc !== null;
    }
    function XB(a) {
      for (var c = Bc; c; )
        VB(a, c), c = MC(c);
    }
    function Kb() {
      fo = null, Bc = null, Ru = !1, Iv = !1;
    }
    function qB() {
      Cg !== null && (H6(Cg), Cg = null);
    }
    function po() {
      return Ru;
    }
    function UO(a) {
      Cg === null ? Cg = [a] : Cg.push(a);
    }
    var hie = e.ReactCurrentBatchConfig, fie = null;
    function pie() {
      return hie.transition;
    }
    var Mu = {
      recordUnsafeLifecycleWarnings: function(a, c) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(a, c) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var gie = function(a) {
        for (var c = null, g = a; g !== null; )
          g.mode & Sn && (c = g), g = g.return;
        return c;
      }, Rv = function(a) {
        var c = [];
        return a.forEach(function(g) {
          c.push(g);
        }), c.sort().join(", ");
      }, jC = [], NC = [], FC = [], $C = [], zC = [], UC = [], Mv = /* @__PURE__ */ new Set();
      Mu.recordUnsafeLifecycleWarnings = function(a, c) {
        Mv.has(a.type) || (typeof c.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        c.componentWillMount.__suppressDeprecationWarning !== !0 && jC.push(a), a.mode & Sn && typeof c.UNSAFE_componentWillMount == "function" && NC.push(a), typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && FC.push(a), a.mode & Sn && typeof c.UNSAFE_componentWillReceiveProps == "function" && $C.push(a), typeof c.componentWillUpdate == "function" && c.componentWillUpdate.__suppressDeprecationWarning !== !0 && zC.push(a), a.mode & Sn && typeof c.UNSAFE_componentWillUpdate == "function" && UC.push(a));
      }, Mu.flushPendingUnsafeLifecycleWarnings = function() {
        var a = /* @__PURE__ */ new Set();
        jC.length > 0 && (jC.forEach(function(pe) {
          a.add(tn(pe) || "Component"), Mv.add(pe.type);
        }), jC = []);
        var c = /* @__PURE__ */ new Set();
        NC.length > 0 && (NC.forEach(function(pe) {
          c.add(tn(pe) || "Component"), Mv.add(pe.type);
        }), NC = []);
        var g = /* @__PURE__ */ new Set();
        FC.length > 0 && (FC.forEach(function(pe) {
          g.add(tn(pe) || "Component"), Mv.add(pe.type);
        }), FC = []);
        var b = /* @__PURE__ */ new Set();
        $C.length > 0 && ($C.forEach(function(pe) {
          b.add(tn(pe) || "Component"), Mv.add(pe.type);
        }), $C = []);
        var C = /* @__PURE__ */ new Set();
        zC.length > 0 && (zC.forEach(function(pe) {
          C.add(tn(pe) || "Component"), Mv.add(pe.type);
        }), zC = []);
        var I = /* @__PURE__ */ new Set();
        if (UC.length > 0 && (UC.forEach(function(pe) {
          I.add(tn(pe) || "Component"), Mv.add(pe.type);
        }), UC = []), c.size > 0) {
          var N = Rv(c);
          o(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, N);
        }
        if (b.size > 0) {
          var H = Rv(b);
          o(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, H);
        }
        if (I.size > 0) {
          var V = Rv(I);
          o(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, V);
        }
        if (a.size > 0) {
          var ee = Rv(a);
          s(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ee);
        }
        if (g.size > 0) {
          var re = Rv(g);
          s(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, re);
        }
        if (C.size > 0) {
          var me = Rv(C);
          s(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, me);
        }
      };
      var YA = /* @__PURE__ */ new Map(), ZB = /* @__PURE__ */ new Set();
      Mu.recordLegacyContextWarning = function(a, c) {
        var g = gie(a);
        if (g === null) {
          o("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!ZB.has(a.type)) {
          var b = YA.get(g);
          (a.type.contextTypes != null || a.type.childContextTypes != null || c !== null && typeof c.getChildContext == "function") && (b === void 0 && (b = [], YA.set(g, b)), b.push(a));
        }
      }, Mu.flushLegacyContextWarning = function() {
        YA.forEach(function(a, c) {
          if (a.length !== 0) {
            var g = a[0], b = /* @__PURE__ */ new Set();
            a.forEach(function(I) {
              b.add(tn(I) || "Component"), ZB.add(I.type);
            });
            var C = Rv(b);
            try {
              Jn(g), o(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, C);
            } finally {
              Cr();
            }
          }
        });
      }, Mu.discardPendingWarnings = function() {
        jC = [], NC = [], FC = [], $C = [], zC = [], UC = [], YA = /* @__PURE__ */ new Map();
      };
    }
    var BO, HO, VO, WO, GO, QB = function(a, c) {
    };
    BO = !1, HO = !1, VO = {}, WO = {}, GO = {}, QB = function(a, c) {
      if (!(a === null || typeof a != "object") && !(!a._store || a._store.validated || a.key != null)) {
        if (typeof a._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        a._store.validated = !0;
        var g = tn(c) || "Component";
        WO[g] || (WO[g] = !0, o('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function mie(a) {
      return a.prototype && a.prototype.isReactComponent;
    }
    function BC(a, c, g) {
      var b = g.ref;
      if (b !== null && typeof b != "function" && typeof b != "object") {
        if ((a.mode & Sn || Xe) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(g._owner && g._self && g._owner.stateNode !== g._self) && // Will already throw with "Function components cannot have string refs"
        !(g._owner && g._owner.tag !== d) && // Will already warn with "Function components cannot be given refs"
        !(typeof g.type == "function" && !mie(g.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        g._owner) {
          var C = tn(a) || "Component";
          VO[C] || (o('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', C, b), VO[C] = !0);
        }
        if (g._owner) {
          var I = g._owner, N;
          if (I) {
            var H = I;
            if (H.tag !== d)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            N = H.stateNode;
          }
          if (!N)
            throw new Error("Missing owner for string ref " + b + ". This error is likely caused by a bug in React. Please file an issue.");
          var V = N;
          fi(b, "ref");
          var ee = "" + b;
          if (c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === ee)
            return c.ref;
          var re = function(me) {
            var pe = V.refs;
            me === null ? delete pe[ee] : pe[ee] = me;
          };
          return re._stringRef = ee, re;
        } else {
          if (typeof b != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!g._owner)
            throw new Error("Element ref was specified as a string (" + b + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return b;
    }
    function XA(a, c) {
      var g = Object.prototype.toString.call(c);
      throw new Error("Objects are not valid as a React child (found: " + (g === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : g) + "). If you meant to render a collection of children, use an array instead.");
    }
    function qA(a) {
      {
        var c = tn(a) || "Component";
        if (GO[c])
          return;
        GO[c] = !0, o("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function JB(a) {
      var c = a._payload, g = a._init;
      return g(c);
    }
    function e4(a) {
      function c(Ee, Le) {
        if (a) {
          var _e = Ee.deletions;
          _e === null ? (Ee.deletions = [Le], Ee.flags |= or) : _e.push(Le);
        }
      }
      function g(Ee, Le) {
        if (!a)
          return null;
        for (var _e = Le; _e !== null; )
          c(Ee, _e), _e = _e.sibling;
        return null;
      }
      function b(Ee, Le) {
        for (var _e = /* @__PURE__ */ new Map(), Ye = Le; Ye !== null; )
          Ye.key !== null ? _e.set(Ye.key, Ye) : _e.set(Ye.index, Ye), Ye = Ye.sibling;
        return _e;
      }
      function C(Ee, Le) {
        var _e = Uv(Ee, Le);
        return _e.index = 0, _e.sibling = null, _e;
      }
      function I(Ee, Le, _e) {
        if (Ee.index = _e, !a)
          return Ee.flags |= Bw, Le;
        var Ye = Ee.alternate;
        if (Ye !== null) {
          var ft = Ye.index;
          return ft < Le ? (Ee.flags |= $r, Le) : ft;
        } else
          return Ee.flags |= $r, Le;
      }
      function N(Ee) {
        return a && Ee.alternate === null && (Ee.flags |= $r), Ee;
      }
      function H(Ee, Le, _e, Ye) {
        if (Le === null || Le.tag !== w) {
          var ft = Uj(_e, Ee.mode, Ye);
          return ft.return = Ee, ft;
        } else {
          var lt = C(Le, _e);
          return lt.return = Ee, lt;
        }
      }
      function V(Ee, Le, _e, Ye) {
        var ft = _e.type;
        if (ft === bs)
          return re(Ee, Le, _e.props.children, Ye, _e.key);
        if (Le !== null && (Le.elementType === ft || // Keep this check inline so it only runs on the false path:
        sH(Le, _e) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof ft == "object" && ft !== null && ft.$$typeof === Bt && JB(ft) === Le.type)) {
          var lt = C(Le, _e.props);
          return lt.ref = BC(Ee, Le, _e), lt.return = Ee, lt._debugSource = _e._source, lt._debugOwner = _e._owner, lt;
        }
        var Qt = zj(_e, Ee.mode, Ye);
        return Qt.ref = BC(Ee, Le, _e), Qt.return = Ee, Qt;
      }
      function ee(Ee, Le, _e, Ye) {
        if (Le === null || Le.tag !== v || Le.stateNode.containerInfo !== _e.containerInfo || Le.stateNode.implementation !== _e.implementation) {
          var ft = Bj(_e, Ee.mode, Ye);
          return ft.return = Ee, ft;
        } else {
          var lt = C(Le, _e.children || []);
          return lt.return = Ee, lt;
        }
      }
      function re(Ee, Le, _e, Ye, ft) {
        if (Le === null || Le.tag !== E) {
          var lt = Og(_e, Ee.mode, Ye, ft);
          return lt.return = Ee, lt;
        } else {
          var Qt = C(Le, _e);
          return Qt.return = Ee, Qt;
        }
      }
      function me(Ee, Le, _e) {
        if (typeof Le == "string" && Le !== "" || typeof Le == "number") {
          var Ye = Uj("" + Le, Ee.mode, _e);
          return Ye.return = Ee, Ye;
        }
        if (typeof Le == "object" && Le !== null) {
          switch (Le.$$typeof) {
            case xa: {
              var ft = zj(Le, Ee.mode, _e);
              return ft.ref = BC(Ee, null, Le), ft.return = Ee, ft;
            }
            case os: {
              var lt = Bj(Le, Ee.mode, _e);
              return lt.return = Ee, lt;
            }
            case Bt: {
              var Qt = Le._payload, cn = Le._init;
              return me(Ee, cn(Qt), _e);
            }
          }
          if (Pn(Le) || xs(Le)) {
            var Sr = Og(Le, Ee.mode, _e, null);
            return Sr.return = Ee, Sr;
          }
          XA(Ee, Le);
        }
        return typeof Le == "function" && qA(Ee), null;
      }
      function pe(Ee, Le, _e, Ye) {
        var ft = Le !== null ? Le.key : null;
        if (typeof _e == "string" && _e !== "" || typeof _e == "number")
          return ft !== null ? null : H(Ee, Le, "" + _e, Ye);
        if (typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case xa:
              return _e.key === ft ? V(Ee, Le, _e, Ye) : null;
            case os:
              return _e.key === ft ? ee(Ee, Le, _e, Ye) : null;
            case Bt: {
              var lt = _e._payload, Qt = _e._init;
              return pe(Ee, Le, Qt(lt), Ye);
            }
          }
          if (Pn(_e) || xs(_e))
            return ft !== null ? null : re(Ee, Le, _e, Ye, null);
          XA(Ee, _e);
        }
        return typeof _e == "function" && qA(Ee), null;
      }
      function Ae(Ee, Le, _e, Ye, ft) {
        if (typeof Ye == "string" && Ye !== "" || typeof Ye == "number") {
          var lt = Ee.get(_e) || null;
          return H(Le, lt, "" + Ye, ft);
        }
        if (typeof Ye == "object" && Ye !== null) {
          switch (Ye.$$typeof) {
            case xa: {
              var Qt = Ee.get(Ye.key === null ? _e : Ye.key) || null;
              return V(Le, Qt, Ye, ft);
            }
            case os: {
              var cn = Ee.get(Ye.key === null ? _e : Ye.key) || null;
              return ee(Le, cn, Ye, ft);
            }
            case Bt:
              var Sr = Ye._payload, nr = Ye._init;
              return Ae(Ee, Le, _e, nr(Sr), ft);
          }
          if (Pn(Ye) || xs(Ye)) {
            var Ki = Ee.get(_e) || null;
            return re(Le, Ki, Ye, ft, null);
          }
          XA(Le, Ye);
        }
        return typeof Ye == "function" && qA(Le), null;
      }
      function Re(Ee, Le, _e) {
        {
          if (typeof Ee != "object" || Ee === null)
            return Le;
          switch (Ee.$$typeof) {
            case xa:
            case os:
              QB(Ee, _e);
              var Ye = Ee.key;
              if (typeof Ye != "string")
                break;
              if (Le === null) {
                Le = /* @__PURE__ */ new Set(), Le.add(Ye);
                break;
              }
              if (!Le.has(Ye)) {
                Le.add(Ye);
                break;
              }
              o("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Ye);
              break;
            case Bt:
              var ft = Ee._payload, lt = Ee._init;
              Re(lt(ft), Le, _e);
              break;
          }
        }
        return Le;
      }
      function Oe(Ee, Le, _e, Ye) {
        for (var ft = null, lt = 0; lt < _e.length; lt++) {
          var Qt = _e[lt];
          ft = Re(Qt, ft, Ee);
        }
        for (var cn = null, Sr = null, nr = Le, Ki = 0, rr = 0, Fi = null; nr !== null && rr < _e.length; rr++) {
          nr.index > rr ? (Fi = nr, nr = null) : Fi = nr.sibling;
          var ra = pe(Ee, nr, _e[rr], Ye);
          if (ra === null) {
            nr === null && (nr = Fi);
            break;
          }
          a && nr && ra.alternate === null && c(Ee, nr), Ki = I(ra, Ki, rr), Sr === null ? cn = ra : Sr.sibling = ra, Sr = ra, nr = Fi;
        }
        if (rr === _e.length) {
          if (g(Ee, nr), po()) {
            var xo = rr;
            Av(Ee, xo);
          }
          return cn;
        }
        if (nr === null) {
          for (; rr < _e.length; rr++) {
            var Jl = me(Ee, _e[rr], Ye);
            Jl !== null && (Ki = I(Jl, Ki, rr), Sr === null ? cn = Jl : Sr.sibling = Jl, Sr = Jl);
          }
          if (po()) {
            var Oa = rr;
            Av(Ee, Oa);
          }
          return cn;
        }
        for (var La = b(Ee, nr); rr < _e.length; rr++) {
          var ia = Ae(La, Ee, rr, _e[rr], Ye);
          ia !== null && (a && ia.alternate !== null && La.delete(ia.key === null ? rr : ia.key), Ki = I(ia, Ki, rr), Sr === null ? cn = ia : Sr.sibling = ia, Sr = ia);
        }
        if (a && La.forEach(function(h0) {
          return c(Ee, h0);
        }), po()) {
          var Cf = rr;
          Av(Ee, Cf);
        }
        return cn;
      }
      function ot(Ee, Le, _e, Ye) {
        var ft = xs(_e);
        if (typeof ft != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          _e[Symbol.toStringTag] === "Generator" && (HO || o("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), HO = !0), _e.entries === ft && (BO || o("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), BO = !0);
          var lt = ft.call(_e);
          if (lt)
            for (var Qt = null, cn = lt.next(); !cn.done; cn = lt.next()) {
              var Sr = cn.value;
              Qt = Re(Sr, Qt, Ee);
            }
        }
        var nr = ft.call(_e);
        if (nr == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Ki = null, rr = null, Fi = Le, ra = 0, xo = 0, Jl = null, Oa = nr.next(); Fi !== null && !Oa.done; xo++, Oa = nr.next()) {
          Fi.index > xo ? (Jl = Fi, Fi = null) : Jl = Fi.sibling;
          var La = pe(Ee, Fi, Oa.value, Ye);
          if (La === null) {
            Fi === null && (Fi = Jl);
            break;
          }
          a && Fi && La.alternate === null && c(Ee, Fi), ra = I(La, ra, xo), rr === null ? Ki = La : rr.sibling = La, rr = La, Fi = Jl;
        }
        if (Oa.done) {
          if (g(Ee, Fi), po()) {
            var ia = xo;
            Av(Ee, ia);
          }
          return Ki;
        }
        if (Fi === null) {
          for (; !Oa.done; xo++, Oa = nr.next()) {
            var Cf = me(Ee, Oa.value, Ye);
            Cf !== null && (ra = I(Cf, ra, xo), rr === null ? Ki = Cf : rr.sibling = Cf, rr = Cf);
          }
          if (po()) {
            var h0 = xo;
            Av(Ee, h0);
          }
          return Ki;
        }
        for (var bE = b(Ee, Fi); !Oa.done; xo++, Oa = nr.next()) {
          var Gd = Ae(bE, Ee, xo, Oa.value, Ye);
          Gd !== null && (a && Gd.alternate !== null && bE.delete(Gd.key === null ? xo : Gd.key), ra = I(Gd, ra, xo), rr === null ? Ki = Gd : rr.sibling = Gd, rr = Gd);
        }
        if (a && bE.forEach(function(Bae) {
          return c(Ee, Bae);
        }), po()) {
          var Uae = xo;
          Av(Ee, Uae);
        }
        return Ki;
      }
      function Ht(Ee, Le, _e, Ye) {
        if (Le !== null && Le.tag === w) {
          g(Ee, Le.sibling);
          var ft = C(Le, _e);
          return ft.return = Ee, ft;
        }
        g(Ee, Le);
        var lt = Uj(_e, Ee.mode, Ye);
        return lt.return = Ee, lt;
      }
      function Lt(Ee, Le, _e, Ye) {
        for (var ft = _e.key, lt = Le; lt !== null; ) {
          if (lt.key === ft) {
            var Qt = _e.type;
            if (Qt === bs) {
              if (lt.tag === E) {
                g(Ee, lt.sibling);
                var cn = C(lt, _e.props.children);
                return cn.return = Ee, cn._debugSource = _e._source, cn._debugOwner = _e._owner, cn;
              }
            } else if (lt.elementType === Qt || // Keep this check inline so it only runs on the false path:
            sH(lt, _e) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Qt == "object" && Qt !== null && Qt.$$typeof === Bt && JB(Qt) === lt.type) {
              g(Ee, lt.sibling);
              var Sr = C(lt, _e.props);
              return Sr.ref = BC(Ee, lt, _e), Sr.return = Ee, Sr._debugSource = _e._source, Sr._debugOwner = _e._owner, Sr;
            }
            g(Ee, lt);
            break;
          } else
            c(Ee, lt);
          lt = lt.sibling;
        }
        if (_e.type === bs) {
          var nr = Og(_e.props.children, Ee.mode, Ye, _e.key);
          return nr.return = Ee, nr;
        } else {
          var Ki = zj(_e, Ee.mode, Ye);
          return Ki.ref = BC(Ee, Le, _e), Ki.return = Ee, Ki;
        }
      }
      function Nn(Ee, Le, _e, Ye) {
        for (var ft = _e.key, lt = Le; lt !== null; ) {
          if (lt.key === ft)
            if (lt.tag === v && lt.stateNode.containerInfo === _e.containerInfo && lt.stateNode.implementation === _e.implementation) {
              g(Ee, lt.sibling);
              var Qt = C(lt, _e.children || []);
              return Qt.return = Ee, Qt;
            } else {
              g(Ee, lt);
              break;
            }
          else
            c(Ee, lt);
          lt = lt.sibling;
        }
        var cn = Bj(_e, Ee.mode, Ye);
        return cn.return = Ee, cn;
      }
      function Tn(Ee, Le, _e, Ye) {
        var ft = typeof _e == "object" && _e !== null && _e.type === bs && _e.key === null;
        if (ft && (_e = _e.props.children), typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case xa:
              return N(Lt(Ee, Le, _e, Ye));
            case os:
              return N(Nn(Ee, Le, _e, Ye));
            case Bt:
              var lt = _e._payload, Qt = _e._init;
              return Tn(Ee, Le, Qt(lt), Ye);
          }
          if (Pn(_e))
            return Oe(Ee, Le, _e, Ye);
          if (xs(_e))
            return ot(Ee, Le, _e, Ye);
          XA(Ee, _e);
        }
        return typeof _e == "string" && _e !== "" || typeof _e == "number" ? N(Ht(Ee, Le, "" + _e, Ye)) : (typeof _e == "function" && qA(Ee), g(Ee, Le));
      }
      return Tn;
    }
    var Yb = e4(!0), t4 = e4(!1);
    function vie(a, c) {
      if (a !== null && c.child !== a.child)
        throw new Error("Resuming work not yet implemented.");
      if (c.child !== null) {
        var g = c.child, b = Uv(g, g.pendingProps);
        for (c.child = b, b.return = c; g.sibling !== null; )
          g = g.sibling, b = b.sibling = Uv(g, g.pendingProps), b.return = c;
        b.sibling = null;
      }
    }
    function yie(a, c) {
      for (var g = a.child; g !== null; )
        sae(g, c), g = g.sibling;
    }
    var KO = bg(null), YO;
    YO = {};
    var ZA = null, Xb = null, XO = null, QA = !1;
    function JA() {
      ZA = null, Xb = null, XO = null, QA = !1;
    }
    function n4() {
      QA = !0;
    }
    function r4() {
      QA = !1;
    }
    function i4(a, c, g) {
      ta(KO, c._currentValue, a), c._currentValue = g, c._currentRenderer !== void 0 && c._currentRenderer !== null && c._currentRenderer !== YO && o("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer = YO;
    }
    function qO(a, c) {
      var g = KO.current;
      ea(KO, c), a._currentValue = g;
    }
    function ZO(a, c, g) {
      for (var b = a; b !== null; ) {
        var C = b.alternate;
        if (rf(b.childLanes, c) ? C !== null && !rf(C.childLanes, c) && (C.childLanes = dn(C.childLanes, c)) : (b.childLanes = dn(b.childLanes, c), C !== null && (C.childLanes = dn(C.childLanes, c))), b === g)
          break;
        b = b.return;
      }
      b !== g && o("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Sie(a, c, g) {
      bie(a, c, g);
    }
    function bie(a, c, g) {
      var b = a.child;
      for (b !== null && (b.return = a); b !== null; ) {
        var C = void 0, I = b.dependencies;
        if (I !== null) {
          C = b.child;
          for (var N = I.firstContext; N !== null; ) {
            if (N.context === c) {
              if (b.tag === d) {
                var H = tg(g), V = vf(Rr, H);
                V.tag = tk;
                var ee = b.updateQueue;
                if (ee !== null) {
                  var re = ee.shared, me = re.pending;
                  me === null ? V.next = V : (V.next = me.next, me.next = V), re.pending = V;
                }
              }
              b.lanes = dn(b.lanes, g);
              var pe = b.alternate;
              pe !== null && (pe.lanes = dn(pe.lanes, g)), ZO(b.return, g, a), I.lanes = dn(I.lanes, g);
              break;
            }
            N = N.next;
          }
        } else if (b.tag === R)
          C = b.type === a.type ? null : b.child;
        else if (b.tag === X) {
          var Ae = b.return;
          if (Ae === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ae.lanes = dn(Ae.lanes, g);
          var Re = Ae.alternate;
          Re !== null && (Re.lanes = dn(Re.lanes, g)), ZO(Ae, g, a), C = b.sibling;
        } else
          C = b.child;
        if (C !== null)
          C.return = b;
        else
          for (C = b; C !== null; ) {
            if (C === a) {
              C = null;
              break;
            }
            var Oe = C.sibling;
            if (Oe !== null) {
              Oe.return = C.return, C = Oe;
              break;
            }
            C = C.return;
          }
        b = C;
      }
    }
    function qb(a, c) {
      ZA = a, Xb = null, XO = null;
      var g = a.dependencies;
      if (g !== null) {
        var b = g.firstContext;
        b !== null && (Qo(g.lanes, c) && rE(), g.firstContext = null);
      }
    }
    function ms(a) {
      QA && o("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var c = a._currentValue;
      if (XO !== a) {
        var g = {
          context: a,
          memoizedValue: c,
          next: null
        };
        if (Xb === null) {
          if (ZA === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Xb = g, ZA.dependencies = {
            lanes: Ue,
            firstContext: g
          };
        } else
          Xb = Xb.next = g;
      }
      return c;
    }
    var Dv = null;
    function QO(a) {
      Dv === null ? Dv = [a] : Dv.push(a);
    }
    function xie() {
      if (Dv !== null) {
        for (var a = 0; a < Dv.length; a++) {
          var c = Dv[a], g = c.interleaved;
          if (g !== null) {
            c.interleaved = null;
            var b = g.next, C = c.pending;
            if (C !== null) {
              var I = C.next;
              C.next = b, g.next = I;
            }
            c.pending = g;
          }
        }
        Dv = null;
      }
    }
    function s4(a, c, g, b) {
      var C = c.interleaved;
      return C === null ? (g.next = g, QO(c)) : (g.next = C.next, C.next = g), c.interleaved = g, ek(a, b);
    }
    function wie(a, c, g, b) {
      var C = c.interleaved;
      C === null ? (g.next = g, QO(c)) : (g.next = C.next, C.next = g), c.interleaved = g;
    }
    function Cie(a, c, g, b) {
      var C = c.interleaved;
      return C === null ? (g.next = g, QO(c)) : (g.next = C.next, C.next = g), c.interleaved = g, ek(a, b);
    }
    function ml(a, c) {
      return ek(a, c);
    }
    var Eie = ek;
    function ek(a, c) {
      a.lanes = dn(a.lanes, c);
      var g = a.alternate;
      g !== null && (g.lanes = dn(g.lanes, c)), g === null && (a.flags & ($r | il)) !== zt && tH(a);
      for (var b = a, C = a.return; C !== null; )
        C.childLanes = dn(C.childLanes, c), g = C.alternate, g !== null ? g.childLanes = dn(g.childLanes, c) : (C.flags & ($r | il)) !== zt && tH(a), b = C, C = C.return;
      if (b.tag === m) {
        var I = b.stateNode;
        return I;
      } else
        return null;
    }
    var o4 = 0, a4 = 1, tk = 2, JO = 3, nk = !1, eL, rk;
    eL = !1, rk = null;
    function tL(a) {
      var c = {
        baseState: a.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ue
        },
        effects: null
      };
      a.updateQueue = c;
    }
    function l4(a, c) {
      var g = c.updateQueue, b = a.updateQueue;
      if (g === b) {
        var C = {
          baseState: b.baseState,
          firstBaseUpdate: b.firstBaseUpdate,
          lastBaseUpdate: b.lastBaseUpdate,
          shared: b.shared,
          effects: b.effects
        };
        c.updateQueue = C;
      }
    }
    function vf(a, c) {
      var g = {
        eventTime: a,
        lane: c,
        tag: o4,
        payload: null,
        callback: null,
        next: null
      };
      return g;
    }
    function Eg(a, c, g) {
      var b = a.updateQueue;
      if (b === null)
        return null;
      var C = b.shared;
      if (rk === C && !eL && (o("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), eL = !0), woe()) {
        var I = C.pending;
        return I === null ? c.next = c : (c.next = I.next, I.next = c), C.pending = c, Eie(a, g);
      } else
        return Cie(a, C, c, g);
    }
    function ik(a, c, g) {
      var b = c.updateQueue;
      if (b !== null) {
        var C = b.shared;
        if (rC(g)) {
          var I = C.lanes;
          I = fb(I, a.pendingLanes);
          var N = dn(I, g);
          C.lanes = N, iC(a, N);
        }
      }
    }
    function nL(a, c) {
      var g = a.updateQueue, b = a.alternate;
      if (b !== null) {
        var C = b.updateQueue;
        if (g === C) {
          var I = null, N = null, H = g.firstBaseUpdate;
          if (H !== null) {
            var V = H;
            do {
              var ee = {
                eventTime: V.eventTime,
                lane: V.lane,
                tag: V.tag,
                payload: V.payload,
                callback: V.callback,
                next: null
              };
              N === null ? I = N = ee : (N.next = ee, N = ee), V = V.next;
            } while (V !== null);
            N === null ? I = N = c : (N.next = c, N = c);
          } else
            I = N = c;
          g = {
            baseState: C.baseState,
            firstBaseUpdate: I,
            lastBaseUpdate: N,
            shared: C.shared,
            effects: C.effects
          }, a.updateQueue = g;
          return;
        }
      }
      var re = g.lastBaseUpdate;
      re === null ? g.firstBaseUpdate = c : re.next = c, g.lastBaseUpdate = c;
    }
    function _ie(a, c, g, b, C, I) {
      switch (g.tag) {
        case a4: {
          var N = g.payload;
          if (typeof N == "function") {
            n4();
            var H = N.call(I, b, C);
            {
              if (a.mode & Sn) {
                ji(!0);
                try {
                  N.call(I, b, C);
                } finally {
                  ji(!1);
                }
              }
              r4();
            }
            return H;
          }
          return N;
        }
        case JO:
          a.flags = a.flags & ~hs | nn;
        case o4: {
          var V = g.payload, ee;
          if (typeof V == "function") {
            n4(), ee = V.call(I, b, C);
            {
              if (a.mode & Sn) {
                ji(!0);
                try {
                  V.call(I, b, C);
                } finally {
                  ji(!1);
                }
              }
              r4();
            }
          } else
            ee = V;
          return ee == null ? b : on({}, b, ee);
        }
        case tk:
          return nk = !0, b;
      }
      return b;
    }
    function sk(a, c, g, b) {
      var C = a.updateQueue;
      nk = !1, rk = C.shared;
      var I = C.firstBaseUpdate, N = C.lastBaseUpdate, H = C.shared.pending;
      if (H !== null) {
        C.shared.pending = null;
        var V = H, ee = V.next;
        V.next = null, N === null ? I = ee : N.next = ee, N = V;
        var re = a.alternate;
        if (re !== null) {
          var me = re.updateQueue, pe = me.lastBaseUpdate;
          pe !== N && (pe === null ? me.firstBaseUpdate = ee : pe.next = ee, me.lastBaseUpdate = V);
        }
      }
      if (I !== null) {
        var Ae = C.baseState, Re = Ue, Oe = null, ot = null, Ht = null, Lt = I;
        do {
          var Nn = Lt.lane, Tn = Lt.eventTime;
          if (rf(b, Nn)) {
            if (Ht !== null) {
              var Le = {
                eventTime: Tn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Ni,
                tag: Lt.tag,
                payload: Lt.payload,
                callback: Lt.callback,
                next: null
              };
              Ht = Ht.next = Le;
            }
            Ae = _ie(a, C, Lt, Ae, c, g);
            var _e = Lt.callback;
            if (_e !== null && // If the update was already committed, we should not queue its
            // callback again.
            Lt.lane !== Ni) {
              a.flags |= Oc;
              var Ye = C.effects;
              Ye === null ? C.effects = [Lt] : Ye.push(Lt);
            }
          } else {
            var Ee = {
              eventTime: Tn,
              lane: Nn,
              tag: Lt.tag,
              payload: Lt.payload,
              callback: Lt.callback,
              next: null
            };
            Ht === null ? (ot = Ht = Ee, Oe = Ae) : Ht = Ht.next = Ee, Re = dn(Re, Nn);
          }
          if (Lt = Lt.next, Lt === null) {
            if (H = C.shared.pending, H === null)
              break;
            var ft = H, lt = ft.next;
            ft.next = null, Lt = lt, C.lastBaseUpdate = ft, C.shared.pending = null;
          }
        } while (!0);
        Ht === null && (Oe = Ae), C.baseState = Oe, C.firstBaseUpdate = ot, C.lastBaseUpdate = Ht;
        var Qt = C.shared.interleaved;
        if (Qt !== null) {
          var cn = Qt;
          do
            Re = dn(Re, cn.lane), cn = cn.next;
          while (cn !== Qt);
        } else I === null && (C.shared.lanes = Ue);
        gE(Re), a.lanes = Re, a.memoizedState = Ae;
      }
      rk = null;
    }
    function Tie(a, c) {
      if (typeof a != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + a));
      a.call(c);
    }
    function c4() {
      nk = !1;
    }
    function ok() {
      return nk;
    }
    function u4(a, c, g) {
      var b = c.effects;
      if (c.effects = null, b !== null)
        for (var C = 0; C < b.length; C++) {
          var I = b[C], N = I.callback;
          N !== null && (I.callback = null, Tie(N, g));
        }
    }
    var HC = {}, _g = bg(HC), VC = bg(HC), ak = bg(HC);
    function lk(a) {
      if (a === HC)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return a;
    }
    function d4() {
      var a = lk(ak.current);
      return a;
    }
    function rL(a, c) {
      ta(ak, c, a), ta(VC, a, a), ta(_g, HC, a);
      var g = Hne(c);
      ea(_g, a), ta(_g, g, a);
    }
    function Zb(a) {
      ea(_g, a), ea(VC, a), ea(ak, a);
    }
    function iL() {
      var a = lk(_g.current);
      return a;
    }
    function h4(a) {
      lk(ak.current);
      var c = lk(_g.current), g = Vne(c, a.type);
      c !== g && (ta(VC, a, a), ta(_g, g, a));
    }
    function sL(a) {
      VC.current === a && (ea(_g, a), ea(VC, a));
    }
    var Pie = 0, f4 = 1, p4 = 1, WC = 2, Du = bg(Pie);
    function oL(a, c) {
      return (a & c) !== 0;
    }
    function Qb(a) {
      return a & f4;
    }
    function aL(a, c) {
      return a & f4 | c;
    }
    function Aie(a, c) {
      return a | c;
    }
    function Tg(a, c) {
      ta(Du, c, a);
    }
    function Jb(a) {
      ea(Du, a);
    }
    function kie(a, c) {
      var g = a.memoizedState;
      return g !== null ? g.dehydrated !== null : (a.memoizedProps, !0);
    }
    function ck(a) {
      for (var c = a; c !== null; ) {
        if (c.tag === $) {
          var g = c.memoizedState;
          if (g !== null) {
            var b = g.dehydrated;
            if (b === null || RB(b) || _O(b))
              return c;
          }
        } else if (c.tag === te && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        c.memoizedProps.revealOrder !== void 0) {
          var C = (c.flags & nn) !== zt;
          if (C)
            return c;
        } else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === a)
          return null;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === a)
            return null;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return null;
    }
    var vl = (
      /*   */
      0
    ), Ts = (
      /* */
      1
    ), $d = (
      /*  */
      2
    ), Ps = (
      /*    */
      4
    ), go = (
      /*   */
      8
    ), lL = [];
    function cL() {
      for (var a = 0; a < lL.length; a++) {
        var c = lL[a];
        c._workInProgressVersionPrimary = null;
      }
      lL.length = 0;
    }
    function Iie(a, c) {
      var g = c._getVersion, b = g(c._source);
      a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [c, b] : a.mutableSourceEagerHydrationData.push(c, b);
    }
    var ht = e.ReactCurrentDispatcher, GC = e.ReactCurrentBatchConfig, uL, e0;
    uL = /* @__PURE__ */ new Set();
    var Ov = Ue, yr = null, As = null, ks = null, uk = !1, KC = !1, YC = 0, Rie = 0, Mie = 25, Ne = null, Hc = null, Pg = -1, dL = !1;
    function dr() {
      {
        var a = Ne;
        Hc === null ? Hc = [a] : Hc.push(a);
      }
    }
    function it() {
      {
        var a = Ne;
        Hc !== null && (Pg++, Hc[Pg] !== a && Die(a));
      }
    }
    function t0(a) {
      a != null && !Pn(a) && o("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Ne, typeof a);
    }
    function Die(a) {
      {
        var c = tn(yr);
        if (!uL.has(c) && (uL.add(c), Hc !== null)) {
          for (var g = "", b = 30, C = 0; C <= Pg; C++) {
            for (var I = Hc[C], N = C === Pg ? a : I, H = C + 1 + ". " + I; H.length < b; )
              H += " ";
            H += N + `
`, g += H;
          }
          o(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, c, g);
        }
      }
    }
    function na() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function hL(a, c) {
      if (dL)
        return !1;
      if (c === null)
        return o("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Ne), !1;
      a.length !== c.length && o(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Ne, "[" + c.join(", ") + "]", "[" + a.join(", ") + "]");
      for (var g = 0; g < c.length && g < a.length; g++)
        if (!bt(a[g], c[g]))
          return !1;
      return !0;
    }
    function n0(a, c, g, b, C, I) {
      Ov = I, yr = c, Hc = a !== null ? a._debugHookTypes : null, Pg = -1, dL = a !== null && a.type !== c.type, c.memoizedState = null, c.updateQueue = null, c.lanes = Ue, a !== null && a.memoizedState !== null ? ht.current = j4 : Hc !== null ? ht.current = L4 : ht.current = O4;
      var N = g(b, C);
      if (KC) {
        var H = 0;
        do {
          if (KC = !1, YC = 0, H >= Mie)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          H += 1, dL = !1, As = null, ks = null, c.updateQueue = null, Pg = -1, ht.current = N4, N = g(b, C);
        } while (KC);
      }
      ht.current = Ck, c._debugHookTypes = Hc;
      var V = As !== null && As.next !== null;
      if (Ov = Ue, yr = null, As = null, ks = null, Ne = null, Hc = null, Pg = -1, a !== null && (a.flags & Cs) !== (c.flags & Cs) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (a.mode & Ot) !== Rt && o("Internal React error: Expected static flag was missing. Please notify the React team."), uk = !1, V)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return N;
    }
    function r0() {
      var a = YC !== 0;
      return YC = 0, a;
    }
    function g4(a, c, g) {
      c.updateQueue = a.updateQueue, (c.mode & ka) !== Rt ? c.flags &= ~(Yh | Go | qr | pn) : c.flags &= ~(qr | pn), a.lanes = dv(a.lanes, g);
    }
    function m4() {
      if (ht.current = Ck, uk) {
        for (var a = yr.memoizedState; a !== null; ) {
          var c = a.queue;
          c !== null && (c.pending = null), a = a.next;
        }
        uk = !1;
      }
      Ov = Ue, yr = null, As = null, ks = null, Hc = null, Pg = -1, Ne = null, k4 = !1, KC = !1, YC = 0;
    }
    function zd() {
      var a = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return ks === null ? yr.memoizedState = ks = a : ks = ks.next = a, ks;
    }
    function Vc() {
      var a;
      if (As === null) {
        var c = yr.alternate;
        c !== null ? a = c.memoizedState : a = null;
      } else
        a = As.next;
      var g;
      if (ks === null ? g = yr.memoizedState : g = ks.next, g !== null)
        ks = g, g = ks.next, As = a;
      else {
        if (a === null)
          throw new Error("Rendered more hooks than during the previous render.");
        As = a;
        var b = {
          memoizedState: As.memoizedState,
          baseState: As.baseState,
          baseQueue: As.baseQueue,
          queue: As.queue,
          next: null
        };
        ks === null ? yr.memoizedState = ks = b : ks = ks.next = b;
      }
      return ks;
    }
    function v4() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function fL(a, c) {
      return typeof c == "function" ? c(a) : c;
    }
    function pL(a, c, g) {
      var b = zd(), C;
      g !== void 0 ? C = g(c) : C = c, b.memoizedState = b.baseState = C;
      var I = {
        pending: null,
        interleaved: null,
        lanes: Ue,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: C
      };
      b.queue = I;
      var N = I.dispatch = Nie.bind(null, yr, I);
      return [b.memoizedState, N];
    }
    function gL(a, c, g) {
      var b = Vc(), C = b.queue;
      if (C === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      C.lastRenderedReducer = a;
      var I = As, N = I.baseQueue, H = C.pending;
      if (H !== null) {
        if (N !== null) {
          var V = N.next, ee = H.next;
          N.next = ee, H.next = V;
        }
        I.baseQueue !== N && o("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), I.baseQueue = N = H, C.pending = null;
      }
      if (N !== null) {
        var re = N.next, me = I.baseState, pe = null, Ae = null, Re = null, Oe = re;
        do {
          var ot = Oe.lane;
          if (rf(Ov, ot)) {
            if (Re !== null) {
              var Lt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Ni,
                action: Oe.action,
                hasEagerState: Oe.hasEagerState,
                eagerState: Oe.eagerState,
                next: null
              };
              Re = Re.next = Lt;
            }
            if (Oe.hasEagerState)
              me = Oe.eagerState;
            else {
              var Nn = Oe.action;
              me = a(me, Nn);
            }
          } else {
            var Ht = {
              lane: ot,
              action: Oe.action,
              hasEagerState: Oe.hasEagerState,
              eagerState: Oe.eagerState,
              next: null
            };
            Re === null ? (Ae = Re = Ht, pe = me) : Re = Re.next = Ht, yr.lanes = dn(yr.lanes, ot), gE(ot);
          }
          Oe = Oe.next;
        } while (Oe !== null && Oe !== re);
        Re === null ? pe = me : Re.next = Ae, bt(me, b.memoizedState) || rE(), b.memoizedState = me, b.baseState = pe, b.baseQueue = Re, C.lastRenderedState = me;
      }
      var Tn = C.interleaved;
      if (Tn !== null) {
        var Ee = Tn;
        do {
          var Le = Ee.lane;
          yr.lanes = dn(yr.lanes, Le), gE(Le), Ee = Ee.next;
        } while (Ee !== Tn);
      } else N === null && (C.lanes = Ue);
      var _e = C.dispatch;
      return [b.memoizedState, _e];
    }
    function mL(a, c, g) {
      var b = Vc(), C = b.queue;
      if (C === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      C.lastRenderedReducer = a;
      var I = C.dispatch, N = C.pending, H = b.memoizedState;
      if (N !== null) {
        C.pending = null;
        var V = N.next, ee = V;
        do {
          var re = ee.action;
          H = a(H, re), ee = ee.next;
        } while (ee !== V);
        bt(H, b.memoizedState) || rE(), b.memoizedState = H, b.baseQueue === null && (b.baseState = H), C.lastRenderedState = H;
      }
      return [H, I];
    }
    function lNe(a, c, g) {
    }
    function cNe(a, c, g) {
    }
    function vL(a, c, g) {
      var b = yr, C = zd(), I, N = po();
      if (N) {
        if (g === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        I = g(), e0 || I !== g() && (o("The result of getServerSnapshot should be cached to avoid an infinite loop"), e0 = !0);
      } else {
        if (I = c(), !e0) {
          var H = c();
          bt(I, H) || (o("The result of getSnapshot should be cached to avoid an infinite loop"), e0 = !0);
        }
        var V = Bk();
        if (V === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        uv(V, Ov) || y4(b, c, I);
      }
      C.memoizedState = I;
      var ee = {
        value: I,
        getSnapshot: c
      };
      return C.queue = ee, gk(b4.bind(null, b, ee, a), [a]), b.flags |= qr, XC(Ts | go, S4.bind(null, b, ee, I, c), void 0, null), I;
    }
    function dk(a, c, g) {
      var b = yr, C = Vc(), I = c();
      if (!e0) {
        var N = c();
        bt(I, N) || (o("The result of getSnapshot should be cached to avoid an infinite loop"), e0 = !0);
      }
      var H = C.memoizedState, V = !bt(H, I);
      V && (C.memoizedState = I, rE());
      var ee = C.queue;
      if (ZC(b4.bind(null, b, ee, a), [a]), ee.getSnapshot !== c || V || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      ks !== null && ks.memoizedState.tag & Ts) {
        b.flags |= qr, XC(Ts | go, S4.bind(null, b, ee, I, c), void 0, null);
        var re = Bk();
        if (re === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        uv(re, Ov) || y4(b, c, I);
      }
      return I;
    }
    function y4(a, c, g) {
      a.flags |= ev;
      var b = {
        getSnapshot: c,
        value: g
      }, C = yr.updateQueue;
      if (C === null)
        C = v4(), yr.updateQueue = C, C.stores = [b];
      else {
        var I = C.stores;
        I === null ? C.stores = [b] : I.push(b);
      }
    }
    function S4(a, c, g, b) {
      c.value = g, c.getSnapshot = b, x4(c) && w4(a);
    }
    function b4(a, c, g) {
      var b = function() {
        x4(c) && w4(a);
      };
      return g(b);
    }
    function x4(a) {
      var c = a.getSnapshot, g = a.value;
      try {
        var b = c();
        return !bt(g, b);
      } catch {
        return !0;
      }
    }
    function w4(a) {
      var c = ml(a, Nt);
      c !== null && Ds(c, a, Nt, Rr);
    }
    function hk(a) {
      var c = zd();
      typeof a == "function" && (a = a()), c.memoizedState = c.baseState = a;
      var g = {
        pending: null,
        interleaved: null,
        lanes: Ue,
        dispatch: null,
        lastRenderedReducer: fL,
        lastRenderedState: a
      };
      c.queue = g;
      var b = g.dispatch = Fie.bind(null, yr, g);
      return [c.memoizedState, b];
    }
    function yL(a) {
      return gL(fL);
    }
    function SL(a) {
      return mL(fL);
    }
    function XC(a, c, g, b) {
      var C = {
        tag: a,
        create: c,
        destroy: g,
        deps: b,
        // Circular
        next: null
      }, I = yr.updateQueue;
      if (I === null)
        I = v4(), yr.updateQueue = I, I.lastEffect = C.next = C;
      else {
        var N = I.lastEffect;
        if (N === null)
          I.lastEffect = C.next = C;
        else {
          var H = N.next;
          N.next = C, C.next = H, I.lastEffect = C;
        }
      }
      return C;
    }
    function bL(a) {
      var c = zd();
      {
        var g = {
          current: a
        };
        return c.memoizedState = g, g;
      }
    }
    function fk(a) {
      var c = Vc();
      return c.memoizedState;
    }
    function qC(a, c, g, b) {
      var C = zd(), I = b === void 0 ? null : b;
      yr.flags |= a, C.memoizedState = XC(Ts | c, g, void 0, I);
    }
    function pk(a, c, g, b) {
      var C = Vc(), I = b === void 0 ? null : b, N = void 0;
      if (As !== null) {
        var H = As.memoizedState;
        if (N = H.destroy, I !== null) {
          var V = H.deps;
          if (hL(I, V)) {
            C.memoizedState = XC(c, g, N, I);
            return;
          }
        }
      }
      yr.flags |= a, C.memoizedState = XC(Ts | c, g, N, I);
    }
    function gk(a, c) {
      return (yr.mode & ka) !== Rt ? qC(Yh | qr | Pd, go, a, c) : qC(qr | Pd, go, a, c);
    }
    function ZC(a, c) {
      return pk(qr, go, a, c);
    }
    function xL(a, c) {
      return qC(pn, $d, a, c);
    }
    function mk(a, c) {
      return pk(pn, $d, a, c);
    }
    function wL(a, c) {
      var g = pn;
      return g |= Wo, (yr.mode & ka) !== Rt && (g |= Go), qC(g, Ps, a, c);
    }
    function vk(a, c) {
      return pk(pn, Ps, a, c);
    }
    function C4(a, c) {
      if (typeof c == "function") {
        var g = c, b = a();
        return g(b), function() {
          g(null);
        };
      } else if (c != null) {
        var C = c;
        C.hasOwnProperty("current") || o("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(C).join(", ") + "}");
        var I = a();
        return C.current = I, function() {
          C.current = null;
        };
      }
    }
    function CL(a, c, g) {
      typeof c != "function" && o("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", c !== null ? typeof c : "null");
      var b = g != null ? g.concat([a]) : null, C = pn;
      return C |= Wo, (yr.mode & ka) !== Rt && (C |= Go), qC(C, Ps, C4.bind(null, c, a), b);
    }
    function yk(a, c, g) {
      typeof c != "function" && o("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", c !== null ? typeof c : "null");
      var b = g != null ? g.concat([a]) : null;
      return pk(pn, Ps, C4.bind(null, c, a), b);
    }
    function Oie(a, c) {
    }
    var Sk = Oie;
    function EL(a, c) {
      var g = zd(), b = c === void 0 ? null : c;
      return g.memoizedState = [a, b], a;
    }
    function bk(a, c) {
      var g = Vc(), b = c === void 0 ? null : c, C = g.memoizedState;
      if (C !== null && b !== null) {
        var I = C[1];
        if (hL(b, I))
          return C[0];
      }
      return g.memoizedState = [a, b], a;
    }
    function _L(a, c) {
      var g = zd(), b = c === void 0 ? null : c, C = a();
      return g.memoizedState = [C, b], C;
    }
    function xk(a, c) {
      var g = Vc(), b = c === void 0 ? null : c, C = g.memoizedState;
      if (C !== null && b !== null) {
        var I = C[1];
        if (hL(b, I))
          return C[0];
      }
      var N = a();
      return g.memoizedState = [N, b], N;
    }
    function TL(a) {
      var c = zd();
      return c.memoizedState = a, a;
    }
    function E4(a) {
      var c = Vc(), g = As, b = g.memoizedState;
      return T4(c, b, a);
    }
    function _4(a) {
      var c = Vc();
      if (As === null)
        return c.memoizedState = a, a;
      var g = As.memoizedState;
      return T4(c, g, a);
    }
    function T4(a, c, g) {
      var b = !ZP(Ov);
      if (b) {
        if (!bt(g, c)) {
          var C = eA();
          yr.lanes = dn(yr.lanes, C), gE(C), a.baseState = !0;
        }
        return c;
      } else
        return a.baseState && (a.baseState = !1, rE()), a.memoizedState = g, g;
    }
    function Lie(a, c, g) {
      var b = ul();
      vi(GD(b, Tu)), a(!0);
      var C = GC.transition;
      GC.transition = {};
      var I = GC.transition;
      GC.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        a(!1), c();
      } finally {
        if (vi(b), GC.transition = C, C === null && I._updatedFibers) {
          var N = I._updatedFibers.size;
          N > 10 && s("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), I._updatedFibers.clear();
        }
      }
    }
    function PL() {
      var a = hk(!1), c = a[0], g = a[1], b = Lie.bind(null, g), C = zd();
      return C.memoizedState = b, [c, b];
    }
    function P4() {
      var a = yL(), c = a[0], g = Vc(), b = g.memoizedState;
      return [c, b];
    }
    function A4() {
      var a = SL(), c = a[0], g = Vc(), b = g.memoizedState;
      return [c, b];
    }
    var k4 = !1;
    function jie() {
      return k4;
    }
    function AL() {
      var a = zd(), c = Bk(), g = c.identifierPrefix, b;
      if (po()) {
        var C = Jre();
        b = ":" + g + "R" + C;
        var I = YC++;
        I > 0 && (b += "H" + I.toString(32)), b += ":";
      } else {
        var N = Rie++;
        b = ":" + g + "r" + N.toString(32) + ":";
      }
      return a.memoizedState = b, b;
    }
    function wk() {
      var a = Vc(), c = a.memoizedState;
      return c;
    }
    function Nie(a, c, g) {
      typeof arguments[3] == "function" && o("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var b = Mg(a), C = {
        lane: b,
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (I4(a))
        R4(c, C);
      else {
        var I = s4(a, c, C, b);
        if (I !== null) {
          var N = Da();
          Ds(I, a, b, N), M4(I, c, b);
        }
      }
      D4(a, b);
    }
    function Fie(a, c, g) {
      typeof arguments[3] == "function" && o("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var b = Mg(a), C = {
        lane: b,
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (I4(a))
        R4(c, C);
      else {
        var I = a.alternate;
        if (a.lanes === Ue && (I === null || I.lanes === Ue)) {
          var N = c.lastRenderedReducer;
          if (N !== null) {
            var H;
            H = ht.current, ht.current = Ou;
            try {
              var V = c.lastRenderedState, ee = N(V, g);
              if (C.hasEagerState = !0, C.eagerState = ee, bt(ee, V)) {
                wie(a, c, C, b);
                return;
              }
            } catch {
            } finally {
              ht.current = H;
            }
          }
        }
        var re = s4(a, c, C, b);
        if (re !== null) {
          var me = Da();
          Ds(re, a, b, me), M4(re, c, b);
        }
      }
      D4(a, b);
    }
    function I4(a) {
      var c = a.alternate;
      return a === yr || c !== null && c === yr;
    }
    function R4(a, c) {
      KC = uk = !0;
      var g = a.pending;
      g === null ? c.next = c : (c.next = g.next, g.next = c), a.pending = c;
    }
    function M4(a, c, g) {
      if (rC(g)) {
        var b = c.lanes;
        b = fb(b, a.pendingLanes);
        var C = dn(b, g);
        c.lanes = C, iC(a, C);
      }
    }
    function D4(a, c, g) {
      iv(a, c);
    }
    var Ck = {
      readContext: ms,
      useCallback: na,
      useContext: na,
      useEffect: na,
      useImperativeHandle: na,
      useInsertionEffect: na,
      useLayoutEffect: na,
      useMemo: na,
      useReducer: na,
      useRef: na,
      useState: na,
      useDebugValue: na,
      useDeferredValue: na,
      useTransition: na,
      useMutableSource: na,
      useSyncExternalStore: na,
      useId: na,
      unstable_isNewReconciler: ue
    }, O4 = null, L4 = null, j4 = null, N4 = null, Ud = null, Ou = null, Ek = null;
    {
      var kL = function() {
        o("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, an = function() {
        o("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      O4 = {
        readContext: function(a) {
          return ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", dr(), t0(c), EL(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", dr(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", dr(), t0(c), gk(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", dr(), t0(g), CL(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", dr(), t0(c), xL(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", dr(), t0(c), wL(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", dr(), t0(c);
          var g = ht.current;
          ht.current = Ud;
          try {
            return _L(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", dr();
          var b = ht.current;
          ht.current = Ud;
          try {
            return pL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", dr(), bL(a);
        },
        useState: function(a) {
          Ne = "useState", dr();
          var c = ht.current;
          ht.current = Ud;
          try {
            return hk(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", dr(), void 0;
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", dr(), TL(a);
        },
        useTransition: function() {
          return Ne = "useTransition", dr(), PL();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", dr(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", dr(), vL(a, c, g);
        },
        useId: function() {
          return Ne = "useId", dr(), AL();
        },
        unstable_isNewReconciler: ue
      }, L4 = {
        readContext: function(a) {
          return ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", it(), EL(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", it(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", it(), gk(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", it(), CL(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", it(), xL(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", it(), wL(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", it();
          var g = ht.current;
          ht.current = Ud;
          try {
            return _L(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", it();
          var b = ht.current;
          ht.current = Ud;
          try {
            return pL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", it(), bL(a);
        },
        useState: function(a) {
          Ne = "useState", it();
          var c = ht.current;
          ht.current = Ud;
          try {
            return hk(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", it(), void 0;
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", it(), TL(a);
        },
        useTransition: function() {
          return Ne = "useTransition", it(), PL();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", it(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", it(), vL(a, c, g);
        },
        useId: function() {
          return Ne = "useId", it(), AL();
        },
        unstable_isNewReconciler: ue
      }, j4 = {
        readContext: function(a) {
          return ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", it(), bk(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", it(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", it(), ZC(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", it(), yk(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", it(), mk(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", it(), vk(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", it();
          var g = ht.current;
          ht.current = Ou;
          try {
            return xk(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", it();
          var b = ht.current;
          ht.current = Ou;
          try {
            return gL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", it(), fk();
        },
        useState: function(a) {
          Ne = "useState", it();
          var c = ht.current;
          ht.current = Ou;
          try {
            return yL(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", it(), Sk();
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", it(), E4(a);
        },
        useTransition: function() {
          return Ne = "useTransition", it(), P4();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", it(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", it(), dk(a, c);
        },
        useId: function() {
          return Ne = "useId", it(), wk();
        },
        unstable_isNewReconciler: ue
      }, N4 = {
        readContext: function(a) {
          return ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", it(), bk(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", it(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", it(), ZC(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", it(), yk(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", it(), mk(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", it(), vk(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", it();
          var g = ht.current;
          ht.current = Ek;
          try {
            return xk(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", it();
          var b = ht.current;
          ht.current = Ek;
          try {
            return mL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", it(), fk();
        },
        useState: function(a) {
          Ne = "useState", it();
          var c = ht.current;
          ht.current = Ek;
          try {
            return SL(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", it(), Sk();
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", it(), _4(a);
        },
        useTransition: function() {
          return Ne = "useTransition", it(), A4();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", it(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", it(), dk(a, c);
        },
        useId: function() {
          return Ne = "useId", it(), wk();
        },
        unstable_isNewReconciler: ue
      }, Ud = {
        readContext: function(a) {
          return kL(), ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", an(), dr(), EL(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", an(), dr(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", an(), dr(), gk(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", an(), dr(), CL(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", an(), dr(), xL(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", an(), dr(), wL(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", an(), dr();
          var g = ht.current;
          ht.current = Ud;
          try {
            return _L(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", an(), dr();
          var b = ht.current;
          ht.current = Ud;
          try {
            return pL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", an(), dr(), bL(a);
        },
        useState: function(a) {
          Ne = "useState", an(), dr();
          var c = ht.current;
          ht.current = Ud;
          try {
            return hk(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", an(), dr(), void 0;
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", an(), dr(), TL(a);
        },
        useTransition: function() {
          return Ne = "useTransition", an(), dr(), PL();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", an(), dr(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", an(), dr(), vL(a, c, g);
        },
        useId: function() {
          return Ne = "useId", an(), dr(), AL();
        },
        unstable_isNewReconciler: ue
      }, Ou = {
        readContext: function(a) {
          return kL(), ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", an(), it(), bk(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", an(), it(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", an(), it(), ZC(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", an(), it(), yk(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", an(), it(), mk(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", an(), it(), vk(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", an(), it();
          var g = ht.current;
          ht.current = Ou;
          try {
            return xk(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", an(), it();
          var b = ht.current;
          ht.current = Ou;
          try {
            return gL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", an(), it(), fk();
        },
        useState: function(a) {
          Ne = "useState", an(), it();
          var c = ht.current;
          ht.current = Ou;
          try {
            return yL(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", an(), it(), Sk();
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", an(), it(), E4(a);
        },
        useTransition: function() {
          return Ne = "useTransition", an(), it(), P4();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", an(), it(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", an(), it(), dk(a, c);
        },
        useId: function() {
          return Ne = "useId", an(), it(), wk();
        },
        unstable_isNewReconciler: ue
      }, Ek = {
        readContext: function(a) {
          return kL(), ms(a);
        },
        useCallback: function(a, c) {
          return Ne = "useCallback", an(), it(), bk(a, c);
        },
        useContext: function(a) {
          return Ne = "useContext", an(), it(), ms(a);
        },
        useEffect: function(a, c) {
          return Ne = "useEffect", an(), it(), ZC(a, c);
        },
        useImperativeHandle: function(a, c, g) {
          return Ne = "useImperativeHandle", an(), it(), yk(a, c, g);
        },
        useInsertionEffect: function(a, c) {
          return Ne = "useInsertionEffect", an(), it(), mk(a, c);
        },
        useLayoutEffect: function(a, c) {
          return Ne = "useLayoutEffect", an(), it(), vk(a, c);
        },
        useMemo: function(a, c) {
          Ne = "useMemo", an(), it();
          var g = ht.current;
          ht.current = Ou;
          try {
            return xk(a, c);
          } finally {
            ht.current = g;
          }
        },
        useReducer: function(a, c, g) {
          Ne = "useReducer", an(), it();
          var b = ht.current;
          ht.current = Ou;
          try {
            return mL(a, c, g);
          } finally {
            ht.current = b;
          }
        },
        useRef: function(a) {
          return Ne = "useRef", an(), it(), fk();
        },
        useState: function(a) {
          Ne = "useState", an(), it();
          var c = ht.current;
          ht.current = Ou;
          try {
            return SL(a);
          } finally {
            ht.current = c;
          }
        },
        useDebugValue: function(a, c) {
          return Ne = "useDebugValue", an(), it(), Sk();
        },
        useDeferredValue: function(a) {
          return Ne = "useDeferredValue", an(), it(), _4(a);
        },
        useTransition: function() {
          return Ne = "useTransition", an(), it(), A4();
        },
        useMutableSource: function(a, c, g) {
          return Ne = "useMutableSource", an(), it(), void 0;
        },
        useSyncExternalStore: function(a, c, g) {
          return Ne = "useSyncExternalStore", an(), it(), dk(a, c);
        },
        useId: function() {
          return Ne = "useId", an(), it(), wk();
        },
        unstable_isNewReconciler: ue
      };
    }
    var Ag = t.unstable_now, F4 = 0, _k = -1, QC = -1, Tk = -1, IL = !1, Pk = !1;
    function $4() {
      return IL;
    }
    function $ie() {
      Pk = !0;
    }
    function zie() {
      IL = !1, Pk = !1;
    }
    function Uie() {
      IL = Pk, Pk = !1;
    }
    function z4() {
      return F4;
    }
    function U4() {
      F4 = Ag();
    }
    function RL(a) {
      QC = Ag(), a.actualStartTime < 0 && (a.actualStartTime = Ag());
    }
    function B4(a) {
      QC = -1;
    }
    function Ak(a, c) {
      if (QC >= 0) {
        var g = Ag() - QC;
        a.actualDuration += g, c && (a.selfBaseDuration = g), QC = -1;
      }
    }
    function Bd(a) {
      if (_k >= 0) {
        var c = Ag() - _k;
        _k = -1;
        for (var g = a.return; g !== null; ) {
          switch (g.tag) {
            case m:
              var b = g.stateNode;
              b.effectDuration += c;
              return;
            case j:
              var C = g.stateNode;
              C.effectDuration += c;
              return;
          }
          g = g.return;
        }
      }
    }
    function ML(a) {
      if (Tk >= 0) {
        var c = Ag() - Tk;
        Tk = -1;
        for (var g = a.return; g !== null; ) {
          switch (g.tag) {
            case m:
              var b = g.stateNode;
              b !== null && (b.passiveEffectDuration += c);
              return;
            case j:
              var C = g.stateNode;
              C !== null && (C.passiveEffectDuration += c);
              return;
          }
          g = g.return;
        }
      }
    }
    function Hd() {
      _k = Ag();
    }
    function DL() {
      Tk = Ag();
    }
    function OL(a) {
      for (var c = a.child; c; )
        a.actualDuration += c.actualDuration, c = c.sibling;
    }
    function Lu(a, c) {
      if (a && a.defaultProps) {
        var g = on({}, c), b = a.defaultProps;
        for (var C in b)
          g[C] === void 0 && (g[C] = b[C]);
        return g;
      }
      return c;
    }
    var LL = {}, jL, NL, FL, $L, zL, H4, kk, UL, BL, HL, JC;
    {
      jL = /* @__PURE__ */ new Set(), NL = /* @__PURE__ */ new Set(), FL = /* @__PURE__ */ new Set(), $L = /* @__PURE__ */ new Set(), UL = /* @__PURE__ */ new Set(), zL = /* @__PURE__ */ new Set(), BL = /* @__PURE__ */ new Set(), HL = /* @__PURE__ */ new Set(), JC = /* @__PURE__ */ new Set();
      var V4 = /* @__PURE__ */ new Set();
      kk = function(a, c) {
        if (!(a === null || typeof a == "function")) {
          var g = c + "_" + a;
          V4.has(g) || (V4.add(g), o("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", c, a));
        }
      }, H4 = function(a, c) {
        if (c === void 0) {
          var g = ln(a) || "Component";
          zL.has(g) || (zL.add(g), o("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", g));
        }
      }, Object.defineProperty(LL, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(LL);
    }
    function VL(a, c, g, b) {
      var C = a.memoizedState, I = g(b, C);
      {
        if (a.mode & Sn) {
          ji(!0);
          try {
            I = g(b, C);
          } finally {
            ji(!1);
          }
        }
        H4(c, I);
      }
      var N = I == null ? C : on({}, C, I);
      if (a.memoizedState = N, a.lanes === Ue) {
        var H = a.updateQueue;
        H.baseState = N;
      }
    }
    var WL = {
      isMounted: Pa,
      enqueueSetState: function(a, c, g) {
        var b = nl(a), C = Da(), I = Mg(b), N = vf(C, I);
        N.payload = c, g != null && (kk(g, "setState"), N.callback = g);
        var H = Eg(b, N, I);
        H !== null && (Ds(H, b, I, C), ik(H, b, I)), iv(b, I);
      },
      enqueueReplaceState: function(a, c, g) {
        var b = nl(a), C = Da(), I = Mg(b), N = vf(C, I);
        N.tag = a4, N.payload = c, g != null && (kk(g, "replaceState"), N.callback = g);
        var H = Eg(b, N, I);
        H !== null && (Ds(H, b, I, C), ik(H, b, I)), iv(b, I);
      },
      enqueueForceUpdate: function(a, c) {
        var g = nl(a), b = Da(), C = Mg(g), I = vf(b, C);
        I.tag = tk, c != null && (kk(c, "forceUpdate"), I.callback = c);
        var N = Eg(g, I, C);
        N !== null && (Ds(N, g, C, b), ik(N, g, C)), qS(g, C);
      }
    };
    function W4(a, c, g, b, C, I, N) {
      var H = a.stateNode;
      if (typeof H.shouldComponentUpdate == "function") {
        var V = H.shouldComponentUpdate(b, I, N);
        {
          if (a.mode & Sn) {
            ji(!0);
            try {
              V = H.shouldComponentUpdate(b, I, N);
            } finally {
              ji(!1);
            }
          }
          V === void 0 && o("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", ln(c) || "Component");
        }
        return V;
      }
      return c.prototype && c.prototype.isPureReactComponent ? !Xt(g, b) || !Xt(C, I) : !0;
    }
    function Bie(a, c, g) {
      var b = a.stateNode;
      {
        var C = ln(c) || "Component", I = b.render;
        I || (c.prototype && typeof c.prototype.render == "function" ? o("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", C) : o("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", C)), b.getInitialState && !b.getInitialState.isReactClassApproved && !b.state && o("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", C), b.getDefaultProps && !b.getDefaultProps.isReactClassApproved && o("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", C), b.propTypes && o("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", C), b.contextType && o("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", C), c.childContextTypes && !JC.has(c) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (a.mode & Sn) === Rt && (JC.add(c), o(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, C)), c.contextTypes && !JC.has(c) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (a.mode & Sn) === Rt && (JC.add(c), o(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, C)), b.contextTypes && o("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", C), c.contextType && c.contextTypes && !BL.has(c) && (BL.add(c), o("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", C)), typeof b.componentShouldUpdate == "function" && o("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", C), c.prototype && c.prototype.isPureReactComponent && typeof b.shouldComponentUpdate < "u" && o("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", ln(c) || "A pure component"), typeof b.componentDidUnmount == "function" && o("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", C), typeof b.componentDidReceiveProps == "function" && o("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", C), typeof b.componentWillRecieveProps == "function" && o("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", C), typeof b.UNSAFE_componentWillRecieveProps == "function" && o("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", C);
        var N = b.props !== g;
        b.props !== void 0 && N && o("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", C, C), b.defaultProps && o("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", C, C), typeof b.getSnapshotBeforeUpdate == "function" && typeof b.componentDidUpdate != "function" && !FL.has(c) && (FL.add(c), o("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", ln(c))), typeof b.getDerivedStateFromProps == "function" && o("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", C), typeof b.getDerivedStateFromError == "function" && o("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", C), typeof c.getSnapshotBeforeUpdate == "function" && o("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", C);
        var H = b.state;
        H && (typeof H != "object" || Pn(H)) && o("%s.state: must be set to an object or null", C), typeof b.getChildContext == "function" && typeof c.childContextTypes != "object" && o("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", C);
      }
    }
    function G4(a, c) {
      c.updater = WL, a.stateNode = c, Up(c, a), c._reactInternalInstance = LL;
    }
    function K4(a, c, g) {
      var b = !1, C = Zl, I = Zl, N = c.contextType;
      if ("contextType" in c) {
        var H = (
          // Allow null for conditional declaration
          N === null || N !== void 0 && N.$$typeof === Be && N._context === void 0
        );
        if (!H && !HL.has(c)) {
          HL.add(c);
          var V = "";
          N === void 0 ? V = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof N != "object" ? V = " However, it is set to a " + typeof N + "." : N.$$typeof === de ? V = " Did you accidentally pass the Context.Provider instead?" : N._context !== void 0 ? V = " Did you accidentally pass the Context.Consumer instead?" : V = " However, it is set to an object with keys {" + Object.keys(N).join(", ") + "}.", o("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", ln(c) || "Component", V);
        }
      }
      if (typeof N == "object" && N !== null)
        I = ms(N);
      else {
        C = Hb(a, c, !0);
        var ee = c.contextTypes;
        b = ee != null, I = b ? Vb(a, C) : Zl;
      }
      var re = new c(g, I);
      if (a.mode & Sn) {
        ji(!0);
        try {
          re = new c(g, I);
        } finally {
          ji(!1);
        }
      }
      var me = a.memoizedState = re.state !== null && re.state !== void 0 ? re.state : null;
      G4(a, re);
      {
        if (typeof c.getDerivedStateFromProps == "function" && me === null) {
          var pe = ln(c) || "Component";
          NL.has(pe) || (NL.add(pe), o("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", pe, re.state === null ? "null" : "undefined", pe));
        }
        if (typeof c.getDerivedStateFromProps == "function" || typeof re.getSnapshotBeforeUpdate == "function") {
          var Ae = null, Re = null, Oe = null;
          if (typeof re.componentWillMount == "function" && re.componentWillMount.__suppressDeprecationWarning !== !0 ? Ae = "componentWillMount" : typeof re.UNSAFE_componentWillMount == "function" && (Ae = "UNSAFE_componentWillMount"), typeof re.componentWillReceiveProps == "function" && re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Re = "componentWillReceiveProps" : typeof re.UNSAFE_componentWillReceiveProps == "function" && (Re = "UNSAFE_componentWillReceiveProps"), typeof re.componentWillUpdate == "function" && re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Oe = "componentWillUpdate" : typeof re.UNSAFE_componentWillUpdate == "function" && (Oe = "UNSAFE_componentWillUpdate"), Ae !== null || Re !== null || Oe !== null) {
            var ot = ln(c) || "Component", Ht = typeof c.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            $L.has(ot) || ($L.add(ot), o(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ot, Ht, Ae !== null ? `
  ` + Ae : "", Re !== null ? `
  ` + Re : "", Oe !== null ? `
  ` + Oe : ""));
          }
        }
      }
      return b && jB(a, C, I), re;
    }
    function Hie(a, c) {
      var g = c.state;
      typeof c.componentWillMount == "function" && c.componentWillMount(), typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), g !== c.state && (o("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", tn(a) || "Component"), WL.enqueueReplaceState(c, c.state, null));
    }
    function Y4(a, c, g, b) {
      var C = c.state;
      if (typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(g, b), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(g, b), c.state !== C) {
        {
          var I = tn(a) || "Component";
          jL.has(I) || (jL.add(I), o("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", I));
        }
        WL.enqueueReplaceState(c, c.state, null);
      }
    }
    function GL(a, c, g, b) {
      Bie(a, c, g);
      var C = a.stateNode;
      C.props = g, C.state = a.memoizedState, C.refs = {}, tL(a);
      var I = c.contextType;
      if (typeof I == "object" && I !== null)
        C.context = ms(I);
      else {
        var N = Hb(a, c, !0);
        C.context = Vb(a, N);
      }
      {
        if (C.state === g) {
          var H = ln(c) || "Component";
          UL.has(H) || (UL.add(H), o("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", H));
        }
        a.mode & Sn && Mu.recordLegacyContextWarning(a, C), Mu.recordUnsafeLifecycleWarnings(a, C);
      }
      C.state = a.memoizedState;
      var V = c.getDerivedStateFromProps;
      if (typeof V == "function" && (VL(a, c, V, g), C.state = a.memoizedState), typeof c.getDerivedStateFromProps != "function" && typeof C.getSnapshotBeforeUpdate != "function" && (typeof C.UNSAFE_componentWillMount == "function" || typeof C.componentWillMount == "function") && (Hie(a, C), sk(a, g, C, b), C.state = a.memoizedState), typeof C.componentDidMount == "function") {
        var ee = pn;
        ee |= Wo, (a.mode & ka) !== Rt && (ee |= Go), a.flags |= ee;
      }
    }
    function Vie(a, c, g, b) {
      var C = a.stateNode, I = a.memoizedProps;
      C.props = I;
      var N = C.context, H = c.contextType, V = Zl;
      if (typeof H == "object" && H !== null)
        V = ms(H);
      else {
        var ee = Hb(a, c, !0);
        V = Vb(a, ee);
      }
      var re = c.getDerivedStateFromProps, me = typeof re == "function" || typeof C.getSnapshotBeforeUpdate == "function";
      !me && (typeof C.UNSAFE_componentWillReceiveProps == "function" || typeof C.componentWillReceiveProps == "function") && (I !== g || N !== V) && Y4(a, C, g, V), c4();
      var pe = a.memoizedState, Ae = C.state = pe;
      if (sk(a, g, C, b), Ae = a.memoizedState, I === g && pe === Ae && !zA() && !ok()) {
        if (typeof C.componentDidMount == "function") {
          var Re = pn;
          Re |= Wo, (a.mode & ka) !== Rt && (Re |= Go), a.flags |= Re;
        }
        return !1;
      }
      typeof re == "function" && (VL(a, c, re, g), Ae = a.memoizedState);
      var Oe = ok() || W4(a, c, I, g, pe, Ae, V);
      if (Oe) {
        if (!me && (typeof C.UNSAFE_componentWillMount == "function" || typeof C.componentWillMount == "function") && (typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount()), typeof C.componentDidMount == "function") {
          var ot = pn;
          ot |= Wo, (a.mode & ka) !== Rt && (ot |= Go), a.flags |= ot;
        }
      } else {
        if (typeof C.componentDidMount == "function") {
          var Ht = pn;
          Ht |= Wo, (a.mode & ka) !== Rt && (Ht |= Go), a.flags |= Ht;
        }
        a.memoizedProps = g, a.memoizedState = Ae;
      }
      return C.props = g, C.state = Ae, C.context = V, Oe;
    }
    function Wie(a, c, g, b, C) {
      var I = c.stateNode;
      l4(a, c);
      var N = c.memoizedProps, H = c.type === c.elementType ? N : Lu(c.type, N);
      I.props = H;
      var V = c.pendingProps, ee = I.context, re = g.contextType, me = Zl;
      if (typeof re == "object" && re !== null)
        me = ms(re);
      else {
        var pe = Hb(c, g, !0);
        me = Vb(c, pe);
      }
      var Ae = g.getDerivedStateFromProps, Re = typeof Ae == "function" || typeof I.getSnapshotBeforeUpdate == "function";
      !Re && (typeof I.UNSAFE_componentWillReceiveProps == "function" || typeof I.componentWillReceiveProps == "function") && (N !== V || ee !== me) && Y4(c, I, b, me), c4();
      var Oe = c.memoizedState, ot = I.state = Oe;
      if (sk(c, b, I, C), ot = c.memoizedState, N === V && Oe === ot && !zA() && !ok() && !Se)
        return typeof I.componentDidUpdate == "function" && (N !== a.memoizedProps || Oe !== a.memoizedState) && (c.flags |= pn), typeof I.getSnapshotBeforeUpdate == "function" && (N !== a.memoizedProps || Oe !== a.memoizedState) && (c.flags |= rl), !1;
      typeof Ae == "function" && (VL(c, g, Ae, b), ot = c.memoizedState);
      var Ht = ok() || W4(c, g, H, b, Oe, ot, me) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Se;
      return Ht ? (!Re && (typeof I.UNSAFE_componentWillUpdate == "function" || typeof I.componentWillUpdate == "function") && (typeof I.componentWillUpdate == "function" && I.componentWillUpdate(b, ot, me), typeof I.UNSAFE_componentWillUpdate == "function" && I.UNSAFE_componentWillUpdate(b, ot, me)), typeof I.componentDidUpdate == "function" && (c.flags |= pn), typeof I.getSnapshotBeforeUpdate == "function" && (c.flags |= rl)) : (typeof I.componentDidUpdate == "function" && (N !== a.memoizedProps || Oe !== a.memoizedState) && (c.flags |= pn), typeof I.getSnapshotBeforeUpdate == "function" && (N !== a.memoizedProps || Oe !== a.memoizedState) && (c.flags |= rl), c.memoizedProps = b, c.memoizedState = ot), I.props = b, I.state = ot, I.context = me, Ht;
    }
    function Lv(a, c) {
      return {
        value: a,
        source: c,
        stack: Ca(c),
        digest: null
      };
    }
    function KL(a, c, g) {
      return {
        value: a,
        source: null,
        stack: g ?? null,
        digest: c ?? null
      };
    }
    function Gie(a, c) {
      return !0;
    }
    function YL(a, c) {
      try {
        var g = Gie(a, c);
        if (g === !1)
          return;
        var b = c.value, C = c.source, I = c.stack, N = I !== null ? I : "";
        if (b != null && b._suppressLogging) {
          if (a.tag === d)
            return;
          console.error(b);
        }
        var H = C ? tn(C) : null, V = H ? "The above error occurred in the <" + H + "> component:" : "The above error occurred in one of your React components:", ee;
        if (a.tag === m)
          ee = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var re = tn(a) || "Anonymous";
          ee = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + re + ".");
        }
        var me = V + `
` + N + `

` + ("" + ee);
        console.error(me);
      } catch (pe) {
        setTimeout(function() {
          throw pe;
        });
      }
    }
    var Kie = typeof WeakMap == "function" ? WeakMap : Map;
    function X4(a, c, g) {
      var b = vf(Rr, g);
      b.tag = JO, b.payload = {
        element: null
      };
      var C = c.value;
      return b.callback = function() {
        $oe(C), YL(a, c);
      }, b;
    }
    function XL(a, c, g) {
      var b = vf(Rr, g);
      b.tag = JO;
      var C = a.type.getDerivedStateFromError;
      if (typeof C == "function") {
        var I = c.value;
        b.payload = function() {
          return C(I);
        }, b.callback = function() {
          oH(a), YL(a, c);
        };
      }
      var N = a.stateNode;
      return N !== null && typeof N.componentDidCatch == "function" && (b.callback = function() {
        oH(a), YL(a, c), typeof C != "function" && Noe(this);
        var V = c.value, ee = c.stack;
        this.componentDidCatch(V, {
          componentStack: ee !== null ? ee : ""
        }), typeof C != "function" && (Qo(a.lanes, Nt) || o("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", tn(a) || "Unknown"));
      }), b;
    }
    function q4(a, c, g) {
      var b = a.pingCache, C;
      if (b === null ? (b = a.pingCache = new Kie(), C = /* @__PURE__ */ new Set(), b.set(c, C)) : (C = b.get(c), C === void 0 && (C = /* @__PURE__ */ new Set(), b.set(c, C))), !C.has(g)) {
        C.add(g);
        var I = zoe.bind(null, a, c, g);
        Aa && mE(a, g), c.then(I, I);
      }
    }
    function Yie(a, c, g, b) {
      var C = a.updateQueue;
      if (C === null) {
        var I = /* @__PURE__ */ new Set();
        I.add(g), a.updateQueue = I;
      } else
        C.add(g);
    }
    function Xie(a, c) {
      var g = a.tag;
      if ((a.mode & Ot) === Rt && (g === u || g === M || g === F)) {
        var b = a.alternate;
        b ? (a.updateQueue = b.updateQueue, a.memoizedState = b.memoizedState, a.lanes = b.lanes) : (a.updateQueue = null, a.memoizedState = null);
      }
    }
    function Z4(a) {
      var c = a;
      do {
        if (c.tag === $ && kie(c))
          return c;
        c = c.return;
      } while (c !== null);
      return null;
    }
    function Q4(a, c, g, b, C) {
      if ((a.mode & Ot) === Rt) {
        if (a === c)
          a.flags |= hs;
        else {
          if (a.flags |= nn, g.flags |= tv, g.flags &= ~(FS | _a), g.tag === d) {
            var I = g.alternate;
            if (I === null)
              g.tag = G;
            else {
              var N = vf(Rr, Nt);
              N.tag = tk, Eg(g, N, Nt);
            }
          }
          g.lanes = dn(g.lanes, Nt);
        }
        return a;
      }
      return a.flags |= hs, a.lanes = C, a;
    }
    function qie(a, c, g, b, C) {
      if (g.flags |= _a, Aa && mE(a, C), b !== null && typeof b == "object" && typeof b.then == "function") {
        var I = b;
        Xie(g), po() && g.mode & Ot && HB();
        var N = Z4(c);
        if (N !== null) {
          N.flags &= ~mi, Q4(N, c, g, a, C), N.mode & Ot && q4(a, I, C), Yie(N, a, I);
          return;
        } else {
          if (!nC(C)) {
            q4(a, I, C), Aj();
            return;
          }
          var H = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          b = H;
        }
      } else if (po() && g.mode & Ot) {
        HB();
        var V = Z4(c);
        if (V !== null) {
          (V.flags & hs) === zt && (V.flags |= mi), Q4(V, c, g, a, C), UO(Lv(b, g));
          return;
        }
      }
      b = Lv(b, g), koe(b);
      var ee = c;
      do {
        switch (ee.tag) {
          case m: {
            var re = b;
            ee.flags |= hs;
            var me = tg(C);
            ee.lanes = dn(ee.lanes, me);
            var pe = X4(ee, re, me);
            nL(ee, pe);
            return;
          }
          case d:
            var Ae = b, Re = ee.type, Oe = ee.stateNode;
            if ((ee.flags & nn) === zt && (typeof Re.getDerivedStateFromError == "function" || Oe !== null && typeof Oe.componentDidCatch == "function" && !Z6(Oe))) {
              ee.flags |= hs;
              var ot = tg(C);
              ee.lanes = dn(ee.lanes, ot);
              var Ht = XL(ee, Ae, ot);
              nL(ee, Ht);
              return;
            }
            break;
        }
        ee = ee.return;
      } while (ee !== null);
    }
    function Zie() {
      return null;
    }
    var eE = e.ReactCurrentOwner, ju = !1, qL, tE, ZL, QL, JL, jv, ej, Ik, nE;
    qL = {}, tE = {}, ZL = {}, QL = {}, JL = {}, jv = !1, ej = {}, Ik = {}, nE = {};
    function Ra(a, c, g, b) {
      a === null ? c.child = t4(c, null, g, b) : c.child = Yb(c, a.child, g, b);
    }
    function Qie(a, c, g, b) {
      c.child = Yb(c, a.child, null, b), c.child = Yb(c, null, g, b);
    }
    function J4(a, c, g, b, C) {
      if (c.type !== c.elementType) {
        var I = g.propTypes;
        I && Iu(
          I,
          b,
          // Resolved props
          "prop",
          ln(g)
        );
      }
      var N = g.render, H = c.ref, V, ee;
      qb(c, C), Wp(c);
      {
        if (eE.current = c, Bs(!0), V = n0(a, c, N, b, H, C), ee = r0(), c.mode & Sn) {
          ji(!0);
          try {
            V = n0(a, c, N, b, H, C), ee = r0();
          } finally {
            ji(!1);
          }
        }
        Bs(!1);
      }
      return Xo(), a !== null && !ju ? (g4(a, c, C), yf(a, c, C)) : (po() && ee && LO(c), c.flags |= _d, Ra(a, c, V, C), c.child);
    }
    function e6(a, c, g, b, C) {
      if (a === null) {
        var I = g.type;
        if (rae(I) && g.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        g.defaultProps === void 0) {
          var N = I;
          return N = d0(I), c.tag = F, c.type = N, rj(c, I), t6(a, c, N, b, C);
        }
        {
          var H = I.propTypes;
          if (H && Iu(
            H,
            b,
            // Resolved props
            "prop",
            ln(I)
          ), g.defaultProps !== void 0) {
            var V = ln(I) || "Unknown";
            nE[V] || (o("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", V), nE[V] = !0);
          }
        }
        var ee = $j(g.type, null, b, c, c.mode, C);
        return ee.ref = c.ref, ee.return = c, c.child = ee, ee;
      }
      {
        var re = g.type, me = re.propTypes;
        me && Iu(
          me,
          b,
          // Resolved props
          "prop",
          ln(re)
        );
      }
      var pe = a.child, Ae = cj(a, C);
      if (!Ae) {
        var Re = pe.memoizedProps, Oe = g.compare;
        if (Oe = Oe !== null ? Oe : Xt, Oe(Re, b) && a.ref === c.ref)
          return yf(a, c, C);
      }
      c.flags |= _d;
      var ot = Uv(pe, b);
      return ot.ref = c.ref, ot.return = c, c.child = ot, ot;
    }
    function t6(a, c, g, b, C) {
      if (c.type !== c.elementType) {
        var I = c.elementType;
        if (I.$$typeof === Bt) {
          var N = I, H = N._payload, V = N._init;
          try {
            I = V(H);
          } catch {
            I = null;
          }
          var ee = I && I.propTypes;
          ee && Iu(
            ee,
            b,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            ln(I)
          );
        }
      }
      if (a !== null) {
        var re = a.memoizedProps;
        if (Xt(re, b) && a.ref === c.ref && // Prevent bailout if the implementation changed due to hot reload.
        c.type === a.type)
          if (ju = !1, c.pendingProps = b = re, cj(a, C))
            (a.flags & tv) !== zt && (ju = !0);
          else return c.lanes = a.lanes, yf(a, c, C);
      }
      return tj(a, c, g, b, C);
    }
    function n6(a, c, g) {
      var b = c.pendingProps, C = b.children, I = a !== null ? a.memoizedState : null;
      if (b.mode === "hidden" || ke)
        if ((c.mode & Ot) === Rt) {
          var N = {
            baseLanes: Ue,
            cachePool: null,
            transitions: null
          };
          c.memoizedState = N, Hk(c, g);
        } else if (Qo(g, Ws)) {
          var me = {
            baseLanes: Ue,
            cachePool: null,
            transitions: null
          };
          c.memoizedState = me;
          var pe = I !== null ? I.baseLanes : g;
          Hk(c, pe);
        } else {
          var H = null, V;
          if (I !== null) {
            var ee = I.baseLanes;
            V = dn(ee, g);
          } else
            V = g;
          c.lanes = c.childLanes = Ws;
          var re = {
            baseLanes: V,
            cachePool: H,
            transitions: null
          };
          return c.memoizedState = re, c.updateQueue = null, Hk(c, V), null;
        }
      else {
        var Ae;
        I !== null ? (Ae = dn(I.baseLanes, g), c.memoizedState = null) : Ae = g, Hk(c, Ae);
      }
      return Ra(a, c, C, g), c.child;
    }
    function Jie(a, c, g) {
      var b = c.pendingProps;
      return Ra(a, c, b, g), c.child;
    }
    function ese(a, c, g) {
      var b = c.pendingProps.children;
      return Ra(a, c, b, g), c.child;
    }
    function tse(a, c, g) {
      {
        c.flags |= pn;
        {
          var b = c.stateNode;
          b.effectDuration = 0, b.passiveEffectDuration = 0;
        }
      }
      var C = c.pendingProps, I = C.children;
      return Ra(a, c, I, g), c.child;
    }
    function r6(a, c) {
      var g = c.ref;
      (a === null && g !== null || a !== null && a.ref !== g) && (c.flags |= Vo, c.flags |= Hw);
    }
    function tj(a, c, g, b, C) {
      if (c.type !== c.elementType) {
        var I = g.propTypes;
        I && Iu(
          I,
          b,
          // Resolved props
          "prop",
          ln(g)
        );
      }
      var N;
      {
        var H = Hb(c, g, !0);
        N = Vb(c, H);
      }
      var V, ee;
      qb(c, C), Wp(c);
      {
        if (eE.current = c, Bs(!0), V = n0(a, c, g, b, N, C), ee = r0(), c.mode & Sn) {
          ji(!0);
          try {
            V = n0(a, c, g, b, N, C), ee = r0();
          } finally {
            ji(!1);
          }
        }
        Bs(!1);
      }
      return Xo(), a !== null && !ju ? (g4(a, c, C), yf(a, c, C)) : (po() && ee && LO(c), c.flags |= _d, Ra(a, c, V, C), c.child);
    }
    function i6(a, c, g, b, C) {
      {
        switch (yae(c)) {
          case !1: {
            var I = c.stateNode, N = c.type, H = new N(c.memoizedProps, I.context), V = H.state;
            I.updater.enqueueSetState(I, V, null);
            break;
          }
          case !0: {
            c.flags |= nn, c.flags |= hs;
            var ee = new Error("Simulated error coming from DevTools"), re = tg(C);
            c.lanes = dn(c.lanes, re);
            var me = XL(c, Lv(ee, c), re);
            nL(c, me);
            break;
          }
        }
        if (c.type !== c.elementType) {
          var pe = g.propTypes;
          pe && Iu(
            pe,
            b,
            // Resolved props
            "prop",
            ln(g)
          );
        }
      }
      var Ae;
      Fd(g) ? (Ae = !0, BA(c)) : Ae = !1, qb(c, C);
      var Re = c.stateNode, Oe;
      Re === null ? (Mk(a, c), K4(c, g, b), GL(c, g, b, C), Oe = !0) : a === null ? Oe = Vie(c, g, b, C) : Oe = Wie(a, c, g, b, C);
      var ot = nj(a, c, g, Oe, Ae, C);
      {
        var Ht = c.stateNode;
        Oe && Ht.props !== b && (jv || o("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", tn(c) || "a component"), jv = !0);
      }
      return ot;
    }
    function nj(a, c, g, b, C, I) {
      r6(a, c);
      var N = (c.flags & nn) !== zt;
      if (!b && !N)
        return C && $B(c, g, !1), yf(a, c, I);
      var H = c.stateNode;
      eE.current = c;
      var V;
      if (N && typeof g.getDerivedStateFromError != "function")
        V = null, B4();
      else {
        Wp(c);
        {
          if (Bs(!0), V = H.render(), c.mode & Sn) {
            ji(!0);
            try {
              H.render();
            } finally {
              ji(!1);
            }
          }
          Bs(!1);
        }
        Xo();
      }
      return c.flags |= _d, a !== null && N ? Qie(a, c, V, I) : Ra(a, c, V, I), c.memoizedState = H.state, C && $B(c, g, !0), c.child;
    }
    function s6(a) {
      var c = a.stateNode;
      c.pendingContext ? NB(a, c.pendingContext, c.pendingContext !== c.context) : c.context && NB(a, c.context, !1), rL(a, c.containerInfo);
    }
    function nse(a, c, g) {
      if (s6(c), a === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var b = c.pendingProps, C = c.memoizedState, I = C.element;
      l4(a, c), sk(c, b, null, g);
      var N = c.memoizedState;
      c.stateNode;
      var H = N.element;
      if (C.isDehydrated) {
        var V = {
          element: H,
          isDehydrated: !1,
          cache: N.cache,
          pendingSuspenseBoundaries: N.pendingSuspenseBoundaries,
          transitions: N.transitions
        }, ee = c.updateQueue;
        if (ee.baseState = V, c.memoizedState = V, c.flags & mi) {
          var re = Lv(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), c);
          return o6(a, c, H, g, re);
        } else if (H !== I) {
          var me = Lv(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), c);
          return o6(a, c, H, g, me);
        } else {
          sie(c);
          var pe = t4(c, null, H, g);
          c.child = pe;
          for (var Ae = pe; Ae; )
            Ae.flags = Ae.flags & ~$r | il, Ae = Ae.sibling;
        }
      } else {
        if (Kb(), H === I)
          return yf(a, c, g);
        Ra(a, c, H, g);
      }
      return c.child;
    }
    function o6(a, c, g, b, C) {
      return Kb(), UO(C), c.flags |= mi, Ra(a, c, g, b), c.child;
    }
    function rse(a, c, g) {
      h4(c), a === null && zO(c);
      var b = c.type, C = c.pendingProps, I = a !== null ? a.memoizedProps : null, N = C.children, H = xO(b, C);
      return H ? N = null : I !== null && xO(b, I) && (c.flags |= ur), r6(a, c), Ra(a, c, N, g), c.child;
    }
    function ise(a, c) {
      return a === null && zO(c), null;
    }
    function sse(a, c, g, b) {
      Mk(a, c);
      var C = c.pendingProps, I = g, N = I._payload, H = I._init, V = H(N);
      c.type = V;
      var ee = c.tag = iae(V), re = Lu(V, C), me;
      switch (ee) {
        case u:
          return rj(c, V), c.type = V = d0(V), me = tj(null, c, V, re, b), me;
        case d:
          return c.type = V = Dj(V), me = i6(null, c, V, re, b), me;
        case M:
          return c.type = V = Oj(V), me = J4(null, c, V, re, b), me;
        case U: {
          if (c.type !== c.elementType) {
            var pe = V.propTypes;
            pe && Iu(
              pe,
              re,
              // Resolved for outer only
              "prop",
              ln(V)
            );
          }
          return me = e6(
            null,
            c,
            V,
            Lu(V.type, re),
            // The inner type can have defaults too
            b
          ), me;
        }
      }
      var Ae = "";
      throw V !== null && typeof V == "object" && V.$$typeof === Bt && (Ae = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + V + ". " + ("Lazy element type must resolve to a class or function." + Ae));
    }
    function ose(a, c, g, b, C) {
      Mk(a, c), c.tag = d;
      var I;
      return Fd(g) ? (I = !0, BA(c)) : I = !1, qb(c, C), K4(c, g, b), GL(c, g, b, C), nj(null, c, g, !0, I, C);
    }
    function ase(a, c, g, b) {
      Mk(a, c);
      var C = c.pendingProps, I;
      {
        var N = Hb(c, g, !1);
        I = Vb(c, N);
      }
      qb(c, b);
      var H, V;
      Wp(c);
      {
        if (g.prototype && typeof g.prototype.render == "function") {
          var ee = ln(g) || "Unknown";
          qL[ee] || (o("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ee, ee), qL[ee] = !0);
        }
        c.mode & Sn && Mu.recordLegacyContextWarning(c, null), Bs(!0), eE.current = c, H = n0(null, c, g, C, I, b), V = r0(), Bs(!1);
      }
      if (Xo(), c.flags |= _d, typeof H == "object" && H !== null && typeof H.render == "function" && H.$$typeof === void 0) {
        var re = ln(g) || "Unknown";
        tE[re] || (o("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", re, re, re), tE[re] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof H == "object" && H !== null && typeof H.render == "function" && H.$$typeof === void 0
      ) {
        {
          var me = ln(g) || "Unknown";
          tE[me] || (o("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", me, me, me), tE[me] = !0);
        }
        c.tag = d, c.memoizedState = null, c.updateQueue = null;
        var pe = !1;
        return Fd(g) ? (pe = !0, BA(c)) : pe = !1, c.memoizedState = H.state !== null && H.state !== void 0 ? H.state : null, tL(c), G4(c, H), GL(c, g, C, b), nj(null, c, g, !0, pe, b);
      } else {
        if (c.tag = u, c.mode & Sn) {
          ji(!0);
          try {
            H = n0(null, c, g, C, I, b), V = r0();
          } finally {
            ji(!1);
          }
        }
        return po() && V && LO(c), Ra(null, c, H, b), rj(c, g), c.child;
      }
    }
    function rj(a, c) {
      {
        if (c && c.childContextTypes && o("%s(...): childContextTypes cannot be defined on a function component.", c.displayName || c.name || "Component"), a.ref !== null) {
          var g = "", b = us();
          b && (g += `

Check the render method of \`` + b + "`.");
          var C = b || "", I = a._debugSource;
          I && (C = I.fileName + ":" + I.lineNumber), JL[C] || (JL[C] = !0, o("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", g));
        }
        if (c.defaultProps !== void 0) {
          var N = ln(c) || "Unknown";
          nE[N] || (o("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", N), nE[N] = !0);
        }
        if (typeof c.getDerivedStateFromProps == "function") {
          var H = ln(c) || "Unknown";
          QL[H] || (o("%s: Function components do not support getDerivedStateFromProps.", H), QL[H] = !0);
        }
        if (typeof c.contextType == "object" && c.contextType !== null) {
          var V = ln(c) || "Unknown";
          ZL[V] || (o("%s: Function components do not support contextType.", V), ZL[V] = !0);
        }
      }
    }
    var ij = {
      dehydrated: null,
      treeContext: null,
      retryLane: Ni
    };
    function sj(a) {
      return {
        baseLanes: a,
        cachePool: Zie(),
        transitions: null
      };
    }
    function lse(a, c) {
      var g = null;
      return {
        baseLanes: dn(a.baseLanes, c),
        cachePool: g,
        transitions: a.transitions
      };
    }
    function cse(a, c, g, b) {
      if (c !== null) {
        var C = c.memoizedState;
        if (C === null)
          return !1;
      }
      return oL(a, WC);
    }
    function use(a, c) {
      return dv(a.childLanes, c);
    }
    function a6(a, c, g) {
      var b = c.pendingProps;
      Sae(c) && (c.flags |= nn);
      var C = Du.current, I = !1, N = (c.flags & nn) !== zt;
      if (N || cse(C, a) ? (I = !0, c.flags &= ~nn) : (a === null || a.memoizedState !== null) && (C = Aie(C, p4)), C = Qb(C), Tg(c, C), a === null) {
        zO(c);
        var H = c.memoizedState;
        if (H !== null) {
          var V = H.dehydrated;
          if (V !== null)
            return gse(c, V);
        }
        var ee = b.children, re = b.fallback;
        if (I) {
          var me = dse(c, ee, re, g), pe = c.child;
          return pe.memoizedState = sj(g), c.memoizedState = ij, me;
        } else
          return oj(c, ee);
      } else {
        var Ae = a.memoizedState;
        if (Ae !== null) {
          var Re = Ae.dehydrated;
          if (Re !== null)
            return mse(a, c, N, b, Re, Ae, g);
        }
        if (I) {
          var Oe = b.fallback, ot = b.children, Ht = fse(a, c, ot, Oe, g), Lt = c.child, Nn = a.child.memoizedState;
          return Lt.memoizedState = Nn === null ? sj(g) : lse(Nn, g), Lt.childLanes = use(a, g), c.memoizedState = ij, Ht;
        } else {
          var Tn = b.children, Ee = hse(a, c, Tn, g);
          return c.memoizedState = null, Ee;
        }
      }
    }
    function oj(a, c, g) {
      var b = a.mode, C = {
        mode: "visible",
        children: c
      }, I = aj(C, b);
      return I.return = a, a.child = I, I;
    }
    function dse(a, c, g, b) {
      var C = a.mode, I = a.child, N = {
        mode: "hidden",
        children: c
      }, H, V;
      return (C & Ot) === Rt && I !== null ? (H = I, H.childLanes = Ue, H.pendingProps = N, a.mode & rn && (H.actualDuration = 0, H.actualStartTime = -1, H.selfBaseDuration = 0, H.treeBaseDuration = 0), V = Og(g, C, b, null)) : (H = aj(N, C), V = Og(g, C, b, null)), H.return = a, V.return = a, H.sibling = V, a.child = H, V;
    }
    function aj(a, c, g) {
      return lH(a, c, Ue, null);
    }
    function l6(a, c) {
      return Uv(a, c);
    }
    function hse(a, c, g, b) {
      var C = a.child, I = C.sibling, N = l6(C, {
        mode: "visible",
        children: g
      });
      if ((c.mode & Ot) === Rt && (N.lanes = b), N.return = c, N.sibling = null, I !== null) {
        var H = c.deletions;
        H === null ? (c.deletions = [I], c.flags |= or) : H.push(I);
      }
      return c.child = N, N;
    }
    function fse(a, c, g, b, C) {
      var I = c.mode, N = a.child, H = N.sibling, V = {
        mode: "hidden",
        children: g
      }, ee;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (I & Ot) === Rt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        c.child !== N
      ) {
        var re = c.child;
        ee = re, ee.childLanes = Ue, ee.pendingProps = V, c.mode & rn && (ee.actualDuration = 0, ee.actualStartTime = -1, ee.selfBaseDuration = N.selfBaseDuration, ee.treeBaseDuration = N.treeBaseDuration), c.deletions = null;
      } else
        ee = l6(N, V), ee.subtreeFlags = N.subtreeFlags & Cs;
      var me;
      return H !== null ? me = Uv(H, b) : (me = Og(b, I, C, null), me.flags |= $r), me.return = c, ee.return = c, ee.sibling = me, c.child = ee, me;
    }
    function Rk(a, c, g, b) {
      b !== null && UO(b), Yb(c, a.child, null, g);
      var C = c.pendingProps, I = C.children, N = oj(c, I);
      return N.flags |= $r, c.memoizedState = null, N;
    }
    function pse(a, c, g, b, C) {
      var I = c.mode, N = {
        mode: "visible",
        children: g
      }, H = aj(N, I), V = Og(b, I, C, null);
      return V.flags |= $r, H.return = c, V.return = c, H.sibling = V, c.child = H, (c.mode & Ot) !== Rt && Yb(c, a.child, null, C), V;
    }
    function gse(a, c, g) {
      return (a.mode & Ot) === Rt ? (o("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), a.lanes = Nt) : _O(c) ? a.lanes = _u : a.lanes = Ws, null;
    }
    function mse(a, c, g, b, C, I, N) {
      if (g)
        if (c.flags & mi) {
          c.flags &= ~mi;
          var Ee = KL(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Rk(a, c, N, Ee);
        } else {
          if (c.memoizedState !== null)
            return c.child = a.child, c.flags |= nn, null;
          var Le = b.children, _e = b.fallback, Ye = pse(a, c, Le, _e, N), ft = c.child;
          return ft.memoizedState = sj(N), c.memoizedState = ij, Ye;
        }
      else {
        if (rie(), (c.mode & Ot) === Rt)
          return Rk(
            a,
            c,
            N,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (_O(C)) {
          var H, V, ee;
          {
            var re = bre(C);
            H = re.digest, V = re.message, ee = re.stack;
          }
          var me;
          V ? me = new Error(V) : me = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var pe = KL(me, H, ee);
          return Rk(a, c, N, pe);
        }
        var Ae = Qo(N, a.childLanes);
        if (ju || Ae) {
          var Re = Bk();
          if (Re !== null) {
            var Oe = rA(Re, N);
            if (Oe !== Ni && Oe !== I.retryLane) {
              I.retryLane = Oe;
              var ot = Rr;
              ml(a, Oe), Ds(Re, a, Oe, ot);
            }
          }
          Aj();
          var Ht = KL(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Rk(a, c, N, Ht);
        } else if (RB(C)) {
          c.flags |= nn, c.child = a.child;
          var Lt = Uoe.bind(null, a);
          return xre(C, Lt), null;
        } else {
          oie(c, C, I.treeContext);
          var Nn = b.children, Tn = oj(c, Nn);
          return Tn.flags |= il, Tn;
        }
      }
    }
    function c6(a, c, g) {
      a.lanes = dn(a.lanes, c);
      var b = a.alternate;
      b !== null && (b.lanes = dn(b.lanes, c)), ZO(a.return, c, g);
    }
    function vse(a, c, g) {
      for (var b = c; b !== null; ) {
        if (b.tag === $) {
          var C = b.memoizedState;
          C !== null && c6(b, g, a);
        } else if (b.tag === te)
          c6(b, g, a);
        else if (b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === a)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a)
            return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }
    function yse(a) {
      for (var c = a, g = null; c !== null; ) {
        var b = c.alternate;
        b !== null && ck(b) === null && (g = c), c = c.sibling;
      }
      return g;
    }
    function Sse(a) {
      if (a !== void 0 && a !== "forwards" && a !== "backwards" && a !== "together" && !ej[a])
        if (ej[a] = !0, typeof a == "string")
          switch (a.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              o('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', a, a.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              o('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', a, a.toLowerCase());
              break;
            }
            default:
              o('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
              break;
          }
        else
          o('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
    }
    function bse(a, c) {
      a !== void 0 && !Ik[a] && (a !== "collapsed" && a !== "hidden" ? (Ik[a] = !0, o('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a)) : c !== "forwards" && c !== "backwards" && (Ik[a] = !0, o('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a)));
    }
    function u6(a, c) {
      {
        var g = Pn(a), b = !g && typeof xs(a) == "function";
        if (g || b) {
          var C = g ? "array" : "iterable";
          return o("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", C, c, C), !1;
        }
      }
      return !0;
    }
    function xse(a, c) {
      if ((c === "forwards" || c === "backwards") && a !== void 0 && a !== null && a !== !1)
        if (Pn(a)) {
          for (var g = 0; g < a.length; g++)
            if (!u6(a[g], g))
              return;
        } else {
          var b = xs(a);
          if (typeof b == "function") {
            var C = b.call(a);
            if (C)
              for (var I = C.next(), N = 0; !I.done; I = C.next()) {
                if (!u6(I.value, N))
                  return;
                N++;
              }
          } else
            o('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', c);
        }
    }
    function lj(a, c, g, b, C) {
      var I = a.memoizedState;
      I === null ? a.memoizedState = {
        isBackwards: c,
        rendering: null,
        renderingStartTime: 0,
        last: b,
        tail: g,
        tailMode: C
      } : (I.isBackwards = c, I.rendering = null, I.renderingStartTime = 0, I.last = b, I.tail = g, I.tailMode = C);
    }
    function d6(a, c, g) {
      var b = c.pendingProps, C = b.revealOrder, I = b.tail, N = b.children;
      Sse(C), bse(I, C), xse(N, C), Ra(a, c, N, g);
      var H = Du.current, V = oL(H, WC);
      if (V)
        H = aL(H, WC), c.flags |= nn;
      else {
        var ee = a !== null && (a.flags & nn) !== zt;
        ee && vse(c, c.child, g), H = Qb(H);
      }
      if (Tg(c, H), (c.mode & Ot) === Rt)
        c.memoizedState = null;
      else
        switch (C) {
          case "forwards": {
            var re = yse(c.child), me;
            re === null ? (me = c.child, c.child = null) : (me = re.sibling, re.sibling = null), lj(
              c,
              !1,
              // isBackwards
              me,
              re,
              I
            );
            break;
          }
          case "backwards": {
            var pe = null, Ae = c.child;
            for (c.child = null; Ae !== null; ) {
              var Re = Ae.alternate;
              if (Re !== null && ck(Re) === null) {
                c.child = Ae;
                break;
              }
              var Oe = Ae.sibling;
              Ae.sibling = pe, pe = Ae, Ae = Oe;
            }
            lj(
              c,
              !0,
              // isBackwards
              pe,
              null,
              // last
              I
            );
            break;
          }
          case "together": {
            lj(
              c,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            c.memoizedState = null;
        }
      return c.child;
    }
    function wse(a, c, g) {
      rL(c, c.stateNode.containerInfo);
      var b = c.pendingProps;
      return a === null ? c.child = Yb(c, null, b, g) : Ra(a, c, b, g), c.child;
    }
    var h6 = !1;
    function Cse(a, c, g) {
      var b = c.type, C = b._context, I = c.pendingProps, N = c.memoizedProps, H = I.value;
      {
        "value" in I || h6 || (h6 = !0, o("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var V = c.type.propTypes;
        V && Iu(V, I, "prop", "Context.Provider");
      }
      if (i4(c, C, H), N !== null) {
        var ee = N.value;
        if (bt(ee, H)) {
          if (N.children === I.children && !zA())
            return yf(a, c, g);
        } else
          Sie(c, C, g);
      }
      var re = I.children;
      return Ra(a, c, re, g), c.child;
    }
    var f6 = !1;
    function Ese(a, c, g) {
      var b = c.type;
      b._context === void 0 ? b !== b.Consumer && (f6 || (f6 = !0, o("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : b = b._context;
      var C = c.pendingProps, I = C.children;
      typeof I != "function" && o("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), qb(c, g);
      var N = ms(b);
      Wp(c);
      var H;
      return eE.current = c, Bs(!0), H = I(N), Bs(!1), Xo(), c.flags |= _d, Ra(a, c, H, g), c.child;
    }
    function rE() {
      ju = !0;
    }
    function Mk(a, c) {
      (c.mode & Ot) === Rt && a !== null && (a.alternate = null, c.alternate = null, c.flags |= $r);
    }
    function yf(a, c, g) {
      return a !== null && (c.dependencies = a.dependencies), B4(), gE(c.lanes), Qo(g, c.childLanes) ? (vie(a, c), c.child) : null;
    }
    function _se(a, c, g) {
      {
        var b = c.return;
        if (b === null)
          throw new Error("Cannot swap the root fiber.");
        if (a.alternate = null, c.alternate = null, g.index = c.index, g.sibling = c.sibling, g.return = c.return, g.ref = c.ref, c === b.child)
          b.child = g;
        else {
          var C = b.child;
          if (C === null)
            throw new Error("Expected parent to have a child.");
          for (; C.sibling !== c; )
            if (C = C.sibling, C === null)
              throw new Error("Expected to find the previous sibling.");
          C.sibling = g;
        }
        var I = b.deletions;
        return I === null ? (b.deletions = [a], b.flags |= or) : I.push(a), g.flags |= $r, g;
      }
    }
    function cj(a, c) {
      var g = a.lanes;
      return !!Qo(g, c);
    }
    function Tse(a, c, g) {
      switch (c.tag) {
        case m:
          s6(c), c.stateNode, Kb();
          break;
        case S:
          h4(c);
          break;
        case d: {
          var b = c.type;
          Fd(b) && BA(c);
          break;
        }
        case v:
          rL(c, c.stateNode.containerInfo);
          break;
        case R: {
          var C = c.memoizedProps.value, I = c.type._context;
          i4(c, I, C);
          break;
        }
        case j:
          {
            var N = Qo(g, c.childLanes);
            N && (c.flags |= pn);
            {
              var H = c.stateNode;
              H.effectDuration = 0, H.passiveEffectDuration = 0;
            }
          }
          break;
        case $: {
          var V = c.memoizedState;
          if (V !== null) {
            if (V.dehydrated !== null)
              return Tg(c, Qb(Du.current)), c.flags |= nn, null;
            var ee = c.child, re = ee.childLanes;
            if (Qo(g, re))
              return a6(a, c, g);
            Tg(c, Qb(Du.current));
            var me = yf(a, c, g);
            return me !== null ? me.sibling : null;
          } else
            Tg(c, Qb(Du.current));
          break;
        }
        case te: {
          var pe = (a.flags & nn) !== zt, Ae = Qo(g, c.childLanes);
          if (pe) {
            if (Ae)
              return d6(a, c, g);
            c.flags |= nn;
          }
          var Re = c.memoizedState;
          if (Re !== null && (Re.rendering = null, Re.tail = null, Re.lastEffect = null), Tg(c, Du.current), Ae)
            break;
          return null;
        }
        case K:
        case Z:
          return c.lanes = Ue, n6(a, c, g);
      }
      return yf(a, c, g);
    }
    function p6(a, c, g) {
      if (c._debugNeedsRemount && a !== null)
        return _se(a, c, $j(c.type, c.key, c.pendingProps, c._debugOwner || null, c.mode, c.lanes));
      if (a !== null) {
        var b = a.memoizedProps, C = c.pendingProps;
        if (b !== C || zA() || // Force a re-render if the implementation changed due to hot reload:
        c.type !== a.type)
          ju = !0;
        else {
          var I = cj(a, g);
          if (!I && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (c.flags & nn) === zt)
            return ju = !1, Tse(a, c, g);
          (a.flags & tv) !== zt ? ju = !0 : ju = !1;
        }
      } else if (ju = !1, po() && Zre(c)) {
        var N = c.index, H = Qre();
        BB(c, H, N);
      }
      switch (c.lanes = Ue, c.tag) {
        case f:
          return ase(a, c, c.type, g);
        case B: {
          var V = c.elementType;
          return sse(a, c, V, g);
        }
        case u: {
          var ee = c.type, re = c.pendingProps, me = c.elementType === ee ? re : Lu(ee, re);
          return tj(a, c, ee, me, g);
        }
        case d: {
          var pe = c.type, Ae = c.pendingProps, Re = c.elementType === pe ? Ae : Lu(pe, Ae);
          return i6(a, c, pe, Re, g);
        }
        case m:
          return nse(a, c, g);
        case S:
          return rse(a, c, g);
        case w:
          return ise(a, c);
        case $:
          return a6(a, c, g);
        case v:
          return wse(a, c, g);
        case M: {
          var Oe = c.type, ot = c.pendingProps, Ht = c.elementType === Oe ? ot : Lu(Oe, ot);
          return J4(a, c, Oe, Ht, g);
        }
        case E:
          return Jie(a, c, g);
        case A:
          return ese(a, c, g);
        case j:
          return tse(a, c, g);
        case R:
          return Cse(a, c, g);
        case P:
          return Ese(a, c, g);
        case U: {
          var Lt = c.type, Nn = c.pendingProps, Tn = Lu(Lt, Nn);
          if (c.type !== c.elementType) {
            var Ee = Lt.propTypes;
            Ee && Iu(
              Ee,
              Tn,
              // Resolved for outer only
              "prop",
              ln(Lt)
            );
          }
          return Tn = Lu(Lt.type, Tn), e6(a, c, Lt, Tn, g);
        }
        case F:
          return t6(a, c, c.type, c.pendingProps, g);
        case G: {
          var Le = c.type, _e = c.pendingProps, Ye = c.elementType === Le ? _e : Lu(Le, _e);
          return ose(a, c, Le, Ye, g);
        }
        case te:
          return d6(a, c, g);
        case ne:
          break;
        case K:
          return n6(a, c, g);
      }
      throw new Error("Unknown unit of work tag (" + c.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function i0(a) {
      a.flags |= pn;
    }
    function g6(a) {
      a.flags |= Vo, a.flags |= Hw;
    }
    var m6, uj, v6, y6;
    m6 = function(a, c, g, b) {
      for (var C = c.child; C !== null; ) {
        if (C.tag === S || C.tag === w)
          Yne(a, C.stateNode);
        else if (C.tag !== v) {
          if (C.child !== null) {
            C.child.return = C, C = C.child;
            continue;
          }
        }
        if (C === c)
          return;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === c)
            return;
          C = C.return;
        }
        C.sibling.return = C.return, C = C.sibling;
      }
    }, uj = function(a, c) {
    }, v6 = function(a, c, g, b, C) {
      var I = a.memoizedProps;
      if (I !== b) {
        var N = c.stateNode, H = iL(), V = qne(N, g, I, b, C, H);
        c.updateQueue = V, V && i0(c);
      }
    }, y6 = function(a, c, g, b) {
      g !== b && i0(c);
    };
    function iE(a, c) {
      if (!po())
        switch (a.tailMode) {
          case "hidden": {
            for (var g = a.tail, b = null; g !== null; )
              g.alternate !== null && (b = g), g = g.sibling;
            b === null ? a.tail = null : b.sibling = null;
            break;
          }
          case "collapsed": {
            for (var C = a.tail, I = null; C !== null; )
              C.alternate !== null && (I = C), C = C.sibling;
            I === null ? !c && a.tail !== null ? a.tail.sibling = null : a.tail = null : I.sibling = null;
            break;
          }
        }
    }
    function mo(a) {
      var c = a.alternate !== null && a.alternate.child === a.child, g = Ue, b = zt;
      if (c) {
        if ((a.mode & rn) !== Rt) {
          for (var V = a.selfBaseDuration, ee = a.child; ee !== null; )
            g = dn(g, dn(ee.lanes, ee.childLanes)), b |= ee.subtreeFlags & Cs, b |= ee.flags & Cs, V += ee.treeBaseDuration, ee = ee.sibling;
          a.treeBaseDuration = V;
        } else
          for (var re = a.child; re !== null; )
            g = dn(g, dn(re.lanes, re.childLanes)), b |= re.subtreeFlags & Cs, b |= re.flags & Cs, re.return = a, re = re.sibling;
        a.subtreeFlags |= b;
      } else {
        if ((a.mode & rn) !== Rt) {
          for (var C = a.actualDuration, I = a.selfBaseDuration, N = a.child; N !== null; )
            g = dn(g, dn(N.lanes, N.childLanes)), b |= N.subtreeFlags, b |= N.flags, C += N.actualDuration, I += N.treeBaseDuration, N = N.sibling;
          a.actualDuration = C, a.treeBaseDuration = I;
        } else
          for (var H = a.child; H !== null; )
            g = dn(g, dn(H.lanes, H.childLanes)), b |= H.subtreeFlags, b |= H.flags, H.return = a, H = H.sibling;
        a.subtreeFlags |= b;
      }
      return a.childLanes = g, c;
    }
    function Pse(a, c, g) {
      if (die() && (c.mode & Ot) !== Rt && (c.flags & nn) === zt)
        return XB(c), Kb(), c.flags |= mi | _a | hs, !1;
      var b = KA(c);
      if (g !== null && g.dehydrated !== null)
        if (a === null) {
          if (!b)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (cie(c), mo(c), (c.mode & rn) !== Rt) {
            var C = g !== null;
            if (C) {
              var I = c.child;
              I !== null && (c.treeBaseDuration -= I.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Kb(), (c.flags & nn) === zt && (c.memoizedState = null), c.flags |= pn, mo(c), (c.mode & rn) !== Rt) {
            var N = g !== null;
            if (N) {
              var H = c.child;
              H !== null && (c.treeBaseDuration -= H.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return qB(), !0;
    }
    function S6(a, c, g) {
      var b = c.pendingProps;
      switch (jO(c), c.tag) {
        case f:
        case B:
        case F:
        case u:
        case M:
        case E:
        case A:
        case j:
        case P:
        case U:
          return mo(c), null;
        case d: {
          var C = c.type;
          return Fd(C) && UA(c), mo(c), null;
        }
        case m: {
          var I = c.stateNode;
          if (Zb(c), MO(c), cL(), I.pendingContext && (I.context = I.pendingContext, I.pendingContext = null), a === null || a.child === null) {
            var N = KA(c);
            if (N)
              i0(c);
            else if (a !== null) {
              var H = a.memoizedState;
              // Check if this is a client root
              (!H.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (c.flags & mi) !== zt) && (c.flags |= rl, qB());
            }
          }
          return uj(a, c), mo(c), null;
        }
        case S: {
          sL(c);
          var V = d4(), ee = c.type;
          if (a !== null && c.stateNode != null)
            v6(a, c, ee, b, V), a.ref !== c.ref && g6(c);
          else {
            if (!b) {
              if (c.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return mo(c), null;
            }
            var re = iL(), me = KA(c);
            if (me)
              aie(c, V, re) && i0(c);
            else {
              var pe = Kne(ee, b, V, re, c);
              m6(pe, c, !1, !1), c.stateNode = pe, Xne(pe, ee, b, V) && i0(c);
            }
            c.ref !== null && g6(c);
          }
          return mo(c), null;
        }
        case w: {
          var Ae = b;
          if (a && c.stateNode != null) {
            var Re = a.memoizedProps;
            y6(a, c, Re, Ae);
          } else {
            if (typeof Ae != "string" && c.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Oe = d4(), ot = iL(), Ht = KA(c);
            Ht ? lie(c) && i0(c) : c.stateNode = Zne(Ae, Oe, ot, c);
          }
          return mo(c), null;
        }
        case $: {
          Jb(c);
          var Lt = c.memoizedState;
          if (a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
            var Nn = Pse(a, c, Lt);
            if (!Nn)
              return c.flags & hs ? c : null;
          }
          if ((c.flags & nn) !== zt)
            return c.lanes = g, (c.mode & rn) !== Rt && OL(c), c;
          var Tn = Lt !== null, Ee = a !== null && a.memoizedState !== null;
          if (Tn !== Ee && Tn) {
            var Le = c.child;
            if (Le.flags |= Td, (c.mode & Ot) !== Rt) {
              var _e = a === null && (c.memoizedProps.unstable_avoidThisFallback !== !0 || !ce);
              _e || oL(Du.current, p4) ? Aoe() : Aj();
            }
          }
          var Ye = c.updateQueue;
          if (Ye !== null && (c.flags |= pn), mo(c), (c.mode & rn) !== Rt && Tn) {
            var ft = c.child;
            ft !== null && (c.treeBaseDuration -= ft.treeBaseDuration);
          }
          return null;
        }
        case v:
          return Zb(c), uj(a, c), a === null && Vre(c.stateNode.containerInfo), mo(c), null;
        case R:
          var lt = c.type._context;
          return qO(lt, c), mo(c), null;
        case G: {
          var Qt = c.type;
          return Fd(Qt) && UA(c), mo(c), null;
        }
        case te: {
          Jb(c);
          var cn = c.memoizedState;
          if (cn === null)
            return mo(c), null;
          var Sr = (c.flags & nn) !== zt, nr = cn.rendering;
          if (nr === null)
            if (Sr)
              iE(cn, !1);
            else {
              var Ki = Ioe() && (a === null || (a.flags & nn) === zt);
              if (!Ki)
                for (var rr = c.child; rr !== null; ) {
                  var Fi = ck(rr);
                  if (Fi !== null) {
                    Sr = !0, c.flags |= nn, iE(cn, !1);
                    var ra = Fi.updateQueue;
                    return ra !== null && (c.updateQueue = ra, c.flags |= pn), c.subtreeFlags = zt, yie(c, g), Tg(c, aL(Du.current, WC)), c.child;
                  }
                  rr = rr.sibling;
                }
              cn.tail !== null && ai() > z6() && (c.flags |= nn, Sr = !0, iE(cn, !1), c.lanes = GP);
            }
          else {
            if (!Sr) {
              var xo = ck(nr);
              if (xo !== null) {
                c.flags |= nn, Sr = !0;
                var Jl = xo.updateQueue;
                if (Jl !== null && (c.updateQueue = Jl, c.flags |= pn), iE(cn, !0), cn.tail === null && cn.tailMode === "hidden" && !nr.alternate && !po())
                  return mo(c), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              ai() * 2 - cn.renderingStartTime > z6() && g !== Ws && (c.flags |= nn, Sr = !0, iE(cn, !1), c.lanes = GP);
            }
            if (cn.isBackwards)
              nr.sibling = c.child, c.child = nr;
            else {
              var Oa = cn.last;
              Oa !== null ? Oa.sibling = nr : c.child = nr, cn.last = nr;
            }
          }
          if (cn.tail !== null) {
            var La = cn.tail;
            cn.rendering = La, cn.tail = La.sibling, cn.renderingStartTime = ai(), La.sibling = null;
            var ia = Du.current;
            return Sr ? ia = aL(ia, WC) : ia = Qb(ia), Tg(c, ia), La;
          }
          return mo(c), null;
        }
        case ne:
          break;
        case K:
        case Z: {
          Pj(c);
          var Cf = c.memoizedState, h0 = Cf !== null;
          if (a !== null) {
            var bE = a.memoizedState, Gd = bE !== null;
            Gd !== h0 && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !ke && (c.flags |= Td);
          }
          return !h0 || (c.mode & Ot) === Rt ? mo(c) : Qo(Wd, Ws) && (mo(c), c.subtreeFlags & ($r | pn) && (c.flags |= Td)), null;
        }
        case oe:
          return null;
        case fe:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + c.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ase(a, c, g) {
      switch (jO(c), c.tag) {
        case d: {
          var b = c.type;
          Fd(b) && UA(c);
          var C = c.flags;
          return C & hs ? (c.flags = C & ~hs | nn, (c.mode & rn) !== Rt && OL(c), c) : null;
        }
        case m: {
          c.stateNode, Zb(c), MO(c), cL();
          var I = c.flags;
          return (I & hs) !== zt && (I & nn) === zt ? (c.flags = I & ~hs | nn, c) : null;
        }
        case S:
          return sL(c), null;
        case $: {
          Jb(c);
          var N = c.memoizedState;
          if (N !== null && N.dehydrated !== null) {
            if (c.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Kb();
          }
          var H = c.flags;
          return H & hs ? (c.flags = H & ~hs | nn, (c.mode & rn) !== Rt && OL(c), c) : null;
        }
        case te:
          return Jb(c), null;
        case v:
          return Zb(c), null;
        case R:
          var V = c.type._context;
          return qO(V, c), null;
        case K:
        case Z:
          return Pj(c), null;
        case oe:
          return null;
        default:
          return null;
      }
    }
    function b6(a, c, g) {
      switch (jO(c), c.tag) {
        case d: {
          var b = c.type.childContextTypes;
          b != null && UA(c);
          break;
        }
        case m: {
          c.stateNode, Zb(c), MO(c), cL();
          break;
        }
        case S: {
          sL(c);
          break;
        }
        case v:
          Zb(c);
          break;
        case $:
          Jb(c);
          break;
        case te:
          Jb(c);
          break;
        case R:
          var C = c.type._context;
          qO(C, c);
          break;
        case K:
        case Z:
          Pj(c);
          break;
      }
    }
    var x6 = null;
    x6 = /* @__PURE__ */ new Set();
    var Dk = !1, vo = !1, kse = typeof WeakSet == "function" ? WeakSet : Set, xt = null, s0 = null, o0 = null;
    function Ise(a) {
      Kh(null, function() {
        throw a;
      }), Uw();
    }
    var Rse = function(a, c) {
      if (c.props = a.memoizedProps, c.state = a.memoizedState, a.mode & rn)
        try {
          Hd(), c.componentWillUnmount();
        } finally {
          Bd(a);
        }
      else
        c.componentWillUnmount();
    };
    function w6(a, c) {
      try {
        kg(Ps, a);
      } catch (g) {
        Br(a, c, g);
      }
    }
    function dj(a, c, g) {
      try {
        Rse(a, g);
      } catch (b) {
        Br(a, c, b);
      }
    }
    function Mse(a, c, g) {
      try {
        g.componentDidMount();
      } catch (b) {
        Br(a, c, b);
      }
    }
    function C6(a, c) {
      try {
        _6(a);
      } catch (g) {
        Br(a, c, g);
      }
    }
    function a0(a, c) {
      var g = a.ref;
      if (g !== null)
        if (typeof g == "function") {
          var b;
          try {
            if (nt && Ze && a.mode & rn)
              try {
                Hd(), b = g(null);
              } finally {
                Bd(a);
              }
            else
              b = g(null);
          } catch (C) {
            Br(a, c, C);
          }
          typeof b == "function" && o("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", tn(a));
        } else
          g.current = null;
    }
    function Ok(a, c, g) {
      try {
        g();
      } catch (b) {
        Br(a, c, b);
      }
    }
    var E6 = !1;
    function Dse(a, c) {
      Wne(a.containerInfo), xt = c, Ose();
      var g = E6;
      return E6 = !1, g;
    }
    function Ose() {
      for (; xt !== null; ) {
        var a = xt, c = a.child;
        (a.subtreeFlags & Bp) !== zt && c !== null ? (c.return = a, xt = c) : Lse();
      }
    }
    function Lse() {
      for (; xt !== null; ) {
        var a = xt;
        Jn(a);
        try {
          jse(a);
        } catch (g) {
          Br(a, a.return, g);
        }
        Cr();
        var c = a.sibling;
        if (c !== null) {
          c.return = a.return, xt = c;
          return;
        }
        xt = a.return;
      }
    }
    function jse(a) {
      var c = a.alternate, g = a.flags;
      if ((g & rl) !== zt) {
        switch (Jn(a), a.tag) {
          case u:
          case M:
          case F:
            break;
          case d: {
            if (c !== null) {
              var b = c.memoizedProps, C = c.memoizedState, I = a.stateNode;
              a.type === a.elementType && !jv && (I.props !== a.memoizedProps && o("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", tn(a) || "instance"), I.state !== a.memoizedState && o("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", tn(a) || "instance"));
              var N = I.getSnapshotBeforeUpdate(a.elementType === a.type ? b : Lu(a.type, b), C);
              {
                var H = x6;
                N === void 0 && !H.has(a.type) && (H.add(a.type), o("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", tn(a)));
              }
              I.__reactInternalSnapshotBeforeUpdate = N;
            }
            break;
          }
          case m: {
            {
              var V = a.stateNode;
              mre(V.containerInfo);
            }
            break;
          }
          case S:
          case w:
          case v:
          case G:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Cr();
      }
    }
    function Nu(a, c, g) {
      var b = c.updateQueue, C = b !== null ? b.lastEffect : null;
      if (C !== null) {
        var I = C.next, N = I;
        do {
          if ((N.tag & a) === a) {
            var H = N.destroy;
            N.destroy = void 0, H !== void 0 && ((a & go) !== vl ? HP(c) : (a & Ps) !== vl && ql(c), (a & $d) !== vl && vE(!0), Ok(c, g, H), (a & $d) !== vl && vE(!1), (a & go) !== vl ? KS() : (a & Ps) !== vl && Gp());
          }
          N = N.next;
        } while (N !== I);
      }
    }
    function kg(a, c) {
      var g = c.updateQueue, b = g !== null ? g.lastEffect : null;
      if (b !== null) {
        var C = b.next, I = C;
        do {
          if ((I.tag & a) === a) {
            (a & go) !== vl ? kd(c) : (a & Ps) !== vl && VP(c);
            var N = I.create;
            (a & $d) !== vl && vE(!0), I.destroy = N(), (a & $d) !== vl && vE(!1), (a & go) !== vl ? GS() : (a & Ps) !== vl && nv();
            {
              var H = I.destroy;
              if (H !== void 0 && typeof H != "function") {
                var V = void 0;
                (I.tag & Ps) !== zt ? V = "useLayoutEffect" : (I.tag & $d) !== zt ? V = "useInsertionEffect" : V = "useEffect";
                var ee = void 0;
                H === null ? ee = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof H.then == "function" ? ee = `

It looks like you wrote ` + V + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + V + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : ee = " You returned: " + H, o("%s must not return anything besides a function, which is used for clean-up.%s", V, ee);
              }
            }
          }
          I = I.next;
        } while (I !== C);
      }
    }
    function Nse(a, c) {
      if ((c.flags & pn) !== zt)
        switch (c.tag) {
          case j: {
            var g = c.stateNode.passiveEffectDuration, b = c.memoizedProps, C = b.id, I = b.onPostCommit, N = z4(), H = c.alternate === null ? "mount" : "update";
            $4() && (H = "nested-update"), typeof I == "function" && I(C, H, g, N);
            var V = c.return;
            e: for (; V !== null; ) {
              switch (V.tag) {
                case m:
                  var ee = V.stateNode;
                  ee.passiveEffectDuration += g;
                  break e;
                case j:
                  var re = V.stateNode;
                  re.passiveEffectDuration += g;
                  break e;
              }
              V = V.return;
            }
            break;
          }
        }
    }
    function Fse(a, c, g, b) {
      if ((g.flags & Hs) !== zt)
        switch (g.tag) {
          case u:
          case M:
          case F: {
            if (!vo)
              if (g.mode & rn)
                try {
                  Hd(), kg(Ps | Ts, g);
                } finally {
                  Bd(g);
                }
              else
                kg(Ps | Ts, g);
            break;
          }
          case d: {
            var C = g.stateNode;
            if (g.flags & pn && !vo)
              if (c === null)
                if (g.type === g.elementType && !jv && (C.props !== g.memoizedProps && o("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", tn(g) || "instance"), C.state !== g.memoizedState && o("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", tn(g) || "instance")), g.mode & rn)
                  try {
                    Hd(), C.componentDidMount();
                  } finally {
                    Bd(g);
                  }
                else
                  C.componentDidMount();
              else {
                var I = g.elementType === g.type ? c.memoizedProps : Lu(g.type, c.memoizedProps), N = c.memoizedState;
                if (g.type === g.elementType && !jv && (C.props !== g.memoizedProps && o("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", tn(g) || "instance"), C.state !== g.memoizedState && o("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", tn(g) || "instance")), g.mode & rn)
                  try {
                    Hd(), C.componentDidUpdate(I, N, C.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Bd(g);
                  }
                else
                  C.componentDidUpdate(I, N, C.__reactInternalSnapshotBeforeUpdate);
              }
            var H = g.updateQueue;
            H !== null && (g.type === g.elementType && !jv && (C.props !== g.memoizedProps && o("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", tn(g) || "instance"), C.state !== g.memoizedState && o("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", tn(g) || "instance")), u4(g, H, C));
            break;
          }
          case m: {
            var V = g.updateQueue;
            if (V !== null) {
              var ee = null;
              if (g.child !== null)
                switch (g.child.tag) {
                  case S:
                    ee = g.child.stateNode;
                    break;
                  case d:
                    ee = g.child.stateNode;
                    break;
                }
              u4(g, V, ee);
            }
            break;
          }
          case S: {
            var re = g.stateNode;
            if (c === null && g.flags & pn) {
              var me = g.type, pe = g.memoizedProps;
              nre(re, me, pe);
            }
            break;
          }
          case w:
            break;
          case v:
            break;
          case j: {
            {
              var Ae = g.memoizedProps, Re = Ae.onCommit, Oe = Ae.onRender, ot = g.stateNode.effectDuration, Ht = z4(), Lt = c === null ? "mount" : "update";
              $4() && (Lt = "nested-update"), typeof Oe == "function" && Oe(g.memoizedProps.id, Lt, g.actualDuration, g.treeBaseDuration, g.actualStartTime, Ht);
              {
                typeof Re == "function" && Re(g.memoizedProps.id, Lt, ot, Ht), Loe(g);
                var Nn = g.return;
                e: for (; Nn !== null; ) {
                  switch (Nn.tag) {
                    case m:
                      var Tn = Nn.stateNode;
                      Tn.effectDuration += ot;
                      break e;
                    case j:
                      var Ee = Nn.stateNode;
                      Ee.effectDuration += ot;
                      break e;
                  }
                  Nn = Nn.return;
                }
              }
            }
            break;
          }
          case $: {
            Gse(a, g);
            break;
          }
          case te:
          case G:
          case ne:
          case K:
          case Z:
          case fe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      vo || g.flags & Vo && _6(g);
    }
    function $se(a) {
      switch (a.tag) {
        case u:
        case M:
        case F: {
          if (a.mode & rn)
            try {
              Hd(), w6(a, a.return);
            } finally {
              Bd(a);
            }
          else
            w6(a, a.return);
          break;
        }
        case d: {
          var c = a.stateNode;
          typeof c.componentDidMount == "function" && Mse(a, a.return, c), C6(a, a.return);
          break;
        }
        case S: {
          C6(a, a.return);
          break;
        }
      }
    }
    function zse(a, c) {
      for (var g = null, b = a; ; ) {
        if (b.tag === S) {
          if (g === null) {
            g = b;
            try {
              var C = b.stateNode;
              c ? hre(C) : pre(b.stateNode, b.memoizedProps);
            } catch (N) {
              Br(a, a.return, N);
            }
          }
        } else if (b.tag === w) {
          if (g === null)
            try {
              var I = b.stateNode;
              c ? fre(I) : gre(I, b.memoizedProps);
            } catch (N) {
              Br(a, a.return, N);
            }
        } else if (!((b.tag === K || b.tag === Z) && b.memoizedState !== null && b !== a)) {
          if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === a)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a)
            return;
          g === b && (g = null), b = b.return;
        }
        g === b && (g = null), b.sibling.return = b.return, b = b.sibling;
      }
    }
    function _6(a) {
      var c = a.ref;
      if (c !== null) {
        var g = a.stateNode, b;
        switch (a.tag) {
          case S:
            b = g;
            break;
          default:
            b = g;
        }
        if (typeof c == "function") {
          var C;
          if (a.mode & rn)
            try {
              Hd(), C = c(b);
            } finally {
              Bd(a);
            }
          else
            C = c(b);
          typeof C == "function" && o("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", tn(a));
        } else
          c.hasOwnProperty("current") || o("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", tn(a)), c.current = b;
      }
    }
    function Use(a) {
      var c = a.alternate;
      c !== null && (c.return = null), a.return = null;
    }
    function T6(a) {
      var c = a.alternate;
      c !== null && (a.alternate = null, T6(c));
      {
        if (a.child = null, a.deletions = null, a.sibling = null, a.tag === S) {
          var g = a.stateNode;
          g !== null && Kre(g);
        }
        a.stateNode = null, a._debugOwner = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
      }
    }
    function Bse(a) {
      for (var c = a.return; c !== null; ) {
        if (P6(c))
          return c;
        c = c.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function P6(a) {
      return a.tag === S || a.tag === m || a.tag === v;
    }
    function A6(a) {
      var c = a;
      e: for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || P6(c.return))
            return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== S && c.tag !== w && c.tag !== X; ) {
          if (c.flags & $r || c.child === null || c.tag === v)
            continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & $r))
          return c.stateNode;
      }
    }
    function Hse(a) {
      var c = Bse(a);
      switch (c.tag) {
        case S: {
          var g = c.stateNode;
          c.flags & ur && (IB(g), c.flags &= ~ur);
          var b = A6(a);
          fj(a, b, g);
          break;
        }
        case m:
        case v: {
          var C = c.stateNode.containerInfo, I = A6(a);
          hj(a, I, C);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function hj(a, c, g) {
      var b = a.tag, C = b === S || b === w;
      if (C) {
        var I = a.stateNode;
        c ? lre(g, I, c) : ore(g, I);
      } else if (b !== v) {
        var N = a.child;
        if (N !== null) {
          hj(N, c, g);
          for (var H = N.sibling; H !== null; )
            hj(H, c, g), H = H.sibling;
        }
      }
    }
    function fj(a, c, g) {
      var b = a.tag, C = b === S || b === w;
      if (C) {
        var I = a.stateNode;
        c ? are(g, I, c) : sre(g, I);
      } else if (b !== v) {
        var N = a.child;
        if (N !== null) {
          fj(N, c, g);
          for (var H = N.sibling; H !== null; )
            fj(H, c, g), H = H.sibling;
        }
      }
    }
    var yo = null, Fu = !1;
    function Vse(a, c, g) {
      {
        var b = c;
        e: for (; b !== null; ) {
          switch (b.tag) {
            case S: {
              yo = b.stateNode, Fu = !1;
              break e;
            }
            case m: {
              yo = b.stateNode.containerInfo, Fu = !0;
              break e;
            }
            case v: {
              yo = b.stateNode.containerInfo, Fu = !0;
              break e;
            }
          }
          b = b.return;
        }
        if (yo === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        k6(a, c, g), yo = null, Fu = !1;
      }
      Use(g);
    }
    function Ig(a, c, g) {
      for (var b = g.child; b !== null; )
        k6(a, c, b), b = b.sibling;
    }
    function k6(a, c, g) {
      switch (qh(g), g.tag) {
        case S:
          vo || a0(g, c);
        case w: {
          {
            var b = yo, C = Fu;
            yo = null, Ig(a, c, g), yo = b, Fu = C, yo !== null && (Fu ? ure(yo, g.stateNode) : cre(yo, g.stateNode));
          }
          return;
        }
        case X: {
          yo !== null && (Fu ? dre(yo, g.stateNode) : EO(yo, g.stateNode));
          return;
        }
        case v: {
          {
            var I = yo, N = Fu;
            yo = g.stateNode.containerInfo, Fu = !0, Ig(a, c, g), yo = I, Fu = N;
          }
          return;
        }
        case u:
        case M:
        case U:
        case F: {
          if (!vo) {
            var H = g.updateQueue;
            if (H !== null) {
              var V = H.lastEffect;
              if (V !== null) {
                var ee = V.next, re = ee;
                do {
                  var me = re, pe = me.destroy, Ae = me.tag;
                  pe !== void 0 && ((Ae & $d) !== vl ? Ok(g, c, pe) : (Ae & Ps) !== vl && (ql(g), g.mode & rn ? (Hd(), Ok(g, c, pe), Bd(g)) : Ok(g, c, pe), Gp())), re = re.next;
                } while (re !== ee);
              }
            }
          }
          Ig(a, c, g);
          return;
        }
        case d: {
          if (!vo) {
            a0(g, c);
            var Re = g.stateNode;
            typeof Re.componentWillUnmount == "function" && dj(g, c, Re);
          }
          Ig(a, c, g);
          return;
        }
        case ne: {
          Ig(a, c, g);
          return;
        }
        case K: {
          if (
            // TODO: Remove this dead flag
            g.mode & Ot
          ) {
            var Oe = vo;
            vo = Oe || g.memoizedState !== null, Ig(a, c, g), vo = Oe;
          } else
            Ig(a, c, g);
          break;
        }
        default: {
          Ig(a, c, g);
          return;
        }
      }
    }
    function Wse(a) {
      a.memoizedState;
    }
    function Gse(a, c) {
      var g = c.memoizedState;
      if (g === null) {
        var b = c.alternate;
        if (b !== null) {
          var C = b.memoizedState;
          if (C !== null) {
            var I = C.dehydrated;
            I !== null && Ire(I);
          }
        }
      }
    }
    function I6(a) {
      var c = a.updateQueue;
      if (c !== null) {
        a.updateQueue = null;
        var g = a.stateNode;
        g === null && (g = a.stateNode = new kse()), c.forEach(function(b) {
          var C = Boe.bind(null, a, b);
          if (!g.has(b)) {
            if (g.add(b), Aa)
              if (s0 !== null && o0 !== null)
                mE(o0, s0);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            b.then(C, C);
          }
        });
      }
    }
    function Kse(a, c, g) {
      s0 = g, o0 = a, Jn(c), R6(c, a), Jn(c), s0 = null, o0 = null;
    }
    function $u(a, c, g) {
      var b = c.deletions;
      if (b !== null)
        for (var C = 0; C < b.length; C++) {
          var I = b[C];
          try {
            Vse(a, c, I);
          } catch (V) {
            Br(I, c, V);
          }
        }
      var N = xd();
      if (c.subtreeFlags & Ko)
        for (var H = c.child; H !== null; )
          Jn(H), R6(H, a), H = H.sibling;
      Jn(N);
    }
    function R6(a, c, g) {
      var b = a.alternate, C = a.flags;
      switch (a.tag) {
        case u:
        case M:
        case U:
        case F: {
          if ($u(c, a), Vd(a), C & pn) {
            try {
              Nu($d | Ts, a, a.return), kg($d | Ts, a);
            } catch (Qt) {
              Br(a, a.return, Qt);
            }
            if (a.mode & rn) {
              try {
                Hd(), Nu(Ps | Ts, a, a.return);
              } catch (Qt) {
                Br(a, a.return, Qt);
              }
              Bd(a);
            } else
              try {
                Nu(Ps | Ts, a, a.return);
              } catch (Qt) {
                Br(a, a.return, Qt);
              }
          }
          return;
        }
        case d: {
          $u(c, a), Vd(a), C & Vo && b !== null && a0(b, b.return);
          return;
        }
        case S: {
          $u(c, a), Vd(a), C & Vo && b !== null && a0(b, b.return);
          {
            if (a.flags & ur) {
              var I = a.stateNode;
              try {
                IB(I);
              } catch (Qt) {
                Br(a, a.return, Qt);
              }
            }
            if (C & pn) {
              var N = a.stateNode;
              if (N != null) {
                var H = a.memoizedProps, V = b !== null ? b.memoizedProps : H, ee = a.type, re = a.updateQueue;
                if (a.updateQueue = null, re !== null)
                  try {
                    rre(N, re, ee, V, H, a);
                  } catch (Qt) {
                    Br(a, a.return, Qt);
                  }
              }
            }
          }
          return;
        }
        case w: {
          if ($u(c, a), Vd(a), C & pn) {
            if (a.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var me = a.stateNode, pe = a.memoizedProps, Ae = b !== null ? b.memoizedProps : pe;
            try {
              ire(me, Ae, pe);
            } catch (Qt) {
              Br(a, a.return, Qt);
            }
          }
          return;
        }
        case m: {
          if ($u(c, a), Vd(a), C & pn && b !== null) {
            var Re = b.memoizedState;
            if (Re.isDehydrated)
              try {
                kre(c.containerInfo);
              } catch (Qt) {
                Br(a, a.return, Qt);
              }
          }
          return;
        }
        case v: {
          $u(c, a), Vd(a);
          return;
        }
        case $: {
          $u(c, a), Vd(a);
          var Oe = a.child;
          if (Oe.flags & Td) {
            var ot = Oe.stateNode, Ht = Oe.memoizedState, Lt = Ht !== null;
            if (ot.isHidden = Lt, Lt) {
              var Nn = Oe.alternate !== null && Oe.alternate.memoizedState !== null;
              Nn || Poe();
            }
          }
          if (C & pn) {
            try {
              Wse(a);
            } catch (Qt) {
              Br(a, a.return, Qt);
            }
            I6(a);
          }
          return;
        }
        case K: {
          var Tn = b !== null && b.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            a.mode & Ot
          ) {
            var Ee = vo;
            vo = Ee || Tn, $u(c, a), vo = Ee;
          } else
            $u(c, a);
          if (Vd(a), C & Td) {
            var Le = a.stateNode, _e = a.memoizedState, Ye = _e !== null, ft = a;
            if (Le.isHidden = Ye, Ye && !Tn && (ft.mode & Ot) !== Rt) {
              xt = ft;
              for (var lt = ft.child; lt !== null; )
                xt = lt, Xse(lt), lt = lt.sibling;
            }
            zse(ft, Ye);
          }
          return;
        }
        case te: {
          $u(c, a), Vd(a), C & pn && I6(a);
          return;
        }
        case ne:
          return;
        default: {
          $u(c, a), Vd(a);
          return;
        }
      }
    }
    function Vd(a) {
      var c = a.flags;
      if (c & $r) {
        try {
          Hse(a);
        } catch (g) {
          Br(a, a.return, g);
        }
        a.flags &= ~$r;
      }
      c & il && (a.flags &= ~il);
    }
    function Yse(a, c, g) {
      s0 = g, o0 = c, xt = a, M6(a, c, g), s0 = null, o0 = null;
    }
    function M6(a, c, g) {
      for (var b = (a.mode & Ot) !== Rt; xt !== null; ) {
        var C = xt, I = C.child;
        if (C.tag === K && b) {
          var N = C.memoizedState !== null, H = N || Dk;
          if (H) {
            pj(a, c, g);
            continue;
          } else {
            var V = C.alternate, ee = V !== null && V.memoizedState !== null, re = ee || vo, me = Dk, pe = vo;
            Dk = H, vo = re, vo && !pe && (xt = C, qse(C));
            for (var Ae = I; Ae !== null; )
              xt = Ae, M6(
                Ae,
                // New root; bubble back up to here and stop.
                c,
                g
              ), Ae = Ae.sibling;
            xt = C, Dk = me, vo = pe, pj(a, c, g);
            continue;
          }
        }
        (C.subtreeFlags & Hs) !== zt && I !== null ? (I.return = C, xt = I) : pj(a, c, g);
      }
    }
    function pj(a, c, g) {
      for (; xt !== null; ) {
        var b = xt;
        if ((b.flags & Hs) !== zt) {
          var C = b.alternate;
          Jn(b);
          try {
            Fse(c, C, b, g);
          } catch (N) {
            Br(b, b.return, N);
          }
          Cr();
        }
        if (b === a) {
          xt = null;
          return;
        }
        var I = b.sibling;
        if (I !== null) {
          I.return = b.return, xt = I;
          return;
        }
        xt = b.return;
      }
    }
    function Xse(a) {
      for (; xt !== null; ) {
        var c = xt, g = c.child;
        switch (c.tag) {
          case u:
          case M:
          case U:
          case F: {
            if (c.mode & rn)
              try {
                Hd(), Nu(Ps, c, c.return);
              } finally {
                Bd(c);
              }
            else
              Nu(Ps, c, c.return);
            break;
          }
          case d: {
            a0(c, c.return);
            var b = c.stateNode;
            typeof b.componentWillUnmount == "function" && dj(c, c.return, b);
            break;
          }
          case S: {
            a0(c, c.return);
            break;
          }
          case K: {
            var C = c.memoizedState !== null;
            if (C) {
              D6(a);
              continue;
            }
            break;
          }
        }
        g !== null ? (g.return = c, xt = g) : D6(a);
      }
    }
    function D6(a) {
      for (; xt !== null; ) {
        var c = xt;
        if (c === a) {
          xt = null;
          return;
        }
        var g = c.sibling;
        if (g !== null) {
          g.return = c.return, xt = g;
          return;
        }
        xt = c.return;
      }
    }
    function qse(a) {
      for (; xt !== null; ) {
        var c = xt, g = c.child;
        if (c.tag === K) {
          var b = c.memoizedState !== null;
          if (b) {
            O6(a);
            continue;
          }
        }
        g !== null ? (g.return = c, xt = g) : O6(a);
      }
    }
    function O6(a) {
      for (; xt !== null; ) {
        var c = xt;
        Jn(c);
        try {
          $se(c);
        } catch (b) {
          Br(c, c.return, b);
        }
        if (Cr(), c === a) {
          xt = null;
          return;
        }
        var g = c.sibling;
        if (g !== null) {
          g.return = c.return, xt = g;
          return;
        }
        xt = c.return;
      }
    }
    function Zse(a, c, g, b) {
      xt = c, Qse(c, a, g, b);
    }
    function Qse(a, c, g, b) {
      for (; xt !== null; ) {
        var C = xt, I = C.child;
        (C.subtreeFlags & sl) !== zt && I !== null ? (I.return = C, xt = I) : Jse(a, c, g, b);
      }
    }
    function Jse(a, c, g, b) {
      for (; xt !== null; ) {
        var C = xt;
        if ((C.flags & qr) !== zt) {
          Jn(C);
          try {
            eoe(c, C, g, b);
          } catch (N) {
            Br(C, C.return, N);
          }
          Cr();
        }
        if (C === a) {
          xt = null;
          return;
        }
        var I = C.sibling;
        if (I !== null) {
          I.return = C.return, xt = I;
          return;
        }
        xt = C.return;
      }
    }
    function eoe(a, c, g, b) {
      switch (c.tag) {
        case u:
        case M:
        case F: {
          if (c.mode & rn) {
            DL();
            try {
              kg(go | Ts, c);
            } finally {
              ML(c);
            }
          } else
            kg(go | Ts, c);
          break;
        }
      }
    }
    function toe(a) {
      xt = a, noe();
    }
    function noe() {
      for (; xt !== null; ) {
        var a = xt, c = a.child;
        if ((xt.flags & or) !== zt) {
          var g = a.deletions;
          if (g !== null) {
            for (var b = 0; b < g.length; b++) {
              var C = g[b];
              xt = C, soe(C, a);
            }
            {
              var I = a.alternate;
              if (I !== null) {
                var N = I.child;
                if (N !== null) {
                  I.child = null;
                  do {
                    var H = N.sibling;
                    N.sibling = null, N = H;
                  } while (N !== null);
                }
              }
            }
            xt = a;
          }
        }
        (a.subtreeFlags & sl) !== zt && c !== null ? (c.return = a, xt = c) : roe();
      }
    }
    function roe() {
      for (; xt !== null; ) {
        var a = xt;
        (a.flags & qr) !== zt && (Jn(a), ioe(a), Cr());
        var c = a.sibling;
        if (c !== null) {
          c.return = a.return, xt = c;
          return;
        }
        xt = a.return;
      }
    }
    function ioe(a) {
      switch (a.tag) {
        case u:
        case M:
        case F: {
          a.mode & rn ? (DL(), Nu(go | Ts, a, a.return), ML(a)) : Nu(go | Ts, a, a.return);
          break;
        }
      }
    }
    function soe(a, c) {
      for (; xt !== null; ) {
        var g = xt;
        Jn(g), aoe(g, c), Cr();
        var b = g.child;
        b !== null ? (b.return = g, xt = b) : ooe(a);
      }
    }
    function ooe(a) {
      for (; xt !== null; ) {
        var c = xt, g = c.sibling, b = c.return;
        if (T6(c), c === a) {
          xt = null;
          return;
        }
        if (g !== null) {
          g.return = b, xt = g;
          return;
        }
        xt = b;
      }
    }
    function aoe(a, c) {
      switch (a.tag) {
        case u:
        case M:
        case F: {
          a.mode & rn ? (DL(), Nu(go, a, c), ML(a)) : Nu(go, a, c);
          break;
        }
      }
    }
    function loe(a) {
      switch (a.tag) {
        case u:
        case M:
        case F: {
          try {
            kg(Ps | Ts, a);
          } catch (g) {
            Br(a, a.return, g);
          }
          break;
        }
        case d: {
          var c = a.stateNode;
          try {
            c.componentDidMount();
          } catch (g) {
            Br(a, a.return, g);
          }
          break;
        }
      }
    }
    function coe(a) {
      switch (a.tag) {
        case u:
        case M:
        case F: {
          try {
            kg(go | Ts, a);
          } catch (c) {
            Br(a, a.return, c);
          }
          break;
        }
      }
    }
    function uoe(a) {
      switch (a.tag) {
        case u:
        case M:
        case F: {
          try {
            Nu(Ps | Ts, a, a.return);
          } catch (g) {
            Br(a, a.return, g);
          }
          break;
        }
        case d: {
          var c = a.stateNode;
          typeof c.componentWillUnmount == "function" && dj(a, a.return, c);
          break;
        }
      }
    }
    function doe(a) {
      switch (a.tag) {
        case u:
        case M:
        case F:
          try {
            Nu(go | Ts, a, a.return);
          } catch (c) {
            Br(a, a.return, c);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var sE = Symbol.for;
      sE("selector.component"), sE("selector.has_pseudo_class"), sE("selector.role"), sE("selector.test_id"), sE("selector.text");
    }
    var hoe = [];
    function foe() {
      hoe.forEach(function(a) {
        return a();
      });
    }
    var poe = e.ReactCurrentActQueue;
    function goe(a) {
      {
        var c = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), g = typeof jest < "u";
        return g && c !== !1;
      }
    }
    function L6() {
      {
        var a = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !a && poe.current !== null && o("The current testing environment is not configured to support act(...)"), a;
      }
    }
    var moe = Math.ceil, gj = e.ReactCurrentDispatcher, mj = e.ReactCurrentOwner, So = e.ReactCurrentBatchConfig, zu = e.ReactCurrentActQueue, Is = (
      /*             */
      0
    ), j6 = (
      /*               */
      1
    ), bo = (
      /*                */
      2
    ), Wc = (
      /*                */
      4
    ), Sf = 0, oE = 1, Nv = 2, Lk = 3, aE = 4, N6 = 5, vj = 6, jn = Is, Ma = null, Pi = null, Rs = Ue, Wd = Ue, yj = bg(Ue), Ms = Sf, lE = null, jk = Ue, cE = Ue, Nk = Ue, uE = null, yl = null, Sj = 0, F6 = 500, $6 = 1 / 0, voe = 500, bf = null;
    function dE() {
      $6 = ai() + voe;
    }
    function z6() {
      return $6;
    }
    var Fk = !1, bj = null, l0 = null, Fv = !1, Rg = null, hE = Ue, xj = [], wj = null, yoe = 50, fE = 0, Cj = null, Ej = !1, $k = !1, Soe = 50, c0 = 0, zk = null, pE = Rr, Uk = Ue, U6 = !1;
    function Bk() {
      return Ma;
    }
    function Da() {
      return (jn & (bo | Wc)) !== Is ? ai() : (pE !== Rr || (pE = ai()), pE);
    }
    function Mg(a) {
      var c = a.mode;
      if ((c & Ot) === Rt)
        return Nt;
      if ((jn & bo) !== Is && Rs !== Ue)
        return tg(Rs);
      var g = pie() !== fie;
      if (g) {
        if (So.transition !== null) {
          var b = So.transition;
          b._updatedFibers || (b._updatedFibers = /* @__PURE__ */ new Set()), b._updatedFibers.add(a);
        }
        return Uk === Ni && (Uk = eA()), Uk;
      }
      var C = ul();
      if (C !== Ni)
        return C;
      var I = Qne();
      return I;
    }
    function boe(a) {
      var c = a.mode;
      return (c & Ot) === Rt ? Nt : Zo();
    }
    function Ds(a, c, g, b) {
      Voe(), U6 && o("useInsertionEffect must not schedule updates."), Ej && ($k = !0), sf(a, g, b), (jn & bo) !== Ue && a === Ma ? Koe(c) : (Aa && mb(a, c, g), Yoe(c), a === Ma && ((jn & bo) === Is && (cE = dn(cE, g)), Ms === aE && Dg(a, Rs)), Sl(a, b), g === Nt && jn === Is && (c.mode & Ot) === Rt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !zu.isBatchingLegacy && (dE(), UB()));
    }
    function xoe(a, c, g) {
      var b = a.current;
      b.lanes = c, sf(a, c, g), Sl(a, g);
    }
    function woe(a) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (jn & bo) !== Is
      );
    }
    function Sl(a, c) {
      var g = a.callbackNode;
      XP(a, c);
      var b = nf(a, a === Ma ? Rs : Ue);
      if (b === Ue) {
        g !== null && rH(g), a.callbackNode = null, a.callbackPriority = Ni;
        return;
      }
      var C = Ei(b), I = a.callbackPriority;
      if (I === C && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(zu.current !== null && g !== Rj)) {
        g == null && I !== Nt && o("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      g != null && rH(g);
      var N;
      if (C === Nt)
        a.tag === xg ? (zu.isBatchingLegacy !== null && (zu.didScheduleLegacyUpdate = !0), qre(V6.bind(null, a))) : zB(V6.bind(null, a)), zu.current !== null ? zu.current.push(wg) : ere(function() {
          (jn & (bo | Wc)) === Is && wg();
        }), N = null;
      else {
        var H;
        switch (_s(b)) {
          case _i:
            H = HS;
            break;
          case Tu:
            H = Xh;
            break;
          case jc:
            H = Lc;
            break;
          case ng:
            H = VS;
            break;
          default:
            H = Lc;
            break;
        }
        N = Mj(H, B6.bind(null, a));
      }
      a.callbackPriority = C, a.callbackNode = N;
    }
    function B6(a, c) {
      if (zie(), pE = Rr, Uk = Ue, (jn & (bo | Wc)) !== Is)
        throw new Error("Should not already be working.");
      var g = a.callbackNode, b = wf();
      if (b && a.callbackNode !== g)
        return null;
      var C = nf(a, a === Ma ? Rs : Ue);
      if (C === Ue)
        return null;
      var I = !uv(a, C) && !JP(a, C) && !c, N = I ? Moe(a, C) : Vk(a, C);
      if (N !== Sf) {
        if (N === Nv) {
          var H = Rd(a);
          H !== Ue && (C = H, N = _j(a, H));
        }
        if (N === oE) {
          var V = lE;
          throw $v(a, Ue), Dg(a, C), Sl(a, ai()), V;
        }
        if (N === vj)
          Dg(a, C);
        else {
          var ee = !uv(a, C), re = a.current.alternate;
          if (ee && !Eoe(re)) {
            if (N = Vk(a, C), N === Nv) {
              var me = Rd(a);
              me !== Ue && (C = me, N = _j(a, me));
            }
            if (N === oE) {
              var pe = lE;
              throw $v(a, Ue), Dg(a, C), Sl(a, ai()), pe;
            }
          }
          a.finishedWork = re, a.finishedLanes = C, Coe(a, N, C);
        }
      }
      return Sl(a, ai()), a.callbackNode === g ? B6.bind(null, a) : null;
    }
    function _j(a, c) {
      var g = uE;
      if (vb(a)) {
        var b = $v(a, c);
        b.flags |= mi, Hre(a.containerInfo);
      }
      var C = Vk(a, c);
      if (C !== Nv) {
        var I = yl;
        yl = g, I !== null && H6(I);
      }
      return C;
    }
    function H6(a) {
      yl === null ? yl = a : yl.push.apply(yl, a);
    }
    function Coe(a, c, g) {
      switch (c) {
        case Sf:
        case oE:
          throw new Error("Root did not complete. This is a bug in React.");
        case Nv: {
          zv(a, yl, bf);
          break;
        }
        case Lk: {
          if (Dg(a, g), qP(g) && // do not delay if we're inside an act() scope
          !iH()) {
            var b = Sj + F6 - ai();
            if (b > 10) {
              var C = nf(a, Ue);
              if (C !== Ue)
                break;
              var I = a.suspendedLanes;
              if (!rf(I, g)) {
                Da(), pb(a, I);
                break;
              }
              a.timeoutHandle = wO(zv.bind(null, a, yl, bf), b);
              break;
            }
          }
          zv(a, yl, bf);
          break;
        }
        case aE: {
          if (Dg(a, g), QP(g))
            break;
          if (!iH()) {
            var N = KP(a, g), H = N, V = ai() - H, ee = Hoe(V) - V;
            if (ee > 10) {
              a.timeoutHandle = wO(zv.bind(null, a, yl, bf), ee);
              break;
            }
          }
          zv(a, yl, bf);
          break;
        }
        case N6: {
          zv(a, yl, bf);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function Eoe(a) {
      for (var c = a; ; ) {
        if (c.flags & ev) {
          var g = c.updateQueue;
          if (g !== null) {
            var b = g.stores;
            if (b !== null)
              for (var C = 0; C < b.length; C++) {
                var I = b[C], N = I.getSnapshot, H = I.value;
                try {
                  if (!bt(N(), H))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var V = c.child;
        if (c.subtreeFlags & ev && V !== null) {
          V.return = c, c = V;
          continue;
        }
        if (c === a)
          return !0;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === a)
            return !0;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return !0;
    }
    function Dg(a, c) {
      c = dv(c, Nk), c = dv(c, cE), nA(a, c);
    }
    function V6(a) {
      if (Uie(), (jn & (bo | Wc)) !== Is)
        throw new Error("Should not already be working.");
      wf();
      var c = nf(a, Ue);
      if (!Qo(c, Nt))
        return Sl(a, ai()), null;
      var g = Vk(a, c);
      if (a.tag !== xg && g === Nv) {
        var b = Rd(a);
        b !== Ue && (c = b, g = _j(a, b));
      }
      if (g === oE) {
        var C = lE;
        throw $v(a, Ue), Dg(a, c), Sl(a, ai()), C;
      }
      if (g === vj)
        throw new Error("Root did not complete. This is a bug in React.");
      var I = a.current.alternate;
      return a.finishedWork = I, a.finishedLanes = c, zv(a, yl, bf), Sl(a, ai()), null;
    }
    function _oe(a, c) {
      c !== Ue && (iC(a, dn(c, Nt)), Sl(a, ai()), (jn & (bo | Wc)) === Is && (dE(), wg()));
    }
    function Tj(a, c) {
      var g = jn;
      jn |= j6;
      try {
        return a(c);
      } finally {
        jn = g, jn === Is && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !zu.isBatchingLegacy && (dE(), UB());
      }
    }
    function Toe(a, c, g, b, C) {
      var I = ul(), N = So.transition;
      try {
        return So.transition = null, vi(_i), a(c, g, b, C);
      } finally {
        vi(I), So.transition = N, jn === Is && dE();
      }
    }
    function xf(a) {
      Rg !== null && Rg.tag === xg && (jn & (bo | Wc)) === Is && wf();
      var c = jn;
      jn |= j6;
      var g = So.transition, b = ul();
      try {
        return So.transition = null, vi(_i), a ? a() : void 0;
      } finally {
        vi(b), So.transition = g, jn = c, (jn & (bo | Wc)) === Is && wg();
      }
    }
    function W6() {
      return (jn & (bo | Wc)) !== Is;
    }
    function Hk(a, c) {
      ta(yj, Wd, a), Wd = dn(Wd, c);
    }
    function Pj(a) {
      Wd = yj.current, ea(yj, a);
    }
    function $v(a, c) {
      a.finishedWork = null, a.finishedLanes = Ue;
      var g = a.timeoutHandle;
      if (g !== CO && (a.timeoutHandle = CO, Jne(g)), Pi !== null)
        for (var b = Pi.return; b !== null; ) {
          var C = b.alternate;
          b6(C, b), b = b.return;
        }
      Ma = a;
      var I = Uv(a.current, null);
      return Pi = I, Rs = Wd = c, Ms = Sf, lE = null, jk = Ue, cE = Ue, Nk = Ue, uE = null, yl = null, xie(), Mu.discardPendingWarnings(), I;
    }
    function G6(a, c) {
      do {
        var g = Pi;
        try {
          if (JA(), m4(), Cr(), mj.current = null, g === null || g.return === null) {
            Ms = oE, lE = c, Pi = null;
            return;
          }
          if (nt && g.mode & rn && Ak(g, !0), je)
            if (Xo(), c !== null && typeof c == "object" && typeof c.then == "function") {
              var b = c;
              Zh(g, b, Rs);
            } else
              rv(g, c, Rs);
          qie(a, g.return, g, c, Rs), q6(g);
        } catch (C) {
          c = C, Pi === g && g !== null ? (g = g.return, Pi = g) : g = Pi;
          continue;
        }
        return;
      } while (!0);
    }
    function K6() {
      var a = gj.current;
      return gj.current = Ck, a === null ? Ck : a;
    }
    function Y6(a) {
      gj.current = a;
    }
    function Poe() {
      Sj = ai();
    }
    function gE(a) {
      jk = dn(a, jk);
    }
    function Aoe() {
      Ms === Sf && (Ms = Lk);
    }
    function Aj() {
      (Ms === Sf || Ms === Lk || Ms === Nv) && (Ms = aE), Ma !== null && (cv(jk) || cv(cE)) && Dg(Ma, Rs);
    }
    function koe(a) {
      Ms !== aE && (Ms = Nv), uE === null ? uE = [a] : uE.push(a);
    }
    function Ioe() {
      return Ms === Sf;
    }
    function Vk(a, c) {
      var g = jn;
      jn |= bo;
      var b = K6();
      if (Ma !== a || Rs !== c) {
        if (Aa) {
          var C = a.memoizedUpdaters;
          C.size > 0 && (mE(a, Rs), C.clear()), sC(a, c);
        }
        bf = fv(), $v(a, c);
      }
      Zr(c);
      do
        try {
          Roe();
          break;
        } catch (I) {
          G6(a, I);
        }
      while (!0);
      if (JA(), jn = g, Y6(b), Pi !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return XS(), Ma = null, Rs = Ue, Ms;
    }
    function Roe() {
      for (; Pi !== null; )
        X6(Pi);
    }
    function Moe(a, c) {
      var g = jn;
      jn |= bo;
      var b = K6();
      if (Ma !== a || Rs !== c) {
        if (Aa) {
          var C = a.memoizedUpdaters;
          C.size > 0 && (mE(a, Rs), C.clear()), sC(a, c);
        }
        bf = fv(), dE(), $v(a, c);
      }
      Zr(c);
      do
        try {
          Doe();
          break;
        } catch (I) {
          G6(a, I);
        }
      while (!0);
      return JA(), Y6(b), jn = g, Pi !== null ? (YS(), Sf) : (XS(), Ma = null, Rs = Ue, Ms);
    }
    function Doe() {
      for (; Pi !== null && !BS(); )
        X6(Pi);
    }
    function X6(a) {
      var c = a.alternate;
      Jn(a);
      var g;
      (a.mode & rn) !== Rt ? (RL(a), g = kj(c, a, Wd), Ak(a, !0)) : g = kj(c, a, Wd), Cr(), a.memoizedProps = a.pendingProps, g === null ? q6(a) : Pi = g, mj.current = null;
    }
    function q6(a) {
      var c = a;
      do {
        var g = c.alternate, b = c.return;
        if ((c.flags & _a) === zt) {
          Jn(c);
          var C = void 0;
          if ((c.mode & rn) === Rt ? C = S6(g, c, Wd) : (RL(c), C = S6(g, c, Wd), Ak(c, !1)), Cr(), C !== null) {
            Pi = C;
            return;
          }
        } else {
          var I = Ase(g, c);
          if (I !== null) {
            I.flags &= jP, Pi = I;
            return;
          }
          if ((c.mode & rn) !== Rt) {
            Ak(c, !1);
            for (var N = c.actualDuration, H = c.child; H !== null; )
              N += H.actualDuration, H = H.sibling;
            c.actualDuration = N;
          }
          if (b !== null)
            b.flags |= _a, b.subtreeFlags = zt, b.deletions = null;
          else {
            Ms = vj, Pi = null;
            return;
          }
        }
        var V = c.sibling;
        if (V !== null) {
          Pi = V;
          return;
        }
        c = b, Pi = c;
      } while (c !== null);
      Ms === Sf && (Ms = N6);
    }
    function zv(a, c, g) {
      var b = ul(), C = So.transition;
      try {
        So.transition = null, vi(_i), Ooe(a, c, g, b);
      } finally {
        So.transition = C, vi(b);
      }
      return null;
    }
    function Ooe(a, c, g, b) {
      do
        wf();
      while (Rg !== null);
      if (Woe(), (jn & (bo | Wc)) !== Is)
        throw new Error("Should not already be working.");
      var C = a.finishedWork, I = a.finishedLanes;
      if (Ad(I), C === null)
        return WS(), null;
      if (I === Ue && o("root.finishedLanes should not be empty during a commit. This is a bug in React."), a.finishedWork = null, a.finishedLanes = Ue, C === a.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      a.callbackNode = null, a.callbackPriority = Ni;
      var N = dn(C.lanes, C.childLanes);
      gb(a, N), a === Ma && (Ma = null, Pi = null, Rs = Ue), ((C.subtreeFlags & sl) !== zt || (C.flags & sl) !== zt) && (Fv || (Fv = !0, wj = g, Mj(Lc, function() {
        return wf(), null;
      })));
      var H = (C.subtreeFlags & (Bp | Ko | Hs | sl)) !== zt, V = (C.flags & (Bp | Ko | Hs | sl)) !== zt;
      if (H || V) {
        var ee = So.transition;
        So.transition = null;
        var re = ul();
        vi(_i);
        var me = jn;
        jn |= Wc, mj.current = null, Dse(a, C), U4(), Kse(a, C, I), Gne(a.containerInfo), a.current = C, qw(I), Yse(C, a, I), Kp(), $P(), jn = me, vi(re), So.transition = ee;
      } else
        a.current = C, U4();
      var pe = Fv;
      if (Fv ? (Fv = !1, Rg = a, hE = I) : (c0 = 0, zk = null), N = a.pendingLanes, N === Ue && (l0 = null), pe || eH(a.current, !1), Vp(C.stateNode, b), Aa && a.memoizedUpdaters.clear(), foe(), Sl(a, ai()), c !== null)
        for (var Ae = a.onRecoverableError, Re = 0; Re < c.length; Re++) {
          var Oe = c[Re], ot = Oe.stack, Ht = Oe.digest;
          Ae(Oe.value, {
            componentStack: ot,
            digest: Ht
          });
        }
      if (Fk) {
        Fk = !1;
        var Lt = bj;
        throw bj = null, Lt;
      }
      return Qo(hE, Nt) && a.tag !== xg && wf(), N = a.pendingLanes, Qo(N, Nt) ? ($ie(), a === Cj ? fE++ : (fE = 0, Cj = a)) : fE = 0, wg(), WS(), null;
    }
    function wf() {
      if (Rg !== null) {
        var a = _s(hE), c = KD(jc, a), g = So.transition, b = ul();
        try {
          return So.transition = null, vi(c), joe();
        } finally {
          vi(b), So.transition = g;
        }
      }
      return !1;
    }
    function Loe(a) {
      xj.push(a), Fv || (Fv = !0, Mj(Lc, function() {
        return wf(), null;
      }));
    }
    function joe() {
      if (Rg === null)
        return !1;
      var a = wj;
      wj = null;
      var c = Rg, g = hE;
      if (Rg = null, hE = Ue, (jn & (bo | Wc)) !== Is)
        throw new Error("Cannot flush passive effects while already rendering.");
      Ej = !0, $k = !1, WP(g);
      var b = jn;
      jn |= Wc, toe(c.current), Zse(c, c.current, g, a);
      {
        var C = xj;
        xj = [];
        for (var I = 0; I < C.length; I++) {
          var N = C[I];
          Nse(c, N);
        }
      }
      Zw(), eH(c.current, !0), jn = b, wg(), $k ? c === zk ? c0++ : (c0 = 0, zk = c) : c0 = 0, Ej = !1, $k = !1, ll(c);
      {
        var H = c.current.stateNode;
        H.effectDuration = 0, H.passiveEffectDuration = 0;
      }
      return !0;
    }
    function Z6(a) {
      return l0 !== null && l0.has(a);
    }
    function Noe(a) {
      l0 === null ? l0 = /* @__PURE__ */ new Set([a]) : l0.add(a);
    }
    function Foe(a) {
      Fk || (Fk = !0, bj = a);
    }
    var $oe = Foe;
    function Q6(a, c, g) {
      var b = Lv(g, c), C = X4(a, b, Nt), I = Eg(a, C, Nt), N = Da();
      I !== null && (sf(I, Nt, N), Sl(I, N));
    }
    function Br(a, c, g) {
      if (Ise(g), vE(!1), a.tag === m) {
        Q6(a, a, g);
        return;
      }
      var b = null;
      for (b = c; b !== null; ) {
        if (b.tag === m) {
          Q6(b, a, g);
          return;
        } else if (b.tag === d) {
          var C = b.type, I = b.stateNode;
          if (typeof C.getDerivedStateFromError == "function" || typeof I.componentDidCatch == "function" && !Z6(I)) {
            var N = Lv(g, a), H = XL(b, N, Nt), V = Eg(b, H, Nt), ee = Da();
            V !== null && (sf(V, Nt, ee), Sl(V, ee));
            return;
          }
        }
        b = b.return;
      }
      o(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, g);
    }
    function zoe(a, c, g) {
      var b = a.pingCache;
      b !== null && b.delete(c);
      var C = Da();
      pb(a, g), Xoe(a), Ma === a && rf(Rs, g) && (Ms === aE || Ms === Lk && qP(Rs) && ai() - Sj < F6 ? $v(a, Ue) : Nk = dn(Nk, g)), Sl(a, C);
    }
    function J6(a, c) {
      c === Ni && (c = boe(a));
      var g = Da(), b = ml(a, c);
      b !== null && (sf(b, c, g), Sl(b, g));
    }
    function Uoe(a) {
      var c = a.memoizedState, g = Ni;
      c !== null && (g = c.retryLane), J6(a, g);
    }
    function Boe(a, c) {
      var g = Ni, b;
      switch (a.tag) {
        case $:
          b = a.stateNode;
          var C = a.memoizedState;
          C !== null && (g = C.retryLane);
          break;
        case te:
          b = a.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      b !== null && b.delete(c), J6(a, g);
    }
    function Hoe(a) {
      return a < 120 ? 120 : a < 480 ? 480 : a < 1080 ? 1080 : a < 1920 ? 1920 : a < 3e3 ? 3e3 : a < 4320 ? 4320 : moe(a / 1960) * 1960;
    }
    function Voe() {
      if (fE > yoe)
        throw fE = 0, Cj = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      c0 > Soe && (c0 = 0, zk = null, o("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function Woe() {
      Mu.flushLegacyContextWarning(), Mu.flushPendingUnsafeLifecycleWarnings();
    }
    function eH(a, c) {
      Jn(a), Wk(a, Go, uoe), c && Wk(a, Yh, doe), Wk(a, Go, loe), c && Wk(a, Yh, coe), Cr();
    }
    function Wk(a, c, g) {
      for (var b = a, C = null; b !== null; ) {
        var I = b.subtreeFlags & c;
        b !== C && b.child !== null && I !== zt ? b = b.child : ((b.flags & c) !== zt && g(b), b.sibling !== null ? b = b.sibling : b = C = b.return);
      }
    }
    var Gk = null;
    function tH(a) {
      {
        if ((jn & bo) !== Is || !(a.mode & Ot))
          return;
        var c = a.tag;
        if (c !== f && c !== m && c !== d && c !== u && c !== M && c !== U && c !== F)
          return;
        var g = tn(a) || "ReactComponent";
        if (Gk !== null) {
          if (Gk.has(g))
            return;
          Gk.add(g);
        } else
          Gk = /* @__PURE__ */ new Set([g]);
        var b = Fr;
        try {
          Jn(a), o("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          b ? Jn(a) : Cr();
        }
      }
    }
    var kj;
    {
      var Goe = null;
      kj = function(a, c, g) {
        var b = cH(Goe, c);
        try {
          return p6(a, c, g);
        } catch (I) {
          if (iie() || I !== null && typeof I == "object" && typeof I.then == "function")
            throw I;
          if (JA(), m4(), b6(a, c), cH(c, b), c.mode & rn && RL(c), Kh(null, p6, null, a, c, g), BD()) {
            var C = Uw();
            typeof C == "object" && C !== null && C._suppressLogging && typeof I == "object" && I !== null && !I._suppressLogging && (I._suppressLogging = !0);
          }
          throw I;
        }
      };
    }
    var nH = !1, Ij;
    Ij = /* @__PURE__ */ new Set();
    function Koe(a) {
      if (gi && !jie())
        switch (a.tag) {
          case u:
          case M:
          case F: {
            var c = Pi && tn(Pi) || "Unknown", g = c;
            if (!Ij.has(g)) {
              Ij.add(g);
              var b = tn(a) || "Unknown";
              o("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", b, c, c);
            }
            break;
          }
          case d: {
            nH || (o("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), nH = !0);
            break;
          }
        }
    }
    function mE(a, c) {
      if (Aa) {
        var g = a.memoizedUpdaters;
        g.forEach(function(b) {
          mb(a, b, c);
        });
      }
    }
    var Rj = {};
    function Mj(a, c) {
      {
        var g = zu.current;
        return g !== null ? (g.push(c), Rj) : US(a, c);
      }
    }
    function rH(a) {
      if (a !== Rj)
        return FP(a);
    }
    function iH() {
      return zu.current !== null;
    }
    function Yoe(a) {
      {
        if (a.mode & Ot) {
          if (!L6())
            return;
        } else if (!goe() || jn !== Is || a.tag !== u && a.tag !== M && a.tag !== F)
          return;
        if (zu.current === null) {
          var c = Fr;
          try {
            Jn(a), o(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, tn(a));
          } finally {
            c ? Jn(a) : Cr();
          }
        }
      }
    }
    function Xoe(a) {
      a.tag !== xg && L6() && zu.current === null && o(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function vE(a) {
      U6 = a;
    }
    var Gc = null, u0 = null, qoe = function(a) {
      Gc = a;
    };
    function d0(a) {
      {
        if (Gc === null)
          return a;
        var c = Gc(a);
        return c === void 0 ? a : c.current;
      }
    }
    function Dj(a) {
      return d0(a);
    }
    function Oj(a) {
      {
        if (Gc === null)
          return a;
        var c = Gc(a);
        if (c === void 0) {
          if (a != null && typeof a.render == "function") {
            var g = d0(a.render);
            if (a.render !== g) {
              var b = {
                $$typeof: Ke,
                render: g
              };
              return a.displayName !== void 0 && (b.displayName = a.displayName), b;
            }
          }
          return a;
        }
        return c.current;
      }
    }
    function sH(a, c) {
      {
        if (Gc === null)
          return !1;
        var g = a.elementType, b = c.type, C = !1, I = typeof b == "object" && b !== null ? b.$$typeof : null;
        switch (a.tag) {
          case d: {
            typeof b == "function" && (C = !0);
            break;
          }
          case u: {
            (typeof b == "function" || I === Bt) && (C = !0);
            break;
          }
          case M: {
            (I === Ke || I === Bt) && (C = !0);
            break;
          }
          case U:
          case F: {
            (I === bn || I === Bt) && (C = !0);
            break;
          }
          default:
            return !1;
        }
        if (C) {
          var N = Gc(g);
          if (N !== void 0 && N === Gc(b))
            return !0;
        }
        return !1;
      }
    }
    function oH(a) {
      {
        if (Gc === null || typeof WeakSet != "function")
          return;
        u0 === null && (u0 = /* @__PURE__ */ new WeakSet()), u0.add(a);
      }
    }
    var Zoe = function(a, c) {
      {
        if (Gc === null)
          return;
        var g = c.staleFamilies, b = c.updatedFamilies;
        wf(), xf(function() {
          Lj(a.current, b, g);
        });
      }
    }, Qoe = function(a, c) {
      {
        if (a.context !== Zl)
          return;
        wf(), xf(function() {
          yE(c, a, null, null);
        });
      }
    };
    function Lj(a, c, g) {
      {
        var b = a.alternate, C = a.child, I = a.sibling, N = a.tag, H = a.type, V = null;
        switch (N) {
          case u:
          case F:
          case d:
            V = H;
            break;
          case M:
            V = H.render;
            break;
        }
        if (Gc === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var ee = !1, re = !1;
        if (V !== null) {
          var me = Gc(V);
          me !== void 0 && (g.has(me) ? re = !0 : c.has(me) && (N === d ? re = !0 : ee = !0));
        }
        if (u0 !== null && (u0.has(a) || b !== null && u0.has(b)) && (re = !0), re && (a._debugNeedsRemount = !0), re || ee) {
          var pe = ml(a, Nt);
          pe !== null && Ds(pe, a, Nt, Rr);
        }
        C !== null && !re && Lj(C, c, g), I !== null && Lj(I, c, g);
      }
    }
    var Joe = function(a, c) {
      {
        var g = /* @__PURE__ */ new Set(), b = new Set(c.map(function(C) {
          return C.current;
        }));
        return jj(a.current, b, g), g;
      }
    };
    function jj(a, c, g) {
      {
        var b = a.child, C = a.sibling, I = a.tag, N = a.type, H = null;
        switch (I) {
          case u:
          case F:
          case d:
            H = N;
            break;
          case M:
            H = N.render;
            break;
        }
        var V = !1;
        H !== null && c.has(H) && (V = !0), V ? eae(a, g) : b !== null && jj(b, c, g), C !== null && jj(C, c, g);
      }
    }
    function eae(a, c) {
      {
        var g = tae(a, c);
        if (g)
          return;
        for (var b = a; ; ) {
          switch (b.tag) {
            case S:
              c.add(b.stateNode);
              return;
            case v:
              c.add(b.stateNode.containerInfo);
              return;
            case m:
              c.add(b.stateNode.containerInfo);
              return;
          }
          if (b.return === null)
            throw new Error("Expected to reach root first.");
          b = b.return;
        }
      }
    }
    function tae(a, c) {
      for (var g = a, b = !1; ; ) {
        if (g.tag === S)
          b = !0, c.add(g.stateNode);
        else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === a)
          return b;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === a)
            return b;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
      return !1;
    }
    var Nj;
    {
      Nj = !1;
      try {
        var aH = Object.preventExtensions({});
      } catch {
        Nj = !0;
      }
    }
    function nae(a, c, g, b) {
      this.tag = a, this.key = g, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = c, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = b, this.flags = zt, this.subtreeFlags = zt, this.deletions = null, this.lanes = Ue, this.childLanes = Ue, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Nj && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ql = function(a, c, g, b) {
      return new nae(a, c, g, b);
    };
    function Fj(a) {
      var c = a.prototype;
      return !!(c && c.isReactComponent);
    }
    function rae(a) {
      return typeof a == "function" && !Fj(a) && a.defaultProps === void 0;
    }
    function iae(a) {
      if (typeof a == "function")
        return Fj(a) ? d : u;
      if (a != null) {
        var c = a.$$typeof;
        if (c === Ke)
          return M;
        if (c === bn)
          return U;
      }
      return f;
    }
    function Uv(a, c) {
      var g = a.alternate;
      g === null ? (g = Ql(a.tag, c, a.key, a.mode), g.elementType = a.elementType, g.type = a.type, g.stateNode = a.stateNode, g._debugSource = a._debugSource, g._debugOwner = a._debugOwner, g._debugHookTypes = a._debugHookTypes, g.alternate = a, a.alternate = g) : (g.pendingProps = c, g.type = a.type, g.flags = zt, g.subtreeFlags = zt, g.deletions = null, g.actualDuration = 0, g.actualStartTime = -1), g.flags = a.flags & Cs, g.childLanes = a.childLanes, g.lanes = a.lanes, g.child = a.child, g.memoizedProps = a.memoizedProps, g.memoizedState = a.memoizedState, g.updateQueue = a.updateQueue;
      var b = a.dependencies;
      switch (g.dependencies = b === null ? null : {
        lanes: b.lanes,
        firstContext: b.firstContext
      }, g.sibling = a.sibling, g.index = a.index, g.ref = a.ref, g.selfBaseDuration = a.selfBaseDuration, g.treeBaseDuration = a.treeBaseDuration, g._debugNeedsRemount = a._debugNeedsRemount, g.tag) {
        case f:
        case u:
        case F:
          g.type = d0(a.type);
          break;
        case d:
          g.type = Dj(a.type);
          break;
        case M:
          g.type = Oj(a.type);
          break;
      }
      return g;
    }
    function sae(a, c) {
      a.flags &= Cs | $r;
      var g = a.alternate;
      if (g === null)
        a.childLanes = Ue, a.lanes = c, a.child = null, a.subtreeFlags = zt, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null, a.selfBaseDuration = 0, a.treeBaseDuration = 0;
      else {
        a.childLanes = g.childLanes, a.lanes = g.lanes, a.child = g.child, a.subtreeFlags = zt, a.deletions = null, a.memoizedProps = g.memoizedProps, a.memoizedState = g.memoizedState, a.updateQueue = g.updateQueue, a.type = g.type;
        var b = g.dependencies;
        a.dependencies = b === null ? null : {
          lanes: b.lanes,
          firstContext: b.firstContext
        }, a.selfBaseDuration = g.selfBaseDuration, a.treeBaseDuration = g.treeBaseDuration;
      }
      return a;
    }
    function oae(a, c, g) {
      var b;
      return a === HA ? (b = Ot, c === !0 && (b |= Sn, b |= ka)) : b = Rt, Aa && (b |= rn), Ql(m, null, null, b);
    }
    function $j(a, c, g, b, C, I) {
      var N = f, H = a;
      if (typeof a == "function")
        Fj(a) ? (N = d, H = Dj(H)) : H = d0(H);
      else if (typeof a == "string")
        N = S;
      else
        e: switch (a) {
          case bs:
            return Og(g.children, C, I, c);
          case as:
            N = A, C |= Sn, (C & Ot) !== Rt && (C |= ka);
            break;
          case Ja:
            return aae(g, C, I, c);
          case Pt:
            return lae(g, C, I, c);
          case en:
            return cae(g, C, I, c);
          case fr:
            return lH(g, C, I, c);
          case Yn:
          case fn:
          case ls:
          case el:
          case pi:
          default: {
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case de:
                  N = R;
                  break e;
                case Be:
                  N = P;
                  break e;
                case Ke:
                  N = M, H = Oj(H);
                  break e;
                case bn:
                  N = U;
                  break e;
                case Bt:
                  N = B, H = null;
                  break e;
              }
            var V = "";
            {
              (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (V += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var ee = b ? tn(b) : null;
              ee && (V += `

Check the render method of \`` + ee + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (a == null ? a : typeof a) + "." + V));
          }
        }
      var re = Ql(N, g, c, C);
      return re.elementType = a, re.type = H, re.lanes = I, re._debugOwner = b, re;
    }
    function zj(a, c, g) {
      var b = null;
      b = a._owner;
      var C = a.type, I = a.key, N = a.props, H = $j(C, I, N, b, c, g);
      return H._debugSource = a._source, H._debugOwner = a._owner, H;
    }
    function Og(a, c, g, b) {
      var C = Ql(E, a, b, c);
      return C.lanes = g, C;
    }
    function aae(a, c, g, b) {
      typeof a.id != "string" && o('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof a.id);
      var C = Ql(j, a, b, c | rn);
      return C.elementType = Ja, C.lanes = g, C.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, C;
    }
    function lae(a, c, g, b) {
      var C = Ql($, a, b, c);
      return C.elementType = Pt, C.lanes = g, C;
    }
    function cae(a, c, g, b) {
      var C = Ql(te, a, b, c);
      return C.elementType = en, C.lanes = g, C;
    }
    function lH(a, c, g, b) {
      var C = Ql(K, a, b, c);
      C.elementType = fr, C.lanes = g;
      var I = {
        isHidden: !1
      };
      return C.stateNode = I, C;
    }
    function Uj(a, c, g) {
      var b = Ql(w, a, null, c);
      return b.lanes = g, b;
    }
    function uae() {
      var a = Ql(S, null, null, Rt);
      return a.elementType = "DELETED", a;
    }
    function dae(a) {
      var c = Ql(X, null, null, Rt);
      return c.stateNode = a, c;
    }
    function Bj(a, c, g) {
      var b = a.children !== null ? a.children : [], C = Ql(v, b, a.key, c);
      return C.lanes = g, C.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: a.implementation
      }, C;
    }
    function cH(a, c) {
      return a === null && (a = Ql(f, null, null, Rt)), a.tag = c.tag, a.key = c.key, a.elementType = c.elementType, a.type = c.type, a.stateNode = c.stateNode, a.return = c.return, a.child = c.child, a.sibling = c.sibling, a.index = c.index, a.ref = c.ref, a.pendingProps = c.pendingProps, a.memoizedProps = c.memoizedProps, a.updateQueue = c.updateQueue, a.memoizedState = c.memoizedState, a.dependencies = c.dependencies, a.mode = c.mode, a.flags = c.flags, a.subtreeFlags = c.subtreeFlags, a.deletions = c.deletions, a.lanes = c.lanes, a.childLanes = c.childLanes, a.alternate = c.alternate, a.actualDuration = c.actualDuration, a.actualStartTime = c.actualStartTime, a.selfBaseDuration = c.selfBaseDuration, a.treeBaseDuration = c.treeBaseDuration, a._debugSource = c._debugSource, a._debugOwner = c._debugOwner, a._debugNeedsRemount = c._debugNeedsRemount, a._debugHookTypes = c._debugHookTypes, a;
    }
    function hae(a, c, g, b, C) {
      this.tag = c, this.containerInfo = a, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = CO, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Ni, this.eventTimes = hv(Ue), this.expirationTimes = hv(Rr), this.pendingLanes = Ue, this.suspendedLanes = Ue, this.pingedLanes = Ue, this.expiredLanes = Ue, this.mutableReadLanes = Ue, this.finishedLanes = Ue, this.entangledLanes = Ue, this.entanglements = hv(Ue), this.identifierPrefix = b, this.onRecoverableError = C, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var I = this.pendingUpdatersLaneMap = [], N = 0; N < ov; N++)
          I.push(/* @__PURE__ */ new Set());
      }
      switch (c) {
        case HA:
          this._debugRootType = g ? "hydrateRoot()" : "createRoot()";
          break;
        case xg:
          this._debugRootType = g ? "hydrate()" : "render()";
          break;
      }
    }
    function uH(a, c, g, b, C, I, N, H, V, ee) {
      var re = new hae(a, c, g, H, V), me = oae(c, I);
      re.current = me, me.stateNode = re;
      {
        var pe = {
          element: b,
          isDehydrated: g,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        me.memoizedState = pe;
      }
      return tL(me), re;
    }
    var Hj = "18.3.1";
    function fae(a, c, g) {
      var b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Nr(b), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: os,
        key: b == null ? null : "" + b,
        children: a,
        containerInfo: c,
        implementation: g
      };
    }
    var Vj, Wj;
    Vj = !1, Wj = {};
    function dH(a) {
      if (!a)
        return Zl;
      var c = nl(a), g = Xre(c);
      if (c.tag === d) {
        var b = c.type;
        if (Fd(b))
          return FB(c, b, g);
      }
      return g;
    }
    function pae(a, c) {
      {
        var g = nl(a);
        if (g === void 0) {
          if (typeof a.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var b = Object.keys(a).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + b);
        }
        var C = ol(g);
        if (C === null)
          return null;
        if (C.mode & Sn) {
          var I = tn(g) || "Component";
          if (!Wj[I]) {
            Wj[I] = !0;
            var N = Fr;
            try {
              Jn(C), g.mode & Sn ? o("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", c, c, I) : o("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", c, c, I);
            } finally {
              N ? Jn(N) : Cr();
            }
          }
        }
        return C.stateNode;
      }
    }
    function hH(a, c, g, b, C, I, N, H) {
      var V = !1, ee = null;
      return uH(a, c, V, ee, g, b, C, I, N);
    }
    function fH(a, c, g, b, C, I, N, H, V, ee) {
      var re = !0, me = uH(g, b, re, a, C, I, N, H, V);
      me.context = dH(null);
      var pe = me.current, Ae = Da(), Re = Mg(pe), Oe = vf(Ae, Re);
      return Oe.callback = c ?? null, Eg(pe, Oe, Re), xoe(me, Re, Ae), me;
    }
    function yE(a, c, g, b) {
      Xw(c, a);
      var C = c.current, I = Da(), N = Mg(C);
      Qw(N);
      var H = dH(g);
      c.context === null ? c.context = H : c.pendingContext = H, gi && Fr !== null && !Vj && (Vj = !0, o(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, tn(Fr) || "Unknown"));
      var V = vf(I, N);
      V.payload = {
        element: a
      }, b = b === void 0 ? null : b, b !== null && (typeof b != "function" && o("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", b), V.callback = b);
      var ee = Eg(C, V, N);
      return ee !== null && (Ds(ee, C, N, I), ik(ee, C, N)), N;
    }
    function Kk(a) {
      var c = a.current;
      if (!c.child)
        return null;
      switch (c.child.tag) {
        case S:
          return c.child.stateNode;
        default:
          return c.child.stateNode;
      }
    }
    function gae(a) {
      switch (a.tag) {
        case m: {
          var c = a.stateNode;
          if (vb(c)) {
            var g = tC(c);
            _oe(c, g);
          }
          break;
        }
        case $: {
          xf(function() {
            var C = ml(a, Nt);
            if (C !== null) {
              var I = Da();
              Ds(C, a, Nt, I);
            }
          });
          var b = Nt;
          Gj(a, b);
          break;
        }
      }
    }
    function pH(a, c) {
      var g = a.memoizedState;
      g !== null && g.dehydrated !== null && (g.retryLane = tA(g.retryLane, c));
    }
    function Gj(a, c) {
      pH(a, c);
      var g = a.alternate;
      g && pH(g, c);
    }
    function mae(a) {
      if (a.tag === $) {
        var c = lv, g = ml(a, c);
        if (g !== null) {
          var b = Da();
          Ds(g, a, c, b);
        }
        Gj(a, c);
      }
    }
    function vae(a) {
      if (a.tag === $) {
        var c = Mg(a), g = ml(a, c);
        if (g !== null) {
          var b = Da();
          Ds(g, a, c, b);
        }
        Gj(a, c);
      }
    }
    function gH(a) {
      var c = NP(a);
      return c === null ? null : c.stateNode;
    }
    var mH = function(a) {
      return null;
    };
    function yae(a) {
      return mH(a);
    }
    var vH = function(a) {
      return !1;
    };
    function Sae(a) {
      return vH(a);
    }
    var yH = null, SH = null, bH = null, xH = null, wH = null, CH = null, EH = null, _H = null, TH = null;
    {
      var PH = function(a, c, g) {
        var b = c[g], C = Pn(a) ? a.slice() : on({}, a);
        return g + 1 === c.length ? (Pn(C) ? C.splice(b, 1) : delete C[b], C) : (C[b] = PH(a[b], c, g + 1), C);
      }, AH = function(a, c) {
        return PH(a, c, 0);
      }, kH = function(a, c, g, b) {
        var C = c[b], I = Pn(a) ? a.slice() : on({}, a);
        if (b + 1 === c.length) {
          var N = g[b];
          I[N] = I[C], Pn(I) ? I.splice(C, 1) : delete I[C];
        } else
          I[C] = kH(
            // $FlowFixMe number or string is fine here
            a[C],
            c,
            g,
            b + 1
          );
        return I;
      }, IH = function(a, c, g) {
        if (c.length !== g.length) {
          s("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var b = 0; b < g.length - 1; b++)
            if (c[b] !== g[b]) {
              s("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return kH(a, c, g, 0);
      }, RH = function(a, c, g, b) {
        if (g >= c.length)
          return b;
        var C = c[g], I = Pn(a) ? a.slice() : on({}, a);
        return I[C] = RH(a[C], c, g + 1, b), I;
      }, MH = function(a, c, g) {
        return RH(a, c, 0, g);
      }, Kj = function(a, c) {
        for (var g = a.memoizedState; g !== null && c > 0; )
          g = g.next, c--;
        return g;
      };
      yH = function(a, c, g, b) {
        var C = Kj(a, c);
        if (C !== null) {
          var I = MH(C.memoizedState, g, b);
          C.memoizedState = I, C.baseState = I, a.memoizedProps = on({}, a.memoizedProps);
          var N = ml(a, Nt);
          N !== null && Ds(N, a, Nt, Rr);
        }
      }, SH = function(a, c, g) {
        var b = Kj(a, c);
        if (b !== null) {
          var C = AH(b.memoizedState, g);
          b.memoizedState = C, b.baseState = C, a.memoizedProps = on({}, a.memoizedProps);
          var I = ml(a, Nt);
          I !== null && Ds(I, a, Nt, Rr);
        }
      }, bH = function(a, c, g, b) {
        var C = Kj(a, c);
        if (C !== null) {
          var I = IH(C.memoizedState, g, b);
          C.memoizedState = I, C.baseState = I, a.memoizedProps = on({}, a.memoizedProps);
          var N = ml(a, Nt);
          N !== null && Ds(N, a, Nt, Rr);
        }
      }, xH = function(a, c, g) {
        a.pendingProps = MH(a.memoizedProps, c, g), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var b = ml(a, Nt);
        b !== null && Ds(b, a, Nt, Rr);
      }, wH = function(a, c) {
        a.pendingProps = AH(a.memoizedProps, c), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var g = ml(a, Nt);
        g !== null && Ds(g, a, Nt, Rr);
      }, CH = function(a, c, g) {
        a.pendingProps = IH(a.memoizedProps, c, g), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var b = ml(a, Nt);
        b !== null && Ds(b, a, Nt, Rr);
      }, EH = function(a) {
        var c = ml(a, Nt);
        c !== null && Ds(c, a, Nt, Rr);
      }, _H = function(a) {
        mH = a;
      }, TH = function(a) {
        vH = a;
      };
    }
    function bae(a) {
      var c = ol(a);
      return c === null ? null : c.stateNode;
    }
    function xae(a) {
      return null;
    }
    function wae() {
      return Fr;
    }
    function Cae(a) {
      var c = a.findFiberByHostInstance, g = e.ReactCurrentDispatcher;
      return Yw({
        bundleType: a.bundleType,
        version: a.version,
        rendererPackageName: a.rendererPackageName,
        rendererConfig: a.rendererConfig,
        overrideHookState: yH,
        overrideHookStateDeletePath: SH,
        overrideHookStateRenamePath: bH,
        overrideProps: xH,
        overridePropsDeletePath: wH,
        overridePropsRenamePath: CH,
        setErrorHandler: _H,
        setSuspenseHandler: TH,
        scheduleUpdate: EH,
        currentDispatcherRef: g,
        findHostInstanceByFiber: bae,
        findFiberByHostInstance: c || xae,
        // React Refresh
        findHostInstancesForRefresh: Joe,
        scheduleRefresh: Zoe,
        scheduleRoot: Qoe,
        setRefreshHandler: qoe,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: wae,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: Hj
      });
    }
    var DH = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(a) {
      console.error(a);
    };
    function Yj(a) {
      this._internalRoot = a;
    }
    Yk.prototype.render = Yj.prototype.render = function(a) {
      var c = this._internalRoot;
      if (c === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? o("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Xk(arguments[1]) ? o("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && o("You passed a second argument to root.render(...) but it only accepts one argument.");
        var g = c.containerInfo;
        if (g.nodeType !== Li) {
          var b = gH(c.current);
          b && b.parentNode !== g && o("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      yE(a, c, null, null);
    }, Yk.prototype.unmount = Yj.prototype.unmount = function() {
      typeof arguments[0] == "function" && o("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var a = this._internalRoot;
      if (a !== null) {
        this._internalRoot = null;
        var c = a.containerInfo;
        W6() && o("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), xf(function() {
          yE(null, a, null, null);
        }), DB(c);
      }
    };
    function Eae(a, c) {
      if (!Xk(a))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      OH(a);
      var g = !1, b = !1, C = "", I = DH;
      c != null && (c.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof c == "object" && c !== null && c.$$typeof === xa && o(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), c.unstable_strictMode === !0 && (g = !0), c.identifierPrefix !== void 0 && (C = c.identifierPrefix), c.onRecoverableError !== void 0 && (I = c.onRecoverableError), c.transitionCallbacks !== void 0 && c.transitionCallbacks);
      var N = hH(a, HA, null, g, b, C, I);
      jA(N.current, a);
      var H = a.nodeType === Li ? a.parentNode : a;
      return EC(H), new Yj(N);
    }
    function Yk(a) {
      this._internalRoot = a;
    }
    function _ae(a) {
      a && qD(a);
    }
    Yk.prototype.unstable_scheduleHydration = _ae;
    function Tae(a, c, g) {
      if (!Xk(a))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      OH(a), c === void 0 && o("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var b = g ?? null, C = g != null && g.hydratedSources || null, I = !1, N = !1, H = "", V = DH;
      g != null && (g.unstable_strictMode === !0 && (I = !0), g.identifierPrefix !== void 0 && (H = g.identifierPrefix), g.onRecoverableError !== void 0 && (V = g.onRecoverableError));
      var ee = fH(c, null, a, HA, b, I, N, H, V);
      if (jA(ee.current, a), EC(a), C)
        for (var re = 0; re < C.length; re++) {
          var me = C[re];
          Iie(ee, me);
        }
      return new Yk(ee);
    }
    function Xk(a) {
      return !!(a && (a.nodeType === Ho || a.nodeType === Kl || a.nodeType === Uh || !ye));
    }
    function SE(a) {
      return !!(a && (a.nodeType === Ho || a.nodeType === Kl || a.nodeType === Uh || a.nodeType === Li && a.nodeValue === " react-mount-point-unstable "));
    }
    function OH(a) {
      a.nodeType === Ho && a.tagName && a.tagName.toUpperCase() === "BODY" && o("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), LC(a) && (a._reactRootContainer ? o("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : o("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var Pae = e.ReactCurrentOwner, LH;
    LH = function(a) {
      if (a._reactRootContainer && a.nodeType !== Li) {
        var c = gH(a._reactRootContainer.current);
        c && c.parentNode !== a && o("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var g = !!a._reactRootContainer, b = Xj(a), C = !!(b && Sg(b));
      C && !g && o("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), a.nodeType === Ho && a.tagName && a.tagName.toUpperCase() === "BODY" && o("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function Xj(a) {
      return a ? a.nodeType === Kl ? a.documentElement : a.firstChild : null;
    }
    function jH() {
    }
    function Aae(a, c, g, b, C) {
      if (C) {
        if (typeof b == "function") {
          var I = b;
          b = function() {
            var pe = Kk(N);
            I.call(pe);
          };
        }
        var N = fH(
          c,
          b,
          a,
          xg,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          jH
        );
        a._reactRootContainer = N, jA(N.current, a);
        var H = a.nodeType === Li ? a.parentNode : a;
        return EC(H), xf(), N;
      } else {
        for (var V; V = a.lastChild; )
          a.removeChild(V);
        if (typeof b == "function") {
          var ee = b;
          b = function() {
            var pe = Kk(re);
            ee.call(pe);
          };
        }
        var re = hH(
          a,
          xg,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          jH
        );
        a._reactRootContainer = re, jA(re.current, a);
        var me = a.nodeType === Li ? a.parentNode : a;
        return EC(me), xf(function() {
          yE(c, re, g, b);
        }), re;
      }
    }
    function kae(a, c) {
      a !== null && typeof a != "function" && o("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", c, a);
    }
    function qk(a, c, g, b, C) {
      LH(g), kae(C === void 0 ? null : C, "render");
      var I = g._reactRootContainer, N;
      if (!I)
        N = Aae(g, c, a, C, b);
      else {
        if (N = I, typeof C == "function") {
          var H = C;
          C = function() {
            var V = Kk(N);
            H.call(V);
          };
        }
        yE(c, N, a, C);
      }
      return Kk(N);
    }
    var NH = !1;
    function Iae(a) {
      {
        NH || (NH = !0, o("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var c = Pae.current;
        if (c !== null && c.stateNode !== null) {
          var g = c.stateNode._warnedAboutRefsInRender;
          g || o("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ln(c.type) || "A component"), c.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return a == null ? null : a.nodeType === Ho ? a : pae(a, "findDOMNode");
    }
    function Rae(a, c, g) {
      if (o("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !SE(c))
        throw new Error("Target container is not a DOM element.");
      {
        var b = LC(c) && c._reactRootContainer === void 0;
        b && o("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return qk(null, a, c, !0, g);
    }
    function Mae(a, c, g) {
      if (o("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !SE(c))
        throw new Error("Target container is not a DOM element.");
      {
        var b = LC(c) && c._reactRootContainer === void 0;
        b && o("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return qk(null, a, c, !1, g);
    }
    function Dae(a, c, g, b) {
      if (o("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !SE(g))
        throw new Error("Target container is not a DOM element.");
      if (a == null || !Jm(a))
        throw new Error("parentComponent must be a valid React Component");
      return qk(a, c, g, !1, b);
    }
    var FH = !1;
    function Oae(a) {
      if (FH || (FH = !0, o("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !SE(a))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var c = LC(a) && a._reactRootContainer === void 0;
        c && o("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (a._reactRootContainer) {
        {
          var g = Xj(a), b = g && !Sg(g);
          b && o("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return xf(function() {
          qk(null, null, a, !1, function() {
            a._reactRootContainer = null, DB(a);
          });
        }), !0;
      } else {
        {
          var C = Xj(a), I = !!(C && Sg(C)), N = a.nodeType === Ho && SE(a.parentNode) && !!a.parentNode._reactRootContainer;
          I && o("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", N ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    sg(gae), YD(mae), Sb(vae), iA(ul), sA(Gs), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && o("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), OP(jne), jS(Tj, Toe, xf);
    function Lae(a, c) {
      var g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Xk(c))
        throw new Error("Target container is not a DOM element.");
      return fae(a, c, null, g);
    }
    function jae(a, c, g, b) {
      return Dae(a, c, g, b);
    }
    var qj = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Sg, Bb, NA, LS, qm, Tj]
    };
    function Nae(a, c) {
      return qj.usingClientEntryPoint || o('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), Eae(a, c);
    }
    function Fae(a, c, g) {
      return qj.usingClientEntryPoint || o('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), Tae(a, c, g);
    }
    function $ae(a) {
      return W6() && o("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), xf(a);
    }
    var zae = Cae({
      findFiberByHostInstance: Tv,
      bundleType: 1,
      version: Hj,
      rendererPackageName: "react-dom"
    });
    if (!zae && pt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var $H = window.location.protocol;
      /^(https?|file):$/.test($H) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + ($H === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    xl.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = qj, xl.createPortal = Lae, xl.createRoot = Nae, xl.findDOMNode = Iae, xl.flushSync = $ae, xl.hydrate = Rae, xl.hydrateRoot = Fae, xl.render = Mae, xl.unmountComponentAtNode = Oae, xl.unstable_batchedUpdates = Tj, xl.unstable_renderSubtreeIntoContainer = jae, xl.version = Hj, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), xl;
}
function aY() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(aY);
    } catch (n) {
      console.error(n);
    }
  }
}
process.env.NODE_ENV === "production" ? (aY(), S3.exports = Ybe()) : S3.exports = Xbe();
var xS = S3.exports;
const qbe = /* @__PURE__ */ Ep(xS);
var b3, hI = xS;
if (process.env.NODE_ENV === "production")
  b3 = hI.createRoot, hI.hydrateRoot;
else {
  var B9 = hI.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  b3 = function(n, t) {
    B9.usingClientEntryPoint = !0;
    try {
      return hI.createRoot(n, t);
    } finally {
      B9.usingClientEntryPoint = !1;
    }
  };
}
const G0 = "TLDRAW_TAB_ID_v2", wh = globalThis.window;
function Zbe() {
  return wh ? ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line deprecation/deprecation
    wh.navigator.platform
  ) || // iPad on iOS 13 detection
  wh.navigator.userAgent.includes("Mac") && "ontouchend" in document : !1;
}
const PM = wh ? wh[G0] ?? EG(G0) ?? "TLDRAW_INSTANCE_STATE_V1_" + Ii() : "<error>";
wh && (wh[G0] = PM, Zbe() ? e5(G0, PM) : _G(G0));
wh == null || wh.addEventListener("beforeunload", () => {
  e5(G0, PM);
});
const lY = {
  Initial: 0
}, j2 = Math.max(...Object.values(lY));
function Qbe(n) {
  n.version < lY.Initial, n.version = j2;
}
const cY = Mn({
  version: Jt,
  currentPageId: U1,
  isFocusMode: kn,
  exportBackground: kn,
  isDebugMode: kn,
  isToolLocked: kn,
  isGridMode: kn,
  pageStates: Ro(
    Mn({
      pageId: U1,
      camera: Mn({
        x: Jt,
        y: Jt,
        z: Jt
      }),
      selectedShapeIds: Ro(eu),
      focusedGroupId: eu.nullable()
    })
  )
});
function Jbe(n) {
  if (!n || typeof n != "object")
    return console.warn("Invalid instance state"), null;
  if (!("version" in n) || typeof n.version != "number")
    return console.warn("No version in instance state"), null;
  n.version !== j2 && (n = ni(n), Qbe(n));
  try {
    return cY.validate(n);
  } catch (t) {
    return console.warn(t), null;
  }
}
function uY(n) {
  const t = n.query.ids("page");
  return ze("sessionStateSnapshot", () => {
    const e = n.get(za);
    if (!e) return null;
    const r = [...t.get()];
    return {
      version: j2,
      currentPageId: e.currentPageId,
      exportBackground: e.exportBackground,
      isFocusMode: e.isFocusMode,
      isDebugMode: e.isDebugMode,
      isToolLocked: e.isToolLocked,
      isGridMode: e.isGridMode,
      pageStates: r.map((i) => {
        const s = n.get(sd.createId(i)), o = n.get(vh.createId(i));
        return {
          pageId: i,
          camera: {
            x: (o == null ? void 0 : o.x) ?? 0,
            y: (o == null ? void 0 : o.y) ?? 0,
            z: (o == null ? void 0 : o.z) ?? 1
          },
          selectedShapeIds: (s == null ? void 0 : s.selectedShapeIds) ?? [],
          focusedGroupId: (s == null ? void 0 : s.focusedGroupId) ?? null
        };
      })
    };
  });
}
function dY(n, t) {
  const e = Jbe(t);
  if (!e) return;
  const r = n.schema.types.instance.create({
    id: za,
    ...XG(n.get(za)),
    currentPageId: e.currentPageId,
    isDebugMode: e.isDebugMode,
    isFocusMode: e.isFocusMode,
    isToolLocked: e.isToolLocked,
    isGridMode: e.isGridMode,
    exportBackground: e.exportBackground
  }), i = n.allRecords().filter((s) => s.typeName === "instance_page_state" || s.typeName === "camera");
  n.atomic(() => {
    n.remove(i.map((s) => s.id));
    for (const s of e.pageStates)
      n.put([
        vh.create({
          id: vh.createId(s.pageId),
          x: s.camera.x,
          y: s.camera.y,
          z: s.camera.z
        }),
        sd.create({
          id: sd.createId(s.pageId),
          pageId: s.pageId,
          selectedShapeIds: s.selectedShapeIds,
          focusedGroupId: s.focusedGroupId
        })
      ]);
    n.put([r]), n.ensureStoreIsUsable();
  });
}
function e0e(n) {
  var i;
  const t = [];
  for (const s of Object.values(n))
    (i = s.typeName) != null && i.match(/^(instance.*|pointer|camera)$/) && t.push(s);
  const e = t.filter(
    (s) => s.typeName === "instance" && s.id !== za
  )[0];
  if (!e) return null;
  const r = {
    version: j2,
    currentPageId: e.currentPageId,
    exportBackground: !!e.exportBackground,
    isFocusMode: !!e.isFocusMode,
    isDebugMode: !!e.isDebugMode,
    isToolLocked: !!e.isToolLocked,
    isGridMode: !1,
    pageStates: t.filter((s) => s.typeName === "instance_page_state" && s.instanceId === e.id).map((s) => {
      const o = n[s.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: s.pageId,
        camera: {
          x: o.x,
          y: o.y,
          z: o.z
        },
        selectedShapeIds: s.selectedShapeIds,
        focusedGroupId: s.focusedGroupId
      };
    })
  };
  try {
    return cY.validate(r), r;
  } catch {
    return null;
  }
}
function hY(n, t) {
  let e = {};
  if ("store" in t) {
    const i = n.schema.migrateStoreSnapshot(t);
    if (i.type !== "success")
      throw new Error("Failed to migrate store snapshot: " + i.reason);
    e.document = {
      schema: n.schema.serialize(),
      store: _1(
        i.value,
        (s, { typeName: o }) => n.scopedTypes.document.has(o)
      )
    };
  } else
    e = t;
  const r = XG(n.get(za));
  n.atomic(() => {
    e.document && n.loadStoreSnapshot(e.document), r && n.update(za, (i) => ({ ...i, ...r })), e.session && dY(n, e.session);
  });
}
const t0e = new vp();
function n0e(n) {
  const e = t0e.get(n, uY).get();
  if (!e)
    throw new Error("Session state is not ready yet");
  return {
    document: n.getStoreSnapshot(),
    session: e
  };
}
function fY(n) {
  const t = [], e = /* @__PURE__ */ new Set();
  for (const r of n) {
    if (e.has(r.type))
      throw new Error(`Binding type "${r.type}" is defined more than once`);
    t.push(r), e.add(r.type);
  }
  return t;
}
function xm({ children: n, className: t = "", ...e }) {
  return /* @__PURE__ */ y.jsx("svg", { ...e, className: Vt("tl-svg-container", t), children: n });
}
function b5(n, t, e, r) {
  const i = n.x - e.x, s = n.y - e.y, o = r.x - e.x, l = r.y - e.y, u = t.x - n.x, d = t.y - n.y, f = o * s - l * i, m = u * s - d * i, v = l * u - o * d;
  if (f === 0 || m === 0 || v === 0) return null;
  if (v !== 0) {
    const S = f / v, w = m / v;
    if (0 <= S && S <= 1 && 0 <= w && w <= 1)
      return O.AddXY(n, S * u, S * d);
  }
  return null;
}
function WT(n, t, e, r) {
  const i = (t.x - n.x) * (t.x - n.x) + (t.y - n.y) * (t.y - n.y), s = 2 * ((t.x - n.x) * (n.x - e.x) + (t.y - n.y) * (n.y - e.y)), o = e.x * e.x + e.y * e.y + n.x * n.x + n.y * n.y - 2 * (e.x * n.x + e.y * n.y) - r * r, l = s * s - 4 * i * o;
  if (l < 0 || l === 0) return null;
  const u = Math.sqrt(l), d = (-s + u) / (2 * i), f = (-s - u) / (2 * i);
  if ((d < 0 || d > 1) && (f < 0 || f > 1))
    return null;
  const m = [];
  return 0 <= d && d <= 1 && m.push(O.Lrp(n, t, d)), 0 <= f && f <= 1 && m.push(O.Lrp(n, t, f)), m.length === 0 ? null : m;
}
function r0e(n, t, e) {
  const r = [];
  let i;
  for (let s = 0, o = e.length - 1; s < o; s++)
    i = b5(n, t, e[s], e[s + 1]), i && r.push(i);
  return r.length === 0 ? null : r;
}
function x5(n, t, e) {
  const r = [];
  let i;
  for (let s = 1, o = e.length; s < o + 1; s++)
    i = b5(
      n,
      t,
      e[s - 1],
      e[s % e.length]
    ), i && r.push(i);
  return r.length === 0 ? null : r;
}
function i0e(n, t, e, r) {
  let i = e.x - n.x, s = e.y - n.y;
  const o = Math.sqrt(i * i + s * s), l = (o * o - r * r + t * t) / (2 * o), u = Math.sqrt(t * t - l * l);
  return i /= o, s /= o, [
    new O(n.x + i * l - s * u, n.y + s * l + i * u),
    new O(n.x + i * l + s * u, n.y + s * l - i * u)
  ];
}
function x3(n, t, e) {
  const r = [];
  let i, s, o;
  for (let l = 0, u = e.length; l < u; l++)
    i = e[l], s = e[(l + 1) % e.length], o = WT(i, s, n, t), o && r.push(...o);
  return r.length === 0 ? null : r;
}
function H9(n, t, e) {
  const r = [];
  let i, s, o;
  for (let l = 1, u = e.length; l < u; l++)
    i = e[l - 1], s = e[l], o = WT(i, s, n, t), o && r.push(...o);
  return r.length === 0 ? null : r;
}
function fI(n, t, e) {
  return (e.y - n.y) * (t.x - n.x) > (t.y - n.y) * (e.x - n.x);
}
function w5(n, t, e, r) {
  return fI(n, e, r) !== fI(t, e, r) && fI(n, t, e) !== fI(n, t, r);
}
function V9(n, t) {
  const e = /* @__PURE__ */ new Map();
  let r, i, s, o;
  for (let l = 0, u = n.length; l < u; l++)
    if (r = n[l], yc(r, t)) {
      const d = ON(r);
      e.has(d) || e.set(d, r);
    }
  for (let l = 0, u = t.length; l < u; l++)
    if (r = t[l], yc(r, n)) {
      const d = ON(r);
      e.has(d) || e.set(d, r);
    }
  for (let l = 0, u = n.length; l < u; l++) {
    r = n[l], i = n[(l + 1) % n.length];
    for (let d = 0, f = t.length; d < f; d++) {
      s = t[d], o = t[(d + 1) % t.length];
      const m = b5(r, i, s, o);
      if (m !== null) {
        const v = ON(m);
        e.has(v) || e.set(v, m);
      }
    }
  }
  return e.size === 0 ? null : s0e([...e.values()]);
}
function ON(n) {
  return `${n.x},${n.y}`;
}
function s0e(n) {
  const t = O.Average(n);
  return n.sort((e, r) => O.Angle(t, e) - O.Angle(t, r));
}
function pY(n, t) {
  let e, r, i, s;
  for (let o = 0, l = n.length; o < l; o++) {
    e = n[o], r = n[(o + 1) % l];
    for (let u = 0, d = t.length; u < d; u++)
      if (i = t[u], s = t[(u + 1) % d], w5(e, r, i, s)) return !0;
  }
  return !1;
}
function o0e(n, t) {
  let e, r, i, s;
  for (let o = 0, l = n.length; o < l; o++) {
    e = n[o], r = n[(o + 1) % l];
    for (let u = 1, d = t.length; u < d; u++)
      if (i = t[u - 1], s = t[u], w5(e, r, i, s)) return !0;
  }
  return !1;
}
class ap extends Mm {
  constructor(e) {
    super({ ...e, isClosed: !1, isFilled: !1 });
    T(this, "start");
    T(this, "end");
    T(this, "d");
    T(this, "u");
    T(this, "ul");
    const { start: r, end: i } = e;
    this.start = r, this.end = i, this.d = r.clone().sub(i), this.u = this.d.clone().uni(), this.ul = this.u.len();
  }
  getLength() {
    return this.d.len();
  }
  midPoint() {
    return this.start.lrp(this.end, 0.5);
  }
  getVertices() {
    return [this.start, this.end];
  }
  nearestPoint(e) {
    const { start: r, end: i, u: s, ul: o } = this;
    if (o === 0) return r;
    const l = O.Sub(e, r).dpr(s) / o, u = r.x + s.x * l;
    if (u < Math.min(r.x, i.x)) return r.x < i.x ? r : i;
    if (u > Math.max(r.x, i.x)) return r.x > i.x ? r : i;
    const d = r.y + s.y * l;
    return d < Math.min(r.y, i.y) ? r.y < i.y ? r : i : d > Math.max(r.y, i.y) ? r.y > i.y ? r : i : new O(u, d);
  }
  hitTestLineSegment(e, r, i = 0) {
    return w5(e, r, this.start, this.end) || this.distanceToLineSegment(e, r) <= i;
  }
  getSvgPathData(e = !0) {
    const { start: r, end: i } = this;
    return `${e ? `M${r.toFixed()}` : ""} L${i.toFixed()}`;
  }
}
class pw extends Mm {
  constructor(e) {
    super({ isClosed: !1, isFilled: !1, ...e });
    T(this, "points");
    T(this, "_segments");
    const { points: r } = e;
    this.points = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices: e } = this;
      for (let r = 0, i = e.length - 1; r < i; r++) {
        const s = e[r], o = e[r + 1];
        this._segments.push(new ap({ start: s, end: o }));
      }
      this.isClosed && this._segments.push(new ap({ start: e[e.length - 1], end: e[0] }));
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((e, r) => e + r.length, 0);
  }
  getVertices() {
    return this.points;
  }
  nearestPoint(e) {
    const { segments: r } = this;
    let i = this.points[0], s = 1 / 0, o, l;
    for (let u = 0; u < r.length; u++)
      o = r[u].nearestPoint(e), l = O.Dist2(o, e), l < s && (i = o, s = l);
    if (!i) throw Error("nearest point not found");
    return i;
  }
  hitTestLineSegment(e, r, i = 0) {
    const { segments: s } = this;
    for (let o = 0, l = s.length; o < l; o++)
      if (s[o].hitTestLineSegment(e, r, i))
        return !0;
    return !1;
  }
  getSvgPathData() {
    const { vertices: e } = this;
    return e.length < 2 ? "" : e.reduce((r, i, s) => s === 0 ? `M ${i.x} ${i.y}` : `${r} L ${i.x} ${i.y}`, "");
  }
}
class Xi extends pw {
  constructor(t) {
    super({ ...t }), this.isClosed = !0;
  }
}
class Sp extends Xi {
  constructor(e) {
    const { x: r = 0, y: i = 0, width: s, height: o } = e;
    super({
      ...e,
      points: [
        new O(r, i),
        new O(r + s, i),
        new O(r + s, i + o),
        new O(r, i + o)
      ]
    });
    T(this, "x");
    T(this, "y");
    T(this, "w");
    T(this, "h");
    this.x = r, this.y = i, this.w = s, this.h = o;
  }
  getBounds() {
    return new vt(this.x, this.y, this.w, this.h);
  }
  getSvgPathData() {
    const { x: e, y: r, w: i, h: s } = this;
    return `M${e},${r} h${i} v${s} h-${i}z`;
  }
}
class ad {
  constructor(t) {
    /**
     * Whether the shape can be snapped to by another shape.
     *
     * @public
     */
    T(this, "canSnap", () => !0);
    /**
     * Whether the shape can be scrolled while editing.
     *
     * @public
     */
    T(this, "canScroll", () => !1);
    /**
     * Whether the shape can be double clicked to edit.
     *
     * @public
     */
    T(this, "canEdit", () => !1);
    /**
     * Whether the shape can be resized.
     *
     * @public
     */
    T(this, "canResize", () => !0);
    /**
     * Whether the shape can be edited in read-only mode.
     *
     * @public
     */
    T(this, "canEditInReadOnly", () => !1);
    /**
     * Whether the shape can be cropped.
     *
     * @public
     */
    T(this, "canCrop", () => !1);
    /**
     * Whether the shape participates in stacking, aligning, and distributing.
     *
     * @public
     */
    T(this, "canBeLaidOut", () => !0);
    /**
     * Whether the shape should hide its resize handles when selected.
     *
     * @public
     */
    T(this, "hideResizeHandles", () => !1);
    /**
     * Whether the shape should hide its rotation handles when selected.
     *
     * @public
     */
    T(this, "hideRotateHandle", () => !1);
    /**
     * Whether the shape should hide its selection bounds background when selected.
     *
     * @public
     */
    T(this, "hideSelectionBoundsBg", () => !1);
    /**
     * Whether the shape should hide its selection bounds foreground when selected.
     *
     * @public
     */
    T(this, "hideSelectionBoundsFg", () => !1);
    /**
     * Whether the shape's aspect ratio is locked.
     *
     * @public
     */
    T(this, "isAspectRatioLocked", () => !1);
    //  Events
    /**
     * A callback called just before a shape is created. This method provides a last chance to modify
     * the created shape.
     *
     * @example
     *
     * ```ts
     * onBeforeCreate = (next) => {
     * 	return { ...next, x: next.x + 1 }
     * }
     * ```
     *
     * @param next - The next shape.
     * @returns The next shape or void.
     * @public
     */
    T(this, "onBeforeCreate");
    /**
     * A callback called just before a shape is updated. This method provides a last chance to modify
     * the updated shape.
     *
     * @example
     *
     * ```ts
     * onBeforeUpdate = (prev, next) => {
     * 	if (prev.x === next.x) {
     * 		return { ...next, x: next.x + 1 }
     * 	}
     * }
     * ```
     *
     * @param prev - The previous shape.
     * @param next - The next shape.
     * @returns The next shape or void.
     * @public
     */
    T(this, "onBeforeUpdate");
    /**
     * A callback called when some other shapes are dragged over this one.
     *
     * @example
     *
     * ```ts
     * onDragShapesOver = (shape, shapes) => {
     * 	this.editor.reparentShapes(shapes, shape.id)
     * }
     * ```
     *
     * @param shape - The shape.
     * @param shapes - The shapes that are being dragged over this one.
     * @public
     */
    T(this, "onDragShapesOver");
    /**
     * A callback called when some other shapes are dragged out of this one.
     *
     * @param shape - The shape.
     * @param shapes - The shapes that are being dragged out.
     * @public
     */
    T(this, "onDragShapesOut");
    /**
     * A callback called when some other shapes are dropped over this one.
     *
     * @param shape - The shape.
     * @param shapes - The shapes that are being dropped over this one.
     * @public
     */
    T(this, "onDropShapesOver");
    /**
     * A callback called when a shape starts being resized.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onResizeStart");
    /**
     * A callback called when a shape changes from a resize.
     *
     * @param shape - The shape at the start of the resize.
     * @param info - Info about the resize.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onResize");
    /**
     * A callback called when a shape finishes resizing.
     *
     * @param initial - The shape at the start of the resize.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onResizeEnd");
    /**
     * A callback called when a shape starts being translated.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onTranslateStart");
    /**
     * A callback called when a shape changes from a translation.
     *
     * @param initial - The shape at the start of the translation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onTranslate");
    /**
     * A callback called when a shape finishes translating.
     *
     * @param initial - The shape at the start of the translation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onTranslateEnd");
    /**
     * A callback called when a shape's handle changes.
     *
     * @param shape - The current shape.
     * @param info - An object containing the handle and whether the handle is 'precise' or not.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onHandleDrag");
    /**
     * A callback called when a shape starts being rotated.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onRotateStart");
    /**
     * A callback called when a shape changes from a rotation.
     *
     * @param initial - The shape at the start of the rotation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onRotate");
    /**
     * A callback called when a shape finishes rotating.
     *
     * @param initial - The shape at the start of the rotation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onRotateEnd");
    /**
     * Not currently used.
     *
     * @internal
     */
    T(this, "onBindingChange");
    /**
     * A callback called when a shape's children change.
     *
     * @param shape - The shape.
     * @returns An array of shape updates, or void.
     * @public
     */
    T(this, "onChildrenChange");
    /**
     * A callback called when a shape's handle is double clicked.
     *
     * @param shape - The shape.
     * @param handle - The handle that is double-clicked.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onDoubleClickHandle");
    /**
     * A callback called when a shape's edge is double clicked.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onDoubleClickEdge");
    /**
     * A callback called when a shape is double clicked.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onDoubleClick");
    /**
     * A callback called when a shape is clicked.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    T(this, "onClick");
    /**
     * A callback called when a shape finishes being editing.
     *
     * @param shape - The shape.
     * @public
     */
    T(this, "onEditEnd");
    this.editor = t;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(t) {
    return !0;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(t) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(t, e) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(t, e) {
    return !1;
  }
  /** @internal */
  expandSelectionOutlinePx(t) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(t) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(t) {
    return {};
  }
}
/**
 * Props allow you to define the shape's properties in a way that the editor can understand.
 * This has two main uses:
 *
 * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
 * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
 *    once, and will be remembered from one shape to the next.
 *
 * @example
 * ```tsx
 * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
 *
 * type MyShape = TLBaseShape<'mine', {
 *      color: TLDefaultColorStyle,
 *      text: string,
 * }>
 *
 * class MyShapeUtil extends ShapeUtil<MyShape> {
 *     static props = {
 *         // we use tldraw's built-in color style:
 *         color: DefaultColorStyle,
 *         // validate that the text prop is a string:
 *         text: T.string,
 *     }
 * }
 * ```
 */
T(ad, "props"), /**
 * Migrations allow you to make changes to a shape's props over time. Read the
 * {@link https://staging.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
 * guide for more information.
 */
T(ad, "migrations"), /**
 * The type of the shape util, which should match the shape's type.
 *
 * @public
 */
T(ad, "type");
function a0e(n, t, e = {}) {
  const {
    closed: r = !1,
    snap: i = 1,
    start: s = "outset",
    end: o = "outset",
    lengthRatio: l = 2,
    style: u = "dashed"
  } = e;
  let d = 0, f = 0, m = 1, v = 0, S = 0;
  switch (u) {
    case "dashed": {
      m = 1, d = Math.min(t * l, n / 4);
      break;
    }
    case "dotted": {
      m = 100, d = t / m;
      break;
    }
    default:
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
  }
  return r || (s === "outset" ? (n += d / 2, S += d / 2) : s === "skip" && (n -= d, S -= d), o === "outset" ? n += d / 2 : o === "skip" && (n -= d)), f = Math.floor(n / d / (2 * m)), f -= f % i, f < 3 && u === "dashed" ? n / t < 5 ? (d = n, f = 1, v = 0) : (d = n * 0.333, v = n * 0.333) : (f = Math.max(f, 3), d = n / f / (2 * m), r ? (S = d / 2, v = (n - f * d) / f) : v = (n - f * d) / Math.max(1, f - 1)), {
    strokeDasharray: [d, v].join(" "),
    strokeDashoffset: S.toString()
  };
}
function W9({ bounds: n, className: t }) {
  const e = we(), r = De("zoom level", () => e.getZoomLevel(), [e]);
  return /* @__PURE__ */ y.jsx("g", { className: t, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: n.sides.map((i, s) => {
    const { strokeDasharray: o, strokeDashoffset: l } = a0e(
      i[0].dist(i[1]),
      1 / r,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ y.jsx(
      "line",
      {
        x1: i[0].x,
        y1: i[0].y,
        x2: i[1].x,
        y2: i[1].y,
        strokeDasharray: o,
        strokeDashoffset: l
      },
      s
    );
  }) });
}
class JI extends ad {
  constructor() {
    super(...arguments);
    T(this, "hideSelectionBoundsFg", () => !0);
    T(this, "canBind", () => !1);
    T(this, "onChildrenChange", (e) => {
      const r = this.editor.getSortedChildIdsForParent(e.id);
      if (r.length === 0) {
        this.editor.getCurrentPageState().focusedGroupId === e.id && this.editor.popFocusedGroupId(), this.editor.deleteShapes([e.id]);
        return;
      } else if (r.length === 1) {
        this.editor.getCurrentPageState().focusedGroupId === e.id && this.editor.popFocusedGroupId(), this.editor.reparentShapes(r, e.parentId), this.editor.deleteShapes([e.id]);
        return;
      }
    });
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(e) {
    const r = this.editor.getSortedChildIdsForParent(e.id);
    return r.length === 0 ? new Sp({ width: 1, height: 1, isFilled: !1 }) : new ld({
      children: r.map((i) => {
        const s = this.editor.getShape(i), o = this.editor.getShapeGeometry(i), l = this.editor.getShapeLocalTransform(s).applyToPoints(o.vertices);
        return o.isClosed ? new Xi({
          points: l,
          isFilled: !0
        }) : new pw({
          points: l
        });
      })
    });
  }
  component(e) {
    const r = this.editor.getErasingShapeIds().includes(e.id), { hintingShapeIds: i } = this.editor.getCurrentPageState(), s = i.length > 0 && i.some(
      (u) => u !== e.id && this.editor.isShapeOfType(this.editor.getShape(u), "group")
    ), o = this.editor.getCurrentPageState().focusedGroupId !== e.id;
    if (!r && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (o || s))
      return null;
    const l = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ y.jsx(xm, { id: e.id, children: /* @__PURE__ */ y.jsx(W9, { className: "tl-group", bounds: l }) });
  }
  indicator(e) {
    const r = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ y.jsx(W9, { className: "", bounds: r });
  }
}
T(JI, "type", "group"), T(JI, "props", aK), T(JI, "migrations", lK);
const gY = [
  // created by grouping interactions, probably the corest core shape that we have
  JI
], l0e = new Set(gY.map((n) => n.type));
function mY(n) {
  const t = [...gY], e = /* @__PURE__ */ new Set();
  for (const r of n) {
    if (l0e.has(r.type))
      throw new Error(
        `Shape type "${r.type}" is a core shapes type and cannot be overridden`
      );
    if (e.has(r.type))
      throw new Error(`Shape type "${r.type}" is defined more than once`);
    t.push(r), e.add(r.type);
  }
  return t;
}
const c0e = {
  maxShapesPerPage: 4e3,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  maxPointsPerDrawShape: 500,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16
};
function G9(n, t) {
  if (!t) return !1;
  switch (n.type) {
    case "mixed":
      return t.type === "mixed";
    case "shared":
      return t.type === "shared" && n.value === t.value;
    default:
      throw ma(n);
  }
}
class u0e {
  constructor(t) {
    /** @internal */
    T(this, "map");
    this.map = new Map(t);
  }
  get(t) {
    return this.map.get(t);
  }
  getAsKnownValue(t) {
    const e = this.get(t);
    if (e && e.type !== "mixed")
      return e.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(t) {
    if (this.size !== t.size) return !1;
    const e = /* @__PURE__ */ new Set();
    for (const [r, i] of this) {
      if (!G9(i, t.get(r))) return !1;
      e.add(r);
    }
    for (const [r, i] of t)
      if (!e.has(r) && !G9(i, this.get(r)))
        return !1;
    return !0;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
}
class w3 extends u0e {
  set(t, e) {
    this.map.set(t, e);
  }
  applyValue(t, e) {
    const r = this.get(t);
    if (!r) {
      this.set(t, { type: "shared", value: e });
      return;
    }
    switch (r.type) {
      case "mixed":
        return;
      case "shared":
        r.value !== e && this.set(t, { type: "mixed" });
        return;
      default:
        ma(r, "type");
    }
  }
}
function d0e(n, t, e) {
  return Th(n).then(function(r) {
    return r.arrayBuffer();
  }).then(function(r) {
    return new File([r], t, { type: e });
  });
}
const h0e = "https://cdn.tldraw.com";
function hm() {
  return `${h0e}/${wK}`;
}
function f0e(n, t) {
  var i;
  let e = n;
  const r = new Set(t);
  for (; r.has(e); )
    e = (i = /^.*(\d+)$/.exec(e)) != null && i[1] ? e.replace(/(\d+)(?=\D?)$/, (s) => (+s + 1).toString()) : `${e} 1`;
  return e;
}
function pI(n, t, e) {
  if (e.length === 0) return [];
  const r = /* @__PURE__ */ new Map();
  for (const s of xn(e.map((o) => n.getShape(o)))) {
    const { parentId: o } = s;
    r.has(o) || r.set(o, {
      children: xn(
        n.getSortedChildIdsForParent(o).map((l) => n.getShape(l))
      ),
      moving: /* @__PURE__ */ new Set()
    }), r.get(o).moving.add(s);
  }
  const i = [];
  switch (t) {
    case "toBack": {
      r.forEach(({ moving: s, children: o }) => p0e(s, o, i));
      break;
    }
    case "toFront": {
      r.forEach(({ moving: s, children: o }) => g0e(s, o, i));
      break;
    }
    case "forward": {
      r.forEach(({ moving: s, children: o }) => m0e(s, o, i));
      break;
    }
    case "backward": {
      r.forEach(({ moving: s, children: o }) => v0e(s, o, i));
      break;
    }
  }
  return i;
}
function p0e(n, t, e) {
  const r = t.length;
  if (n.size === r) return;
  let i, s;
  for (let o = 0; o < r; o++) {
    const l = t[o];
    if (n.has(l))
      i = l.index, n.delete(l);
    else {
      s = l.index;
      break;
    }
  }
  if (n.size !== 0) {
    const o = Zx(i, s, n.size);
    e.push(
      ...Array.from(n.values()).sort(fa).map((l, u) => ({ ...l, index: o[u] }))
    );
  }
}
function g0e(n, t, e) {
  const r = t.length;
  if (n.size === r) return;
  let i, s;
  for (let o = r - 1; o > -1; o--) {
    const l = t[o];
    if (n.has(l))
      s = l.index, n.delete(l);
    else {
      i = l.index;
      break;
    }
  }
  if (n.size !== 0) {
    const o = Zx(i, s, n.size);
    e.push(
      ...Array.from(n.values()).sort(fa).map((l, u) => ({ ...l, index: o[u] }))
    );
  }
}
function m0e(n, t, e) {
  var s;
  const r = t.length;
  if (n.size === r) return;
  let i = { name: "skipping" };
  for (let o = 0; o < r; o++) {
    const l = n.has(t[o]);
    switch (i.name) {
      case "skipping": {
        if (!l) continue;
        i = { name: "selecting", selectIndex: o };
        break;
      }
      case "selecting": {
        if (l) continue;
        const { selectIndex: u } = i;
        Zx(t[o].index, (s = t[o + 1]) == null ? void 0 : s.index, o - u).forEach(
          (d, f) => e.push({ ...t[u + f], index: d })
        ), i = { name: "skipping" };
        break;
      }
    }
  }
}
function v0e(n, t, e) {
  var s;
  const r = t.length;
  if (n.size === r) return;
  let i = { name: "skipping" };
  for (let o = r - 1; o > -1; o--) {
    const l = n.has(t[o]);
    switch (i.name) {
      case "skipping": {
        if (!l) continue;
        i = { name: "selecting", selectIndex: o };
        break;
      }
      case "selecting": {
        if (l) continue;
        Zx((s = t[o - 1]) == null ? void 0 : s.index, t[o].index, i.selectIndex - o).forEach(
          (u, d) => {
            e.push({ ...t[o + d + 1], index: u });
          }
        ), i = { name: "skipping" };
        break;
      }
    }
  }
}
function vY({ editor: n }) {
  const t = n.getSelectedShapes(), e = n.getSelectionRotation(), r = n.getSelectionRotatedPageBounds(), {
    inputs: { originPagePoint: i }
  } = n;
  if (!r)
    return null;
  const s = r.center.clone().rotWith(r.point, e);
  return {
    selectionPageCenter: s,
    initialCursorAngle: s.angle(i),
    initialSelectionRotation: e,
    shapeSnapshots: t.map((o) => ({
      shape: ni(o),
      initialPagePoint: n.getShapePageTransform(o.id).point()
    }))
  };
}
function eR({
  delta: n,
  editor: t,
  snapshot: e,
  stage: r
}) {
  const { selectionPageCenter: i, shapeSnapshots: s } = e;
  t.updateShapes(
    s.map(({ shape: l, initialPagePoint: u }) => {
      const d = kl(l.parentId) ? t.getShapePageTransform(l.parentId) : At.Identity(), f = O.RotWith(u, i, n), m = At.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        At.Inverse(d),
        f
      ), v = ym(l.rotation + n);
      return {
        id: l.id,
        type: l.type,
        x: m.x,
        y: m.y,
        rotation: v
      };
    })
  );
  const o = [];
  s.forEach(({ shape: l }) => {
    var m, v, S;
    const u = t.getShape(l.id);
    if (!u) return;
    const d = t.getShapeUtil(l);
    if (r === "start" || r === "one-off") {
      const w = (m = d.onRotateStart) == null ? void 0 : m.call(d, l);
      w && o.push(w);
    }
    const f = (v = d.onRotate) == null ? void 0 : v.call(d, l, u);
    if (f && o.push(f), r === "end" || r === "one-off") {
      const w = (S = d.onRotateEnd) == null ? void 0 : S.call(d, l, u);
      w && o.push(w);
    }
  }), o.length > 0 && t.updateShapes(o);
}
const y0e = (n) => {
  const { store: t } = n, e = t.query.filterHistory("binding"), r = t.query.records("binding");
  function i() {
    const s = r.get(), o = /* @__PURE__ */ new Map();
    for (const l of s) {
      const { fromId: u, toId: d } = l, f = o.get(u);
      f ? f.push(l) : o.set(u, [l]);
      const m = o.get(d);
      m ? m.push(l) : o.set(d, [l]);
    }
    return o;
  }
  return ze("arrowBindingsIndex", (s, o) => {
    if (Yy(s))
      return i();
    const l = s, u = e.getDiffSince(o);
    if (u === mc)
      return i();
    let d;
    function f(S) {
      d ?? (d = new Map(l));
      const w = d.get(S.fromId), E = w == null ? void 0 : w.filter((R) => R.id !== S.id);
      E != null && E.length ? d.set(S.fromId, E) : d.delete(S.fromId);
      const A = d.get(S.toId), P = A == null ? void 0 : A.filter((R) => R.id !== S.id);
      P != null && P.length ? d.set(S.toId, P) : d.delete(S.toId);
    }
    function m(S) {
      d ?? (d = new Map(l));
      let w = d.get(S);
      return w ? w === l.get(S) && (w = w.slice(0), d.set(S, w)) : (w = [], d.set(S, w)), w;
    }
    function v(S) {
      m(S.fromId).push(S), m(S.toId).push(S);
    }
    for (const S of u) {
      for (const w of zi(S.added))
        v(w);
      for (const [w, E] of zi(S.updated))
        f(w), v(E);
      for (const w of zi(S.removed))
        f(w);
    }
    return d ?? l;
  });
};
function S0e(n, t, e) {
  const r = n.getShapeMaskedPageBounds(t);
  return r === void 0 ? !0 : !e.includes(r);
}
const b0e = (n) => {
  function t(e) {
    const r = e.getCurrentPageShapeIds(), i = e.getViewportPageBounds(), s = /* @__PURE__ */ new Set();
    return r.forEach((o) => {
      S0e(e, o, i) && s.add(o);
    }), s;
  }
  return ze("getCulledShapes", (e) => {
    if (Yy(e))
      return t(n);
    const r = t(n);
    if (e.size !== r.size) return r;
    for (const i of e)
      if (!r.has(i))
        return r;
    return e;
  });
}, x0e = (n) => {
  const t = n.query.ids("shape"), e = n.query.filterHistory("shape");
  function r() {
    const i = {}, s = t.get(), o = Array(s.size);
    return s.forEach((l) => o.push(n.get(l))), o.sort(fa), o.forEach((l) => {
      i[l.parentId] || (i[l.parentId] = []), i[l.parentId].push(l.id);
    }), i;
  }
  return ze(
    "parentsToChildrenWithIndexes",
    (i, s) => {
      if (Yy(i))
        return r();
      const o = e.getDiffSince(s);
      if (o === mc)
        return r();
      if (o.length === 0) return i;
      let l = null;
      const u = (m) => {
        l || (l = { ...i }), l[m] ? l[m] === i[m] && (l[m] = [...l[m]]) : l[m] = [];
      }, d = /* @__PURE__ */ new Set();
      let f;
      for (let m = 0, v = o.length; m < v; m++) {
        f = o[m];
        for (const S of Object.values(f.added))
          N0(S) && (u(S.parentId), l[S.parentId].push(S.id), d.add(l[S.parentId]));
        for (const [S, w] of Object.values(f.updated))
          if (N0(w) && N0(S)) {
            if (S.parentId !== w.parentId)
              u(S.parentId), u(w.parentId), l[S.parentId].splice(l[S.parentId].indexOf(w.id), 1), l[w.parentId].push(w.id), d.add(l[w.parentId]);
            else if (S.index !== w.index) {
              u(w.parentId);
              const E = l[w.parentId].indexOf(w.id);
              l[w.parentId][E] = w.id, d.add(l[w.parentId]);
            }
          }
        for (const S of Object.values(f.removed))
          N0(S) && (u(S.parentId), l[S.parentId].splice(l[S.parentId].indexOf(S.id), 1));
      }
      for (const m of d) {
        const v = xn(m.map((S) => n.get(S)));
        v.sort(fa), m.splice(0, m.length, ...v.map((S) => S.id));
      }
      return l ?? i;
    }
  );
}, LN = (n, t, e) => {
  for (; !El(e.parentId); ) {
    const r = n.get(e.parentId);
    if (!r) return !1;
    e = r;
  }
  return e.parentId === t;
}, w0e = (n, t) => {
  const e = n.query.ids("shape");
  let r = null;
  function i() {
    const s = t();
    return r = s, new Set(
      [...e.get()].filter((o) => LN(n, s, n.get(o)))
    );
  }
  return ze("_shapeIdsInCurrentPage", (s, o) => {
    if (Yy(s))
      return i();
    const l = t();
    if (l !== r)
      return i();
    const u = n.history.getDiffSince(o);
    if (u === mc)
      return i();
    const d = new XI(
      s
    );
    for (const m of u) {
      for (const v of Object.values(m.added))
        N0(v) && LN(n, l, v) && d.add(v.id);
      for (const [v, S] of Object.values(m.updated))
        N0(S) && (LN(n, l, S) ? d.add(S.id) : d.remove(S.id));
      for (const v of Object.keys(m.removed))
        kl(v) && d.remove(v);
    }
    const f = d.get();
    return f ? KE(f.value, f.diff) : s;
  });
}, yY = D.createContext(null);
function C0e({
  context: n,
  editor: t,
  children: e
}) {
  return /* @__PURE__ */ y.jsx(M2.Provider, { value: t, children: /* @__PURE__ */ y.jsx(yY.Provider, { value: n, children: e }) });
}
function SY() {
  const n = D.useContext(yY);
  return n ? { isDarkMode: n.isDarkMode } : null;
}
async function E0e(n, t, e = {}) {
  var $, U;
  const r = typeof t[0] == "string" ? t : t.map((F) => F.id);
  if (r.length === 0) return;
  if (!window.document) throw Error("No document");
  const {
    scale: i = 1,
    background: s = !1,
    padding: o = n.options.defaultSvgPadding,
    preserveAspectRatio: l = !1
  } = e, u = e.darkMode ?? n.user.getIsDarkMode(), d = Pp({ isDarkMode: u }), f = n.getShapeAndDescendantIds(r), m = n.getUnorderedRenderingShapes(!1).filter(({ id: F }) => f.has(F));
  let v = null;
  if (e.bounds)
    v = e.bounds;
  else
    for (const { id: F } of m) {
      const B = n.getShapeMaskedPageBounds(F);
      B && (v ? v.union(B) : v = B.clone());
    }
  if (!v) return;
  const S = r.length === 1 && n.isShapeOfType(n.getShape(r[0]), "frame") ? r[0] : null;
  S || v.expandBy(o);
  const w = v.width * i, E = v.height * i;
  try {
    (U = ($ = document.body).focus) == null || U.call($);
  } catch {
  }
  const A = [], P = /* @__PURE__ */ new Map(), R = {
    isDarkMode: u,
    addExportDef: (F) => {
      if (P.has(F.key)) return;
      const B = (async () => {
        const G = await F.getElement();
        G && A.push(/* @__PURE__ */ y.jsx(D.Fragment, { children: G }, A.length));
      })();
      P.set(F.key, B);
    }
  }, M = (await Promise.all(
    m.map(async ({ id: F, opacity: B, index: G, backgroundIndex: X }) => {
      var ue, Se;
      if (F === S) return [];
      const te = n.getShape(F);
      if (n.isShapeOfType(te, "group")) return [];
      const ne = n.getShapeUtil(te);
      let K = await ((ue = ne.toSvg) == null ? void 0 : ue.call(ne, te, R)), Z = await ((Se = ne.toBackgroundSvg) == null ? void 0 : Se.call(ne, te, R));
      if (!K && !Z) {
        const ke = n.getShapePageBounds(te);
        K = /* @__PURE__ */ y.jsx(
          "rect",
          {
            width: ke.w,
            height: ke.h,
            fill: d.solid,
            stroke: d.grey.pattern,
            strokeWidth: 1
          }
        );
      }
      let oe = n.getShapePageTransform(te).toCssString();
      "scale" in te.props && te.props.scale !== 1 && (oe = `${oe} scale(${te.props.scale}, ${te.props.scale})`), K && (K = /* @__PURE__ */ y.jsx("g", { transform: oe, opacity: B, children: K }, te.id)), Z && (Z = /* @__PURE__ */ y.jsx("g", { transform: oe, opacity: B, children: Z }, `bg_${te.id}`));
      const fe = n.getShapeMask(te.id);
      if (fe) {
        const ke = `mask_${te.id.replace(":", "_")}`;
        A.push(
          /* @__PURE__ */ y.jsx("clipPath", { id: ke, children: /* @__PURE__ */ y.jsx("path", { d: `M${fe.map(({ x: ce, y: ye }) => `${ce},${ye}`).join("L")}Z` }) }, A.length)
        ), K && (K = /* @__PURE__ */ y.jsx("g", { clipPath: `url(#${ke})`, children: K }, te.id)), Z && (Z = /* @__PURE__ */ y.jsx("g", { clipPath: `url(#${ke})`, children: Z }, `bg_${te.id}`));
      }
      const ie = [];
      return K && ie.push({ zIndex: G, element: K }), Z && ie.push({ zIndex: X, element: Z }), ie;
    })
  )).flat();
  return await Promise.all(P.values()), { jsx: /* @__PURE__ */ y.jsx(C0e, { editor: n, context: R, children: /* @__PURE__ */ y.jsxs(
    "svg",
    {
      preserveAspectRatio: l || void 0,
      direction: "ltr",
      width: w,
      height: E,
      viewBox: `${v.minX} ${v.minY} ${v.width} ${v.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: {
        backgroundColor: s ? S ? d.solid : d.background : "transparent"
      },
      children: [
        /* @__PURE__ */ y.jsx("defs", { children: A }),
        M.sort((F, B) => F.zIndex - B.zIndex).map(({ element: F }) => F)
      ]
    }
  ) }), width: w, height: E };
}
const _0e = 40;
class T0e {
  constructor(t) {
    T(this, "_clickId", "");
    T(this, "_clickTimeout");
    T(this, "_clickScreenPoint");
    T(this, "_previousScreenPoint");
    T(this, "_getClickTimeout", (t, e = Ii()) => {
      this._clickId = e, clearTimeout(this._clickTimeout), this._clickTimeout = this.editor.timers.setTimeout(
        () => {
          if (this._clickState === t && this._clickId === e) {
            switch (this._clickState) {
              case "pendingTriple": {
                this.editor.dispatch({
                  ...this.lastPointerInfo,
                  type: "click",
                  name: "double_click",
                  phase: "settle"
                });
                break;
              }
              case "pendingQuadruple": {
                this.editor.dispatch({
                  ...this.lastPointerInfo,
                  type: "click",
                  name: "triple_click",
                  phase: "settle"
                });
                break;
              }
              case "pendingOverflow": {
                this.editor.dispatch({
                  ...this.lastPointerInfo,
                  type: "click",
                  name: "quadruple_click",
                  phase: "settle"
                });
                break;
              }
            }
            this._clickState = "idle";
          }
        },
        t === "idle" || t === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
      );
    });
    /**
     * The current click state.
     *
     * @internal
     */
    T(this, "_clickState", "idle");
    T(this, "lastPointerInfo", {});
    T(this, "handlePointerEvent", (t) => {
      switch (t.name) {
        case "pointer_down": {
          if (!this._clickState) return t;
          switch (this._clickScreenPoint = O.From(t.point), this._previousScreenPoint && O.Dist2(this._previousScreenPoint, this._clickScreenPoint) > _0e ** 2 && (this._clickState = "idle"), this._previousScreenPoint = this._clickScreenPoint, this.lastPointerInfo = t, this._clickState) {
            case "pendingDouble":
              return this._clickState = "pendingTriple", this._clickTimeout = this._getClickTimeout(this._clickState), {
                ...t,
                type: "click",
                name: "double_click",
                phase: "down"
              };
            case "pendingTriple":
              return this._clickState = "pendingQuadruple", this._clickTimeout = this._getClickTimeout(this._clickState), {
                ...t,
                type: "click",
                name: "triple_click",
                phase: "down"
              };
            case "pendingQuadruple":
              return this._clickState = "pendingOverflow", this._clickTimeout = this._getClickTimeout(this._clickState), {
                ...t,
                type: "click",
                name: "quadruple_click",
                phase: "down"
              };
            case "idle": {
              this._clickState = "pendingDouble";
              break;
            }
            case "pendingOverflow": {
              this._clickState = "overflow";
              break;
            }
          }
          return this._clickTimeout = this._getClickTimeout(this._clickState), t;
        }
        case "pointer_up": {
          if (!this._clickState) return t;
          switch (this._clickScreenPoint = O.From(t.point), this._clickState) {
            case "pendingTriple":
              return {
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "up"
              };
            case "pendingQuadruple":
              return {
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "up"
              };
            case "pendingOverflow":
              return {
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "up"
              };
          }
          return t;
        }
        case "pointer_move":
          return this._clickState !== "idle" && this._clickScreenPoint && O.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared) && this.cancelDoubleClickTimeout(), t;
      }
      return t;
    });
    /**
     * Cancel the double click timeout.
     *
     * @internal
     */
    T(this, "cancelDoubleClickTimeout", () => {
      this._clickTimeout = clearTimeout(this._clickTimeout), this._clickState = "idle";
    });
    this.editor = t;
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
}
class P0e {
  constructor(t) {
    T(this, "_isEdgeScrolling", !1);
    T(this, "_edgeScrollDuration", -1);
    this.editor = t;
  }
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(t) {
    const { editor: e } = this, r = this.getEdgeScroll();
    if (r.x === 0 && r.y === 0)
      this._isEdgeScrolling && (this._isEdgeScrolling = !1, this._edgeScrollDuration = 0);
    else if (this._isEdgeScrolling || (this._isEdgeScrolling = !0, this._edgeScrollDuration = 0), this._edgeScrollDuration += t, this._edgeScrollDuration > e.options.edgeScrollDelay) {
      const i = e.options.edgeScrollEaseDuration > 0 ? Js.easeInCubic(
        Math.min(
          1,
          this._edgeScrollDuration / (e.options.edgeScrollDelay + e.options.edgeScrollEaseDuration)
        )
      ) : 1;
      this.moveCameraWhenCloseToEdge({
        x: r.x * i,
        y: r.y * i
      });
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @internal
   */
  getEdgeProximityFactors(t, e, r, i, s) {
    const { editor: o } = this, l = o.options.edgeScrollDistance, u = r ? o.options.coarsePointerWidth : 0, d = t - u, f = t + u, m = i ? 0 : l, v = s ? e : e - l;
    return d < m ? Math.min(1, (m - d) / l) : f > v ? -Math.min(1, (f - v) / l) : 0;
  }
  getEdgeScroll() {
    const { editor: t } = this, {
      inputs: {
        currentScreenPoint: { x: e, y: r }
      }
    } = t, i = t.getViewportScreenBounds(), {
      isCoarsePointer: s,
      insets: [o, l, u, d]
    } = t.getInstanceState(), f = this.getEdgeProximityFactors(e, i.w, s, d, l), m = this.getEdgeProximityFactors(r, i.h, s, o, u);
    return {
      x: f,
      y: m
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(t) {
    const { editor: e } = this;
    if (!e.inputs.isDragging || e.inputs.isPanning || e.getCameraOptions().isLocked || t.x === 0 && t.y === 0) return;
    const r = e.getViewportScreenBounds(), i = r.w < 1e3 ? 0.612 : 1, s = r.h < 1e3 ? 0.612 : 1, o = e.getZoomLevel(), l = e.user.getEdgeScrollSpeed() * e.options.edgeScrollSpeed, u = l * t.x * i / o, d = l * t.y * s / o, { x: f, y: m, z: v } = e.getCamera();
    e.setCamera(new O(f + u, m + d, v));
  }
}
class A0e {
  constructor(t) {
    /**
     * Whether the editor is running in Safari.
     *
     * @public
     */
    T(this, "isSafari");
    /**
     * Whether the editor is running on iOS.
     *
     * @public
     */
    T(this, "isIos");
    /**
     * Whether the editor is running on iOS.
     *
     * @public
     */
    T(this, "isChromeForIos");
    /**
     * Whether the editor is running on Firefox.
     *
     * @public
     */
    T(this, "isFirefox");
    /**
     * Whether the editor is running on Android.
     *
     * @public
     */
    T(this, "isAndroid");
    this.editor = t, typeof window < "u" && "navigator" in window ? (this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i), this.isChromeForIos = /crios.*safari/i.test(navigator.userAgent), this.isFirefox = /firefox/i.test(navigator.userAgent), this.isAndroid = /android/i.test(navigator.userAgent)) : (this.isSafari = !1, this.isIos = !1, this.isChromeForIos = !1, this.isFirefox = !1, this.isAndroid = !1);
  }
}
class k0e {
  constructor(t, e) {
    T(this, "disposeSideEffectListener");
    this.editor = t, this.disposeSideEffectListener = t.sideEffects.registerAfterChangeHandler(
      "instance",
      (i, s) => {
        i.isFocused !== s.isFocused && (s.isFocused ? this.focus() : this.blur(), this.updateContainerClass());
      }
    );
    const r = t.getInstanceState().isFocused;
    e !== r && t.updateInstanceState({ isFocused: !!e }), this.updateContainerClass();
  }
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const t = this.editor.getContainer();
    this.editor.getInstanceState().isFocused ? t.classList.add("tl-container__focused") : t.classList.remove("tl-container__focused");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete(), this.editor.getContainer().blur();
  }
  dispose() {
    var t;
    (t = this.disposeSideEffectListener) == null || t.call(this);
  }
}
function DE(n) {
  return R0e;
}
class I0e {
  constructor() {
    T(this, "length", 0);
    T(this, "head", null);
    T(this, "tail", this);
  }
  push(t) {
    return new C5(t, this);
  }
  toArray() {
    return cp;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: !0 };
      }
    };
  }
}
const R0e = new I0e();
class C5 {
  constructor(t, e) {
    T(this, "length");
    this.head = t, this.tail = e, this.length = e.length + 1;
  }
  push(t) {
    return new C5(t, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let t = this;
    return {
      next() {
        if (t.length) {
          const e = t.head;
          return t = t.tail, { value: e, done: !1 };
        } else
          return { value: void 0, done: !0 };
      }
    };
  }
}
class M0e {
  constructor(t) {
    T(this, "store");
    T(this, "dispose");
    T(this, "state", "recording");
    T(this, "pendingDiff", new O0e());
    T(this, "stacks", Qs(
      "HistoryManager.stacks",
      {
        undos: DE(),
        redos: DE()
      },
      {
        isEqual: (t, e) => t.undos === e.undos && t.redos === e.redos
      }
    ));
    T(this, "annotateError");
    /** @internal */
    T(this, "_isInBatch", !1);
    T(this, "batch", (t, e) => {
      const r = this.state;
      r !== "paused" && (e != null && e.history) && (this.state = D0e[e.history]);
      try {
        if (this._isInBatch)
          return bh(t), this;
        this._isInBatch = !0;
        try {
          bh(t);
        } catch (i) {
          throw this.annotateError(i), i;
        } finally {
          this._isInBatch = !1;
        }
        return this;
      } finally {
        this.state = r;
      }
    });
    // History
    T(this, "_undo", ({
      pushToRedoStack: t,
      toMark: e = void 0
    }) => {
      var i;
      const r = this.state;
      this.state = "paused";
      try {
        let { undos: s, redos: o } = this.stacks.get();
        const l = this.pendingDiff.clear(), u = MG(l), d = c3(l);
        t && !u && (o = o.push({ type: "diff", diff: l }));
        let f = !1;
        if (u)
          for (; ((i = s.head) == null ? void 0 : i.type) === "stop"; ) {
            const m = s.head;
            if (s = s.tail, t && (o = o.push(m)), m.id === e) {
              f = !0;
              break;
            }
          }
        if (!f)
          e: for (; s.head; ) {
            const m = s.head;
            switch (s = s.tail, t && (o = o.push(m)), m.type) {
              case "diff":
                T1(d, [c3(m.diff)]);
                break;
              case "stop":
                if (!e || m.id === e) break e;
                break;
              default:
                ma(m);
            }
          }
        this.store.applyDiff(d, { ignoreEphemeralKeys: !0 }), this.store.ensureStoreIsUsable(), this.stacks.set({ undos: s, redos: o });
      } finally {
        this.state = r;
      }
      return this;
    });
    T(this, "undo", () => (this._undo({ pushToRedoStack: !0 }), this));
    T(this, "redo", () => {
      var e;
      const t = this.state;
      this.state = "paused";
      try {
        this.flushPendingDiff();
        let { undos: r, redos: i } = this.stacks.get();
        if (i.length === 0)
          return this;
        for (; ((e = i.head) == null ? void 0 : e.type) === "stop"; )
          r = r.push(i.head), i = i.tail;
        const s = uM();
        for (; i.head; ) {
          const o = i.head;
          if (r = r.push(o), i = i.tail, o.type === "diff")
            T1(s, [o.diff]);
          else
            break;
        }
        this.store.applyDiff(s, { ignoreEphemeralKeys: !0 }), this.store.ensureStoreIsUsable(), this.stacks.set({ undos: r, redos: i });
      } finally {
        this.state = t;
      }
      return this;
    });
    T(this, "bail", () => (this._undo({ pushToRedoStack: !1 }), this));
    T(this, "bailToMark", (t) => (this._undo({ pushToRedoStack: !1, toMark: t }), this));
    T(this, "squashToMark", (t) => {
      var s;
      let e = this.stacks.get().undos;
      const r = [];
      for (; e.head && !(e.head.type === "stop" && e.head.id === t); )
        e.head.type === "diff" && r.push(e.head.diff), e = e.tail;
      if (!e.head || ((s = e.head) == null ? void 0 : s.id) !== t)
        return console.error("Could not find mark to squash to: ", t), this;
      if (r.length === 0)
        return this;
      const i = uM();
      return T1(i, r.reverse()), this.stacks.update(({ redos: o }) => ({
        undos: e.push({
          type: "diff",
          diff: i
        }),
        redos: o
      })), this;
    });
    T(this, "mark", (t = Ii()) => (bh(() => {
      this.flushPendingDiff(), this.stacks.update(({ undos: e, redos: r }) => ({ undos: e.push({ type: "stop", id: t }), redos: r }));
    }), t));
    this.store = t.store, this.annotateError = t.annotateError ?? F1, this.dispose = this.store.addHistoryInterceptor((e, r) => {
      if (r === "user")
        switch (this.state) {
          case "recording":
            this.pendingDiff.apply(e.changes), this.stacks.update(({ undos: i }) => ({ undos: i, redos: DE() }));
            break;
          case "recordingPreserveRedoStack":
            this.pendingDiff.apply(e.changes);
            break;
          case "paused":
            break;
          default:
            ma(this.state);
        }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty()) return;
    const t = this.pendingDiff.clear();
    this.stacks.update(({ undos: e, redos: r }) => ({
      undos: e.push({ type: "diff", diff: t }),
      redos: r
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  clear() {
    this.stacks.set({ undos: DE(), redos: DE() }), this.pendingDiff.clear();
  }
  /** @internal */
  debug() {
    const { undos: t, redos: e } = this.stacks.get();
    return {
      undos: t.toArray(),
      redos: e.toArray(),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
}
const D0e = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
class O0e {
  constructor() {
    T(this, "diff", uM());
    T(this, "isEmptyAtom", Qs("PendingDiff.isEmpty", !0));
  }
  clear() {
    const t = this.diff;
    return this.diff = uM(), this.isEmptyAtom.set(!0), t;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(t) {
    T1(this.diff, [t]), this.isEmptyAtom.set(MG(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
}
class L0e {
  constructor(t) {
    T(this, "scribbleItems", /* @__PURE__ */ new Map());
    T(this, "state", "paused");
    T(this, "addScribble", (t, e = Ii()) => {
      const r = {
        id: e,
        scribble: {
          id: e,
          size: 20,
          color: "accent",
          opacity: 0.8,
          delay: 0,
          points: [],
          shrink: 0.1,
          taper: !0,
          ...t,
          state: "starting"
        },
        timeoutMs: 0,
        delayRemaining: t.delay ?? 0,
        prev: null,
        next: null
      };
      return this.scribbleItems.set(e, r), r;
    });
    /**
     * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
     *
     * @public
     */
    T(this, "stop", (t) => {
      const e = this.scribbleItems.get(t);
      if (!e) throw Error(`Scribble with id ${t} not found`);
      return e.delayRemaining = Math.min(e.delayRemaining, 200), e.scribble.state = "stopping", e;
    });
    /**
     * Set the scribble's next point.
     *
     * @param point - The point to add.
     * @public
     */
    T(this, "addPoint", (t, e, r) => {
      const i = this.scribbleItems.get(t);
      if (!i) throw Error(`Scribble with id ${t} not found`);
      const { prev: s } = i, o = { x: e, y: r, z: 0.5 };
      return (!s || O.Dist(s, o) >= 1) && (i.next = o), i;
    });
    /**
     * Update on each animation frame.
     *
     * @param elapsed - The number of milliseconds since the last tick.
     * @public
     */
    T(this, "tick", (t) => {
      this.scribbleItems.size !== 0 && this.editor.run(() => {
        this.scribbleItems.forEach((e) => {
          if (e.scribble.state === "starting") {
            const { next: u, prev: d } = e;
            u && u !== d && (e.prev = u, e.scribble.points.push(u)), e.scribble.points.length > 8 && (e.scribble.state = "active");
            return;
          }
          e.delayRemaining > 0 && (e.delayRemaining = Math.max(0, e.delayRemaining - t)), e.timeoutMs += t, e.timeoutMs >= 16 && (e.timeoutMs = 0);
          const { delayRemaining: r, timeoutMs: i, prev: s, next: o, scribble: l } = e;
          switch (l.state) {
            case "active": {
              o && o !== s ? (e.prev = o, l.points.push(o), r === 0 && l.points.length > 8 && l.points.shift()) : i === 0 && (l.points.length > 1 ? l.points.shift() : e.delayRemaining = l.delay);
              break;
            }
            case "stopping": {
              if (e.delayRemaining === 0 && i === 0) {
                if (l.points.length === 1) {
                  this.scribbleItems.delete(e.id);
                  return;
                }
                l.shrink && (l.size = Math.max(1, l.size * (1 - l.shrink))), l.points.shift();
              }
              break;
            }
          }
        }), this.editor.updateInstanceState({
          scribbles: Array.from(this.scribbleItems.values()).map(({ scribble: e }) => ({
            ...e,
            points: [...e.points]
          })).slice(-5)
          // limit to three as a minor sanity check
        });
      });
    });
    this.editor = t;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] }), this.scribbleItems.clear();
  }
}
var j0e = Object.defineProperty, N0e = Object.getOwnPropertyDescriptor, N2 = (n, t, e, r) => {
  for (var i = N0e(t, e), s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (i = o(t, e, i) || i);
  return i && j0e(t, e, i), i;
};
const qt = (n) => Math.round(n * 10 ** 8) / 10 ** 8;
function kf(n, t, e, r, i) {
  const s = n.filter(
    (l) => (r === "forward" ? l.startNode.id === t : l.endNode.id === t) && qt(l.length) === qt(e) && nd(
      l.breadthIntersection[0],
      l.breadthIntersection[1],
      i[0],
      i[1]
    )
  );
  if (s.length === 0) return [];
  const o = /* @__PURE__ */ new Set();
  return s.forEach((l) => {
    const u = r === "forward" ? l.endNode.id : l.startNode.id;
    if (!o.has(u)) {
      o.add(u);
      const d = kf(
        n,
        u,
        e,
        r,
        nd(
          l.breadthIntersection[0],
          l.breadthIntersection[1],
          i[0],
          i[1]
        )
      );
      s.push(...d);
    }
  }), s;
}
function F0e(n) {
  n.sort((t, e) => e.gaps.length - t.gaps.length);
  for (let t = n.length - 1; t > 0; t--) {
    const e = n[t];
    for (let r = t - 1; r >= 0; r--) {
      const i = n[r];
      if (i.direction === e.direction && e.gaps.every(
        (s) => i.gaps.some(
          (o) => qt(s.startEdge[0].x) === qt(o.startEdge[0].x) && qt(s.startEdge[0].y) === qt(o.startEdge[0].y) && qt(s.startEdge[1].x) === qt(o.startEdge[1].x) && qt(s.startEdge[1].y) === qt(o.startEdge[1].y)
        ) && i.gaps.some(
          (o) => qt(s.endEdge[0].x) === qt(o.endEdge[0].x) && qt(s.endEdge[0].y) === qt(o.endEdge[0].y) && qt(s.endEdge[1].x) === qt(o.endEdge[1].x) && qt(s.endEdge[1].y) === qt(o.endEdge[1].y)
        )
      )) {
        n.splice(t, 1);
        break;
      }
    }
  }
}
class GT {
  constructor(t) {
    T(this, "editor");
    this.manager = t, this.editor = t.editor;
  }
  getSnapPointsCache() {
    const { editor: t } = this;
    return t.store.createComputedCache("snapPoints", (e) => {
      const r = t.getShapePageTransform(e.id);
      if (!r) return;
      const s = t.getShapeUtil(e).getBoundsSnapGeometry(e).points ?? t.getShapeGeometry(e).bounds.cornersAndCenter;
      if (!(!r || !s))
        return s.map((o, l) => {
          const { x: u, y: d } = At.applyToPoint(r, o);
          return { x: u, y: d, id: `${e.id}:${l}` };
        });
    });
  }
  getSnapPoints(t) {
    return this.getSnapPointsCache().get(t) ?? [];
  }
  getSnappablePoints() {
    const t = this.getSnapPointsCache(), e = this.manager.getSnappableShapes(), r = [];
    for (const i of e) {
      const s = t.get(i);
      s && r.push(...s);
    }
    return r;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (t) => ({
      id: t,
      pageBounds: nu(this.editor.getShapePageBounds(t))
    }));
  }
  getVisibleGaps() {
    const t = [], e = [];
    let r, i;
    const s = this.getSnappableGapNodes().sort((l, u) => l.pageBounds.minX - u.pageBounds.minX);
    for (let l = 0; l < s.length; l++) {
      r = s[l];
      for (let u = l + 1; u < s.length; u++)
        i = s[u], // is there space between the boxes
        r.pageBounds.maxX < i.pageBounds.minX && // and they overlap in the y axis
        ME(
          r.pageBounds.minY,
          r.pageBounds.maxY,
          i.pageBounds.minY,
          i.pageBounds.maxY
        ) && t.push({
          startNode: r,
          endNode: i,
          startEdge: [
            new O(r.pageBounds.maxX, r.pageBounds.minY),
            new O(r.pageBounds.maxX, r.pageBounds.maxY)
          ],
          endEdge: [
            new O(i.pageBounds.minX, i.pageBounds.minY),
            new O(i.pageBounds.minX, i.pageBounds.maxY)
          ],
          length: i.pageBounds.minX - r.pageBounds.maxX,
          breadthIntersection: nd(
            r.pageBounds.minY,
            r.pageBounds.maxY,
            i.pageBounds.minY,
            i.pageBounds.maxY
          )
        });
    }
    const o = s.sort((l, u) => l.pageBounds.minY - u.pageBounds.minY);
    for (let l = 0; l < o.length; l++) {
      r = o[l];
      for (let u = l + 1; u < o.length; u++)
        i = o[u], // is there space between the boxes
        r.pageBounds.maxY < i.pageBounds.minY && // do they overlap in the x axis
        ME(
          r.pageBounds.minX,
          r.pageBounds.maxX,
          i.pageBounds.minX,
          i.pageBounds.maxX
        ) && e.push({
          startNode: r,
          endNode: i,
          startEdge: [
            new O(r.pageBounds.minX, r.pageBounds.maxY),
            new O(r.pageBounds.maxX, r.pageBounds.maxY)
          ],
          endEdge: [
            new O(i.pageBounds.minX, i.pageBounds.minY),
            new O(i.pageBounds.maxX, i.pageBounds.minY)
          ],
          length: i.pageBounds.minY - r.pageBounds.maxY,
          breadthIntersection: nd(
            r.pageBounds.minX,
            r.pageBounds.maxX,
            i.pageBounds.minX,
            i.pageBounds.maxX
          )
        });
    }
    return { horizontal: t, vertical: e };
  }
  snapTranslateShapes({
    lockedAxis: t,
    initialSelectionPageBounds: e,
    initialSelectionSnapPoints: r,
    dragDelta: i
  }) {
    var A, P;
    const s = this.manager.getSnapThreshold(), o = this.getSnappablePoints(), l = e.clone().translate(i), u = r.map(
      ({ x: R, y: M }, j) => ({
        id: "selection:" + j,
        x: R + i.x,
        y: M + i.y
      })
    ), d = o, f = [], m = [], v = new O(s, s);
    this.collectPointSnaps({
      minOffset: v,
      nearestSnapsX: f,
      nearestSnapsY: m,
      otherNodeSnapPoints: d,
      selectionSnapPoints: u
    }), this.collectGapSnaps({
      selectionPageBounds: l,
      nearestSnapsX: f,
      nearestSnapsY: m,
      minOffset: v
    });
    const S = new O(
      t === "x" ? 0 : ((A = f[0]) == null ? void 0 : A.nudge) ?? 0,
      t === "y" ? 0 : ((P = m[0]) == null ? void 0 : P.nudge) ?? 0
    );
    v.x = 0, v.y = 0, f.length = 0, m.length = 0, u.forEach((R) => {
      R.x += S.x, R.y += S.y;
    }), l.translate(S), this.collectPointSnaps({
      minOffset: v,
      nearestSnapsX: f,
      nearestSnapsY: m,
      otherNodeSnapPoints: d,
      selectionSnapPoints: u
    }), this.collectGapSnaps({
      selectionPageBounds: l,
      nearestSnapsX: f,
      nearestSnapsY: m,
      minOffset: v
    });
    const w = this.getPointSnapLines({
      nearestSnapsX: f,
      nearestSnapsY: m
    }), E = this.getGapSnapLines({
      selectionPageBounds: l,
      nearestSnapsX: f,
      nearestSnapsY: m
    });
    return this.manager.setIndicators([...E, ...w]), { nudge: S };
  }
  snapResizeShapes({
    initialSelectionPageBounds: t,
    dragDelta: e,
    handle: r,
    isAspectRatioLocked: i,
    isResizingFromCenter: s
  }) {
    var F, B;
    const o = this.manager.getSnapThreshold(), {
      box: l,
      scaleX: u,
      scaleY: d
    } = vt.Resize(
      t,
      r,
      s ? e.x * 2 : e.x,
      s ? e.y * 2 : e.y,
      i
    );
    let f = r;
    u < 0 && (f = zSe(f)), d < 0 && (f = $Se(f)), s && (l.center = t.center);
    const m = f === "top" || f === "bottom", v = f === "left" || f === "right", S = K9(f, l), w = this.getSnappablePoints(), E = [], A = [], P = new O(o, o);
    this.collectPointSnaps({
      minOffset: P,
      nearestSnapsX: E,
      nearestSnapsY: A,
      otherNodeSnapPoints: w,
      selectionSnapPoints: S
    });
    const R = new O(
      m ? 0 : ((F = E[0]) == null ? void 0 : F.nudge) ?? 0,
      v ? 0 : ((B = A[0]) == null ? void 0 : B.nudge) ?? 0
    );
    if (i && USe(f) && R.len() !== 0) {
      const G = E.length && A.length ? Math.abs(R.x) < Math.abs(R.y) ? "x" : "y" : E.length ? "x" : "y", X = t.aspectRatio;
      G === "x" ? (A.length = 0, R.y = R.x / X, (f === "bottom_left" || f === "top_right") && (R.y = -R.y)) : (E.length = 0, R.x = R.y * X, (f === "bottom_left" || f === "top_right") && (R.x = -R.x));
    }
    const M = O.Add(e, R), { box: j } = vt.Resize(
      t,
      r,
      s ? M.x * 2 : M.x,
      s ? M.y * 2 : M.y,
      i
    );
    s && (j.center = t.center);
    const $ = K9("any", j);
    E.length = 0, A.length = 0, P.x = 0, P.y = 0, this.collectPointSnaps({
      minOffset: P,
      nearestSnapsX: E,
      nearestSnapsY: A,
      otherNodeSnapPoints: w,
      selectionSnapPoints: $
    });
    const U = this.getPointSnapLines({
      nearestSnapsX: E,
      nearestSnapsY: A
    });
    return this.manager.setIndicators([...U]), { nudge: R };
  }
  collectPointSnaps({
    selectionSnapPoints: t,
    otherNodeSnapPoints: e,
    minOffset: r,
    nearestSnapsX: i,
    nearestSnapsY: s
  }) {
    for (const o of t)
      for (const l of e) {
        const u = O.Sub(o, l), d = Math.abs(u.x), f = Math.abs(u.y);
        qt(d) <= qt(r.x) && (qt(d) < qt(r.x) && (i.length = 0), i.push({
          type: "points",
          points: { thisPoint: o, otherPoint: l },
          nudge: l.x - o.x
        }), r.x = d), qt(f) <= qt(r.y) && (qt(f) < qt(r.y) && (s.length = 0), s.push({
          type: "points",
          points: { thisPoint: o, otherPoint: l },
          nudge: l.y - o.y
        }), r.y = f);
      }
  }
  collectGapSnaps({
    selectionPageBounds: t,
    minOffset: e,
    nearestSnapsX: r,
    nearestSnapsY: i
  }) {
    const { horizontal: s, vertical: o } = this.getVisibleGaps();
    for (const l of s) {
      if (!ME(
        l.breadthIntersection[0],
        l.breadthIntersection[1],
        t.minY,
        t.maxY
      ))
        continue;
      const d = l.startEdge[0].x + l.length / 2 - t.center.x;
      if (l.length > t.width && qt(Math.abs(d)) <= qt(e.x)) {
        qt(Math.abs(d)) < qt(e.x) && (r.length = 0), e.x = Math.abs(d);
        const P = {
          type: "gap_center",
          gap: l,
          nudge: d
        }, R = r.find(({ type: j }) => j === "gap_center"), M = R && nd(
          l.breadthIntersection[0],
          l.breadthIntersection[1],
          R.gap.breadthIntersection[0],
          R.gap.breadthIntersection[1]
        );
        R && R.gap.length > l.length && M ? r[r.indexOf(R)] = P : (!R || !M) && r.push(P);
      }
      const m = l.startNode.pageBounds.minX - l.length, v = t.maxX, S = m - v;
      qt(Math.abs(S)) <= qt(e.x) && (qt(Math.abs(S)) < qt(e.x) && (r.length = 0), e.x = Math.abs(S), r.push({
        type: "gap_duplicate",
        gap: l,
        protrusionDirection: "left",
        nudge: S
      }));
      const w = l.endNode.pageBounds.maxX + l.length, E = t.minX, A = w - E;
      qt(Math.abs(A)) <= qt(e.x) && (qt(Math.abs(A)) < qt(e.x) && (r.length = 0), e.x = Math.abs(A), r.push({
        type: "gap_duplicate",
        gap: l,
        protrusionDirection: "right",
        nudge: A
      }));
    }
    for (const l of o) {
      if (!ME(
        l.breadthIntersection[0],
        l.breadthIntersection[1],
        t.minX,
        t.maxX
      ))
        continue;
      const d = l.startEdge[0].y + l.length / 2 - t.center.y;
      if (l.length > t.height && qt(Math.abs(d)) <= qt(e.y)) {
        qt(Math.abs(d)) < qt(e.y) && (i.length = 0), e.y = Math.abs(d);
        const P = {
          type: "gap_center",
          gap: l,
          nudge: d
        }, R = i.find(({ type: j }) => j === "gap_center"), M = R && ME(
          R.gap.breadthIntersection[0],
          R.gap.breadthIntersection[1],
          l.breadthIntersection[0],
          l.breadthIntersection[1]
        );
        R && R.gap.length > l.length && M ? i[i.indexOf(R)] = P : (!R || !M) && i.push(P);
        continue;
      }
      const m = l.startNode.pageBounds.minY - l.length, v = t.maxY, S = m - v;
      qt(Math.abs(S)) <= qt(e.y) && (qt(Math.abs(S)) < qt(e.y) && (i.length = 0), e.y = Math.abs(S), i.push({
        type: "gap_duplicate",
        gap: l,
        protrusionDirection: "top",
        nudge: S
      }));
      const w = l.endNode.pageBounds.maxY + l.length, E = t.minY, A = w - E;
      qt(Math.abs(A)) <= qt(e.y) && (qt(Math.abs(A)) < qt(e.y) && (i.length = 0), e.y = Math.abs(A), i.push({
        type: "gap_duplicate",
        gap: l,
        protrusionDirection: "bottom",
        nudge: A
      }));
    }
  }
  getPointSnapLines({
    nearestSnapsX: t,
    nearestSnapsY: e
  }) {
    const r = {}, i = {};
    if (t.length > 0) {
      for (const s of t)
        if (s.type === "points") {
          const o = qt(s.points.otherPoint.x);
          r[o] || (r[o] = []), r[o].push(s.points);
        }
    }
    if (e.length > 0) {
      for (const s of e)
        if (s.type === "points") {
          const o = qt(s.points.otherPoint.y);
          i[o] || (i[o] = []), i[o].push(s.points);
        }
    }
    return Object.values(r).concat(Object.values(i)).map((s) => ({
      id: Ii(),
      type: "points",
      points: Xz(
        s.map((o) => O.From(o.otherPoint)).concat(s.map((o) => O.From(o.thisPoint))),
        (o, l) => o.equals(l)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds: t,
    nearestSnapsX: e,
    nearestSnapsY: r
  }) {
    const { vertical: i, horizontal: s } = this.getVisibleGaps(), o = {
      top: t.sides[0],
      right: t.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [t.corners[3], t.corners[2]],
      left: [t.corners[0], t.corners[3]]
    }, l = [];
    if (e.length > 0)
      for (const u of e) {
        if (u.type === "points") continue;
        const {
          gap: { breadthIntersection: d, startEdge: f, startNode: m, endNode: v, length: S, endEdge: w }
        } = u;
        switch (u.type) {
          case "gap_center": {
            const E = (S - t.width) / 2, A = nd(
              d[0],
              d[1],
              t.minY,
              t.maxY
            );
            l.push({
              type: "gaps",
              direction: "horizontal",
              id: Ii(),
              gaps: [
                ...kf(
                  s,
                  m.id,
                  E,
                  "backward",
                  A
                ),
                {
                  startEdge: f,
                  endEdge: o.left
                },
                {
                  startEdge: o.right,
                  endEdge: w
                },
                ...kf(
                  s,
                  v.id,
                  E,
                  "forward",
                  A
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const E = nd(
              d[0],
              d[1],
              t.minY,
              t.maxY
            );
            l.push({
              type: "gaps",
              direction: "horizontal",
              id: Ii(),
              gaps: u.protrusionDirection === "left" ? [
                {
                  startEdge: o.right,
                  endEdge: f.map(
                    (A) => A.clone().addXY(-m.pageBounds.width, 0)
                  )
                },
                { startEdge: f, endEdge: w },
                ...kf(
                  s,
                  v.id,
                  S,
                  "forward",
                  E
                )
              ] : [
                ...kf(
                  s,
                  m.id,
                  S,
                  "backward",
                  E
                ),
                { startEdge: f, endEdge: w },
                {
                  startEdge: w.map(
                    (A) => A.clone().addXY(u.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: o.left
                }
              ]
            });
            break;
          }
        }
      }
    if (r.length > 0)
      for (const u of r) {
        if (u.type === "points") continue;
        const {
          gap: { breadthIntersection: d, startEdge: f, startNode: m, endNode: v, length: S, endEdge: w }
        } = u;
        switch (u.type) {
          case "gap_center": {
            const E = (S - t.height) / 2, A = nd(
              d[0],
              d[1],
              t.minX,
              t.maxX
            );
            l.push({
              type: "gaps",
              direction: "vertical",
              id: Ii(),
              gaps: [
                ...kf(
                  i,
                  m.id,
                  E,
                  "backward",
                  A
                ),
                {
                  startEdge: f,
                  endEdge: o.top
                },
                {
                  startEdge: o.bottom,
                  endEdge: w
                },
                ...kf(
                  i,
                  u.gap.endNode.id,
                  E,
                  "forward",
                  A
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const E = nd(
                d[0],
                d[1],
                t.minX,
                t.maxX
              );
              l.push({
                type: "gaps",
                direction: "vertical",
                id: Ii(),
                gaps: u.protrusionDirection === "top" ? [
                  {
                    startEdge: o.bottom,
                    endEdge: f.map(
                      (A) => A.clone().addXY(0, -m.pageBounds.height)
                    )
                  },
                  { startEdge: f, endEdge: w },
                  ...kf(
                    i,
                    v.id,
                    S,
                    "forward",
                    E
                  )
                ] : [
                  ...kf(
                    i,
                    m.id,
                    S,
                    "backward",
                    E
                  ),
                  { startEdge: f, endEdge: w },
                  {
                    startEdge: w.map(
                      (A) => A.clone().addXY(0, v.pageBounds.height)
                    ),
                    endEdge: o.top
                  }
                ]
              });
            }
            break;
        }
      }
    return F0e(l), l;
  }
}
N2([
  ze
], GT.prototype, "getSnapPointsCache");
N2([
  ze
], GT.prototype, "getSnappablePoints");
N2([
  ze
], GT.prototype, "getSnappableGapNodes");
N2([
  ze
], GT.prototype, "getVisibleGaps");
function K9(n, t) {
  const { minX: e, maxX: r, minY: i, maxY: s } = t, o = [];
  switch (n) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      o.push({
        id: "top_left",
        handle: "top_left",
        x: e,
        y: i
      });
  }
  switch (n) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      o.push({
        id: "top_right",
        handle: "top_right",
        x: r,
        y: i
      });
  }
  switch (n) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      o.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: r,
        y: s
      });
  }
  switch (n) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      o.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: e,
        y: s
      });
  }
  return o;
}
var $0e = Object.defineProperty, z0e = Object.getOwnPropertyDescriptor, U0e = (n, t, e, r) => {
  for (var i = z0e(t, e), s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (i = o(t, e, i) || i);
  return i && $0e(t, e, i), i;
};
const B0e = () => null, H0e = () => [];
class bY {
  constructor(t) {
    T(this, "editor");
    this.manager = t, this.editor = t.editor;
  }
  getSnapGeometryCache() {
    const { editor: t } = this;
    return t.store.createComputedCache("handle snap geometry", (e) => {
      const r = t.getShapeUtil(e).getHandleSnapGeometry(e);
      return {
        outline: r.outline === void 0 ? t.getShapeGeometry(e) : r.outline,
        points: r.points ?? [],
        getSelfSnapOutline: r.getSelfSnapOutline ?? B0e,
        getSelfSnapPoints: r.getSelfSnapPoints ?? H0e
      };
    });
  }
  *iterateSnapPointsInPageSpace(t, e) {
    var i, s;
    const r = (i = this.getSnapGeometryCache().get(t)) == null ? void 0 : i.getSelfSnapPoints(e);
    if (r && r.length) {
      const o = nu(this.editor.getShapePageTransform(t));
      for (const l of r)
        yield o.applyToPoint(l);
    }
    for (const o of this.manager.getSnappableShapes()) {
      if (o === t) continue;
      const l = (s = this.getSnapGeometryCache().get(o)) == null ? void 0 : s.points;
      if (!l || !l.length) continue;
      const u = nu(this.editor.getShapePageTransform(o));
      for (const d of l)
        yield u.applyToPoint(d);
    }
  }
  *iterateSnapOutlines(t, e) {
    var i, s;
    const r = (i = this.getSnapGeometryCache().get(t)) == null ? void 0 : i.getSelfSnapOutline(e);
    r && (yield { shapeId: t, outline: r });
    for (const o of this.manager.getSnappableShapes()) {
      if (o === t) continue;
      const l = (s = this.getSnapGeometryCache().get(o)) == null ? void 0 : s.outline;
      l && (yield { shapeId: o, outline: l });
    }
  }
  getHandleSnapPosition({
    currentShapeId: t,
    handle: e,
    handleInPageSpace: r
  }) {
    const i = this.manager.getSnapThreshold();
    let s = i, o = null;
    for (const d of this.iterateSnapPointsInPageSpace(t, e))
      O.DistMin(r, d, s) && (s = O.Dist(r, d), o = d);
    if (o) return o;
    let l = i, u = null;
    for (const { shapeId: d, outline: f } of this.iterateSnapOutlines(t, e)) {
      const m = nu(this.editor.getShapePageTransform(d)), v = this.editor.getPointInShapeSpace(d, r), S = f.nearestPoint(v), w = m.applyToPoint(S);
      O.DistMin(r, w, l) && (l = O.Dist(r, w), u = w);
    }
    return u || null;
  }
  snapHandle({
    currentShapeId: t,
    handle: e
  }) {
    const i = nu(this.editor.getShapePageTransform(t)).applyToPoint(e), s = this.getHandleSnapPosition({ currentShapeId: t, handle: e, handleInPageSpace: i });
    return s ? (this.manager.setIndicators([
      {
        id: Ii(),
        type: "points",
        points: [s]
      }
    ]), { nudge: O.Sub(s, i) }) : null;
  }
}
U0e([
  ze
], bY.prototype, "getSnapGeometryCache");
var V0e = Object.defineProperty, W0e = Object.getOwnPropertyDescriptor, E5 = (n, t, e, r) => {
  for (var i = W0e(t, e), s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (i = o(t, e, i) || i);
  return i && V0e(t, e, i), i;
};
class F2 {
  constructor(t) {
    T(this, "shapeBounds");
    T(this, "handles");
    T(this, "_snapIndicators", Qs("snapLines", void 0));
    this.editor = t, this.shapeBounds = new GT(this), this.handles = new bY(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? cp;
  }
  clearIndicators() {
    this.getIndicators().length && this._snapIndicators.set(void 0);
  }
  setIndicators(t) {
    this._snapIndicators.set(t);
  }
  getSnapThreshold() {
    return 8 / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor: t } = this, e = t.getViewportPageBounds(), r = t.getSelectedShapeIds(), i = /* @__PURE__ */ new Set(), s = (o) => {
      if (kl(o)) {
        const u = t.getShape(o);
        u && t.isShapeOfType(u, "frame") && i.add(o);
      }
      const l = t.getSortedChildIdsForParent(o);
      for (const u of l) {
        if (r.includes(u)) continue;
        const d = t.getShape(u);
        if (!d || !t.getShapeUtil(d).canSnap(d)) continue;
        const m = t.getShapePageBounds(u);
        if (m && e.includes(m)) {
          if (t.isShapeOfType(d, "group")) {
            s(u);
            continue;
          }
          i.add(u);
        }
      }
    };
    return s(this.getCurrentCommonAncestor() ?? t.getCurrentPageId()), i;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
}
E5([
  ze
], F2.prototype, "getSnapThreshold");
E5([
  ze
], F2.prototype, "getSnappableShapes");
E5([
  ze
], F2.prototype, "getCurrentCommonAncestor");
const G0e = /\r?\n|\r/g;
function Y9(n) {
  return n.replace(G0e, `
`).split(`
`).map((t) => t || " ").join(`
`);
}
const K0e = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
}, Y0e = /\s/;
class X0e {
  constructor(t) {
    T(this, "baseElm");
    T(this, "measureText", (t, e) => {
      var o;
      const r = (o = this.baseElm) == null ? void 0 : o.cloneNode();
      this.baseElm.insertAdjacentElement("afterend", r), r.setAttribute("dir", "auto"), r.style.setProperty("unicode-bidi", "plaintext"), r.style.setProperty("font-family", e.fontFamily), r.style.setProperty("font-style", e.fontStyle), r.style.setProperty("font-weight", e.fontWeight), r.style.setProperty("font-size", e.fontSize + "px"), r.style.setProperty("line-height", e.lineHeight * e.fontSize + "px"), r.style.setProperty("max-width", e.maxWidth === null ? null : e.maxWidth + "px"), r.style.setProperty("min-width", e.minWidth === null ? null : e.minWidth + "px"), r.style.setProperty("padding", e.padding), r.style.setProperty(
        "overflow-wrap",
        e.disableOverflowWrapBreaking ? "normal" : "break-word"
      ), r.textContent = Y9(t);
      const i = r.scrollWidth, s = r.getBoundingClientRect();
      return r.remove(), {
        x: 0,
        y: 0,
        w: s.width,
        h: s.height,
        scrollWidth: i
      };
    });
    this.editor = t;
    const e = this.editor.getContainer(), r = document.createElement("div");
    r.classList.add("tl-text"), r.classList.add("tl-text-measure"), r.tabIndex = -1, e.appendChild(r), this.baseElm = r, t.disposables.add(() => {
      r.remove();
    });
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(t, { shouldTruncateToFirstLine: e = !1 } = {}) {
    const r = [], i = t.getBoundingClientRect(), s = -i.left, o = -i.top, l = new Range(), u = t.childNodes[0];
    let d = 0, f = null, m = null, v = 0, S = 0, w = !1;
    for (const E of t.childNodes)
      if (E.nodeType === Node.TEXT_NODE)
        for (const A of E.textContent ?? "") {
          l.setStart(u, d), l.setEnd(u, d + A.length);
          const P = l.getClientRects(), R = P[P.length - 1], M = R.top + o, j = R.left + s, $ = R.right + s, U = j < S, F = Y0e.test(A);
          if (
            // If we're at a word boundary...
            F !== m || // ...or we're on a different line...
            M !== v || // ...or we're at the start of the text and haven't created a span yet...
            !f
          ) {
            if (f) {
              if (e && M !== v) {
                w = !0;
                break;
              }
              r.push(f);
            }
            f = {
              box: { x: j, y: M, w: R.width, h: R.height },
              text: A
            }, S = j;
          } else
            U && (f.box.x = j), f.box.w = U ? f.box.w + R.width : $ - f.box.x, f.text += A;
          A === `
` && (S = 0), m = F, v = M, d += A.length;
        }
    return f && r.push(f), { spans: r, didTruncate: w };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(t, e) {
    var d;
    if (t === "") return [];
    const r = (d = this.baseElm) == null ? void 0 : d.cloneNode();
    this.baseElm.insertAdjacentElement("afterend", r);
    const i = Math.ceil(e.width - e.padding * 2);
    r.setAttribute("dir", "auto"), r.style.setProperty("unicode-bidi", "plaintext"), r.style.setProperty("width", `${i}px`), r.style.setProperty("height", "min-content"), r.style.setProperty("font-size", `${e.fontSize}px`), r.style.setProperty("font-family", e.fontFamily), r.style.setProperty("font-weight", e.fontWeight), r.style.setProperty("line-height", `${e.lineHeight * e.fontSize}px`), r.style.setProperty("text-align", K0e[e.textAlign]);
    const s = e.overflow === "truncate-ellipsis" || e.overflow === "truncate-clip";
    s && (r.style.setProperty("overflow-wrap", "anywhere"), r.style.setProperty("word-break", "break-all"));
    const o = Y9(t);
    r.textContent = o;
    const { spans: l, didTruncate: u } = this.measureElementTextNodeSpans(r, {
      shouldTruncateToFirstLine: s
    });
    if (e.overflow === "truncate-ellipsis" && u) {
      r.textContent = "…";
      const f = Math.ceil(this.measureElementTextNodeSpans(r).spans[0].box.w);
      r.style.setProperty("width", `${i - f}px`), r.textContent = o;
      const m = this.measureElementTextNodeSpans(r, {
        shouldTruncateToFirstLine: !0
      }).spans, v = m[m.length - 1];
      return m.push({
        text: "…",
        box: {
          x: Math.min(v.box.x + v.box.w, e.width - e.padding - f),
          y: v.box.y,
          w: f,
          h: v.box.h
        }
      }), m;
    }
    return r.remove(), l;
  }
}
const X9 = typeof process < "u" && process.env.NODE_ENV === "test" ? (
  // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow
  // for the tick manager since it sets up a raf loop.
  function(t) {
    const e = requestAnimationFrame(t);
    return () => cancelAnimationFrame(e);
  }
) : PG;
class q0e {
  constructor(t) {
    T(this, "cancelRaf");
    T(this, "isPaused", !0);
    T(this, "now", 0);
    T(this, "start", () => {
      var t;
      this.isPaused = !1, (t = this.cancelRaf) == null || t.call(this), this.cancelRaf = X9(this.tick), this.now = Date.now();
    });
    T(this, "tick", () => {
      if (this.isPaused)
        return;
      const t = Date.now(), e = t - this.now;
      this.now = t, this.updatePointerVelocity(e), this.editor.emit("frame", e), this.editor.emit("tick", e), this.cancelRaf = X9(this.tick);
    });
    // Clear the listener
    T(this, "dispose", () => {
      var t;
      this.isPaused = !0, (t = this.cancelRaf) == null || t.call(this);
    });
    T(this, "prevPoint", new O());
    T(this, "updatePointerVelocity", (t) => {
      const {
        prevPoint: e,
        editor: {
          inputs: { currentScreenPoint: r, pointerVelocity: i }
        }
      } = this;
      if (t === 0) return;
      const s = O.Sub(r, e);
      this.prevPoint = r.clone();
      const o = s.len(), l = o ? s.div(o) : new O(0, 0), u = i.clone().lrp(l.mul(o / t), 0.5);
      Math.abs(u.x) < 0.01 && (u.x = 0), Math.abs(u.y) < 0.01 && (u.y = 0), i.equals(u) || (this.editor.inputs.pointerVelocity = u);
    });
    this.editor = t, this.editor.disposables.add(this.dispose), this.start();
  }
}
var Z0e = Object.defineProperty, Q0e = Object.getOwnPropertyDescriptor, cu = (n, t, e, r) => {
  for (var i = Q0e(t, e), s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (i = o(t, e, i) || i);
  return i && Z0e(t, e, i), i;
};
class Cc {
  constructor(t, e) {
    T(this, "systemColorScheme", Qs("systemColorScheme", "light"));
    T(this, "updateUserPreferences", (t) => {
      this.user.setUserPreferences({
        ...this.user.userPreferences.get(),
        ...t
      });
    });
    if (this.user = t, this.inferDarkMode = e, typeof window > "u" || !("matchMedia" in window)) return;
    const r = window.matchMedia("(prefers-color-scheme: dark)");
    r != null && r.matches && this.systemColorScheme.set("dark"), r == null || r.addEventListener("change", (i) => {
      i.matches ? this.systemColorScheme.set("dark") : this.systemColorScheme.set("light");
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return !0;
      case "light":
        return !1;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : !1;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? _f.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? _f.animationSpeed;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    return this.user.userPreferences.get().name ?? _f.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? _f.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? _f.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? _f.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? _f.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? _f.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? _f.isPasteAtCursorMode;
  }
}
cu([
  ze
], Cc.prototype, "getUserPreferences");
cu([
  ze
], Cc.prototype, "getIsDarkMode");
cu([
  ze
], Cc.prototype, "getEdgeScrollSpeed");
cu([
  ze
], Cc.prototype, "getAnimationSpeed");
cu([
  ze
], Cc.prototype, "getId");
cu([
  ze
], Cc.prototype, "getName");
cu([
  ze
], Cc.prototype, "getLocale");
cu([
  ze
], Cc.prototype, "getColor");
cu([
  ze
], Cc.prototype, "getIsSnapMode");
cu([
  ze
], Cc.prototype, "getIsWrapMode");
cu([
  ze
], Cc.prototype, "getIsDynamicResizeMode");
cu([
  ze
], Cc.prototype, "getIsPasteAtCursorMode");
const J0e = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
}, exe = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
class Tt {
  constructor(t, e) {
    T(this, "performanceTracker");
    T(this, "id");
    T(this, "type");
    T(this, "shapeType");
    T(this, "initial");
    T(this, "children");
    T(this, "isLockable");
    T(this, "parent");
    T(this, "_path");
    T(this, "_current");
    T(this, "_isActive");
    /**
     * Transition to a new active child state node.
     *
     * @example
     * ```ts
     * parentState.transition('childStateA')
     * parentState.transition('childStateB', { myData: 4 })
     *```
     *
     * @param id - The id of the child state node to transition to.
     * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
     *
     * @public
     */
    T(this, "transition", (t, e = {}) => {
      var s;
      const r = t.split(".");
      let i = this;
      for (let o = 0; o < r.length; o++) {
        const l = r[o], u = i.getCurrent(), d = (s = i.children) == null ? void 0 : s[l];
        if (!d)
          throw Error(`${i.id} - no child state exists with the id ${l}.`);
        if ((u == null ? void 0 : u.id) !== d.id && (u == null || u.exit(e, l), i._current.set(d), d.enter(e, (u == null ? void 0 : u.id) || "initial"), !d.getIsActive()))
          break;
        i = d;
      }
      return this;
    });
    T(this, "handleEvent", (t) => {
      var i;
      const e = J0e[t.name], r = this._current.__unsafe__getWithoutCapture();
      (i = this[e]) == null || i.call(this, t), this._isActive.__unsafe__getWithoutCapture() && r && r === this._current.__unsafe__getWithoutCapture() && r.handleEvent(t);
    });
    // todo: move this logic into transition
    T(this, "enter", (t, e) => {
      var r;
      if (qi.measurePerformance.get() && exe.includes(this.id) && this.performanceTracker.start(this.id), this._isActive.set(!0), (r = this.onEnter) == null || r.call(this, t, e), this.children && this.initial && this.getIsActive()) {
        const i = this.children[this.initial];
        this._current.set(i), i.enter(t, e);
      }
    });
    // todo: move this logic into transition
    T(this, "exit", (t, e) => {
      var r, i;
      qi.measurePerformance.get() && this.performanceTracker.isStarted() && this.performanceTracker.stop(), this._isActive.set(!1), (r = this.onExit) == null || r.call(this, t, e), this.getIsActive() || (i = this.getCurrent()) == null || i.exit(t, e);
    });
    /**
     * This is a hack / escape hatch that will tell the editor to
     * report a different state as active (in `getCurrentToolId()`) when
     * this state is active. This is usually used when a tool transitions
     * to a child of a different state for a certain interaction and then
     * returns to the original tool when that interaction completes; and
     * where we would want to show the original tool as active in the UI.
     *
     * @public
     */
    T(this, "_currentToolIdMask", Qs("curent tool id mask", void 0));
    T(this, "onWheel");
    T(this, "onPointerDown");
    T(this, "onPointerMove");
    T(this, "onLongPress");
    T(this, "onPointerUp");
    T(this, "onDoubleClick");
    T(this, "onTripleClick");
    T(this, "onQuadrupleClick");
    T(this, "onRightClick");
    T(this, "onMiddleClick");
    T(this, "onKeyDown");
    T(this, "onKeyUp");
    T(this, "onKeyRepeat");
    T(this, "onCancel");
    T(this, "onComplete");
    T(this, "onInterrupt");
    T(this, "onTick");
    T(this, "onEnter");
    T(this, "onExit");
    this.editor = t;
    const { id: r, children: i, initial: s, isLockable: o } = this.constructor;
    this.id = r, this._isActive = Qs("toolIsActive" + this.id, !1), this._current = Qs("toolState" + this.id, void 0), this._path = ze("toolPath" + this.id, () => {
      const l = this.getCurrent();
      return this.id + (l ? `.${l.getPath()}` : "");
    }), this.parent = e ?? {}, this.parent ? i && s ? (this.type = "branch", this.initial = s, this.children = Object.fromEntries(
      i().map((l) => [l.id, new l(this.editor, this)])
    ), this._current.set(this.children[this.initial])) : this.type = "leaf" : (this.type = "root", i && s && (this.initial = s, this.children = Object.fromEntries(
      i().map((l) => [l.id, new l(this.editor, this)])
    ), this._current.set(this.children[this.initial]))), this.isLockable = o, this.performanceTracker = new uG();
  }
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(t) {
    this._currentToolIdMask.set(t);
  }
}
T(Tt, "id"), T(Tt, "initial"), T(Tt, "children"), T(Tt, "isLockable", !0);
class tR extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onKeyDown", (e) => {
      var r;
      switch (e.code) {
        case "KeyZ": {
          if (!(e.shiftKey || e.ctrlKey)) {
            const i = this.getCurrent();
            i && ((r = i.getCurrent()) == null ? void 0 : r.id) === "idle" && this.children.zoom && this.editor.setCurrentTool("zoom", { ...e, onInteractionEnd: i.id });
          }
          break;
        }
      }
    });
  }
}
T(tR, "id", "root"), T(tR, "initial", ""), T(tR, "children", () => []);
var txe = Object.defineProperty, nxe = Object.getOwnPropertyDescriptor, wt = (n, t, e, r) => {
  for (var i = nxe(t, e), s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (i = o(t, e, i) || i);
  return i && txe(t, e, i), i;
};
class mt extends Wbe {
  constructor({
    store: e,
    user: r,
    shapeUtils: i,
    bindingUtils: s,
    tools: o,
    getContainer: l,
    cameraOptions: u,
    initialState: d,
    autoFocus: f,
    inferDarkMode: m,
    options: v
  }) {
    super();
    T(this, "options");
    /**
     * The editor's store
     *
     * @public
     */
    T(this, "store");
    /**
     * The root state of the statechart.
     *
     * @public
     */
    T(this, "root");
    /**
     * A set of functions to call when the app is disposed.
     *
     * @public
     */
    T(this, "disposables", /* @__PURE__ */ new Set());
    /**
     * Whether the editor is disposed.
     *
     * @public
     */
    T(this, "isDisposed", !1);
    /** @internal */
    T(this, "_tickManager");
    /**
     * A manager for the app's snapping feature.
     *
     * @public
     */
    T(this, "snaps");
    /**
     * A manager for the any asynchronous events and making sure they're
     * cleaned up upon disposal.
     *
     * @public
     */
    T(this, "timers");
    /**
     * A manager for the user and their preferences.
     *
     * @public
     */
    T(this, "user");
    /**
     * A helper for measuring text.
     *
     * @public
     */
    T(this, "textMeasure");
    /**
     * A manager for the editor's environment.
     *
     * @public
     */
    T(this, "environment");
    /**
     * A manager for the editor's scribbles.
     *
     * @public
     */
    T(this, "scribbles");
    /**
     * A manager for side effects and correct state enforcement. See {@link @tldraw/store#StoreSideEffects} for details.
     *
     * @public
     */
    T(this, "sideEffects");
    /**
     * A manager for moving the camera when the mouse is at the edge of the screen.
     *
     * @public
     */
    T(this, "edgeScrollManager");
    /**
     * A manager for ensuring correct focus. See FocusManager for details.
     *
     * @internal
     */
    T(this, "focusManager");
    /**
     * The current HTML element containing the editor.
     *
     * @example
     * ```ts
     * const container = editor.getContainer()
     * ```
     *
     * @public
     */
    T(this, "getContainer");
    /* ------------------- Shape Utils ------------------ */
    /**
     * A map of shape utility classes (TLShapeUtils) by shape type.
     *
     * @public
     */
    T(this, "shapeUtils");
    T(this, "styleProps");
    /* ------------------- Binding Utils ------------------ */
    /**
     * A map of shape utility classes (TLShapeUtils) by shape type.
     *
     * @public
     */
    T(this, "bindingUtils");
    /* --------------------- History -------------------- */
    /**
     * A manager for the app's history.
     *
     * @readonly
     */
    T(this, "history");
    T(this, "_shouldIgnoreShapeLock", !1);
    /** @internal */
    T(this, "_crashingError", null);
    /** @internal */
    T(this, "_updateInstanceState", (e, r) => {
      this.run(() => {
        this.store.put([
          {
            ...this.getInstanceState(),
            ...e
          }
        ]);
      }, r);
    });
    /** @internal */
    T(this, "_isChangingStyleTimeout", -1);
    /* --------------------- Cursor --------------------- */
    /**
     * Set the cursor.
     *
     * @param type - The cursor type.
     * @param rotation - The cursor rotation.
     *
     * @public
     */
    T(this, "setCursor", (e) => (this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...e } }), this));
    T(this, "_updateCurrentPageState", (e) => {
      this.store.update(e.id ?? this.getCurrentPageState().id, (r) => ({
        ...r,
        ...e
      }));
    });
    T(this, "_cameraOptions", Qs("camera options", m9));
    /** @internal */
    T(this, "_viewportAnimation", null);
    // Viewport
    /** @internal */
    T(this, "_willSetInitialBounds", !0);
    // Following
    // When we are 'locked on' to a user, our camera is derived from their camera.
    T(this, "_isLockedOnFollowingUser", Qs("isLockedOnFollowingUser", !1));
    // Camera state
    // Camera state does two things: first, it allows us to subscribe to whether
    // the camera is moving or not; and second, it allows us to update the rendering
    // shapes on the canvas. Changing the rendering shapes may cause shapes to
    // unmount / remount in the DOM, which is expensive; and computing visibility is
    // also expensive in large projects. For this reason, we use a second bounding
    // box just for rendering, and we only update after the camera stops moving.
    T(this, "_cameraState", Qs("camera state", "idle"));
    T(this, "_cameraStateTimeoutRemaining", 0);
    T(this, "_decayCameraStateTimeout", (e) => {
      this._cameraStateTimeoutRemaining -= e, !(this._cameraStateTimeoutRemaining > 0) && (this.off("tick", this._decayCameraStateTimeout), this._cameraState.set("idle"));
    });
    T(this, "_tickCameraState", () => {
      this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs, this._cameraState.__unsafe__getWithoutCapture() === "idle" && (this._cameraState.set("moving"), this.on("tick", this._decayCameraStateTimeout));
    });
    /* @internal */
    T(this, "_currentPageShapeIds");
    // Parents and children
    /**
     * A cache of parents to children.
     *
     * @internal
     */
    T(this, "_parentIdsToChildIds");
    T(this, "animatingShapes", /* @__PURE__ */ new Map());
    /** @internal */
    T(this, "_updateShapes", (e) => {
      this.getInstanceState().isReadonly || this.run(() => {
        var o, l;
        const r = [];
        let i, s;
        for (let u = 0, d = e.length; u < d; u++) {
          const f = e[u];
          f && (i = this.getShape(f.id), i && (s = Yd(i, f), s !== i && (s = ((l = (o = this.getShapeUtil(i)).onBeforeUpdate) == null ? void 0 : l.call(o, i, s)) ?? s, r.push(s))));
        }
        this.store.put(r);
      });
    });
    /* --------------------- Content -------------------- */
    /** @internal */
    T(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    });
    /** @internal */
    T(this, "externalContentHandlers", {
      text: null,
      files: null,
      embed: null,
      "svg-text": null,
      url: null
    });
    /* --------------------- Events --------------------- */
    /**
     * The app's current input state.
     *
     * @public
     */
    T(this, "inputs", {
      /** The most recent pointer down's position in the current page space. */
      originPagePoint: new O(),
      /** The most recent pointer down's position in screen space. */
      originScreenPoint: new O(),
      /** The previous pointer position in the current page space. */
      previousPagePoint: new O(),
      /** The previous pointer position in screen space. */
      previousScreenPoint: new O(),
      /** The most recent pointer position in the current page space. */
      currentPagePoint: new O(),
      /** The most recent pointer position in screen space. */
      currentScreenPoint: new O(),
      /** A set containing the currently pressed keys. */
      keys: /* @__PURE__ */ new Set(),
      /** A set containing the currently pressed buttons. */
      buttons: /* @__PURE__ */ new Set(),
      /** Whether the input is from a pe. */
      isPen: !1,
      /** Whether the shift key is currently pressed. */
      shiftKey: !1,
      /** Whether the control or command key is currently pressed. */
      ctrlKey: !1,
      /** Whether the alt or option key is currently pressed. */
      altKey: !1,
      /** Whether the user is dragging. */
      isDragging: !1,
      /** Whether the user is pointing. */
      isPointing: !1,
      /** Whether the user is pinching. */
      isPinching: !1,
      /** Whether the user is editing. */
      isEditing: !1,
      /** Whether the user is panning. */
      isPanning: !1,
      /** Velocity of mouse pointer, in pixels per millisecond */
      pointerVelocity: new O()
    });
    /**
     * A manager for recording multiple click events.
     *
     * @internal
     */
    T(this, "_clickManager", new T0e(this));
    /**
     * The previous cursor. Used for restoring the cursor after pan events.
     *
     * @internal
     */
    T(this, "_prevCursor", "default");
    /** @internal */
    T(this, "_shiftKeyTimeout", -1);
    /** @internal */
    T(this, "_setShiftKeyTimeout", () => {
      this.inputs.shiftKey = !1, this.dispatch({
        type: "keyboard",
        name: "key_up",
        key: "Shift",
        shiftKey: this.inputs.shiftKey,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        code: "ShiftLeft"
      });
    });
    /** @internal */
    T(this, "_altKeyTimeout", -1);
    /** @internal */
    T(this, "_setAltKeyTimeout", () => {
      this.inputs.altKey = !1, this.dispatch({
        type: "keyboard",
        name: "key_up",
        key: "Alt",
        shiftKey: this.inputs.shiftKey,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        code: "AltLeft"
      });
    });
    /** @internal */
    T(this, "_ctrlKeyTimeout", -1);
    /** @internal */
    T(this, "_setCtrlKeyTimeout", () => {
      this.inputs.ctrlKey = !1, this.dispatch({
        type: "keyboard",
        name: "key_up",
        key: "Ctrl",
        shiftKey: this.inputs.shiftKey,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        code: "ControlLeft"
      });
    });
    /** @internal */
    T(this, "_restoreToolId", "select");
    /** @internal */
    T(this, "_pinchStart", 1);
    /** @internal */
    T(this, "_didPinch", !1);
    /** @internal */
    T(this, "_selectedShapeIdsAtPointerDown", []);
    /** @internal */
    T(this, "_longPressTimeout", -1);
    /** @internal */
    T(this, "capturedPointerId", null);
    /** @internal */
    T(this, "performanceTracker");
    /** @internal */
    T(this, "performanceTrackerTimeout", -1);
    /**
     * Dispatch an event to the editor.
     *
     * @example
     * ```ts
     * editor.dispatch(myPointerEvent)
     * ```
     *
     * @param info - The event info.
     *
     * @public
     */
    T(this, "dispatch", (e) => (this._pendingEventsForNextTick.push(e), e.type === "pointer" && e.name === "pointer_move" || e.type === "wheel" || e.type === "pinch" || this._flushEventsForTick(0), this));
    T(this, "_pendingEventsForNextTick", []);
    T(this, "_flushEventForTick", (e) => {
      if (this.getCrashingError()) return this;
      const { inputs: r } = this, { type: i } = e;
      if (e.type === "misc") {
        (e.name === "cancel" || e.name === "complete") && (this.inputs.isDragging = !1, this.inputs.isPanning && (this.inputs.isPanning = !1, this.setCursor({ type: this._prevCursor, rotation: 0 }))), this.root.handleEvent(e);
        return;
      }
      e.shiftKey ? (clearTimeout(this._shiftKeyTimeout), this._shiftKeyTimeout = -1, r.shiftKey = !0) : !e.shiftKey && r.shiftKey && this._shiftKeyTimeout === -1 && (this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150)), e.altKey ? (clearTimeout(this._altKeyTimeout), this._altKeyTimeout = -1, r.altKey = !0) : !e.altKey && r.altKey && this._altKeyTimeout === -1 && (this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150)), e.ctrlKey ? (clearTimeout(this._ctrlKeyTimeout), this._ctrlKeyTimeout = -1, r.ctrlKey = !0) : !e.ctrlKey && r.ctrlKey && this._ctrlKeyTimeout === -1 && (this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150));
      const { originPagePoint: s, currentPagePoint: o } = r;
      r.isPointing || (r.isDragging = !1);
      const l = this.store.unsafeGetWithoutCapture(za), u = this.store.get(this._getCurrentPageStateId()), d = this._cameraOptions.__unsafe__getWithoutCapture();
      switch (i) {
        case "pinch": {
          if (d.isLocked) return;
          switch (clearTimeout(this._longPressTimeout), this._updateInputsFromEvent(e), e.name) {
            case "pinch_start": {
              if (r.isPinching) return;
              r.isEditing || (this._pinchStart = this.getCamera().z, this._selectedShapeIdsAtPointerDown.length || (this._selectedShapeIdsAtPointerDown = [...u.selectedShapeIds]), this._didPinch = !0, r.isPinching = !0, this.interrupt());
              return;
            }
            case "pinch": {
              if (!r.isPinching) return;
              const {
                point: { z: f = 1 },
                delta: { x: m, y: v }
              } = e, { x: S, y: w } = O.SubXY(
                e.point,
                l.screenBounds.x,
                l.screenBounds.y
              );
              this.stopCameraAnimation(), l.followingUserId && this.stopFollowingUser();
              const { x: E, y: A, z: P } = nI(() => this.getCamera()), { panSpeed: R, zoomSpeed: M } = d;
              this._setCamera(
                new O(
                  E + m * R / P - S / P + S / (f * M),
                  A + v * R / P - w / P + w / (f * M),
                  f * M
                ),
                { immediate: !0 }
              );
              return;
            }
            case "pinch_end": {
              if (!r.isPinching) return this;
              r.isPinching = !1;
              const { _selectedShapeIdsAtPointerDown: f } = this;
              this.setSelectedShapes(this._selectedShapeIdsAtPointerDown), this._selectedShapeIdsAtPointerDown = [], this._didPinch && (this._didPinch = !1, f.length > 0 && this.once("tick", () => {
                this._didPinch || this.setSelectedShapes(f);
              }));
              return;
            }
          }
        }
        case "wheel": {
          if (d.isLocked) return;
          if (this._updateInputsFromEvent(e), !this.getIsMenuOpen()) {
            const { panSpeed: f, zoomSpeed: m, wheelBehavior: v } = d;
            if (v !== "none") {
              this.stopCameraAnimation(), l.followingUserId && this.stopFollowingUser();
              const { x: S, y: w, z: E } = nI(() => this.getCamera()), { x: A, y: P, z: R = 0 } = e.delta;
              let M = v;
              switch (r.ctrlKey && (M = v === "pan" ? "zoom" : "pan"), M) {
                case "zoom": {
                  const { x: j, y: $ } = this.inputs.currentScreenPoint;
                  let U = R;
                  v === "zoom" && (Math.abs(P) > 10 ? U = 10 * Math.sign(P) / 100 : U = P / 100);
                  const F = E + (U ?? 0) * m * E;
                  this._setCamera(
                    new O(
                      S + (j / F - j) - (j / E - j),
                      w + ($ / F - $) - ($ / E - $),
                      F
                    ),
                    { immediate: !0 }
                  ), this.maybeTrackPerformance("Zooming");
                  return;
                }
                case "pan": {
                  this._setCamera(new O(S + A * f / E, w + P * f / E, E), {
                    immediate: !0
                  }), this.maybeTrackPerformance("Panning");
                  return;
                }
              }
            }
          }
          break;
        }
        case "pointer": {
          if (r.isPinching) return;
          this._updateInputsFromEvent(e);
          const { isPen: f } = e, { isPenMode: m } = l;
          switch (e.name) {
            case "pointer_down": {
              if (m && !f) return;
              if (this.clearOpenMenus(), this.inputs.isPanning || (this._longPressTimeout = this.timers.setTimeout(() => {
                this.dispatch({
                  ...e,
                  point: this.inputs.currentScreenPoint,
                  name: "long_press"
                });
              }, this.options.longPressDurationMs)), this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds(), e.button === y9 && (this.capturedPointerId = e.pointerId), r.buttons.add(e.button), r.isPointing = !0, r.isDragging = !1, !m && f && this.updateInstanceState({ isPenMode: !0 }), e.button === S9 ? (this._restoreToolId = this.getCurrentToolId(), this.complete(), this.setCurrentTool("eraser")) : e.button === cI && (this.inputs.isPanning || (this._prevCursor = this.getInstanceState().cursor.type), this.inputs.isPanning = !0, clearTimeout(this._longPressTimeout)), this.inputs.isPanning)
                return this.stopCameraAnimation(), this.setCursor({ type: "grabbing", rotation: 0 }), this;
              break;
            }
            case "pointer_move": {
              if (!f && m) return;
              const { x: v, y: S, z: w } = nI(() => this.getCamera());
              if (this.inputs.isPanning && this.inputs.isPointing) {
                const { currentScreenPoint: E, previousScreenPoint: A } = this.inputs, { panSpeed: P } = d, R = O.Sub(E, A);
                this.setCamera(
                  new O(v + R.x * P / w, S + R.y * P / w, w),
                  { immediate: !0 }
                ), this.maybeTrackPerformance("Panning");
                return;
              }
              r.isPointing && !r.isDragging && O.Dist2(s, o) * this.getZoomLevel() > (l.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / w && (r.isDragging = !0, clearTimeout(this._longPressTimeout));
              break;
            }
            case "pointer_up": {
              if (r.isDragging = !1, r.isPointing = !1, clearTimeout(this._longPressTimeout), r.buttons.delete(e.button), this.getIsMenuOpen() || l.isPenMode && !f) return;
              if (this.capturedPointerId === e.pointerId && (this.capturedPointerId = null, e.button = 0), r.isPanning) {
                r.keys.has("Space") || (r.isPanning = !1);
                const v = this.inputs.pointerVelocity, S = Math.min(2, v.len());
                switch (e.button) {
                  case y9: {
                    this.setCursor({ type: "grab", rotation: 0 });
                    break;
                  }
                  case cI:
                    this.inputs.keys.has(" ") ? this.setCursor({ type: "grab", rotation: 0 }) : this.setCursor({ type: this._prevCursor, rotation: 0 });
                }
                S > 0 && this.slideCamera({ speed: S, direction: v });
              } else
                e.button === S9 && (this.complete(), this.setCurrentTool(this._restoreToolId));
              break;
            }
          }
          break;
        }
        case "keyboard": {
          switch (e.key === "ShiftRight" && (e.key = "ShiftLeft"), e.key === "AltRight" && (e.key = "AltLeft"), e.code === "ControlRight" && (e.code = "ControlLeft"), e.name) {
            case "key_down": {
              r.keys.add(e.code), e.code === "Space" && !e.ctrlKey && (this.inputs.isPanning || (this._prevCursor = l.cursor.type), this.inputs.isPanning = !0, clearTimeout(this._longPressTimeout), this.setCursor({ type: this.inputs.isPointing ? "grabbing" : "grab", rotation: 0 }));
              break;
            }
            case "key_up": {
              r.keys.delete(e.code), e.code === "Space" && (this.inputs.buttons.has(cI) || (this.inputs.isPanning = !1, this.setCursor({ type: this._prevCursor, rotation: 0 })));
              break;
            }
          }
          break;
        }
      }
      if (e.type === "pointer") {
        e.button === cI ? e.name = "middle_click" : e.button === f5 && (e.name = "right_click");
        const { isPenMode: f } = this.store.unsafeGetWithoutCapture(za);
        if (e.isPen === f) {
          const m = this._clickManager.handlePointerEvent(e);
          if (e.name !== m.name) {
            this.root.handleEvent(e), this.emit("event", e), this.root.handleEvent(m), this.emit("event", m);
            return;
          }
        }
      }
      return this.root.handleEvent(e), this.emit("event", e), this;
    });
    this.options = { ...c0e, ...v }, this.store = e, this.disposables.add(this.store.dispose.bind(this.store)), this.history = new M0e({
      store: e,
      annotateError: (G) => {
        this.annotateError(G, { origin: "history.batch", willCrashApp: !0 }), this.crash(G);
      }
    }), this.snaps = new F2(this), this.timers = new zme(), this.disposables.add(this.timers.dispose.bind(this.timers)), this._cameraOptions.set({ ...m9, ...u }), this.user = new Cc(r ?? iY(), m ?? !1), this.getContainer = l ?? (() => document.body), this.textMeasure = new X0e(this), this._tickManager = new q0e(this);
    class S extends tR {
    }
    T(S, "initial", d ?? ""), this.root = new S(this), this.root.children = {};
    const w = mY(i), E = {}, A = {}, P = /* @__PURE__ */ new Map();
    for (const G of w) {
      const X = new G(this);
      E[G.type] = X;
      const te = NG(G.props ?? {});
      A[G.type] = te;
      for (const ne of te.keys())
        if (!P.has(ne.id))
          P.set(ne.id, ne);
        else if (P.get(ne.id) !== ne)
          throw Error(
            `Multiple style props with id "${ne.id}" in use. Style prop IDs must be unique.`
          );
    }
    this.shapeUtils = E, this.styleProps = A;
    const R = fY(s), M = {};
    for (const G of R) {
      const X = new G(this);
      M[G.type] = X;
    }
    this.bindingUtils = M;
    for (const G of [...o]) {
      if (xh(this.root.children, G.id))
        throw Error(`Can't override tool with id "${G.id}"`);
      this.root.children[G.id] = new G(this, this.root);
    }
    this.environment = new A0e(this), this.scribbles = new L0e(this);
    const j = (G, X) => {
      let te = null;
      const ne = G.selectedShapeIds.filter(
        (oe) => !X.has(oe)
      );
      ne.length !== G.selectedShapeIds.length && (te || (te = { ...G }), te.selectedShapeIds = ne);
      const K = G.erasingShapeIds.filter(
        (oe) => !X.has(oe)
      );
      K.length !== G.erasingShapeIds.length && (te || (te = { ...G }), te.erasingShapeIds = K), G.hoveredShapeId && X.has(G.hoveredShapeId) && (te || (te = { ...G }), te.hoveredShapeId = null), G.editingShapeId && X.has(G.editingShapeId) && (te || (te = { ...G }), te.editingShapeId = null);
      const Z = G.hintingShapeIds.filter(
        (oe) => !X.has(oe)
      );
      return Z.length !== G.hintingShapeIds.length && (te || (te = { ...G }), te.hintingShapeIds = Z), G.focusedGroupId && X.has(G.focusedGroupId) && (te || (te = { ...G }), te.focusedGroupId = null), te;
    };
    this.sideEffects = this.store.sideEffects;
    let $ = /* @__PURE__ */ new Map();
    const U = /* @__PURE__ */ new Set(), F = /* @__PURE__ */ new Set();
    let B = /* @__PURE__ */ new Set();
    if (this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        var G, X, te, ne;
        U.clear();
        for (const K of F) {
          F.delete(K);
          const Z = this.getShape(K);
          if (!Z) continue;
          const oe = this.getShapeUtil(Z), fe = (G = oe.onChildrenChange) == null ? void 0 : G.call(oe, Z);
          fe != null && fe.length && this.updateShapes(fe);
        }
        if (B.size) {
          const K = B;
          B = /* @__PURE__ */ new Set();
          for (const Z of K) {
            const oe = this.getBindingUtil(Z);
            (X = oe.onOperationComplete) == null || X.call(oe);
          }
        }
        if ($.size) {
          const K = $;
          $ = /* @__PURE__ */ new Map();
          for (const Z of K.values())
            (ne = (te = this.getBindingUtil(Z.binding)).onAfterDelete) == null || ne.call(te, Z);
        }
        this.emit("update");
      })
    ), this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (G, X) => {
            var te, ne, K, Z;
            for (const oe of this.getBindingsInvolvingShape(X))
              B.add(oe.type), oe.fromId === X.id && ((ne = (te = this.getBindingUtil(oe)).onAfterChangeFromShape) == null || ne.call(te, {
                binding: oe,
                shapeBefore: G,
                shapeAfter: X
              })), oe.toId === X.id && ((Z = (K = this.getBindingUtil(oe)).onAfterChangeToShape) == null || Z.call(K, {
                binding: oe,
                shapeBefore: G,
                shapeAfter: X
              }));
            if (G.parentId !== X.parentId) {
              const oe = (fe) => {
                var ue, Se, ke, ce;
                const ie = this.getShape(fe);
                if (ie)
                  for (const ye of this.getBindingsInvolvingShape(ie))
                    B.add(ye.type), ye.fromId === ie.id && ((Se = (ue = this.getBindingUtil(ye)).onAfterChangeFromShape) == null || Se.call(ue, {
                      binding: ye,
                      shapeBefore: ie,
                      shapeAfter: ie
                    })), ye.toId === ie.id && ((ce = (ke = this.getBindingUtil(ye)).onAfterChangeToShape) == null || ce.call(ke, {
                      binding: ye,
                      shapeBefore: ie,
                      shapeAfter: ie
                    }));
              };
              oe(X.id), this.visitDescendants(X.id, oe);
            }
            if (G.parentId !== X.parentId && El(X.parentId)) {
              const oe = /* @__PURE__ */ new Set([G.id]);
              this.visitDescendants(G.id, (fe) => {
                oe.add(fe);
              });
              for (const fe of this.getPageStates()) {
                if (fe.pageId === X.parentId) continue;
                const ie = j(fe, oe);
                ie && this.store.put([ie]);
              }
            }
            G.parentId && kl(G.parentId) && F.add(G.parentId), X.parentId !== G.parentId && kl(X.parentId) && F.add(X.parentId);
          },
          beforeDelete: (G) => {
            var K, Z, oe, fe;
            if (U.has(G.id)) return;
            G.parentId && kl(G.parentId) && F.add(G.parentId), U.add(G.id);
            const X = [];
            for (const ie of this.getBindingsInvolvingShape(G)) {
              B.add(ie.type), X.push(ie.id);
              const ue = this.getBindingUtil(ie);
              ie.fromId === G.id ? ((K = ue.onBeforeIsolateToShape) == null || K.call(ue, { binding: ie, removedShape: G }), (Z = ue.onBeforeDeleteFromShape) == null || Z.call(ue, { binding: ie, shape: G })) : ((oe = ue.onBeforeIsolateFromShape) == null || oe.call(ue, { binding: ie, removedShape: G }), (fe = ue.onBeforeDeleteToShape) == null || fe.call(ue, { binding: ie, shape: G }));
            }
            X.length && this.deleteBindings(X);
            const te = /* @__PURE__ */ new Set([G.id]), ne = xn(
              this.getPageStates().map((ie) => j(ie, te))
            );
            ne.length && this.store.put(ne);
          }
        },
        binding: {
          beforeCreate: (G) => {
            var te, ne;
            const X = (ne = (te = this.getBindingUtil(G)).onBeforeCreate) == null ? void 0 : ne.call(te, { binding: G });
            return X || G;
          },
          afterCreate: (G) => {
            var X, te;
            B.add(G.type), (te = (X = this.getBindingUtil(G)).onAfterCreate) == null || te.call(X, { binding: G });
          },
          beforeChange: (G, X) => {
            var ne, K;
            const te = (K = (ne = this.getBindingUtil(X)).onBeforeChange) == null ? void 0 : K.call(ne, {
              bindingBefore: G,
              bindingAfter: X
            });
            return te || X;
          },
          afterChange: (G, X) => {
            var te, ne;
            B.add(X.type), (ne = (te = this.getBindingUtil(X)).onAfterChange) == null || ne.call(te, { bindingBefore: G, bindingAfter: X });
          },
          beforeDelete: (G) => {
            var X, te;
            (te = (X = this.getBindingUtil(G)).onBeforeDelete) == null || te.call(X, { binding: G });
          },
          afterDelete: (G) => {
            var X, te;
            (te = (X = this.getBindingUtil(G)).onAfterDelete) == null || te.call(X, { binding: G }), B.add(G.type);
          }
        },
        page: {
          afterCreate: (G) => {
            const X = vh.createId(G.id), te = sd.createId(G.id);
            this.store.has(X) || this.store.put([vh.create({ id: X })]), this.store.has(te) || this.store.put([
              sd.create({ id: te, pageId: G.id })
            ]);
          },
          afterDelete: (G, X) => {
            var K, Z;
            if (((K = this.getInstanceState()) == null ? void 0 : K.currentPageId) === G.id) {
              const oe = (Z = this.getPages().find((fe) => fe.id !== G.id)) == null ? void 0 : Z.id;
              oe ? this.store.put([{ ...this.getInstanceState(), currentPageId: oe }]) : X === "user" && this.store.ensureStoreIsUsable();
            }
            const te = vh.createId(G.id), ne = sd.createId(G.id);
            this.store.remove([te, ne]);
          }
        },
        instance: {
          afterChange: (G, X, te) => {
            var ne;
            if (!this.store.has(X.currentPageId)) {
              const K = this.store.has(G.currentPageId) ? G.currentPageId : (ne = this.getPages()[0]) == null ? void 0 : ne.id;
              K ? this.store.update(X.id, (Z) => ({
                ...Z,
                currentPageId: K
              })) : te === "user" && this.store.ensureStoreIsUsable();
            }
          }
        },
        instance_page_state: {
          afterChange: (G, X) => {
            if ((G == null ? void 0 : G.selectedShapeIds) !== (X == null ? void 0 : X.selectedShapeIds)) {
              const te = X.selectedShapeIds.filter((K) => {
                var oe, fe;
                let Z = (oe = this.getShape(K)) == null ? void 0 : oe.parentId;
                for (; kl(Z); ) {
                  if (X.selectedShapeIds.includes(Z))
                    return !1;
                  Z = (fe = this.getShape(Z)) == null ? void 0 : fe.parentId;
                }
                return !0;
              });
              let ne = null;
              if (te.length > 0) {
                const K = this.findCommonAncestor(
                  xn(te.map((Z) => this.getShape(Z))),
                  (Z) => this.isShapeOfType(Z, "group")
                );
                K && (ne = K);
              } else
                X != null && X.focusedGroupId && (ne = X.focusedGroupId);
              (te.length !== X.selectedShapeIds.length || ne !== X.focusedGroupId) && this.store.put([
                {
                  ...X,
                  selectedShapeIds: te,
                  focusedGroupId: ne ?? null
                }
              ]);
            }
          }
        }
      })
    ), this._currentPageShapeIds = w0e(
      this.store,
      () => this.getCurrentPageId()
    ), this._parentIdsToChildIds = x0e(this.store), this.disposables.add(
      this.store.listen((G) => {
        this.emit("change", G);
      })
    ), this.disposables.add(this.history.dispose), this.run(
      () => {
        this.store.ensureStoreIsUsable(), this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    ), d && this.root.children[d] === void 0)
      throw Error(`No state found for initialState "${d}".`);
    this.root.enter(void 0, "initial"), this.edgeScrollManager = new P0e(this), this.focusManager = new k0e(this, f), this.disposables.add(this.focusManager.dispose.bind(this.focusManager)), this.getInstanceState().followingUserId && this.stopFollowingUser(), this.on("tick", this._flushEventsForTick), this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    }), this.performanceTracker = new uG();
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((e) => e()), this.disposables.clear(), this.isDisposed = !0;
  }
  getShapeUtil(e) {
    const r = typeof e == "string" ? e : e.type, i = Dl(this.shapeUtils, r);
    return ii(i, `No shape util found for type "${r}"`), i;
  }
  getBindingUtil(e) {
    const r = typeof e == "string" ? e : e.type, i = Dl(this.bindingUtils, r);
    return ii(i, `No binding util found for type "${r}"`), i;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    return this._flushEventsForTick(0), this.complete(), this.history.undo(), this;
  }
  getCanUndo() {
    return this.history.getNumUndos() > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    return this._flushEventsForTick(0), this.complete(), this.history.redo(), this;
  }
  clearHistory() {
    return this.history.clear(), this;
  }
  getCanRedo() {
    return this.history.getNumRedos() > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * editor.mark()
   * editor.mark('flip shapes')
   * ```
   *
   * @param markId - The mark's id, usually the reason for adding the mark.
   *
   * @public
   */
  mark(e) {
    return this.history.mark(e), this;
  }
  /**
   * Squash the history to the given mark id.
   *
   * @example
   * ```ts
   * editor.mark('bump shapes')
   * // ... some changes
   * editor.squashToMark('bump shapes')
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(e) {
    return this.history.squashToMark(e), this;
  }
  /**
   * Clear all marks in the undo stack back to the next mark.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    return this.history.bail(), this;
  }
  /**
   * Clear all marks in the undo stack back to the mark with the provided mark id.
   *
   * @example
   * ```ts
   * editor.bailToMark('dragging')
   * ```
   *
   * @public
   */
  bailToMark(e) {
    return this.history.bailToMark(e), this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(e, r) {
    const i = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = (r == null ? void 0 : r.ignoreShapeLock) ?? i;
    try {
      this.history.batch(e, r);
    } finally {
      this._shouldIgnoreShapeLock = i;
    }
    return this;
  }
  /**
   * @deprecated Use `Editor.run` instead.
   */
  batch(e, r) {
    return this.run(e, r);
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(e, {
    origin: r,
    willCrashApp: i,
    tags: s,
    extras: o
  }) {
    const l = this.createErrorAnnotations(r, i);
    return qz(e, {
      tags: { ...l.tags, ...s },
      extras: { ...l.extras, ...o }
    }), i && this.store.markAsPossiblyCorrupted(), this;
  }
  /** @internal */
  createErrorAnnotations(e, r) {
    try {
      const i = this.getEditingShapeId();
      return {
        tags: {
          origin: e,
          willCrashApp: r
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes(),
          editingShape: i ? this.getShape(i) : void 0,
          inputs: this.inputs
        }
      };
    } catch {
      return {
        tags: {
          origin: e,
          willCrashApp: r
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(e) {
    return this._crashingError = e, this.store.markAsPossiblyCorrupted(), this.emit("crash", { error: e }), this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(e) {
    const r = e.split(".").reverse();
    let i = this.root;
    for (; r.length > 0; ) {
      const s = r.pop();
      if (!s) return !0;
      const o = i.getCurrent();
      if ((o == null ? void 0 : o.id) === s) {
        if (r.length === 0) return !0;
        i = o;
        continue;
      } else return !1;
    }
    return !1;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...e) {
    return e.some((r) => this.isIn(r));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(e, r = {}) {
    return this.root.transition(e, r), this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const e = this.getCurrentTool();
    return e ? e.getCurrentToolIdMask() ?? e.id : "";
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * state.getStateDescendant('select')
   * state.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(e) {
    var s;
    const r = e.split(".").reverse();
    let i = this.root;
    for (; r.length > 0; ) {
      const o = r.pop();
      if (!o) return i;
      const l = (s = i.children) == null ? void 0 : s[o];
      if (!l) return;
      i = l;
    }
    return i;
  }
  getDocumentSettings() {
    return this.store.get(h3);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(e) {
    return this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...e }]);
      },
      { history: "ignore" }
    ), this;
  }
  getInstanceState() {
    return this.store.get(za);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   *
   * @public
   */
  updateInstanceState(e, r) {
    return this._updateInstanceState(e, { history: "ignore", ...r }), e.isChangingStyle !== void 0 && (clearTimeout(this._isChangingStyleTimeout), e.isChangingStyle === !0 && (this._isChangingStyleTimeout = this.timers.setTimeout(() => {
      this._updateInstanceState({ isChangingStyle: !1 }, { history: "ignore" });
    }, 2e3))), this;
  }
  getOpenMenus() {
    return this.getInstanceState().openMenus;
  }
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * editor.addOpenMenu('menu-id')
   * ```
   *
   * @public
   */
  addOpenMenu(e) {
    const r = new Set(this.getOpenMenus());
    return r.has(e) || (r.add(e), this.updateInstanceState({ openMenus: [...r] })), this;
  }
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * editor.deleteOpenMenu('menu-id')
   * ```
   *
   * @public
   */
  deleteOpenMenu(e) {
    const r = new Set(this.getOpenMenus());
    return r.has(e) && (r.delete(e), this.updateInstanceState({ openMenus: [...r] })), this;
  }
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * editor.clearOpenMenus()
   * ```
   *
   * @public
   */
  clearOpenMenus() {
    return this.getOpenMenus().length && this.updateInstanceState({ openMenus: [] }), this;
  }
  getIsMenuOpen() {
    return this.getOpenMenus().length > 0;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return sd.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(e) {
    return this._updateCurrentPageState(e), this;
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    const { selectedShapeIds: e } = this.getCurrentPageState();
    return xn(e.map((r) => this.store.get(r)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids to select.
   *
   * @public
   */
  setSelectedShapes(e) {
    return this.run(
      () => {
        const r = e.map((o) => typeof o == "string" ? o : o.id), { selectedShapeIds: i } = this.getCurrentPageState(), s = new Set(i);
        if (r.length === s.size && r.every((o) => s.has(o))) return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: r }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param id - The id of the shape to check.
   *
   * @public
   */
  isAncestorSelected(e) {
    const r = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null, i = this.getShape(r);
    if (!i) return !1;
    const s = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(i, (o) => s.includes(o.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param ids - The ids to select.
   *
   * @public
   */
  select(...e) {
    const r = typeof e[0] == "string" ? e : e.map((i) => i.id);
    return this.setSelectedShapes(r), this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = this.getSelectedShapeIds();
    return i.length > 0 && r.length > 0 && this.setSelectedShapes(i.filter((s) => !r.includes(s))), this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const e = this.getSortedChildIdsForParent(this.getCurrentPageId());
    return e.length <= 0 ? this : (this.setSelectedShapes(this._getUnlockedShapeIds(e)), this);
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    return this.getSelectedShapeIds().length > 0 && this.setSelectedShapes([]), this;
  }
  getOnlySelectedShapeId() {
    var e;
    return ((e = this.getOnlySelectedShape()) == null ? void 0 : e.id) ?? null;
  }
  getOnlySelectedShape() {
    const e = this.getSelectedShapes();
    return e.length === 1 ? e[0] : null;
  }
  getSelectionPageBounds() {
    const e = this.getCurrentPageState().selectedShapeIds;
    return e.length === 0 ? null : vt.Common(xn(e.map((r) => this.getShapePageBounds(r))));
  }
  getSelectionRotation() {
    const e = this.getSelectedShapeIds();
    let r = !1, i = 0;
    for (let s = 0, o = e.length; s < o; s++) {
      const l = this.getShapePageTransform(e[s]);
      if (l)
        if (r) {
          if (l.rotation() !== i)
            return 0;
        } else
          r = !0, i = l.rotation();
    }
    return i;
  }
  getSelectionRotatedPageBounds() {
    const e = this.getSelectedShapeIds();
    if (e.length === 0)
      return;
    const r = this.getSelectionRotation();
    if (r === 0)
      return this.getSelectionPageBounds();
    if (e.length === 1) {
      const s = this.getShapeGeometry(e[0]).bounds.clone(), o = this.getShapePageTransform(e[0]);
      return s.point = o.applyToPoint(s.point), s;
    }
    const i = vt.FromPoints(
      this.getSelectedShapeIds().flatMap((s) => {
        const o = this.getShapePageTransform(s);
        return o ? o.applyToPoints(this.getShapeGeometry(s).bounds.corners) : [];
      }).map((s) => s.rot(-r))
    );
    return i.point = i.point.rot(r), i;
  }
  getSelectionRotatedScreenBounds() {
    const e = this.getSelectionRotatedPageBounds();
    if (!e) return;
    const { x: r, y: i } = this.pageToScreen(e.point), s = this.getZoomLevel();
    return new vt(r, i, e.width * s, e.height * s);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const e = this.getFocusedGroupId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(e) {
    const r = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    if (r !== null) {
      const i = this.getShape(r);
      if (!i)
        throw Error(`Editor.setFocusedGroup: Shape with id ${r} does not exist`);
      if (!this.isShapeOfType(i, "group"))
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${i.type}`
        );
    }
    return r === this.getFocusedGroupId() ? this : this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (i) => ({ ...i, focusedGroupId: r }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const e = this.getFocusedGroup();
    if (e) {
      const r = this.findShapeAncestor(
        e,
        (i) => this.isShapeOfType(i, "group")
      );
      this.setFocusedGroup((r == null ? void 0 : r.id) ?? null), this.select(e.id);
    } else
      this.setFocusedGroup(null), this.selectNone();
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const e = this.getEditingShapeId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(e) {
    const r = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    if (r !== this.getEditingShapeId()) {
      if (r) {
        const i = this.getShape(r);
        if (i && this.getShapeUtil(i).canEdit(i))
          return this.run(
            () => {
              this._updateCurrentPageState({ editingShapeId: r });
            },
            { history: "ignore" }
          ), this;
      }
      this.run(
        () => {
          this._updateCurrentPageState({ editingShapeId: null });
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const e = this.getHoveredShapeId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shapes - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(e) {
    const r = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    return r === this.getHoveredShapeId() ? this : (this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: r });
      },
      { history: "ignore" }
    ), this);
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const e = this.getHintingShapeIds();
    return xn(e.map((r) => this.getShape(r)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(e) {
    const r = typeof e[0] == "string" ? e : e.map((i) => i.id);
    return this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: Xz(r) });
      },
      { history: "ignore" }
    ), this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const e = this.getErasingShapeIds();
    return xn(e.map((r) => this.getShape(r)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id);
    r.sort();
    const i = this.getErasingShapeIds();
    return this.run(
      () => {
        if (r.length === i.length) {
          for (let s = 0; s < r.length; s++)
            if (r[s] !== i[s]) {
              this._updateCurrentPageState({ erasingShapeIds: r });
              break;
            }
        } else
          this._updateCurrentPageState({ erasingShapeIds: r });
      },
      { history: "ignore" }
    ), this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(e) {
    const r = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    return r !== this.getCroppingShapeId() && this.run(
      () => {
        if (!r)
          this.updateCurrentPageState({ croppingShapeId: null });
        else {
          const i = this.getShape(r), s = this.getShapeUtil(i);
          i && s.canCrop(i) && this.updateCurrentPageState({ croppingShapeId: r });
        }
      },
      { history: "ignore" }
    ), this;
  }
  _unsafe_getCameraId() {
    return vh.createId(this.getCurrentPageId());
  }
  getCamera() {
    const e = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const r = this.getCameraForFollowing();
      if (r)
        return { ...e, ...r };
    }
    return e;
  }
  getViewportPageBoundsForFollowing() {
    const e = this.getInstanceState().followingUserId;
    if (!e) return null;
    const r = this.getCollaborators().find((v) => v.userId === e);
    if (!r) return null;
    const { w: i, h: s } = r.screenBounds, { x: o, y: l, z: u } = r.camera, d = new vt(-o, -l, i / u, s / u), f = this.getViewportScreenBounds().clone(), m = f.width / f.height;
    return f.width = d.width, f.height = f.width / m, f.height < d.height && (f.height = d.height, f.width = f.height * m), f.center = d.center, f;
  }
  getCameraForFollowing() {
    const e = this.getViewportPageBoundsForFollowing();
    return e ? {
      x: -e.x,
      y: -e.y,
      z: this.getViewportScreenBounds().w / e.width
    } : null;
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const e = this.getCameraOptions();
    if (!e.constraints || e.constraints.initialZoom === "default") return 1;
    const { zx: r, zy: i } = Z9(this, e);
    switch (e.constraints.initialZoom) {
      case "fit-min":
        return Math.max(r, i);
      case "fit-max":
        return Math.min(r, i);
      case "fit-x":
        return r;
      case "fit-y":
        return i;
      case "fit-min-100":
        return Math.min(1, Math.max(r, i));
      case "fit-max-100":
        return Math.min(1, Math.min(r, i));
      case "fit-x-100":
        return Math.min(1, r);
      case "fit-y-100":
        return Math.min(1, i);
      default:
        throw ma(e.constraints.initialZoom);
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const e = this.getCameraOptions();
    if (!e.constraints || e.constraints.baseZoom === "default") return 1;
    const { zx: r, zy: i } = Z9(this, e);
    switch (e.constraints.baseZoom) {
      case "fit-min":
        return Math.max(r, i);
      case "fit-max":
        return Math.min(r, i);
      case "fit-x":
        return r;
      case "fit-y":
        return i;
      case "fit-min-100":
        return Math.min(1, Math.max(r, i));
      case "fit-max-100":
        return Math.min(1, Math.min(r, i));
      case "fit-x-100":
        return Math.min(1, r);
      case "fit-y-100":
        return Math.min(1, i);
      default:
        throw ma(e.constraints.baseZoom);
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param options - The camera options to set.
   *
   * @public */
  setCameraOptions(e) {
    var i;
    const r = ni({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...e
    });
    return ((i = r.zoomSteps) == null ? void 0 : i.length) < 1 && (r.zoomSteps = [1]), this._cameraOptions.set(r), this;
  }
  /** @internal */
  getConstrainedCamera(e, r) {
    const i = this.getCamera();
    let { x: s, y: o, z: l = i.z } = e;
    if (!(r != null && r.force)) {
      const u = this.getCameraOptions(), d = u.zoomSteps[0], f = Io(u.zoomSteps), m = this.getViewportScreenBounds();
      if (u.constraints) {
        const { constraints: v } = u, S = Math.min(v.padding.y, m.w / 2), w = Math.min(v.padding.x, m.h / 2), E = vt.From(u.constraints.bounds), A = (m.w - w * 2) / E.w, P = (m.h - S * 2) / E.h, R = this.getBaseZoom(), M = f * R, j = d * R;
        if (r != null && r.reset && (l = this.getInitialZoom()), l < j || l > M) {
          const { x: K, y: Z, z: oe } = i, fe = -K + m.w / oe / 2, ie = -Z + m.h / oe / 2;
          l = Zs(l, j, M);
          const ue = -K + m.w / l / 2, Se = -Z + m.h / l / 2;
          s = K + ue - fe, o = Z + Se - ie;
        }
        const $ = w / l - E.x, U = S / l - E.y, F = (m.w - w * 2) / l - E.w, B = (m.h - S * 2) / l - E.h, G = $ + F * v.origin.x, X = U + B * v.origin.y, te = typeof v.behavior == "string" ? v.behavior : v.behavior.x, ne = typeof v.behavior == "string" ? v.behavior : v.behavior.y;
        if (r != null && r.reset)
          s = G, o = X;
        else {
          switch (te) {
            case "fixed": {
              s = G;
              break;
            }
            case "contain": {
              l < A ? s = G : s = Zs(s, $ + F, $);
              break;
            }
            case "inside": {
              l < A ? s = Zs(s, $, (m.w - w) / l - E.w) : s = Zs(s, $ + F, $);
              break;
            }
            case "outside": {
              s = Zs(s, w / l - E.w, (m.w - w) / l);
              break;
            }
            case "free":
              break;
            default:
              throw ma(te);
          }
          switch (ne) {
            case "fixed": {
              o = X;
              break;
            }
            case "contain": {
              l < P ? o = X : o = Zs(o, U + B, U);
              break;
            }
            case "inside": {
              l < P ? o = Zs(o, U, (m.h - S) / l - E.h) : o = Zs(o, U + B, U);
              break;
            }
            case "outside": {
              o = Zs(o, S / l - E.h, (m.h - S) / l);
              break;
            }
            case "free":
              break;
            default:
              throw ma(ne);
          }
        }
      } else if (l > f || l < d) {
        const { x: v, y: S, z: w } = i;
        l = Zs(l, d, f), s = v + (-v + m.w / l / 2) - (-v + m.w / w / 2), o = S + (-S + m.h / l / 2) - (-S + m.h / w / 2);
      }
    }
    return { x: s, y: o, z: l };
  }
  /** @internal */
  _setCamera(e, r) {
    const i = this.getCamera(), { x: s, y: o, z: l } = this.getConstrainedCamera(e, r);
    return i.x === s && i.y === o && i.z === l ? this : (bh(() => {
      const u = { ...i, x: s, y: o, z: l };
      this.run(
        () => {
          this.store.put([u]);
        },
        { history: "ignore" }
      );
      const { currentScreenPoint: d, currentPagePoint: f } = this.inputs, { screenBounds: m } = this.store.unsafeGetWithoutCapture(za);
      if (d.x / l - s !== f.x || d.y / l - o !== f.y) {
        const v = {
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          // weird but true: we need to put the screen point back into client space
          point: O.AddXY(d, m.x, m.y),
          pointerId: v9.CAMERA_MOVE,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          shiftKey: this.inputs.shiftKey,
          button: 0,
          isPen: this.getInstanceState().isPenMode ?? !1
        };
        r != null && r.immediate ? this._flushEventForTick(v) : this.dispatch(v);
      }
      this._tickCameraState();
    }), this);
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(e, r) {
    const { isLocked: i } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (i && !(r != null && r.force)) return this;
    this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser();
    const s = O.Cast(e);
    Number.isFinite(s.x) || (s.x = 0), Number.isFinite(s.y) || (s.y = 0), (s.z === void 0 || !Number.isFinite(s.z)) && (e.z = this.getZoomLevel());
    const o = this.getConstrainedCamera(s, r);
    if (r != null && r.animation) {
      const { width: l, height: u } = this.getViewportScreenBounds();
      this._animateToViewport(
        new vt(-o.x, -o.y, l / o.z, u / o.z),
        r
      );
    } else
      this._setCamera(o, {
        ...r,
        // we already did the constraining, so we don't need to do it again
        force: !0
      });
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param animation - The camera move options.
   *
   * @public
   */
  centerOnPoint(e, r) {
    const { isLocked: i } = this.getCameraOptions();
    if (i && !(r != null && r.force)) return this;
    const { width: s, height: o } = this.getViewportPageBounds();
    return this.setCamera(new O(-(e.x - s / 2), -(e.y - o / 2), this.getCamera().z), r), this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(e) {
    const r = [...this.getCurrentPageShapeIds()];
    if (r.length <= 0) return this;
    const i = vt.Common(xn(r.map((s) => this.getShapePageBounds(s))));
    return this.zoomToBounds(i, e), this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(e = this.getViewportScreenCenter(), r) {
    const { isLocked: i, constraints: s } = this.getCameraOptions();
    if (i && !(r != null && r.force)) return this;
    const o = this.getCamera(), { x: l, y: u, z: d } = o, { x: f, y: m } = e;
    let v = 1;
    if (s) {
      const S = this.getInitialZoom();
      d !== S && (v = S);
    }
    return this.setCamera(
      new O(l + (f / v - f) - (f / d - f), u + (m / v - m) - (m / d - m), v),
      r
    ), this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(e = this.getViewportScreenCenter(), r) {
    const { isLocked: i } = this.getCameraOptions();
    if (i && !(r != null && r.force)) return this;
    const { x: s, y: o, z: l } = this.getCamera(), { zoomSteps: u } = this.getCameraOptions();
    if (u !== null && u.length > 1) {
      const d = this.getBaseZoom();
      let f = Io(u) * d;
      for (let m = 1; m < u.length; m++) {
        const v = u[m - 1] * d, S = u[m] * d;
        if (!(S - l <= (S - v) / 2)) {
          f = S;
          break;
        }
      }
      this.setCamera(
        new O(
          s + (e.x / f - e.x) - (e.x / l - e.x),
          o + (e.y / f - e.y) - (e.y / l - e.y),
          f
        ),
        r
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(e = this.getViewportScreenCenter(), r) {
    const { isLocked: i } = this.getCameraOptions();
    if (i && !(r != null && r.force)) return this;
    const { zoomSteps: s } = this.getCameraOptions();
    if (s !== null && s.length > 1) {
      const o = this.getBaseZoom(), { x: l, y: u, z: d } = this.getCamera();
      let f = s[0] * o;
      for (let m = s.length - 1; m > 0; m--) {
        const v = s[m - 1] * o, S = s[m] * o;
        if (!(S - d >= (S - v) / 2)) {
          f = v;
          break;
        }
      }
      this.setCamera(
        new O(
          l + (e.x / f - e.x) - (e.x / d - e.x),
          u + (e.y / f - e.y) - (e.y / d - e.y),
          f
        ),
        r
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param animation - The camera move options.
   *
   * @public
   */
  zoomToSelection(e) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(e != null && e.force)) return this;
    const i = this.getSelectionPageBounds();
    return i && this.zoomToBounds(i, {
      targetZoom: Math.max(1, this.getZoomLevel()),
      ...e
    }), this;
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(e, r) {
    const i = this._cameraOptions.__unsafe__getWithoutCapture();
    if (i.isLocked && !(r != null && r.force)) return this;
    const s = this.getViewportScreenBounds(), o = (r == null ? void 0 : r.inset) ?? Math.min(Aye, s.width * 0.28), l = this.getBaseZoom(), u = i.zoomSteps[0], d = Io(i.zoomSteps);
    let f = Zs(
      Math.min(
        (s.width - o) / e.w,
        (s.height - o) / e.h
      ),
      u * l,
      d * l
    );
    return (r == null ? void 0 : r.targetZoom) !== void 0 && (f = Math.min(r.targetZoom, f)), this.setCamera(
      new O(
        -e.x + (s.width - e.w * f) / 2 / f,
        -e.y + (s.height - e.h * f) / 2 / f,
        f
      ),
      r
    ), this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    return this.emit("stop-camera-animation"), this;
  }
  /** @internal */
  _animateViewport(e) {
    if (!this._viewportAnimation) return;
    this._viewportAnimation.elapsed += e;
    const { elapsed: r, easing: i, duration: s, start: o, end: l } = this._viewportAnimation;
    if (r > s) {
      this.off("tick", this._animateViewport), this._viewportAnimation = null, this._setCamera(new O(-l.x, -l.y, this.getViewportScreenBounds().width / l.width));
      return;
    }
    const u = s - r, d = i(1 - u / s), f = o.minX + (l.minX - o.minX) * d, m = o.minY + (l.minY - o.minY) * d, v = o.maxX + (l.maxX - o.maxX) * d;
    this._setCamera(new O(-f, -m, this.getViewportScreenBounds().width / (v - f)), {
      force: !0
    });
  }
  /** @internal */
  _animateToViewport(e, r = { animation: AN }) {
    const { animation: i, ...s } = r;
    if (!i) return;
    const { duration: o = 0, easing: l = Js.easeInOutCubic } = i, u = this.user.getAnimationSpeed(), d = this.getViewportPageBounds();
    return this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser(), o === 0 || u === 0 ? this._setCamera(
      new O(
        -e.x,
        -e.y,
        this.getViewportScreenBounds().width / e.width
      ),
      { ...s }
    ) : (this._viewportAnimation = {
      elapsed: 0,
      duration: o / u,
      easing: l,
      start: d.clone(),
      end: e.clone()
    }, this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport), this._viewportAnimation = null;
    }), this.on("tick", this._animateViewport), this);
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(e = {}) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(e != null && e.force)) return this;
    if (this.user.getAnimationSpeed() === 0) return this;
    this.stopCameraAnimation();
    const {
      speed: s,
      friction: o = this.options.cameraSlideFriction,
      direction: l,
      speedThreshold: u = 0.01
    } = e;
    let d = Math.min(s, 1);
    const f = () => {
      this.off("tick", m), this.off("stop-camera-animation", f);
    };
    this.once("stop-camera-animation", f);
    const m = (v) => {
      const { x: S, y: w, z: E } = this.getCamera(), A = O.Mul(l, d * v / E);
      d *= 1 - o, d < u ? f() : this._setCamera(new O(S + A.x, w + A.y, E));
    };
    return this.on("tick", m), this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(e, r = { animation: { duration: 500 } }) {
    const i = this.getCollaborators().find((s) => s.userId === e);
    return i ? (this.run(() => {
      this.getInstanceState().followingUserId !== null && this.stopFollowingUser();
      const s = i.currentPageId === this.getCurrentPageId();
      s || this.setCurrentPage(i.currentPageId), r && r.animation && !s && (r.animation = void 0), this.centerOnPoint(i.cursor, r);
      const { highlightedUserIds: o } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...o, e] }), this.timers.setTimeout(() => {
        const l = [...this.getInstanceState().highlightedUserIds], u = l.indexOf(e);
        u < 0 || (l.splice(u, 1), this.updateInstanceState({ highlightedUserIds: l }));
      }, this.options.collaboratorIdleTimeoutMs);
    }), this) : this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(e, r = !1) {
    e.width = Math.max(e.width, 1), e.height = Math.max(e.height, 1);
    const i = [
      // top
      e.minY !== 0,
      // right
      !vm(document.body.scrollWidth, e.maxX, 1),
      // bottom
      !vm(document.body.scrollHeight, e.maxY, 1),
      // left
      e.minX !== 0
    ], { screenBounds: s, insets: o } = this.getInstanceState();
    if (e.equals(s) && i.every((u, d) => u === o[d]))
      return this;
    const { _willSetInitialBounds: l } = this;
    if (this._willSetInitialBounds = !1, l)
      this.updateInstanceState({ screenBounds: e.toJson(), insets: i }), this.setCamera(this.getCamera());
    else if (r && !this.getInstanceState().followingUserId) {
      const u = this.getViewportPageBounds().center;
      this.updateInstanceState({ screenBounds: e.toJson(), insets: i }), this.centerOnPoint(u);
    } else
      this.updateInstanceState({ screenBounds: e.toJson(), insets: i }), this._setCamera(O.From({ ...this.getCamera() }));
    return this._tickCameraState(), this;
  }
  getViewportScreenBounds() {
    const { x: e, y: r, w: i, h: s } = this.getInstanceState().screenBounds;
    return new vt(e, r, i, s);
  }
  getViewportScreenCenter() {
    const e = this.getViewportScreenBounds();
    return new O(
      e.midX - e.minX,
      e.midY - e.minY
    );
  }
  getViewportPageBounds() {
    const { w: e, h: r } = this.getViewportScreenBounds(), { x: i, y: s, z: o } = this.getCamera();
    return new vt(-i, -s, e / o, r / o);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(e) {
    const { screenBounds: r } = this.store.unsafeGetWithoutCapture(za), { x: i, y: s, z: o = 1 } = this.getCamera();
    return new O(
      (e.x - r.x) / o - i,
      (e.y - r.y) / o - s,
      e.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(e) {
    const { screenBounds: r } = this.store.unsafeGetWithoutCapture(za), { x: i, y: s, z: o = 1 } = this.getCamera();
    return new O(
      (e.x + i) * o + r.x,
      (e.y + s) * o + r.y,
      e.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(e) {
    const { x: r, y: i, z: s = 1 } = this.getCamera();
    return new O((e.x + r) * s, (e.y + i) * s, e.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const e = this._getCollaboratorsQuery().get();
    return e.length ? [...new Set(e.map((i) => i.userId))].sort().map((i) => e.filter((o) => o.userId === i).sort((o, l) => l.lastActivityTimestamp - o.lastActivityTimestamp)[0]) : cp;
  }
  getCollaboratorsOnCurrentPage() {
    const e = this.getCurrentPageId();
    return this.getCollaborators().filter((r) => r.currentPageId === e);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   * @param opts - Options for starting to follow a user.
   *
   * @public
   */
  startFollowingUser(e) {
    this.stopFollowingUser();
    const r = this._getCollaboratorsQuery().get().filter((o) => o.userId === e);
    if (!r.length)
      return console.warn("User not found"), this;
    const i = this.user.getId();
    if (i || console.warn("You should set the userId for the current instance before following a user"), r.some((o) => o.followingUserId === i))
      return this;
    const s = ze("latestLeaderPresence", () => this.getCollaborators().find((o) => o.userId === e));
    return bh(() => {
      this.updateInstanceState({ followingUserId: e }, { history: "ignore" });
      const o = bS("update current page", () => {
        const d = s.get();
        if (!d) {
          this.stopFollowingUser();
          return;
        }
        d.currentPageId !== this.getCurrentPageId() && this.getPage(d.currentPageId) && this.run(
          () => {
            this.store.put([
              { ...this.getInstanceState(), currentPageId: d.currentPageId }
            ]), this._isLockedOnFollowingUser.set(!0);
          },
          { history: "ignore" }
        );
      }), l = () => {
        o(), this._isLockedOnFollowingUser.set(!1), this.off("frame", u), this.off("stop-following", l);
      }, u = () => {
        if (!s.get()) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get()) return;
        const f = this.user.getAnimationSpeed();
        if (f === 0) {
          this._isLockedOnFollowingUser.set(!0);
          return;
        }
        const m = this.getViewportPageBoundsForFollowing();
        if (!m) {
          this.stopFollowingUser();
          return;
        }
        const v = this.getViewportPageBounds(), S = Math.abs(m.minX - v.minX) + Math.abs(m.maxX - v.maxX), w = Math.abs(m.minY - v.minY) + Math.abs(m.maxY - v.maxY);
        if (S < this.options.followChaseViewportSnap && w < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(!0);
          return;
        }
        const E = Zs(f * 0.5, 0.1, 0.8), A = new vt(
          Il(v.minX, m.minX, E),
          Il(v.minY, m.minY, E),
          Il(v.width, m.width, E),
          Il(v.height, m.height, E)
        ), P = new O(
          -A.x,
          -A.y,
          this.getViewportScreenBounds().width / A.width
        );
        this.stopCameraAnimation(), this._setCamera(P);
      };
      this.once("stop-following", l), this.addListener("frame", u), u();
    }), this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    return this.run(
      () => {
        this.store.put([this.getCamera()]), this._isLockedOnFollowingUser.set(!1), this.updateInstanceState({ followingUserId: null }), this.emit("stop-following");
      },
      { history: "ignore" }
    ), this;
  }
  /** @internal */
  getUnorderedRenderingShapes(e) {
    const r = [];
    let i = this.options.maxShapesPerPage * 2, s = this.options.maxShapesPerPage;
    const o = this.getErasingShapeIds(), l = (d, f, m) => {
      const v = this.getShape(d);
      if (!v) return;
      f *= v.opacity;
      let S = !1;
      const w = this.getShapeUtil(v);
      e && (S = !m && o.includes(d), S && (f *= 0.32)), r.push({
        id: d,
        shape: v,
        util: w,
        index: i,
        backgroundIndex: s,
        opacity: f
      }), i += 1, s += 1;
      const E = this.getSortedChildIdsForParent(d);
      if (!E.length) return;
      let A = null;
      w.providesBackgroundForChildren(v) && (A = s, s = i, i += this.options.maxShapesPerPage);
      for (const P of E)
        l(P, f, m || S);
      A !== null && (s = A);
    }, u = e ? [this.getCurrentPage()] : this.getPages();
    for (const d of u)
      for (const f of this.getSortedChildIdsForParent(d.id))
        l(f, 1, !1);
    return r;
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    return this.getUnorderedRenderingShapes(!0).sort(Ome);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return this._getAllPagesQuery().get().sort(fa);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or page id) to get.
   *
   * @public
   */
  getPage(e) {
    return this.store.get(typeof e == "string" ? e : e.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or page id) to get.
   *
   * @public
   **/
  getPageShapeIds(e) {
    const r = typeof e == "string" ? e : e.id, i = this.store.query.exec("shape", { parentId: { eq: r } });
    return this.getShapeAndDescendantIds(i.map((s) => s.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(e) {
    const r = typeof e == "string" ? e : e.id;
    return this.store.has(r) ? (this.stopFollowingUser(), this.complete(), this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: r }]);
      },
      { history: "record-preserveRedoStack" }
    )) : (console.error("Tried to set the current page id to a page that doesn't exist."), this);
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(e) {
    return this.getInstanceState().isReadonly ? this : this.getPage(e.id) ? this.run(() => this.store.update(e.id, (i) => ({ ...i, ...e }))) : this;
  }
  /**
   * Create a page.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(e) {
    return this.run(() => {
      if (this.getInstanceState().isReadonly || this.getPages().length >= this.options.maxPages) return;
      const r = this.getPages(), i = f0e(
        e.name ?? "Page 1",
        r.map((l) => l.name)
      );
      let s = e.index;
      (!s || r.some((l) => l.index === s)) && (s = id(r[r.length - 1].index));
      const o = yp.create({
        meta: {},
        ...e,
        name: i,
        index: s
      });
      this.store.put([o]);
    }), this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param id - The id of the page to delete.
   *
   * @public
   */
  deletePage(e) {
    const r = typeof e == "string" ? e : e.id;
    return this.run(() => {
      if (this.getInstanceState().isReadonly) return;
      const i = this.getPages();
      if (i.length === 1) return;
      const s = this.getPage(r);
      if (s) {
        if (r === this.getCurrentPageId()) {
          const o = i.findIndex((u) => u.id === r), l = i[o - 1] ?? i[o + 1];
          this.setCurrentPage(l.id);
        }
        this.store.remove([s.id]);
      }
    }), this;
  }
  /**
   * Duplicate a page.
   *
   * @param id - The id of the page to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(e, r = yp.createId()) {
    if (this.getPages().length >= this.options.maxPages) return this;
    const i = typeof e == "string" ? e : e.id, s = this.getPage(i);
    if (!s) return this;
    const o = { ...this.getCamera() }, l = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(s.id));
    return this.run(() => {
      var f;
      const u = this.getPages(), d = $1(s.index, (f = u[u.indexOf(s) + 1]) == null ? void 0 : f.index);
      if (this.createPage({ name: s.name + " Copy", id: r, index: d }), this.setCurrentPage(r), this.setCamera(o), l)
        return this.putContentOntoCurrentPage(l);
    }), this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param id - The id of the page to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(e, r) {
    const i = typeof e == "string" ? e : e.id;
    return this.getInstanceState().isReadonly ? this : (this.updatePage({ id: i, name: r }), this);
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(e) {
    return this.getInstanceState().isReadonly ? this : e.length <= 0 ? this : (this.run(() => this.store.put(e), { history: "ignore" }), this);
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(e) {
    return this.getInstanceState().isReadonly ? this : e.length <= 0 ? this : (this.run(
      () => {
        this.store.put(
          e.map((r) => ({
            ...this.store.get(r.id),
            ...r
          }))
        );
      },
      { history: "ignore" }
    ), this);
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param ids - The assets to delete.
   *
   * @public
   */
  deleteAssets(e) {
    if (this.getInstanceState().isReadonly) return this;
    const r = typeof e[0] == "string" ? e : e.map((i) => i.id);
    return r.length <= 0 ? this : (this.run(() => this.store.remove(r), { history: "ignore" }), this);
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(e) {
    return this.store.get(typeof e == "string" ? e : e.id);
  }
  async resolveAssetUrl(e, r) {
    if (!e) return null;
    const i = this.getAsset(e);
    if (!i) return null;
    const { screenScale: s = 1, shouldResolveToOriginal: o = !1 } = r, u = Math.max(0.125, ((m) => Math.pow(2, Math.ceil(Math.log2(m))))(s)), d = "connection" in navigator ? navigator.connection.effectiveType : null, f = this.getInstanceState().devicePixelRatio;
    return await this.store.props.assets.resolve(i, {
      screenScale: s || 1,
      steppedScreenScale: u,
      dpr: f,
      networkEffectiveType: d,
      shouldResolveToOriginal: o
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(e, r) {
    return await this.store.props.assets.upload(e, r);
  }
  _getShapeGeometryCache() {
    return this.store.createComputedCache(
      "bounds",
      (e) => this.getShapeUtil(e).getGeometry(e),
      (e, r) => e.props === r.props
    );
  }
  /**
   * Get the geometry of a shape.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   *
   * @public
   */
  getShapeGeometry(e) {
    return this._getShapeGeometryCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache("handles", (e) => {
      var r, i;
      return (i = (r = this.getShapeUtil(e)).getHandles) == null ? void 0 : i.call(r, e);
    });
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(e) {
    return this._getShapeHandlesCache().get(typeof e == "string" ? e : e.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(e) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    if (!i) throw Error("Editor.getTransform: shape not found");
    return At.Identity().translate(i.x, i.y).rotate(i.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (e) => {
      if (El(e.parentId))
        return this.getShapeLocalTransform(e);
      const r = this._getShapePageTransformCache().get(e.parentId) ?? At.Identity();
      return At.Compose(r, this.getShapeLocalTransform(e));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(e) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    return !i || El(i.parentId) ? At.Identity() : this._getShapePageTransformCache().get(i.parentId) ?? At.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(e) {
    const r = typeof e == "string" ? e : e.id;
    return this._getShapePageTransformCache().get(r) ?? At.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (e) => {
      const r = this._getShapePageTransformCache().get(e.id);
      return r ? vt.FromPoints(
        At.applyToPoints(r, this.getShapeGeometry(e).vertices)
      ) : new vt();
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(e) {
    return this._getShapePageBoundsCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (e) => {
      const r = this._getShapeMaskCache().get(e.id);
      if (!r) return;
      if (r.length === 0)
        return "polygon(0px 0px, 0px 0px, 0px 0px)";
      const i = this._getShapePageTransformCache().get(e.id);
      return i ? `polygon(${At.applyToPoints(At.Inverse(i), r).map((o) => `${o.x}px ${o.y}px`).join(",")})` : void 0;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(e) {
    return this._getShapeClipPathCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (e) => {
      if (El(e.parentId)) return;
      const r = this.getShapeAncestors(e.id).filter(
        (s) => this.isShapeOfType(s, "frame")
      );
      return r.length === 0 ? void 0 : r.map(
        (s) => (
          // Apply the frame transform to the frame outline to get the frame outline in the current page space
          this._getShapePageTransformCache().get(s.id).applyToPoints(this.getShapeGeometry(s).vertices)
        )
      ).reduce((s, o) => {
        if (!(o && s)) return;
        const l = V9(s, o);
        return l ? l.map(O.Cast) : [];
      });
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param id - The id of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(e) {
    return this._getShapeMaskCache().get(typeof e == "string" ? e : e.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(e) {
    return typeof e != "string" && (e = e.id), this._getShapeMaskedPageBoundsCache().get(e);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (e) => {
      const r = this._getShapePageBoundsCache().get(e.id);
      if (!r) return;
      const i = this._getShapeMaskCache().get(e.id);
      if (i) {
        if (i.length === 0) return;
        const { corners: s } = r;
        if (s.every((l, u) => l && O.Equals(l, i[u]))) return r.clone();
        const o = V9(i, s);
        return o ? vt.FromPoints(o) : void 0;
      }
      return r;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   *
   * @public
   */
  getShapeAncestors(e, r = []) {
    const i = typeof e == "string" ? e : e.id, s = this.getShape(i);
    if (!s) return r;
    const o = s.parentId;
    if (El(o))
      return r.reverse(), r;
    const l = this.store.get(o);
    return l ? (r.push(l), this.getShapeAncestors(l, r)) : r;
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   *
   * @public
   */
  findShapeAncestor(e, r) {
    const i = typeof e == "string" ? e : e.id, s = this.getShape(i);
    if (!s) return;
    const o = s.parentId;
    if (El(o)) return;
    const l = this.getShape(o);
    if (l)
      return r(l) ? l : this.findShapeAncestor(l, r);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(e, r) {
    const i = typeof e == "string" ? e : e == null ? void 0 : e.id, s = i && this.getShape(i);
    return s ? s.parentId === r ? !0 : this.hasAncestor(this.getShapeParent(s), r) : !1;
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(e, r) {
    var d;
    if (e.length === 0)
      return;
    const i = typeof e[0] == "string" ? e : e.map((f) => f.id), s = xn(i.map((f) => this.getShape(f)));
    if (s.length === 1) {
      const f = s[0].parentId;
      return El(f) ? void 0 : r ? (d = this.findShapeAncestor(s[0], r)) == null ? void 0 : d.id : f;
    }
    const [o, ...l] = s;
    let u = this.getShapeParent(o);
    for (; u; ) {
      if (r && !r(u)) {
        u = this.getShapeParent(u);
        continue;
      }
      if (l.every((f) => this.hasAncestor(f, u.id)))
        return u.id;
      u = this.getShapeParent(u);
    }
  }
  isShapeOrAncestorLocked(e) {
    const r = typeof e == "string" ? this.getShape(e) : e;
    return r === void 0 ? !1 : r.isLocked ? !0 : this.isShapeOrAncestorLocked(this.getShapeParent(r));
  }
  _notVisibleShapes() {
    return b0e(this);
  }
  getCulledShapes() {
    const e = this._notVisibleShapes().get(), r = this.getSelectedShapeIds(), i = this.getEditingShapeId(), s = new Set(e);
    return i && s.delete(i), r.forEach((o) => {
      s.delete(o);
    }), s;
  }
  getCurrentPageBounds() {
    let e;
    return this.getCurrentPageShapeIdsSorted().forEach((r) => {
      const i = this.getShapeMaskedPageBounds(r);
      i && (e ? e = e.expand(i) : e = i.clone());
    }), e;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(e) {
    const r = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((i) => i.type !== "group" && r.includes(i.id)).reverse().find((i) => this.isPointInShape(i, e, { hitInside: !0, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(e, r = {}) {
    const i = this.getZoomLevel(), s = this.getViewportPageBounds(), {
      filter: o,
      margin: l = 0,
      hitLocked: u = !1,
      hitLabels: d = !1,
      hitInside: f = !1,
      hitFrameInside: m = !1
    } = r;
    let v = 1 / 0, S = null, w = 1 / 0, E = null;
    const A = (r.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((P) => {
      if (P.isLocked && !u || this.isShapeOfType(P, "group")) return !1;
      const R = this.getShapeMask(P);
      return R && !yc(e, R) ? !1 : o ? o(P) : !0;
    });
    for (let P = A.length - 1; P >= 0; P--) {
      const R = A[P], M = this.getShapeGeometry(R), j = M instanceof ld, $ = this.getPointInShapeSpace(R, e);
      if ((this.isShapeOfType(R, "arrow") || this.isShapeOfType(R, "geo") && R.props.fill === "none") && R.props.text.trim()) {
        for (const F of M.children)
          if (F.isLabel && F.isPointInBounds($))
            return R;
      }
      if (this.isShapeOfType(R, "frame")) {
        const F = M.distanceToPoint($, f);
        if (Math.abs(F) <= l)
          return E || R;
        if (M.hitTestPoint($, 0, !0))
          return E || S || (m ? R : void 0);
        continue;
      }
      let U;
      if (j) {
        let F = 1 / 0;
        for (const B of M.children) {
          if (B.isLabel && !d) continue;
          const G = B.distanceToPoint($, f);
          G < F && (F = G);
        }
        U = F;
      } else
        l === 0 && (M.bounds.w < 1 || M.bounds.h < 1) || M.bounds.containsPoint($, l) ? U = M.distanceToPoint($, f) : U = 1 / 0;
      if (M.isClosed) {
        if (U <= l) {
          if (M.isFilled || j && M.children[0].isFilled)
            return E || R;
          if (this.getShapePageBounds(R).contains(s)) continue;
          if (Math.abs(U) < l)
            Math.abs(U) < w && (w = Math.abs(U), E = R);
          else if (!E) {
            const { area: F } = M;
            F < v && (v = F, S = R);
          }
        }
      } else if (U < this.options.hitTestMargin / i)
        return R;
    }
    return E || S || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, exact: true })
   * ```
   *
   * @param point - The page point to test.
   *
   * @public
   */
  getShapesAtPoint(e, r = {}) {
    return this.getCurrentPageShapes().filter((i) => this.isPointInShape(i, e, r));
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param hitInside - Whether to count as a hit if the point is inside of a closed shape.
   *
   * @public
   */
  isPointInShape(e, r, i = {}) {
    const { hitInside: s = !1, margin: o = 0 } = i, l = typeof e == "string" ? e : e.id, u = this.getShapeMask(l);
    return u && !yc(r, u) ? !1 : this.getShapeGeometry(l).hitTestPoint(
      this.getPointInShapeSpace(e, r),
      o,
      s
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(e, r) {
    const i = typeof e == "string" ? e : e.id;
    return this._getShapePageTransformCache().get(i).clone().invert().applyToPoint(r);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(e, r) {
    const i = typeof e == "string" ? e : e.id, s = this.getShape(i);
    if (!s) return new O(0, 0);
    if (El(s.parentId)) return O.From(r);
    const o = this.getShapePageTransform(s.parentId);
    return o ? o.clone().invert().applyToPoint(r) : O.From(r);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (e) => this.store.get(e));
  }
  getCurrentPageShapesSorted() {
    const e = [], r = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let i = 0, s = r.length; i < s; i++)
      xY(this, r[i], e);
    return e;
  }
  getCurrentPageRenderingShapesSorted() {
    const e = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(({ id: r }) => !e.has(r));
  }
  isShapeOfType(e, r) {
    const i = typeof e == "string" ? this.getShape(e) : e;
    return i ? i.type === r : !1;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param id - The id of the shape to get.
   *
   * @public
   */
  getShape(e) {
    const r = typeof e == "string" ? e : e.id;
    if (kl(r))
      return this.store.get(r);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(e) {
    const r = typeof e == "string" ? e : e == null ? void 0 : e.id;
    if (!r) return;
    const i = this.getShape(r);
    if (!(i === void 0 || !kl(i.parentId)))
      return this.store.get(i.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(e, r) {
    return r ? r.parentId === e.parentId ? r : this.findShapeAncestor(
      r,
      (s) => s.parentId === e.parentId
    ) : void 0;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(e, r = this.getCurrentPageId()) {
    const i = typeof e == "string" ? e : e.id, s = this.getShape(i);
    if (!s) return !1;
    let o = !1;
    if (s.parentId === r)
      o = !0;
    else {
      let l = this.getShape(s.parentId);
      e: for (; l; ) {
        if (l.parentId === r) {
          o = !0;
          break e;
        }
        l = this.getShape(l.parentId);
      }
    }
    return o;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(e) {
    const r = typeof e == "string" ? e : e == null ? void 0 : e.id, i = r && this.getShape(r);
    if (i)
      return El(i.parentId) ? i.parentId : this.getAncestorPageId(this.getShape(i.parentId));
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(e, r, i) {
    const s = typeof e[0] == "string" ? e : e.map((S) => S.id);
    if (s.length === 0) return this;
    const o = [], l = El(r) ? At.Identity() : this.getShapePageTransform(r), u = l.rotation();
    let d = [];
    const f = xn(this.getSortedChildIdsForParent(r).map((S) => this.getShape(S)));
    if (i) {
      const S = f.find((w) => w.index === i);
      if (S) {
        const w = f[f.indexOf(S) + 1];
        w ? d = Zx(i, w.index, s.length) : d = CN(i, s.length);
      } else {
        const w = f.sort(fa).find((E) => E.index > i);
        w ? d = Zx(i, w.index, s.length) : d = CN(i, s.length);
      }
    } else {
      const S = f.length && f[f.length - 1];
      d = S ? CN(S.index, s.length) : z1(s.length);
    }
    const m = l.clone().invert(), v = xn(s.map((S) => this.getShape(S)));
    return this.run(
      () => {
        for (let S = 0; S < v.length; S++) {
          const w = v[S], E = this.getShapePageTransform(w);
          if (!E) continue;
          const A = E.point();
          if (!A) continue;
          const P = m.applyToPoint(A), R = E.rotation() - u;
          o.push({
            id: w.id,
            type: w.type,
            parentId: r,
            x: P.x,
            y: P.y,
            rotation: R,
            index: d[S]
          });
        }
        this.updateShapes(o);
      },
      { ignoreShapeLock: !0 }
    ), this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parentId - The id of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(e) {
    const r = typeof e == "string" ? e : e.id, i = this._parentIdsToChildIds.get()[r];
    if (!i || i.length === 0)
      return "a1";
    const s = this.getShape(i[i.length - 1]);
    return id(s.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parentId - The id of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(e) {
    const r = typeof e == "string" ? e : e.id, i = this._parentIdsToChildIds.get()[r];
    return i || cp;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parentId - The id of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(e, r) {
    const i = typeof e == "string" ? e : e.id, s = this.getSortedChildIdsForParent(i);
    for (const o of s)
      r(o) !== !1 && this.visitDescendants(o, r);
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(e) {
    const r = /* @__PURE__ */ new Set();
    for (const i of e.map((s) => this.getShape(s)).sort(fa))
      r.add(i.id), this.visitDescendants(i, (s) => {
        r.add(s);
      });
    return r;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDroppingOverShape(e, r = []) {
    const i = this.getCurrentPageShapesSorted();
    for (let s = i.length - 1; s >= 0; s--) {
      const o = i[s];
      if (
        // don't allow dropping on selected shapes
        this.getSelectedShapeIds().includes(o.id) || // only allow shapes that can receive children
        !this.getShapeUtil(o).canDropShapes(o, r) || // don't allow dropping a shape on itself or one of it's children
        r.find((u) => u.id === o.id || this.hasAncestor(o, u.id))
      )
        continue;
      const l = this.getShapeMaskedPageBounds(o.id);
      if (l && l.containsPoint(e) && this.getShapeGeometry(o).hitTestPoint(this.getPointInShapeSpace(o, e), 0, !0))
        return o;
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(e, r) {
    const i = typeof e == "string" ? e : e.id, s = this.getShape(i);
    let o = s, l = s;
    const u = this.getFocusedGroup();
    for (; l; ) {
      if (this.isShapeOfType(l, "group") && (u == null ? void 0 : u.id) !== l.id && !this.hasAncestor(u, l.id) && ((r == null ? void 0 : r(l)) ?? !0))
        o = l;
      else if ((u == null ? void 0 : u.id) === l.id)
        break;
      l = this.getShapeParent(l);
    }
    return o;
  }
  _getBindingsIndexCache() {
    const e = y0e(this);
    return this.store.createComputedCache("bindingsIndex", (r) => e.get().get(r.id));
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(e) {
    return this.store.get(e);
  }
  /**
   * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose
   * `fromId` matched the shape's ID.
   */
  getBindingsFromShape(e, r) {
    const i = typeof e == "string" ? e : e.id;
    return this.getBindingsInvolvingShape(i).filter(
      (s) => s.fromId === i && s.type === r
    );
  }
  /**
   * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose
   * `toId` matches the shape's ID.
   */
  getBindingsToShape(e, r) {
    const i = typeof e == "string" ? e : e.id;
    return this.getBindingsInvolvingShape(i).filter(
      (s) => s.toId === i && s.type === r
    );
  }
  /**
   * Get all bindings involving a particular shape. This includes bindings where the shape is the
   * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.
   */
  getBindingsInvolvingShape(e, r) {
    const i = typeof e == "string" ? e : e.id, s = this._getBindingsIndexCache().get(i) ?? cp;
    return r ? s.filter((o) => o.type === r) : s;
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(e) {
    const r = [];
    for (const i of e) {
      const s = this.getShape(i.fromId), o = this.getShape(i.toId);
      if (!s || !o || !this.canBindShapes({ fromShape: s, toShape: o, binding: i })) continue;
      const u = this.getBindingUtil(i.type).getDefaultProps(), d = this.store.schema.types.binding.create({
        ...i,
        id: i.id ?? qy(),
        props: {
          ...u,
          ...i.props
        }
      });
      r.push(d);
    }
    return this.store.put(r), this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(e) {
    return this.createBindings([e]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(e) {
    const r = [];
    for (const i of e) {
      if (!i) continue;
      const s = this.getBinding(i.id);
      if (!s) continue;
      const o = Yd(s, i);
      if (o === s) continue;
      const l = this.getShape(o.fromId), u = this.getShape(o.toId);
      !l || !u || this.canBindShapes({ fromShape: l, toShape: u, binding: o }) && r.push(o);
    }
    return this.store.put(r), this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(e) {
    return this.updateBindings([e]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(e, { isolateShapes: r = !1 } = {}) {
    const i = e.map((s) => typeof s == "string" ? s : s.id);
    return r ? this.store.atomic(() => {
      var s, o;
      for (const l of i) {
        const u = this.getBinding(l);
        if (!u) continue;
        const d = this.getBindingUtil(u);
        (s = d.onBeforeIsolateFromShape) == null || s.call(d, { binding: u, removedShape: this.getShape(u.toId) }), (o = d.onBeforeIsolateToShape) == null || o.call(d, { binding: u, removedShape: this.getShape(u.fromId) }), this.store.remove([l]);
      }
    }) : this.store.remove(i), this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(e, r) {
    return this.deleteBindings([e], r);
  }
  canBindShapes({
    fromShape: e,
    toShape: r,
    binding: i
  }) {
    const s = typeof e == "string" ? e : e.type, o = typeof r == "string" ? r : r.type, l = typeof i == "string" ? i : i.type, u = { fromShapeType: s, toShapeType: o, bindingType: l };
    return s === o ? this.getShapeUtil(s).canBind(u) : this.getShapeUtil(s).canBind(u) && this.getShapeUtil(o).canBind(u);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   * Note: Currently, this assumes that the shapes are your currently selected shapes.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   */
  rotateShapesBy(e, r) {
    if ((typeof e[0] == "string" ? e : e.map((o) => o.id)).length <= 0) return this;
    const s = vY({ editor: this });
    return s ? (eR({ delta: r, snapshot: s, editor: this, stage: "one-off" }), this) : this;
  }
  getChangesToTranslateShape(e, r) {
    var o, l, u;
    let i = e;
    const s = this.getShapeUtil(e);
    return i = Yd(
      i,
      ((o = s.onTranslateStart) == null ? void 0 : o.call(s, i)) ?? void 0
    ), i = Yd(i, {
      id: e.id,
      type: e.type,
      x: r.x,
      y: r.y
    }), i = Yd(
      i,
      ((l = s.onTranslate) == null ? void 0 : l.call(s, e, i)) ?? void 0
    ), i = Yd(
      i,
      ((u = s.onTranslateEnd) == null ? void 0 : u.call(s, e, i)) ?? void 0
    ), i;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param direction - The direction in which to move the shapes.
   * @param historyOptions - The history options for the change.
   */
  nudgeShapes(e, r) {
    const i = typeof e[0] == "string" ? e : e.map((o) => o.id);
    if (i.length <= 0) return this;
    const s = [];
    for (const o of i) {
      const l = this.getShape(o), u = O.From(r), d = this.getShapeParentTransform(l);
      d && u.rot(-d.rotation()), s.push(this.getChangesToTranslateShape(l, u.add(l)));
    }
    return this.updateShapes(s), this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(e, r) {
    return this.run(() => {
      const i = typeof e[0] == "string" ? e : e.map((v) => v.id);
      if (i.length <= 0) return this;
      const s = new Set(i), o = this.getShapeAndDescendantIds(i), l = [...o].reverse(), u = /* @__PURE__ */ new Map();
      for (const v of o)
        u.set(v, Ar());
      const { shapesToCreate: d, bindingsToCreate: f } = q9(
        this,
        o,
        (v) => {
          const S = [];
          for (const E of v) {
            const A = this.getBinding(E);
            if (!A) continue;
            const P = qy();
            S.push({
              ...A,
              id: P,
              fromId: nu(u.get(A.fromId)),
              toId: nu(u.get(A.toId))
            });
          }
          const w = [];
          for (const E of l) {
            const A = nu(u.get(E)), P = this.getShape(E);
            if (!P) continue;
            let R = 0, M = 0;
            if (r && s.has(E)) {
              const X = this.getShapeParentTransform(P), te = new O(r.x, r.y).rot(-X.rotation());
              R = te.x, M = te.y;
            }
            const j = P.parentId, $ = this.getSortedChildIdsForParent(j), U = $.indexOf(P.id), F = $[U + 1], B = F ? this.getShape(F) : null, G = B ? $1(P.index, B.index) : id(P.index);
            w.push({
              ...P,
              id: A,
              x: P.x + R,
              y: P.y + M,
              index: G,
              parentId: u.get(P.parentId) ?? P.parentId
            });
          }
          return { shapesToCreate: w, bindingsToCreate: S };
        }
      );
      if (d.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {
        gI(this);
        return;
      }
      if (this.createShapes(d), this.createBindings(f), this.setSelectedShapes(xn(i.map((v) => u.get(v)))), r !== void 0) {
        const v = this.getSelectionPageBounds(), S = this.getViewportPageBounds();
        v && !S.contains(v) && this.centerOnPoint(v.center, {
          animation: { duration: this.options.animationMediumMs }
        });
      }
    }), this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(e, r) {
    const i = typeof e[0] == "string" ? e : e.map((u) => u.id);
    if (i.length === 0) return this;
    if (this.getInstanceState().isReadonly) return this;
    const s = this.getCurrentPageId();
    if (r === s) return this;
    if (!this.store.has(r)) return this;
    const o = this.getContentFromCurrentPage(i);
    if (!o) return this;
    if (this.getPageShapeIds(r).size + o.shapes.length > this.options.maxShapesPerPage)
      return gI(this, r), this;
    const l = this.getCamera().z;
    return this.run(() => {
      this.deleteShapes(i), this.setCurrentPage(r), this.setFocusedGroup(null), this.selectNone(), this.putContentOntoCurrentPage(o, {
        select: !0,
        preserveIds: !0,
        preservePosition: !0
      }), this.setCamera({ ...this.getCamera(), z: l }), this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    }), this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(e) {
    const r = typeof e[0] == "string" ? e : e.map((l) => l.id);
    if (this.getInstanceState().isReadonly || r.length === 0) return this;
    let i = !0, s = !0;
    const o = [];
    for (const l of r) {
      const u = this.getShape(l);
      u && (o.push(u), u.isLocked ? s = !1 : i = !1);
    }
    return this.run(() => {
      s ? (this.updateShapes(
        o.map((l) => ({ id: l.id, type: l.type, isLocked: !0 }))
      ), this.setSelectedShapes([])) : i ? this.updateShapes(
        o.map((l) => ({ id: l.id, type: l.type, isLocked: !1 }))
      ) : this.updateShapes(
        o.map((l) => ({ id: l.id, type: l.type, isLocked: !0 }))
      );
    }), this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = pI(this, "toBack", r);
    return i && this.updateShapes(i), this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendBackward(e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = pI(this, "backward", r);
    return i && this.updateShapes(i), this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringForward(e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = pI(this, "forward", r);
    return i && this.updateShapes(i), this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = pI(this, "toFront", r);
    return i && this.updateShapes(i), this;
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(e, r) {
    const i = typeof e[0] == "string" ? e : e.map((l) => l.id);
    if (this.getInstanceState().isReadonly) return this;
    let s = xn(i.map((l) => this.getShape(l)));
    if (!s.length) return this;
    s = xn(
      s.map((l) => this.isShapeOfType(l, "group") ? this.getSortedChildIdsForParent(l.id).map((u) => this.getShape(u)) : l).flat()
    );
    const o = vt.Common(
      xn(s.map((l) => this.getShapePageBounds(l)))
    ).center;
    return this.run(() => {
      for (const l of s) {
        const u = this.getShapeGeometry(l).bounds, d = this.getShapePageTransform(l.id);
        d && this.resizeShape(
          l.id,
          { x: r === "horizontal" ? -1 : 1, y: r === "vertical" ? -1 : 1 },
          {
            initialBounds: u,
            initialPageTransform: d,
            initialShape: l,
            mode: "scale_shape",
            isAspectRatioLocked: this.getShapeUtil(l).isAspectRatioLocked(l),
            scaleOrigin: o,
            scaleAxisRotation: 0
          }
        );
      }
    }), this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal', 32)
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes.
   *
   * @public
   */
  stackShapes(e, r, i) {
    const s = typeof e[0] == "string" ? e : e.map((A) => A.id);
    if (this.getInstanceState().isReadonly) return this;
    const o = s.map((A) => this.getShape(A)).filter((A) => A ? this.getShapeUtil(A).canBeLaidOut(A) : !1), l = o.length;
    if (i === 0 && l < 3 || l < 2) return this;
    const u = Object.fromEntries(
      o.map((A) => [A.id, this.getShapePageBounds(A)])
    );
    let d, f, m, v;
    r === "horizontal" ? (d = "x", f = "minX", m = "maxX", v = "width") : (d = "y", f = "minY", m = "maxY", v = "height");
    let S;
    if (i === 0) {
      const A = [];
      o.sort((R, M) => u[R.id][f] - u[M.id][f]);
      for (let R = 0; R < l - 1; R++) {
        const M = o[R], j = o[R + 1], $ = u[M.id], F = u[j.id][f] - $[m], B = A.find((G) => G.gap === F);
        B ? B.count++ : A.push({ gap: F, count: 1 });
      }
      let P = 0;
      A.forEach((R) => {
        R.count > P && (P = R.count, S = R.gap);
      }), P === 1 && (S = Math.max(0, A.reduce((R, M) => R + M.gap * M.count, 0) / (l - 1)));
    } else
      S = i;
    const w = [];
    let E = u[o[0].id][m];
    return o.forEach((A, P) => {
      var U, F;
      if (P === 0) return;
      const R = { x: 0, y: 0 };
      R[d] = E + S - u[A.id][d];
      const M = this.getShapeParent(A), j = M ? O.Rot(R, -this.getShapePageTransform(M).decompose().rotation) : R, $ = (F = (U = this.getShapeUtil(A)).onTranslateStart) == null ? void 0 : F.call(U, A);
      w.push(
        $ ? {
          ...$,
          [d]: A[d] + j[d]
        } : {
          id: A.id,
          type: A.type,
          [d]: A[d] + j[d]
        }
      ), E += u[A.id][v] + S;
    }), this.updateShapes(w), this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2], 32)
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to 16.
   */
  packShapes(e, r) {
    var F, B;
    const i = typeof e[0] == "string" ? e : e.map((G) => G.id);
    if (this.getInstanceState().isReadonly) return this;
    if (i.length < 2) return this;
    const s = i.map((G) => this.getShape(G)).filter((G) => G ? this.getShapeUtil(G).canBeLaidOut(G) : !1), o = {}, l = {};
    let u, d, f = 0;
    for (let G = 0; G < s.length; G++)
      u = s[G], d = this.getShapePageBounds(u), o[u.id] = d, l[u.id] = d.clone(), f += d.width * d.height;
    const m = vt.Common(xn(Object.values(o))), v = m.width;
    s.sort((G, X) => o[X.id].height - o[G.id].height);
    const S = Math.max(Math.ceil(Math.sqrt(f / 0.95)), v), w = [new vt(m.x, m.y, S, 1 / 0)];
    let E = 0, A = 0, P, R;
    for (let G = 0; G < s.length; G++) {
      u = s[G], d = l[u.id];
      for (let X = w.length - 1; X >= 0; X--)
        if (P = w[X], !(d.width > P.width || d.height > P.height)) {
          d.x = P.x, d.y = P.y, A = Math.max(A, d.maxY), E = Math.max(E, d.maxX), d.width === P.width && d.height === P.height ? (R = w.pop(), X < w.length && (w[X] = R)) : d.height === P.height ? (P.x += d.width + r, P.width -= d.width + r) : d.width === P.width ? (P.y += d.height + r, P.height -= d.height + r) : (w.push(
            new vt(
              P.x + (d.width + r),
              P.y,
              P.width - (d.width + r),
              d.height
            )
          ), P.y += d.height + r, P.height -= d.height + r);
          break;
        }
    }
    const M = vt.Common(Object.values(l)), j = O.Sub(m.center, M.center);
    let $;
    const U = [];
    for (let G = 0; G < s.length; G++) {
      u = s[G], d = o[u.id], $ = l[u.id];
      const X = O.Sub($.point, d.point).add(j), te = this.getShapeParentTransform(u);
      te && X.rot(-te.rotation());
      const ne = {
        id: u.id,
        type: u.type,
        x: u.x + X.x,
        y: u.y + X.y
      }, K = (B = (F = this.getShapeUtil(u)).onTranslateStart) == null ? void 0 : B.call(F, {
        ...u,
        ...ne
      });
      K ? U.push({ ...ne, ...K }) : U.push(ne);
    }
    return U.length && this.updateShapes(U), this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(e, r) {
    const i = typeof e[0] == "string" ? e : e.map((d) => d.id);
    if (this.getInstanceState().isReadonly) return this;
    if (i.length < 2) return this;
    const s = xn(i.map((d) => this.getShape(d))), o = Object.fromEntries(
      s.map((d) => [d.id, this.getShapePageBounds(d)])
    ), l = vt.Common(xn(Object.values(o))), u = [];
    return s.forEach((d) => {
      const f = o[d.id];
      if (!f) return;
      const m = { x: 0, y: 0 };
      switch (r) {
        case "top": {
          m.y = l.minY - f.minY;
          break;
        }
        case "center-vertical": {
          m.y = l.midY - f.minY - f.height / 2;
          break;
        }
        case "bottom": {
          m.y = l.maxY - f.minY - f.height;
          break;
        }
        case "left": {
          m.x = l.minX - f.minX;
          break;
        }
        case "center-horizontal": {
          m.x = l.midX - f.minX - f.width / 2;
          break;
        }
        case "right": {
          m.x = l.maxX - f.minX - f.width;
          break;
        }
      }
      const v = this.getShapeParent(d), S = v ? O.Rot(m, -this.getShapePageTransform(v).decompose().rotation) : m;
      u.push(this.getChangesToTranslateShape(d, O.Add(d, S)));
    }), this.updateShapes(u), this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(e, r) {
    const i = typeof e[0] == "string" ? e : e.map((M) => M.id);
    if (this.getInstanceState().isReadonly) return this;
    if (i.length < 3) return this;
    const s = i.length, o = xn(i.map((M) => this.getShape(M))), l = Object.fromEntries(
      o.map((M) => [M.id, this.getShapePageBounds(M)])
    );
    let u, d, f, m, v;
    r === "horizontal" ? (u = "x", d = "minX", f = "maxX", m = "midX", v = "width") : (u = "y", d = "minY", f = "maxY", m = "midY", v = "height");
    const S = [], w = o.sort(
      (M, j) => l[M.id][d] - l[j.id][d]
    )[0], E = o.sort((M, j) => l[j.id][f] - l[M.id][f])[0], A = l[w.id][m], P = (l[E.id][m] - A) / (s - 1), R = A + P;
    return o.filter((M) => M !== w && M !== E).sort((M, j) => l[M.id][m] - l[j.id][m]).forEach((M, j) => {
      const $ = { x: 0, y: 0 };
      $[u] = R + P * j - l[M.id][v] / 2 - l[M.id][u];
      const U = this.getShapeParent(M), F = U ? O.Rot($, -this.getShapePageTransform(U).rotation()) : $;
      S.push(this.getChangesToTranslateShape(M, O.Add(M, F)));
    }), this.updateShapes(S), this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(e, r) {
    const i = typeof e[0] == "string" ? e : e.map((d) => d.id);
    if (this.getInstanceState().isReadonly) return this;
    if (i.length < 2) return this;
    const s = xn(i.map((d) => this.getShape(d))), o = Object.fromEntries(i.map((d) => [d, this.getShapeGeometry(d).bounds])), l = Object.fromEntries(i.map((d) => [d, this.getShapePageBounds(d)])), u = vt.Common(xn(Object.values(l)));
    switch (r) {
      case "vertical": {
        this.run(() => {
          for (const d of s) {
            if (this.getShapePageTransform(d).rotation() % wr) continue;
            const m = o[d.id], v = l[d.id], S = new O(0, u.minY - v.minY), w = this.getShapeParentTransform(d);
            w && S.rot(-w.rotation());
            const { x: E, y: A } = O.Add(S, d);
            this.updateShapes([{ id: d.id, type: d.type, x: E, y: A }]);
            const P = new O(1, u.height / v.height);
            this.resizeShape(d.id, P, {
              initialBounds: m,
              scaleOrigin: new O(v.center.x, u.minY),
              isAspectRatioLocked: this.getShapeUtil(d).isAspectRatioLocked(d),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
      case "horizontal": {
        this.run(() => {
          for (const d of s) {
            const f = o[d.id], m = l[d.id];
            if (this.getShapePageTransform(d).rotation() % wr) continue;
            const S = new O(u.minX - m.minX, 0), w = this.getShapeParentTransform(d);
            w && S.rot(-w.rotation());
            const { x: E, y: A } = O.Add(S, d);
            this.updateShapes([{ id: d.id, type: d.type, x: E, y: A }]);
            const P = new O(u.width / m.width, 1);
            this.resizeShape(d.id, P, {
              initialBounds: f,
              scaleOrigin: new O(u.minX, m.center.y),
              isAspectRatioLocked: this.getShapeUtil(d).isAspectRatioLocked(d),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
    }
    return this;
  }
  /**
   * Resize a shape.
   *
   * @param id - The id of the shape to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param options - Additional options.
   *
   * @public
   */
  resizeShape(e, r, i = {}) {
    var w, E, A;
    const s = typeof e == "string" ? e : e.id;
    if (this.getInstanceState().isReadonly) return this;
    Number.isFinite(r.x) || (r = new O(1, r.y)), Number.isFinite(r.y) || (r = new O(r.x, 1));
    const o = i.initialShape ?? this.getShape(s);
    if (!o) return this;
    const l = i.scaleOrigin ?? ((w = this.getShapePageBounds(s)) == null ? void 0 : w.center);
    if (!l) return this;
    const u = i.initialPageTransform ? At.Cast(i.initialPageTransform) : this.getShapePageTransform(s);
    if (!u) return this;
    const d = u.rotation();
    if (d == null) return this;
    const f = i.scaleAxisRotation ?? d, m = i.initialBounds ?? this.getShapeGeometry(s).bounds;
    if (!m) return this;
    const v = i.isAspectRatioLocked ?? this.getShapeUtil(o).isAspectRatioLocked(o);
    if (!TK(d, f))
      return this._resizeUnalignedShape(s, r, {
        ...i,
        initialBounds: m,
        scaleOrigin: l,
        scaleAxisRotation: f,
        initialPageTransform: u,
        isAspectRatioLocked: v,
        initialShape: o
      });
    const S = this.getShapeUtil(o);
    if (v && (Math.abs(r.x) > Math.abs(r.y) ? r = new O(r.x, Math.sign(r.y) * Math.abs(r.x)) : r = new O(Math.sign(r.x) * Math.abs(r.y), r.y)), S.onResize && S.canResize(o)) {
      const P = this._scalePagePoint(
        At.applyToPoint(u, new O(0, 0)),
        l,
        r,
        f
      ), R = this.getPointInParentSpace(o.id, P), M = new O(r.x, r.y), j = vm(
        (d - f) % Math.PI,
        0
      );
      M.x = j ? r.x : r.y, M.y = j ? r.y : r.x;
      const $ = At.applyToPoint(u, new O()), { x: U, y: F } = this.getPointInParentSpace(o.id, $);
      let B = o;
      i.skipStartAndEndCallbacks || (B = Yd(
        o,
        ((E = S.onResizeStart) == null ? void 0 : E.call(S, o)) ?? void 0
      )), B = Yd(B, {
        id: s,
        type: o.type,
        x: R.x,
        y: R.y,
        ...S.onResize(
          { ...o, x: U, y: F },
          {
            newPoint: R,
            handle: i.dragHandle ?? "bottom_right",
            // don't set isSingle to true for children
            mode: i.mode ?? "scale_shape",
            scaleX: M.x,
            scaleY: M.y,
            initialBounds: m,
            initialShape: o
          }
        )
      }), i.skipStartAndEndCallbacks || (B = Yd(
        B,
        ((A = S.onResizeEnd) == null ? void 0 : A.call(S, o, B)) ?? void 0
      )), this.updateShapes([B]);
    } else {
      const P = At.applyToPoint(u, m.center), R = this._scalePagePoint(
        P,
        l,
        r,
        f
      ), M = this.getPointInParentSpace(
        o.id,
        P
      ), j = this.getPointInParentSpace(o.id, R), $ = O.Sub(j, M);
      this.updateShapes([
        {
          id: s,
          type: o.type,
          x: o.x + $.x,
          y: o.y + $.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(e, r, i, s) {
    const o = O.RotWith(e, r, -s).sub(r), l = O.MulV(o, i);
    return O.Add(l, r).rotWith(
      r,
      s
    );
  }
  /** @internal */
  _resizeUnalignedShape(e, r, i) {
    const { type: s } = i.initialShape, o = new O(r.x, r.y);
    if (Math.abs(r.x) > Math.abs(r.y) ? o.x = Math.sign(r.x) * Math.abs(r.y) : o.y = Math.sign(r.y) * Math.abs(r.x), this.resizeShape(e, o, {
      initialShape: i.initialShape,
      initialBounds: i.initialBounds,
      isAspectRatioLocked: i.isAspectRatioLocked
    }), Math.sign(r.x) * Math.sign(r.y) < 0) {
      let { rotation: P } = At.Decompose(i.initialPageTransform);
      P -= 2 * P, this.updateShapes([{ id: e, type: s, rotation: P }]);
    }
    const l = At.applyToPoint(
      i.initialPageTransform,
      i.initialBounds.center
    ), u = this._scalePagePoint(
      l,
      i.scaleOrigin,
      r,
      i.scaleAxisRotation
    ), d = this.getShapePageBounds(e), f = this.getShapePageTransform(e), m = d.center, v = f.point();
    if (!m || !v) return this;
    const S = O.Sub(u, m), w = O.Add(v, S), { x: E, y: A } = this.getPointInParentSpace(e, w);
    return this.updateShapes([{ id: e, type: s, x: E, y: A }]), this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(e) {
    return {};
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { text: "ok" } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(e) {
    return this.createShapes([e]), this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { text: "ok" } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   * @param select - Whether to select the created shapes. Defaults to false.
   *
   * @public
   */
  createShapes(e) {
    if (!Array.isArray(e))
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    if (this.getInstanceState().isReadonly) return this;
    if (e.length <= 0) return this;
    const r = this.getCurrentPageShapeIds();
    if (e.length + r.size > this.options.maxShapesPerPage)
      return gI(this), this;
    const s = this.getFocusedGroupId();
    return this.run(() => {
      var m, v;
      const o = this.getCurrentPageShapesSorted(), l = e.map((S) => {
        if (S.id || (S = { id: Ar(), ...S }), !S.parentId || !(this.store.has(S.parentId) || e.some((w) => w.id === S.parentId))) {
          let w = this.getFocusedGroupId();
          for (let A = o.length - 1; A >= 0; A--) {
            const P = o[A];
            if (
              // parent.type === 'frame'
              this.getShapeUtil(P).canReceiveNewChildrenOfType(P, S.type) && this.isPointInShape(
                P,
                // If no parent is provided, then we can treat the
                // shape's provided x/y as being in the page's space.
                { x: S.x ?? 0, y: S.y ?? 0 },
                {
                  margin: 0,
                  hitInside: !0
                }
              )
            ) {
              w = P.id;
              break;
            }
          }
          const E = S.parentId;
          if (w === S.id && (w = s), w !== E && (S = { ...S }, S.parentId = w, kl(w))) {
            const A = this.getPointInShapeSpace(this.getShape(w), {
              x: S.x ?? 0,
              y: S.y ?? 0
            });
            S.x = A.x, S.y = A.y, S.rotation = -this.getShapePageTransform(w).rotation() + (S.rotation ?? 0);
          }
        }
        return S;
      }), u = /* @__PURE__ */ new Map(), d = [], { opacityForNextShape: f } = this.getInstanceState();
      for (const S of l) {
        const w = this.getShapeUtil(S);
        let E = S.index;
        if (!E) {
          const M = S.parentId ?? s;
          u.has(M) || u.set(M, this.getHighestIndexForParent(M)), E = u.get(M), u.set(M, id(E));
        }
        const A = w.getDefaultProps();
        for (const [M, j] of this.styleProps[S.type])
          A[j] = this.getStyleForNextShape(M);
        let P = this.store.schema.types.shape.create({
          ...S,
          index: E,
          opacity: S.opacity ?? f,
          parentId: S.parentId ?? s,
          props: "props" in S ? { ...A, ...S.props } : A
        });
        if (P.index === void 0)
          throw Error("no index!");
        const R = (v = (m = this.getShapeUtil(P)).onBeforeCreate) == null ? void 0 : v.call(m, P);
        R && (P = R), d.push(P);
      }
      d.forEach((S) => {
        S.meta = {
          ...this.getInitialMetaForShape(S),
          ...S.meta
        };
      }), this.store.put(d);
    }), this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param options - The animation's options.
   *
   * @public
   */
  animateShape(e, r = { animation: AN }) {
    return this.animateShapes([e], r);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param options - The animation's options.
   *
   * @public
   */
  animateShapes(e, r = { animation: AN }) {
    if (!r.animation) return this;
    const { duration: i = 500, easing: s = Js.linear } = r.animation, o = Ii();
    let l = i, u;
    const d = [];
    let f, m;
    for (let S = 0, w = e.length; S < w; S++) {
      if (f = e[S], !f) continue;
      const E = this.getShape(f.id);
      E && (m = {
        start: ni(E),
        end: Yd(ni(E), f)
      }, d.push(m), this.animatingShapes.set(E.id, o));
    }
    const v = (S) => {
      var P, R;
      if (l -= S, l < 0) {
        const { animatingShapes: M } = this, j = e.filter(
          ($) => $ && M.get($.id) === o
        );
        j.length && this.updateShapes(j), this.off("tick", v);
        return;
      }
      u = s(1 - l / i);
      const { animatingShapes: w } = this, E = [];
      let A;
      for (let M = 0, j = d.length; M < j; M++) {
        const { start: $, end: U } = d[M];
        A = w.get($.id), A === o && E.push({
          ...U,
          x: $.x + (U.x - $.x) * u,
          y: $.y + (U.y - $.y) * u,
          opacity: $.opacity + (U.opacity - $.opacity) * u,
          rotation: $.rotation + (U.rotation - $.rotation) * u,
          props: ((R = (P = this.getShapeUtil(U)).getInterpolatedProps) == null ? void 0 : R.call(P, $, U, u)) ?? U.props
        });
      }
      this._updateShapes(E);
    };
    return this.on("tick", v), this;
  }
  groupShapes(e, r = {}) {
    var E;
    const { groupId: i = Ar(), select: s = !0 } = r;
    if (!Array.isArray(e))
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    if (this.getInstanceState().isReadonly) return this;
    const o = typeof e[0] == "string" ? e : e.map((A) => A.id);
    if (o.length <= 1) return this;
    const l = xn(
      (this._shouldIgnoreShapeLock ? o : this._getUnlockedShapeIds(o)).map(
        (A) => this.getShape(A)
      )
    ), u = l.sort(fa).map((A) => A.id), d = vt.Common(xn(l.map((A) => this.getShapePageBounds(A)))), { x: f, y: m } = d.point, v = this.findCommonAncestor(l) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const S = l.filter((A) => A.parentId === v).sort(fa), w = (E = S[S.length - 1]) == null ? void 0 : E.index;
    return this.run(() => {
      this.createShapes([
        {
          id: i,
          type: "group",
          parentId: v,
          index: w,
          x: f,
          y: m,
          opacity: 1,
          props: {}
        }
      ]), this.reparentShapes(u, i), s && this.select(i);
    }), this;
  }
  ungroupShapes(e, r = {}) {
    if (this.getInstanceState().isReadonly) return this;
    const { select: i = !0 } = r, s = typeof e[0] == "string" ? e : e.map((d) => d.id), o = xn(
      (this._shouldIgnoreShapeLock ? s : this._getUnlockedShapeIds(s)).map(
        (d) => this.getShape(d)
      )
    );
    if (o.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const l = /* @__PURE__ */ new Set(), u = [];
    return o.forEach((d) => {
      this.isShapeOfType(d, "group") ? u.push(d) : l.add(d.id);
    }), u.length === 0 ? this : (this.run(() => {
      let d;
      for (let f = 0, m = u.length; f < m; f++) {
        d = u[f];
        const v = this.getSortedChildIdsForParent(d.id);
        for (let S = 0, w = v.length; S < w; S++)
          l.add(v[S]);
        this.reparentShapes(v, d.parentId, d.index);
      }
      this.deleteShapes(u.map((f) => f.id)), i && this.select(...l);
    }), this);
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(e) {
    return this.updateShapes([e]), this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(e) {
    const r = Array(e.length);
    for (let i = 0, s = e.length; i < s; i++) {
      const o = e[i];
      if (!o) continue;
      const l = this.getShape(o.id);
      if (l) {
        if (!this._shouldIgnoreShapeLock) {
          if (l.isLocked) {
            if (!(Object.hasOwn(o, "isLocked") && !o.isLocked))
              continue;
          } else if (this.isShapeOrAncestorLocked(l))
            continue;
        }
        this.animatingShapes.delete(o.id), r.push(o);
      }
    }
    return this._updateShapes(r), this;
  }
  /** @internal */
  _getUnlockedShapeIds(e) {
    return e.filter((r) => {
      var i;
      return !((i = this.getShape(r)) != null && i.isLocked);
    });
  }
  deleteShapes(e) {
    if (this.getInstanceState().isReadonly) return this;
    if (!Array.isArray(e))
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    const r = typeof e[0] == "string" ? e : e.map((o) => o.id), i = this._shouldIgnoreShapeLock ? r : this._getUnlockedShapeIds(r);
    if (i.length === 0) return this;
    const s = new Set(i);
    for (const o of i)
      this.visitDescendants(o, (l) => {
        s.add(l);
      });
    return this.run(() => this.store.remove([...s]));
  }
  deleteShape(e) {
    return this.deleteShapes([typeof e == "string" ? e : e.id]), this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(e, r) {
    if (this.isShapeOfType(e, "group")) {
      const i = this._parentIdsToChildIds.get()[e.id];
      if (!i) return;
      for (let s = 0, o = i.length; s < o; s++)
        this._extractSharedStyles(this.getShape(i[s]), r);
    } else
      for (const [i, s] of this.styleProps[e.type])
        r.applyValue(i, Dl(e.props, s));
  }
  _getSelectionSharedStyles() {
    const e = this.getSelectedShapes(), r = new w3();
    for (const i of e)
      this._extractSharedStyles(i, r);
    return r;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(e) {
    const r = this.getInstanceState().stylesForNextShape[e.id];
    return r === void 0 ? e.defaultValue : r;
  }
  getShapeStyleIfExists(e, r) {
    const i = this.styleProps[e.type].get(r);
    if (i !== void 0)
      return Dl(e.props, i);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0)
      return this._getSelectionSharedStyles();
    const e = this.root.getCurrent(), r = new w3();
    if (!e) return r;
    if (e.shapeType)
      for (const i of this.styleProps[e.shapeType].keys())
        r.applyValue(i, this.getStyleForNextShape(i));
    return r;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const e = [], r = (s) => {
        const o = this.getShape(s);
        if (o)
          if (this.isShapeOfType(o, "group"))
            for (const l of this.getSortedChildIdsForParent(o.id))
              r(l);
          else
            e.push(o);
      };
      for (const s of this.getSelectedShapeIds())
        r(s);
      let i = null;
      for (const s of e)
        if (i === null)
          i = s.opacity;
        else if (i !== s.opacity)
          return { type: "mixed" };
      if (i !== null) return { type: "shared", value: i };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(e, r) {
    return this.updateInstanceState({ opacityForNextShape: e }, r), this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(e) {
    const r = this.getSelectedShapes();
    if (r.length > 0) {
      const i = [], s = (o) => {
        if (this.isShapeOfType(o, "group")) {
          const l = this.getSortedChildIdsForParent(o);
          for (const u of l)
            s(this.getShape(u));
        } else
          i.push(o);
      };
      for (const o of r)
        s(o);
      this.updateShapes(
        i.map((o) => ({
          id: o.id,
          type: o.type,
          opacity: e
        }))
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(e, r, i) {
    const s = this.getInstanceState().stylesForNextShape;
    return this.updateInstanceState(
      { stylesForNextShape: { ...s, [e.id]: r } },
      i
    ), this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForSelectedShapes(e, r) {
    const i = this.getSelectedShapes();
    if (i.length > 0) {
      const s = [], o = (l) => {
        if (this.isShapeOfType(l, "group")) {
          const u = this.getSortedChildIdsForParent(l.id);
          for (const d of u)
            o(this.getShape(d));
        } else {
          const u = this.getShapeUtil(l), d = this.styleProps[l.type].get(e);
          if (d) {
            const f = {
              id: l.id,
              type: l.type,
              props: { [d]: r }
            };
            s.push({
              util: u,
              originalShape: l,
              updatePartial: f
            });
          }
        }
      };
      for (const l of i)
        o(l);
      this.updateShapes(s.map(({ updatePartial: l }) => l));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(e, r) {
    return this.externalAssetContentHandlers[e] = r, this;
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(e) {
    var r, i;
    return await ((i = (r = this.externalAssetContentHandlers)[e.type]) == null ? void 0 : i.call(r, e));
  }
  hasExternalAssetHandler(e) {
    return !!this.externalAssetContentHandlers[e];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(e, r) {
    return this.externalContentHandlers[e] = r, this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   */
  async putExternalContent(e) {
    var r, i;
    return (i = (r = this.externalContentHandlers)[e.type]) == null ? void 0 : i.call(r, e);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(e) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id);
    if (!r || r.length === 0) return;
    const i = this.getShapeAndDescendantIds(r);
    return q9(this, i, (s) => {
      const o = [];
      for (const m of s) {
        const v = this.getBinding(m);
        v && o.push(v);
      }
      const l = [], u = [];
      for (const m of i) {
        const v = this.getShape(m);
        if (!v) continue;
        if (!i.has(v.parentId)) {
          const w = this.getShapePageTransform(v.id), E = w.point();
          u.push({
            ...v,
            x: E.x,
            y: E.y,
            rotation: w.rotation(),
            parentId: this.getCurrentPageId()
          }), l.push(v.id);
        } else
          u.push(v);
      }
      const d = [], f = /* @__PURE__ */ new Set();
      for (const m of u) {
        if (!("assetId" in m.props)) continue;
        const v = m.props.assetId;
        if (!v || f.has(v)) continue;
        f.add(v);
        const S = this.getAsset(v);
        S && d.push(S);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: u,
        rootShapeIds: l,
        bindings: o,
        assets: d
      };
    });
  }
  async resolveAssetsInContent(e) {
    if (!e) return;
    const r = [];
    return await Promise.allSettled(
      e.assets.map(async (i) => {
        var s, o;
        if ((i.type === "image" || i.type === "video") && !((s = i.props.src) != null && s.startsWith("data:image")) && !((o = i.props.src) != null && o.startsWith("http"))) {
          const l = ni(i), u = await this.store.props.assets.resolve(i, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: !0
          });
          l.props.src = await Xy.blobToDataUrl(
            await Th(u).then((d) => d.blob())
          ), r.push(l);
        } else
          r.push(i);
      })
    ), e.assets = r, e;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param options - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(e, r = {}) {
    var te, ne;
    if (this.getInstanceState().isReadonly) return this;
    if (!e.schema)
      throw Error(`Could not put content:
content is missing a schema.`);
    const { select: i = !1, preserveIds: s = !1, preservePosition: o = !1 } = r;
    let { point: l = void 0 } = r;
    const u = this.getCurrentPageId(), { rootShapeIds: d } = e, f = [], m = [], v = [], S = {
      store: {
        ...Object.fromEntries(e.assets.map((K) => [K.id, K])),
        ...Object.fromEntries(e.shapes.map((K) => [K.id, K])),
        ...Object.fromEntries(
          ((te = e.bindings) == null ? void 0 : te.map((K) => [K.id, K])) ?? []
        )
      },
      schema: e.schema
    }, w = this.store.schema.migrateStoreSnapshot(S);
    if (w.type === "error")
      throw Error("Could not put content: could not migrate content");
    for (const K of Object.values(w.value))
      switch (K.typeName) {
        case "asset": {
          f.push(K);
          break;
        }
        case "shape": {
          m.push(K);
          break;
        }
        case "binding": {
          v.push(K);
          break;
        }
      }
    const E = new Map(
      s ? m.map((K) => [K.id, K.id]) : m.map((K) => [K.id, Ar()])
    ), A = new Map(
      s ? v.map((K) => [K.id, K.id]) : v.map((K) => [K.id, qy()])
    );
    let P = this.getCurrentPageId(), R = 1 / 0, M = [];
    for (const K of this.getSelectedShapes()) {
      if (R === 0) break;
      const Z = this.isShapeOfType(K, "frame"), oe = this.getShapeAncestors(K);
      Z && oe.push(K);
      const fe = Z ? oe.length + 1 : oe.length;
      if (fe < R)
        R = fe, M = oe, P = Z ? K.id : K.parentId;
      else if (fe === R) {
        if (M.length !== oe.length)
          throw Error(`Ancestors: ${M.length} !== ${oe.length}`);
        if (M.length === 0) {
          P = u;
          break;
        } else {
          P = u;
          for (let ie = 0; ie < M.length && oe[ie] === M[ie]; ie++)
            P = oe[ie].id;
        }
      }
    }
    let j = !1;
    if (!El(P)) {
      const K = this.getShape(P);
      if (K) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(K)))
          P = u;
        else if (d.length === 1) {
          const Z = m.find((oe) => oe.id === d[0]);
          this.isShapeOfType(K, "frame") && this.isShapeOfType(Z, "frame") && Z.props.w === (K == null ? void 0 : K.props.w) && Z.props.h === (K == null ? void 0 : K.props.h) && (j = !0);
        }
      } else
        P = u;
    }
    j || (j = E.has(P)), j && (P = this.getShape(P).parentId);
    let $ = this.getHighestIndexForParent(P);
    const U = [], F = m.map((K) => {
      const Z = E.get(K.id), oe = { ...K, id: Z };
      return d.includes(K.id) && (oe.parentId = u, U.push(oe)), E.has(oe.parentId) ? oe.parentId = E.get(K.parentId) : (d.push(oe.id), oe.index = $, $ = id($)), oe;
    });
    if (F.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage)
      return gI(this), this;
    const B = v.map(
      (K) => ({
        ...K,
        id: nu(A.get(K.id)),
        fromId: nu(E.get(K.fromId)),
        toId: nu(E.get(K.toId))
      })
    ), G = [], X = [];
    for (const K of f)
      this.store.has(K.id) || ((K.type === "image" || K.type === "video") && ((ne = K.props.src) != null && ne.startsWith("data:image")) && (X.push(ni(K)), K.props.src = null), G.push(K));
    return Promise.allSettled(
      X.map(async (K) => {
        const Z = await d0e(
          K.props.src,
          K.props.name,
          K.props.mimeType ?? "image/png"
        ), oe = await this.getAssetForExternalContent({ type: "file", file: Z });
        if (!oe) {
          this.deleteAssets([K.id]);
          return;
        }
        this.updateAssets([{ ...oe, id: K.id }]);
      })
    ), this.run(() => {
      G.length > 0 && this.createAssets(G), this.createShapes(F), this.createBindings(B), i && this.select(...U.map((ie) => ie.id)), P !== u && this.reparentShapes(
        U.map((ie) => ie.id),
        P
      );
      const K = F.map((ie) => this.getShape(ie.id)), Z = vt.Common(K.map((ie) => this.getShapePageBounds(ie)));
      if (l === void 0)
        if (El(P)) {
          const ie = this.getViewportPageBounds();
          o || ie.includes(vt.From(Z)) ? l = Z.center : l = ie.center;
        } else {
          const ie = this.getShape(P);
          l = At.applyToPoint(
            this.getShapePageTransform(ie),
            this.getShapeGeometry(ie).bounds.center
          );
        }
      if (U.length === 1) {
        const ie = U[0];
        if (this.isShapeOfType(ie, "frame"))
          for (; this.getShapesAtPoint(l).some(
            (ue) => this.isShapeOfType(ue, "frame") && ue.props.w === ie.props.w && ue.props.h === ie.props.h
          ); )
            l.x += Z.w + 16;
      }
      const oe = vt.Common(
        xn(U.map(({ id: ie }) => this.getShapePageBounds(ie)))
      ).center, fe = O.Sub(l, oe);
      this.updateShapes(
        U.map(({ id: ie }) => {
          const ue = this.getShape(ie), Se = this.getShapeParentTransform(ie).decompose().rotation, ke = O.Rot(fe, -Se);
          return { id: ue.id, type: ue.type, x: ue.x + ke.x, y: ue.y + ke.y };
        })
      );
    }), this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param ids - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(e, r = {}) {
    const i = await E0e(this, e, r);
    if (!i) return;
    const s = document.createDocumentFragment(), o = b3(s);
    xS.flushSync(() => {
      o.render(i.jsx);
    });
    const l = s.firstElementChild;
    return ii(l instanceof SVGSVGElement, "Expected an SVG element"), o.unmount(), { svg: l, width: i.width, height: i.height };
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param ids - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(e, r = {}) {
    const i = await this.getSvgElement(e, r);
    return i ? {
      svg: new XMLSerializer().serializeToString(i.svg),
      width: i.width,
      height: i.height
    } : void 0;
  }
  /** @deprecated Use {@link Editor.getSvgString} or {@link Editor.getSvgElement} instead. */
  async getSvg(e, r = {}) {
    const i = await this.getSvgElement(e, r);
    if (i)
      return i.svg;
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(e) {
    const {
      pointerVelocity: r,
      previousScreenPoint: i,
      previousPagePoint: s,
      currentScreenPoint: o,
      currentPagePoint: l
    } = this.inputs, { screenBounds: u } = this.store.unsafeGetWithoutCapture(za), { x: d, y: f, z: m } = nI(() => this.getCamera()), v = e.point.x - u.x, S = e.point.y - u.y, w = e.point.z ?? 0.5;
    i.setTo(o), s.setTo(l), o.set(v, S);
    const E = v / m - d, A = S / m - f;
    isFinite(E) && isFinite(A) && l.set(E, A, w), this.inputs.isPen = e.type === "pointer" && e.isPen, (e.name === "pointer_down" || this.inputs.isPinching) && (r.set(0, 0), this.inputs.originScreenPoint.setTo(o), this.inputs.originPagePoint.setTo(l)), this.run(
      () => {
        var P;
        this.store.put([
          {
            id: bM,
            typeName: "pointer",
            x: l.x,
            y: l.y,
            lastActivityTimestamp: (
              // If our pointer moved only because we're following some other user, then don't
              // update our last activity timestamp; otherwise, update it to the current timestamp.
              e.type === "pointer" && e.pointerId === v9.CAMERA_MOVE ? ((P = this.store.unsafeGetWithoutCapture(bM)) == null ? void 0 : P.lastActivityTimestamp) ?? this._tickManager.now : this._tickManager.now
            ),
            meta: {}
          }
        ]);
      },
      { history: "ignore" }
    );
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    return this.dispatch({ type: "misc", name: "cancel" }), this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    return this.dispatch({ type: "misc", name: "interrupt" }), this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    return this.dispatch({ type: "misc", name: "complete" }), this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer: e = !0 } = {}) {
    return this.getIsFocused() ? this : (e && this.focusManager.focus(), this.updateInstanceState({ isFocused: !0 }), this);
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer: e = !0 } = {}) {
    return this.getIsFocused() ? (e ? this.focusManager.blur() : this.complete(), this.updateInstanceState({ isFocused: !1 }), this) : this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return n0e(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - the snapshot to load
   * @returns
   */
  loadSnapshot(e) {
    return hY(this.store, e), this;
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _flushEventsForTick(e) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const r = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const i of r)
          this._flushEventForTick(i);
      }
      e > 0 && this.root.handleEvent({ type: "misc", name: "tick", elapsed: e }), this.scribbles.tick(e);
    });
  }
  /** @internal */
  maybeTrackPerformance(e) {
    qi.measurePerformance.get() && (this.performanceTracker.isStarted() ? clearTimeout(this.performanceTrackerTimeout) : this.performanceTracker.start(e), this.performanceTrackerTimeout = this.timers.setTimeout(() => {
      this.performanceTracker.stop();
    }, 50));
  }
}
wt([
  ze
], mt.prototype, "getCanUndo");
wt([
  ze
], mt.prototype, "getCanRedo");
wt([
  ze
], mt.prototype, "getPath");
wt([
  ze
], mt.prototype, "getCurrentTool");
wt([
  ze
], mt.prototype, "getCurrentToolId");
wt([
  ze
], mt.prototype, "getDocumentSettings");
wt([
  ze
], mt.prototype, "getInstanceState");
wt([
  ze
], mt.prototype, "getOpenMenus");
wt([
  ze
], mt.prototype, "getIsMenuOpen");
wt([
  ze
], mt.prototype, "getPageStates");
wt([
  ze
], mt.prototype, "_getPageStatesQuery");
wt([
  ze
], mt.prototype, "getCurrentPageState");
wt([
  ze
], mt.prototype, "_getCurrentPageStateId");
wt([
  ze
], mt.prototype, "getSelectedShapeIds");
wt([
  ze
], mt.prototype, "getSelectedShapes");
wt([
  ze
], mt.prototype, "getOnlySelectedShapeId");
wt([
  ze
], mt.prototype, "getOnlySelectedShape");
wt([
  ze
], mt.prototype, "getSelectionPageBounds");
wt([
  ze
], mt.prototype, "getSelectionRotation");
wt([
  ze
], mt.prototype, "getSelectionRotatedPageBounds");
wt([
  ze
], mt.prototype, "getSelectionRotatedScreenBounds");
wt([
  ze
], mt.prototype, "getFocusedGroupId");
wt([
  ze
], mt.prototype, "getFocusedGroup");
wt([
  ze
], mt.prototype, "getEditingShapeId");
wt([
  ze
], mt.prototype, "getEditingShape");
wt([
  ze
], mt.prototype, "getHoveredShapeId");
wt([
  ze
], mt.prototype, "getHoveredShape");
wt([
  ze
], mt.prototype, "getHintingShapeIds");
wt([
  ze
], mt.prototype, "getHintingShape");
wt([
  ze
], mt.prototype, "getErasingShapeIds");
wt([
  ze
], mt.prototype, "getErasingShapes");
wt([
  ze
], mt.prototype, "_unsafe_getCameraId");
wt([
  ze
], mt.prototype, "getCamera");
wt([
  ze
], mt.prototype, "getViewportPageBoundsForFollowing");
wt([
  ze
], mt.prototype, "getCameraForFollowing");
wt([
  ze
], mt.prototype, "getZoomLevel");
wt([
  ze
], mt.prototype, "getViewportScreenBounds");
wt([
  ze
], mt.prototype, "getViewportScreenCenter");
wt([
  ze
], mt.prototype, "getViewportPageBounds");
wt([
  ze
], mt.prototype, "_getCollaboratorsQuery");
wt([
  ze
], mt.prototype, "getCollaborators");
wt([
  ze
], mt.prototype, "getCollaboratorsOnCurrentPage");
wt([
  ze
], mt.prototype, "getRenderingShapes");
wt([
  ze
], mt.prototype, "_getAllPagesQuery");
wt([
  ze
], mt.prototype, "getPages");
wt([
  ze
], mt.prototype, "getCurrentPageId");
wt([
  ze
], mt.prototype, "getCurrentPageShapeIdsSorted");
wt([
  ze
], mt.prototype, "_getAllAssetsQuery");
wt([
  ze
], mt.prototype, "_getShapeGeometryCache");
wt([
  ze
], mt.prototype, "_getShapeHandlesCache");
wt([
  ze
], mt.prototype, "_getShapePageTransformCache");
wt([
  ze
], mt.prototype, "_getShapePageBoundsCache");
wt([
  ze
], mt.prototype, "_getShapeClipPathCache");
wt([
  ze
], mt.prototype, "_getShapeMaskCache");
wt([
  ze
], mt.prototype, "_getShapeMaskedPageBoundsCache");
wt([
  ze
], mt.prototype, "_notVisibleShapes");
wt([
  ze
], mt.prototype, "getCulledShapes");
wt([
  ze
], mt.prototype, "getCurrentPageBounds");
wt([
  ze
], mt.prototype, "getCurrentPageShapes");
wt([
  ze
], mt.prototype, "getCurrentPageShapesSorted");
wt([
  ze
], mt.prototype, "getCurrentPageRenderingShapesSorted");
wt([
  ze
], mt.prototype, "_getBindingsIndexCache");
wt([
  ze
], mt.prototype, "_getSelectionSharedStyles");
wt([
  ze({ isEqual: (n, t) => n.equals(t) })
], mt.prototype, "getSharedStyles");
wt([
  ze
], mt.prototype, "getSharedOpacity");
wt([
  ze
], mt.prototype, "getIsFocused");
function gI(n, t = n.getCurrentPageId()) {
  const e = n.getPage(t).name;
  n.emit("max-shapes", { name: e, pageId: t, count: n.options.maxShapesPerPage });
}
function Yd(n, t) {
  if (!t) return n;
  let e = null;
  const r = Object.entries(t);
  for (let i = 0, s = r.length; i < s; i++) {
    const [o, l] = r[i];
    if (l !== void 0 && !(o === "id" || o === "type" || o === "typeName") && l !== n[o]) {
      if (e || (e = { ...n }), o === "props" || o === "meta") {
        e[o] = { ...n[o] };
        for (const [u, d] of Object.entries(l))
          d !== void 0 && (e[o][u] = d);
        continue;
      }
      e[o] = l;
    }
  }
  return e || n;
}
function xY(n, t, e) {
  const r = n.getShape(t);
  if (!r) return;
  e.push(r);
  const i = n.getSortedChildIdsForParent(t);
  for (let s = 0, o = i.length; s < o; s++)
    xY(n, i[s], e);
}
function q9(n, t, e) {
  let r;
  if (n.run(
    () => {
      const i = n.store.extractingChanges(() => {
        const s = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (const l of t)
          if (n.getShape(l))
            for (const d of n.getBindingsInvolvingShape(l)) {
              const f = t.has(d.fromId), m = t.has(d.toId);
              if (f && m) {
                s.add(d.id);
                continue;
              }
              (!f || !m) && o.add(d.id);
            }
        n.deleteBindings([...o], { isolateShapes: !0 });
        try {
          r = gm.ok(e(s));
        } catch (l) {
          r = gm.err(l);
        }
      });
      n.store.applyDiff(c3(i));
    },
    { history: "ignore" }
  ), r.ok)
    return r.value;
  throw r.error;
}
function Z9(n, t) {
  if (!t.constraints) throw Error("Should have constraints here");
  const {
    padding: { x: e, y: r }
  } = t.constraints, i = n.getViewportScreenBounds(), s = vt.From(t.constraints.bounds), o = (i.w - e * 2) / s.w, l = (i.h - r * 2) / s.h;
  return { zx: o, zy: l };
}
function KT() {
  const n = we(), t = SY();
  return De("isDarkMode", () => (t == null ? void 0 : t.isDarkMode) ?? n.user.getIsDarkMode(), [
    t,
    n
  ]);
}
const Q9 = "<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>", J9 = "<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>", mI = '<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>';
function Lg(n, t, e, r, i, s = 16, o = 16) {
  const l = (-e - t) * (cr / 180), u = Math.sin(l), d = Math.cos(l), f = 1 * d - 1 * u, m = 1 * u + 1 * d;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${i};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${f}' dy='${m}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${t + e} 16 16)${r ? " scale(-1,-1) translate(0, -32)" : ""}' filter='url(%23shadow)'>` + n.replaceAll('"', "'") + `</g></svg>") ${s} ${o}, pointer`;
}
const rxe = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
], ixe = {
  none: () => "none",
  "ew-resize": (n, t, e) => Lg(J9, n, 0, t, e),
  "ns-resize": (n, t, e) => Lg(J9, n, 90, t, e),
  "nesw-resize": (n, t, e) => Lg(Q9, n, 0, t, e),
  "nwse-resize": (n, t, e) => Lg(Q9, n, 90, t, e),
  "nwse-rotate": (n, t, e) => Lg(mI, n, 0, t, e),
  "nesw-rotate": (n, t, e) => Lg(mI, n, 90, t, e),
  "senw-rotate": (n, t, e) => Lg(mI, n, 180, t, e),
  "swne-rotate": (n, t, e) => Lg(mI, n, 270, t, e)
};
function nc(n, t = 0, e = "black") {
  return ixe[n](Eye(t), !1, e);
}
function sxe() {
  const n = we(), t = io(), e = KT();
  mm(
    "useCursor",
    () => {
      const { type: r, rotation: i } = n.getInstanceState().cursor;
      if (rxe.includes(r)) {
        t.style.setProperty("--tl-cursor", `var(--tl-cursor-${r})`);
        return;
      }
      t.style.setProperty(
        "--tl-cursor",
        nc(r, i, e ? "white" : "black")
      );
    },
    [n, t, e]
  );
}
function oxe() {
  const n = we(), t = io(), e = KT(), r = De(qi.forceSrgb);
  Gn.useEffect(() => {
    e ? (t.setAttribute("data-color-mode", "dark"), t.classList.remove("tl-theme__light"), t.classList.add("tl-theme__dark")) : (t.setAttribute("data-color-mode", "light"), t.classList.remove("tl-theme__dark"), t.classList.add("tl-theme__light")), r ? t.classList.add("tl-theme__force-sRGB") : t.classList.remove("tl-theme__force-sRGB");
  }, [n, t, r, e]);
}
function wY(n) {
  const t = D.useRef();
  return D.useLayoutEffect(() => {
    t.current = n;
  }), D.useDebugValue(n), D.useCallback((...e) => {
    const r = t.current;
    return ii(r, "fn does not exist"), r(...e);
  }, []);
}
function axe() {
  const [n, t] = D.useState(0);
  D.useEffect(() => t((e) => e + 1), []);
}
const lxe = (n) => n.props.src, cxe = {
  upload: (n, t) => Xy.blobToDataUrl(t)
};
function uxe(n) {
  return "schema" in n && n.schema ? n.schema : dye({
    shapes: "shapeUtils" in n && n.shapeUtils ? e7(mY(n.shapeUtils)) : void 0,
    bindings: "bindingUtils" in n && n.bindingUtils ? e7(fY(n.bindingUtils)) : void 0,
    migrations: "migrations" in n ? n.migrations : void 0
  });
}
function AM({
  initialData: n,
  defaultName: t = "",
  id: e,
  assets: r = cxe,
  onMount: i,
  collaboration: s,
  ...o
} = {}) {
  const l = uxe(o), u = new r5({
    id: e,
    schema: l,
    initialData: n,
    props: {
      defaultName: t,
      assets: {
        upload: r.upload,
        resolve: r.resolve ?? lxe
      },
      onMount: (d) => {
        ii(d instanceof mt), i == null || i(d);
      },
      collaboration: s
    }
  });
  if (o.snapshot) {
    if (n) throw new Error("Cannot provide both initialData and snapshot");
    hY(u, o.snapshot);
  }
  return u;
}
function e7(n) {
  return Object.fromEntries(
    n.map((t) => [
      t.type,
      {
        props: t.props,
        migrations: t.migrations
      }
    ])
  );
}
const dxe = (n, t) => t.some((e) => n instanceof e);
let t7, n7;
function hxe() {
  return t7 || (t7 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function fxe() {
  return n7 || (n7 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const CY = /* @__PURE__ */ new WeakMap(), C3 = /* @__PURE__ */ new WeakMap(), EY = /* @__PURE__ */ new WeakMap(), jN = /* @__PURE__ */ new WeakMap(), _5 = /* @__PURE__ */ new WeakMap();
function pxe(n) {
  const t = new Promise((e, r) => {
    const i = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", o);
    }, s = () => {
      e(up(n.result)), i();
    }, o = () => {
      r(n.error), i();
    };
    n.addEventListener("success", s), n.addEventListener("error", o);
  });
  return t.then((e) => {
    e instanceof IDBCursor && CY.set(e, n);
  }).catch(() => {
  }), _5.set(t, n), t;
}
function gxe(n) {
  if (C3.has(n))
    return;
  const t = new Promise((e, r) => {
    const i = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", o), n.removeEventListener("abort", o);
    }, s = () => {
      e(), i();
    }, o = () => {
      r(n.error || new DOMException("AbortError", "AbortError")), i();
    };
    n.addEventListener("complete", s), n.addEventListener("error", o), n.addEventListener("abort", o);
  });
  C3.set(n, t);
}
let E3 = {
  get(n, t, e) {
    if (n instanceof IDBTransaction) {
      if (t === "done")
        return C3.get(n);
      if (t === "objectStoreNames")
        return n.objectStoreNames || EY.get(n);
      if (t === "store")
        return e.objectStoreNames[1] ? void 0 : e.objectStore(e.objectStoreNames[0]);
    }
    return up(n[t]);
  },
  set(n, t, e) {
    return n[t] = e, !0;
  },
  has(n, t) {
    return n instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in n;
  }
};
function mxe(n) {
  E3 = n(E3);
}
function vxe(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...e) {
    const r = n.call(NN(this), t, ...e);
    return EY.set(r, t.sort ? t.sort() : [t]), up(r);
  } : fxe().includes(n) ? function(...t) {
    return n.apply(NN(this), t), up(CY.get(this));
  } : function(...t) {
    return up(n.apply(NN(this), t));
  };
}
function yxe(n) {
  return typeof n == "function" ? vxe(n) : (n instanceof IDBTransaction && gxe(n), dxe(n, hxe()) ? new Proxy(n, E3) : n);
}
function up(n) {
  if (n instanceof IDBRequest)
    return pxe(n);
  if (jN.has(n))
    return jN.get(n);
  const t = yxe(n);
  return t !== n && (jN.set(n, t), _5.set(t, n)), t;
}
const NN = (n) => _5.get(n);
function _Y(n, t, { blocked: e, upgrade: r, blocking: i, terminated: s } = {}) {
  const o = indexedDB.open(n, t), l = up(o);
  return r && o.addEventListener("upgradeneeded", (u) => {
    r(up(o.result), u.oldVersion, u.newVersion, up(o.transaction), u);
  }), e && o.addEventListener("blocked", (u) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    u.oldVersion,
    u.newVersion,
    u
  )), l.then((u) => {
    s && u.addEventListener("close", () => s()), i && u.addEventListener("versionchange", (d) => i(d.oldVersion, d.newVersion, d));
  }).catch(() => {
  }), l;
}
function TY(n, { blocked: t } = {}) {
  const e = indexedDB.deleteDatabase(n);
  return t && e.addEventListener("blocked", (r) => t(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    r.oldVersion,
    r
  )), up(e).then(() => {
  });
}
const Sxe = ["get", "getKey", "getAll", "getAllKeys", "count"], bxe = ["put", "add", "delete", "clear"], FN = /* @__PURE__ */ new Map();
function r7(n, t) {
  if (!(n instanceof IDBDatabase && !(t in n) && typeof t == "string"))
    return;
  if (FN.get(t))
    return FN.get(t);
  const e = t.replace(/FromIndex$/, ""), r = t !== e, i = bxe.includes(e);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(e in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || Sxe.includes(e))
  )
    return;
  const s = async function(o, ...l) {
    const u = this.transaction(o, i ? "readwrite" : "readonly");
    let d = u.store;
    return r && (d = d.index(l.shift())), (await Promise.all([
      d[e](...l),
      i && u.done
    ]))[0];
  };
  return FN.set(t, s), s;
}
mxe((n) => ({
  ...n,
  get: (t, e, r) => r7(t, e) || n.get(t, e, r),
  has: (t, e) => !!r7(t, e) || n.has(t, e)
}));
const xxe = "TLDRAW_DOCUMENT_v2", wxe = "TLDRAW_ASSET_STORE_v1", PY = "TLDRAW_DB_NAME_INDEX_v2", Fn = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function AY(n) {
  const t = xxe + n;
  return Exe(t), await _Y(t, 4, {
    upgrade(e) {
      e.objectStoreNames.contains(Fn.Records) || e.createObjectStore(Fn.Records), e.objectStoreNames.contains(Fn.Schema) || e.createObjectStore(Fn.Schema), e.objectStoreNames.contains(Fn.SessionState) || e.createObjectStore(Fn.SessionState), e.objectStoreNames.contains(Fn.Assets) || e.createObjectStore(Fn.Assets);
    }
  });
}
async function Cxe(n) {
  const t = window.indexedDB.databases ? (await window.indexedDB.databases()).map((v) => v.name) : T5(), e = wxe + n;
  if (!t.find((v) => v === e)) return;
  const i = await _Y(e, 1, {
    upgrade(v) {
      v.objectStoreNames.contains("assets") || v.createObjectStore("assets");
    }
  }), s = i.transaction(["assets"], "readonly"), o = s.objectStore("assets"), l = await o.getAllKeys(), u = await Promise.all(
    l.map(async (v) => [v, await o.get(v)])
  );
  await s.done;
  const d = await AY(n), f = d.transaction([Fn.Assets], "readwrite"), m = f.objectStore(Fn.Assets);
  for (const [v, S] of u)
    m.put(S, v);
  await f.done, i.close(), d.close(), await TY(e);
}
const O1 = class O1 {
  constructor(t) {
    T(this, "getDbPromise");
    T(this, "isClosed", !1);
    T(this, "pendingTransactionSet", /* @__PURE__ */ new Set());
    O1.connectedInstances.add(this), this.getDbPromise = (async () => (await Cxe(t), await AY(t)))();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(F1);
  }
  async close() {
    this.isClosed || (this.isClosed = !0, await this.pending(), (await this.getDb()).close(), O1.connectedInstances.delete(this));
  }
  tx(t, e, r) {
    const i = (async () => {
      ii(!this.isClosed, "db is closed");
      const o = (await this.getDb()).transaction(e, t);
      try {
        return await r(o);
      } finally {
        this.isClosed ? o.abort() : await o.done;
      }
    })();
    return this.pendingTransactionSet.add(i), i.finally(() => this.pendingTransactionSet.delete(i)), i;
  }
  async load({ sessionId: t } = {}) {
    return await this.tx(
      "readonly",
      [Fn.Records, Fn.Schema, Fn.SessionState],
      async (e) => {
        var u, d;
        const r = e.objectStore(Fn.Records), i = e.objectStore(Fn.Schema), s = e.objectStore(Fn.SessionState);
        let o = t ? (u = await s.get(t)) == null ? void 0 : u.snapshot : null;
        return o || (o = (d = (await s.getAll()).sort((m, v) => m.updatedAt - v.updatedAt).pop()) == null ? void 0 : d.snapshot), {
          records: await r.getAll(),
          schema: await i.get(Fn.Schema),
          sessionStateSnapshot: o
        };
      }
    );
  }
  async storeChanges({
    schema: t,
    changes: e,
    sessionId: r,
    sessionStateSnapshot: i
  }) {
    await this.tx("readwrite", [Fn.Records, Fn.Schema, Fn.SessionState], async (s) => {
      const o = s.objectStore(Fn.Records), l = s.objectStore(Fn.Schema), u = s.objectStore(Fn.SessionState);
      for (const [d, f] of Object.entries(e.added))
        await o.put(f, d);
      for (const [d, f] of Object.values(e.updated))
        await o.put(f, f.id);
      for (const d of Object.keys(e.removed))
        await o.delete(d);
      l.put(t.serialize(), Fn.Schema), i && r ? u.put(
        {
          snapshot: i,
          updatedAt: Date.now(),
          id: r
        },
        r
      ) : (i || r) && console.error("sessionStateSnapshot and instanceId must be provided together");
    });
  }
  async storeSnapshot({
    schema: t,
    snapshot: e,
    sessionId: r,
    sessionStateSnapshot: i
  }) {
    await this.tx("readwrite", [Fn.Records, Fn.Schema, Fn.SessionState], async (s) => {
      const o = s.objectStore(Fn.Records), l = s.objectStore(Fn.Schema), u = s.objectStore(Fn.SessionState);
      await o.clear();
      for (const [d, f] of Object.entries(e))
        await o.put(f, d);
      l.put(t.serialize(), Fn.Schema), i && r ? u.put(
        {
          snapshot: i,
          updatedAt: Date.now(),
          id: r
        },
        r
      ) : (i || r) && console.error("sessionStateSnapshot and instanceId must be provided together");
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [Fn.SessionState], async (t) => {
      const e = t.objectStore(Fn.SessionState), r = (await e.getAll()).sort((s, o) => s.updatedAt - o.updatedAt);
      if (r.length < 10) {
        await t.done;
        return;
      }
      const i = r.slice(0, r.length - 10);
      for (const { id: s } of i)
        await e.delete(s);
    });
  }
  async getAsset(t) {
    return await this.tx("readonly", [Fn.Assets], async (e) => await e.objectStore(Fn.Assets).get(t));
  }
  async storeAsset(t, e) {
    await this.tx("readwrite", [Fn.Assets], async (r) => {
      await r.objectStore(Fn.Assets).put(e, t);
    });
  }
};
/** @internal */
T(O1, "connectedInstances", /* @__PURE__ */ new Set());
let kM = O1;
function T5() {
  const n = JSON.parse(Qz(PY) || "[]") ?? [];
  return Array.isArray(n) ? n : [];
}
function Exe(n) {
  const t = new Set(T5());
  t.add(n), Jz(PY, JSON.stringify([...t]));
}
function _xe() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
• If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function Txe() {
  window.alert(
    `Oops! We could not access your browser's storage—and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}
const Pxe = 350, Axe = 1e4, i7 = Symbol("UPDATE_INSTANCE_STATE"), kxe = (n) => n;
class Ixe {
  constructor(t) {
    T(this, "onmessage");
  }
  postMessage(t) {
  }
  close() {
  }
}
const Rxe = typeof BroadcastChannel > "u" ? Ixe : BroadcastChannel;
class Mxe {
  constructor(t, {
    persistenceKey: e,
    sessionId: r = PM,
    onLoad: i,
    onLoadError: s
  }, o = new Rxe(`tldraw-tab-sync-${e}`)) {
    T(this, "disposables", /* @__PURE__ */ new Set());
    T(this, "diffQueue", []);
    T(this, "didDispose", !1);
    T(this, "shouldDoFullDBWrite", !0);
    T(this, "isReloading", !1);
    T(this, "persistenceKey");
    T(this, "sessionId");
    T(this, "serializedSchema");
    T(this, "isDebugging", !1);
    T(this, "documentTypes");
    T(this, "$sessionStateSnapshot");
    /** @internal */
    T(this, "db");
    T(this, "initTime", Date.now());
    T(this, "isPersisting", !1);
    T(this, "didLastWriteError", !1);
    // eslint-disable-next-line no-restricted-globals
    T(this, "scheduledPersistTimeout", null);
    this.store = t, this.channel = o, typeof window < "u" && (window.tlsync = this), this.persistenceKey = e, this.sessionId = r, this.db = new kM(e), this.disposables.add(() => this.db.close()), this.serializedSchema = this.store.schema.serialize(), this.$sessionStateSnapshot = uY(this.store), this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      t.listen(
        ({ changes: l }) => {
          this.diffQueue.push(l), this.channel.postMessage(
            kxe({
              type: "diff",
              storeId: this.store.id,
              changes: l,
              schema: this.serializedSchema
            })
          ), this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    ), this.disposables.add(
      t.listen(
        () => {
          this.diffQueue.push(i7), this.schedulePersist();
        },
        { scope: "session" }
      )
    ), this.connect(i, s), this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((l) => l.scope === "document").map((l) => l.typeName)
    );
  }
  debug(...t) {
    this.isDebugging && console.debug(...t);
  }
  async connect(t, e) {
    this.debug("connecting");
    let r;
    try {
      r = await this.db.load({ sessionId: this.sessionId });
    } catch (i) {
      e(i), Txe();
      return;
    }
    if (this.debug("loaded data from store", r, "didDispose", this.didDispose), !this.didDispose)
      try {
        if (r) {
          const i = Object.fromEntries(r.records.map((l) => [l.id, l])), s = r.sessionStateSnapshot ?? e0e(i), o = this.store.schema.migrateStoreSnapshot({
            store: i,
            // eslint-disable-next-line deprecation/deprecation
            schema: r.schema ?? this.store.schema.serializeEarliestVersion()
          });
          if (o.type === "error") {
            console.error("failed to migrate store", o), e(new Error(`Failed to migrate store: ${o.reason}`));
            return;
          }
          this.store.mergeRemoteChanges(() => {
            this.store.put(
              Object.values(o.value).filter((l) => this.documentTypes.has(l.typeName)),
              "initialize"
            );
          }), s && dY(this.store, s);
        }
        this.channel.onmessage = ({ data: i }) => {
          var l, u;
          this.debug("got message", i);
          const s = i, o = this.store.schema.getMigrationsSince(s.schema);
          if (o.ok) {
            if (o.value.length > 0) {
              this.debug("telling them to reload"), this.channel.postMessage({ type: "announce", schema: this.serializedSchema }), this.shouldDoFullDBWrite = !0, this.persistIfNeeded();
              return;
            }
          } else {
            if (Date.now() - this.initTime < 5e3) {
              e(new Error("Schema mismatch, please close other tabs and reload the page"));
              return;
            }
            this.debug("reloading"), this.isReloading = !0, (u = (l = window == null ? void 0 : window.location) == null ? void 0 : l.reload) == null || u.call(l);
            return;
          }
          s.type === "diff" && (this.debug("applying diff"), bh(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(s.changes), this.store.ensureStoreIsUsable();
            });
          }));
        }, this.channel.postMessage({ type: "announce", schema: this.serializedSchema }), this.disposables.add(() => {
          this.channel.close();
        }), t(this);
      } catch (i) {
        if (this.debug("error loading data from store", i), this.didDispose) return;
        e(i);
        return;
      }
  }
  close() {
    this.debug("closing"), this.didDispose = !0, this.disposables.forEach((t) => t());
  }
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout), !this.scheduledPersistTimeout && (this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null, this.persistIfNeeded();
      },
      this.didLastWriteError ? Axe : Pxe
    ));
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    }), this.scheduledPersistTimeout && (clearTimeout(this.scheduledPersistTimeout), this.scheduledPersistTimeout = null), !this.isPersisting && (this.isReloading || this.store.isPossiblyCorrupted() || (this.shouldDoFullDBWrite || this.diffQueue.length > 0) && this.doPersist());
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    if (ii(!this.isPersisting, "persist already in progress"), this.didDispose) return;
    this.isPersisting = !0, this.debug("doPersist start");
    const t = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite)
        this.shouldDoFullDBWrite = !1, await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      else {
        const e = n5(
          t.filter((r) => r !== i7)
        );
        await this.db.storeChanges({
          changes: e,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = !1;
    } catch (e) {
      this.shouldDoFullDBWrite = !0, this.didLastWriteError = !0, console.error("failed to store changes in indexed db", e), _xe(), typeof window < "u" && window.location.reload();
    }
    this.isPersisting = !1, this.debug("doPersist end"), this.schedulePersist();
  }
}
function kY(n) {
  const t = D.useRef(n), [e, r] = D.useState(n);
  e !== t.current && r(t.current);
  const i = D.useCallback((s) => {
    typeof s == "function" ? t.current = s(t.current) : t.current = s, r(t.current);
  }, []);
  return [e, i];
}
function Dxe(n) {
  const [t, e] = kY({ status: "loading" });
  return n = O2(n), D.useEffect(() => {
    const { persistenceKey: r, sessionId: i, ...s } = n;
    if (!r) {
      e({
        status: "not-synced",
        store: AM(s)
      });
      return;
    }
    e({ status: "loading" });
    const o = new vp(), l = {
      upload: async (m, v) => (await f.db.storeAsset(m.id, v), m.id),
      resolve: async (m) => m.props.src ? m.props.src.startsWith("asset:") ? await o.get(m, async () => {
        const v = await f.db.getAsset(m.id);
        return v ? URL.createObjectURL(v) : null;
      }) : m.props.src : null,
      ...s.assets
    }, u = AM({ ...s, assets: l });
    let d = !1;
    const f = new Mxe(u, {
      sessionId: i,
      persistenceKey: r,
      onLoad() {
        d || e({ store: u, status: "synced-local" });
      },
      onLoadError(m) {
        d || e({ status: "error", error: m });
      }
    });
    return () => {
      d = !0, f.close();
    };
  }, [n, e]), t;
}
function Oxe() {
  const n = we(), t = io();
  D.useEffect(() => {
    const e = (s) => t.style.setProperty("--tl-zoom", s.toString()), r = hG(e, 100), i = new uw("useZoomCss", () => {
      n.getCurrentPageShapeIds().size < 300 ? e(n.getZoomLevel()) : r(n.getZoomLevel());
    });
    return i.attach(), i.execute(), () => {
      i.detach(), r.cancel();
    };
  }, [n, t]);
}
function _3(n) {
  const t = new ArrayBuffer(n.length), e = new Uint8Array(t);
  for (let r = 0, i = n.length; r < i; r++)
    e[r] = n.charCodeAt(r);
  return t;
}
function Lxe(n) {
  const t = atob(n), e = _3(t);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(e),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    !0,
    ["verify"]
  );
}
const jxe = 5, nR = {
  ANNUAL_LICENSE: 1,
  PERPETUAL_LICENSE: 2,
  INTERNAL_LICENSE: 4
}, Nxe = Math.max(...Object.values(nR)), qE = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
}, Fxe = Object.keys(qE).length, vI = "sales@tldraw.com";
class P5 {
  constructor(t, e, r) {
    T(this, "publicKey", "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ");
    T(this, "isDevelopment");
    T(this, "isTest");
    T(this, "isCryptoAvailable");
    T(this, "state", Qs("license state", "pending"));
    this.isTest = process.env.NODE_ENV === "test", this.isDevelopment = this.getIsDevelopment(r), this.publicKey = e || this.publicKey, this.isCryptoAvailable = !!crypto.subtle, t5.enableLicensing.get() ? this.getLicenseFromKey(t).then((i) => {
      const s = $xe(i);
      this.state.set(s ? "unlicensed" : "licensed");
    }) : this.state.set("licensed");
  }
  getIsDevelopment(t) {
    return t === "development" ? !0 : t === "production" ? !1 : window.location.protocol !== "https:";
  }
  async extractLicenseKey(t) {
    const [e, r] = t.split("."), [i, s] = e.split("/");
    if (!i.startsWith("tldraw-"))
      throw new Error(`Unsupported prefix '${i}'`);
    const o = await Lxe(this.publicKey);
    let l;
    try {
      l = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        o,
        new Uint8Array(_3(atob(r))),
        new Uint8Array(_3(atob(s)))
      );
    } catch (d) {
      throw console.error(d), new Error("Could not perform signature validation");
    }
    if (!l)
      throw new Error("Invalid signature");
    let u;
    try {
      u = JSON.parse(atob(s));
    } catch {
      throw new Error("Could not parse object");
    }
    return u.length > Fxe && this.outputMessages([
      "License key contains some unknown properties.",
      "You may want to update tldraw packages to a newer version to get access to new functionality."
    ]), {
      id: u[qE.ID],
      hosts: u[qE.HOSTS],
      flags: u[qE.FLAGS],
      expiryDate: u[qE.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(t) {
    if (!t)
      return this.isDevelopment || this.outputNoLicenseKeyProvided(), { isLicenseParseable: !1, reason: "no-key-provided" };
    if (this.isDevelopment && !this.isCryptoAvailable)
      return console.log(
        "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
      ), console.log("You should check that this works in production separately."), { isLicenseParseable: !1, reason: "has-key-development-mode" };
    let e = t.replace(/[\u200B-\u200D\uFEFF]/g, "");
    e = e.replace(/\r?\n|\r/g, "");
    try {
      const r = await this.extractLicenseKey(e), i = new Date(r.expiryDate), s = this.isFlagEnabled(r.flags, nR.ANNUAL_LICENSE), o = this.isFlagEnabled(r.flags, nR.PERPETUAL_LICENSE), l = {
        license: r,
        isLicenseParseable: !0,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(r),
        expiryDate: i,
        isAnnualLicense: s,
        isAnnualLicenseExpired: s && this.isAnnualLicenseExpired(i),
        isPerpetualLicense: o,
        isPerpetualLicenseExpired: o && this.isPerpetualLicenseExpired(i),
        isInternalLicense: this.isFlagEnabled(r.flags, nR.INTERNAL_LICENSE)
      };
      return this.outputLicenseInfoIfNeeded(l), l;
    } catch (r) {
      return this.outputInvalidLicenseKey(r.message), { isLicenseParseable: !1, reason: "invalid-license-key" };
    }
  }
  isDomainValid(t) {
    const e = window.location.hostname.toLowerCase();
    return t.hosts.some((r) => {
      const i = r.toLowerCase().trim();
      return i === e || `www.${i}` === e || i === `www.${e}` || r === "*" ? !0 : r.includes("*") ? new RegExp(r.replace(/\*/g, ".*?")).test(e) : !1;
    });
  }
  getExpirationDateWithoutGracePeriod(t) {
    return new Date(t.getFullYear(), t.getMonth(), t.getDate());
  }
  getExpirationDateWithGracePeriod(t) {
    return new Date(
      t.getFullYear(),
      t.getMonth(),
      t.getDate() + jxe + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(t) {
    const e = this.getExpirationDateWithGracePeriod(t), r = /* @__PURE__ */ new Date() >= e;
    return !r && /* @__PURE__ */ new Date() >= this.getExpirationDateWithoutGracePeriod(t) && this.outputMessages([
      "tldraw license is about to expire, you are in a grace period.",
      `Please reach out to ${vI} if you would like to renew your license.`
    ]), r;
  }
  isPerpetualLicenseExpired(t) {
    const e = this.getExpirationDateWithGracePeriod(t), r = {
      major: new Date(f9.major),
      minor: new Date(f9.minor)
    };
    return r.major >= e || r.minor >= e;
  }
  isFlagEnabled(t, e) {
    return (t & e) === e;
  }
  outputNoLicenseKeyProvided() {
    this.outputMessages([
      "No tldraw license key provided!",
      `Please reach out to ${vI} if you would like to license tldraw or if you'd like a trial.`
    ]);
  }
  outputInvalidLicenseKey(t) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${t}`]);
  }
  outputLicenseInfoIfNeeded(t) {
    t.isAnnualLicenseExpired && this.outputMessages([
      "Your tldraw license has expired!",
      `Please reach out to ${vI} to renew.`
    ]), !t.isDomainValid && !t.isDevelopment && this.outputMessages([
      "This tldraw license key is not valid for this domain!",
      `Please reach out to ${vI} if you would like to use tldraw on other domains.`
    ]), t.license.flags >= Nxe * 2 && this.outputMessages([
      "This tldraw license contains some unknown flags.",
      "You may want to update tldraw packages to a newer version to get access to new functionality."
    ]);
  }
  outputMessages(t) {
    if (!this.isTest) {
      this.outputDelimiter();
      for (const e of t)
        console.log(
          `%c${e}`,
          "color: white; background: crimson; padding: 2px; border-radius: 3px;"
        );
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      "color: white; background: crimson; padding: 2px; border-radius: 3px;"
    );
  }
}
T(P5, "className", "tl-watermark_SEE-LICENSE");
function $xe(n) {
  if (!n.isLicenseParseable || !n.isDomainValid && !n.isDevelopment) return !0;
  if (n.isPerpetualLicenseExpired || n.isAnnualLicenseExpired) {
    if (n.isInternalLicense)
      throw new Error("License: Internal license expired.");
    return !0;
  }
  return !1;
}
const IY = D.createContext({}), zxe = () => D.useContext(IY);
function Uxe({
  licenseKey: n,
  children: t
}) {
  const [e] = D.useState(() => new P5(n));
  return /* @__PURE__ */ y.jsx(IY.Provider, { value: e, children: t });
}
const Bxe = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>', Hxe = `${hm()}/watermarks/watermark-desktop.svg`, yI = `data:image/svg+xml;utf8,${encodeURIComponent(Bxe)}`;
let $N = null;
async function Vxe(n) {
  return n ? yI : ($N || ($N = Promise.race([
    // try and load the remote watermark, if it fails, fallback to the local one
    (async () => {
      try {
        const t = await Th(Hxe);
        if (!t.ok) return yI;
        const e = await t.blob();
        return URL.createObjectURL(e);
      } catch {
        return yI;
      }
    })(),
    // but if that's taking a long time (>3s) just show the local one anyway
    new Promise((t) => {
      setTimeout(() => {
        t(yI);
      }, 3e3);
    })
  ])), $N);
}
const Wxe = Gn.memo(function({
  forceLocal: t = !1
}) {
  const e = PK(), r = we(), i = zxe(), s = De(
    "show watermark",
    () => t5.enableLicensing.get() && r.getViewportScreenBounds().width > 760 && i.state.get() === "unlicensed",
    [r, i]
  ), o = De("debug mode", () => r.getInstanceState().isDebugMode, [r]), l = De("is menu open", () => r.getIsMenuOpen(), [r]), [u, d] = D.useState(null), f = t || i.isDevelopment;
  if (D.useEffect(() => {
    if (!s) return;
    let S = !1;
    return (async () => {
      const w = await Vxe(f);
      S || d(w);
    })(), () => {
      S = !0;
    };
  }, [f, s]), !s || !u) return null;
  const m = P5.className, v = `url('${u}') center 100% / 100% no-repeat`;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx("style", { children: `
/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
users. By using this library, you agree to keep the watermark's behavior, 
keeping it visible, unobscured, and available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

.${m} {
	position: absolute;
	bottom: var(--space-2);
	right: var(--space-2);
	width: 96px;
	height: 32px;
	z-index: 2147483647 !important;
	pointer-events: ${l ? "none" : "all"};
	background-color: color-mix(in srgb, var(--color-background) 62%, transparent);
	border-radius: 5px;
	padding: 2px;
	box-sizing: content-box;
}

.${m}[data-debug='true'] {
	bottom: 46px;
}

.${m} > a {
	position: absolute;
	width: 96px;
	height: 32px;
	pointer-events: none;
	cursor: inherit;
	color: var(--color-text);
	background-color: currentColor;
	opacity: .28;
}

@media (hover: hover) {
	.${m}:hover {
		background-color: var(--color-background);
		transition: background-color 0.2s ease-in-out;
		transition-delay: 0.32s;
	}
	.${m}:hover > a {
		animation: delayed_link 0.2s forwards ease-in-out;
		animation-delay: 0.32s;
	}
}

@keyframes delayed_link {
	0% {
		cursor: inherit;
		opacity: .38;
		pointer-events: none;
	}
	100% {
		cursor: pointer;
		opacity: 1;
		pointer-events: all;
	}
}
` }),
    /* @__PURE__ */ y.jsx("div", { className: m, "data-debug": o, draggable: !1, ...e, children: /* @__PURE__ */ y.jsx(
      "a",
      {
        href: "https://tldraw.dev",
        target: "_blank",
        rel: "noreferrer",
        draggable: !1,
        onPointerDown: to,
        style: { mask: v, WebkitMask: v }
      }
    ) })
  ] });
}), Gxe = [], Kxe = [], Yxe = [], Xxe = "tl-container", qxe = D.memo(function({
  store: t,
  components: e,
  className: r,
  user: i,
  ...s
}) {
  const [o, l] = Gn.useState(null), u = D.useMemo(() => i ?? iY(), [i]), d = (e == null ? void 0 : e.ErrorFallback) === void 0 ? XK : e == null ? void 0 : e.ErrorFallback, f = {
    ...s,
    shapeUtils: s.shapeUtils ?? Gxe,
    bindingUtils: s.bindingUtils ?? Kxe,
    tools: s.tools ?? Yxe,
    components: e
  };
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      ref: l,
      "data-tldraw": wK,
      draggable: !1,
      className: Vt(`${Xxe} tl-theme__light`, r),
      onPointerDown: to,
      tabIndex: -1,
      children: /* @__PURE__ */ y.jsx(
        H1,
        {
          fallback: d,
          onError: (m) => qz(m, { tags: { origin: "react.tldraw-before-app" } }),
          children: o && /* @__PURE__ */ y.jsx(Uxe, { licenseKey: s.licenseKey, children: /* @__PURE__ */ y.jsx(Iye, { container: o, children: /* @__PURE__ */ y.jsx(Obe, { overrides: e, children: t ? t instanceof r5 ? (
            // Store is ready to go, whether externally synced or not
            /* @__PURE__ */ y.jsx(MY, { ...f, store: t, user: u })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            /* @__PURE__ */ y.jsx(RY, { ...f, store: t, user: u })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            /* @__PURE__ */ y.jsx(Zxe, { ...f, store: t, user: u })
          ) }) }) })
        }
      )
    }
  );
});
function Zxe(n) {
  const {
    defaultName: t,
    snapshot: e,
    initialData: r,
    shapeUtils: i,
    bindingUtils: s,
    persistenceKey: o,
    sessionId: l,
    user: u,
    assets: d
  } = n, f = Dxe({
    shapeUtils: i,
    bindingUtils: s,
    initialData: r,
    persistenceKey: o,
    sessionId: l,
    defaultName: t,
    snapshot: e,
    assets: d
  });
  return /* @__PURE__ */ y.jsx(RY, { ...n, store: f, user: u });
}
const RY = D.memo(function({
  store: t,
  user: e,
  ...r
}) {
  const i = io();
  D.useLayoutEffect(() => {
    e.userPreferences.get().colorScheme === "dark" && (i.classList.remove("tl-theme__light"), i.classList.add("tl-theme__dark"));
  }, [i, e]);
  const { LoadingScreen: s } = xi();
  switch (t.status) {
    case "error":
      throw t.error;
    case "loading":
      return s ? /* @__PURE__ */ y.jsx(s, {}) : null;
  }
  return /* @__PURE__ */ y.jsx(MY, { ...r, store: t.store, user: e });
}), zN = () => document.location.search.includes("tldraw_preserve_focus");
function MY({
  onMount: n,
  children: t,
  store: e,
  tools: r,
  shapeUtils: i,
  bindingUtils: s,
  user: o,
  initialState: l,
  autoFocus: u = !0,
  inferDarkMode: d,
  cameraOptions: f,
  options: m,
  licenseKey: v
}) {
  const { ErrorFallback: S } = xi(), w = io(), [E, A] = kY(null), P = D.useRef({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: u && !zN(),
    inferDarkMode: d,
    initialState: l,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions: f
  });
  D.useLayoutEffect(() => {
    P.current = {
      autoFocus: u && !zN(),
      inferDarkMode: d,
      initialState: l,
      cameraOptions: f
    };
  }, [u, d, l, f]), D.useLayoutEffect(
    () => {
      const { autoFocus: j, inferDarkMode: $, initialState: U, cameraOptions: F } = P.current, B = new mt({
        store: e,
        shapeUtils: i,
        bindingUtils: s,
        tools: r,
        getContainer: () => w,
        user: o,
        initialState: U,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: j,
        inferDarkMode: $,
        cameraOptions: F,
        options: m,
        licenseKey: v
      });
      return A(B), () => {
        B.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [s, w, m, i, e, r, o, A, v]
  ), D.useLayoutEffect(() => {
    E && f && E.setCameraOptions(f);
  }, [E, f]);
  const R = D.useSyncExternalStore(
    D.useCallback(
      (j) => E ? (E.on("crash", j), () => E.off("crash", j)) : () => {
      },
      [E]
    ),
    () => (E == null ? void 0 : E.getCrashingError()) ?? null
  );
  D.useEffect(
    function() {
      if (!E) return;
      function $() {
        E && E.focus();
      }
      function U() {
        E && E.blur();
      }
      if (u && zN())
        return E.getContainer().addEventListener("pointerdown", $), document.body.addEventListener("pointerdown", U), () => {
          var F;
          (F = E.getContainer()) == null || F.removeEventListener("pointerdown", $), document.body.removeEventListener("pointerdown", U);
        };
    },
    [E, u]
  );
  const { Canvas: M } = xi();
  return E ? (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ y.jsx(H1, {
      fallback: S,
      onError: (j) => E.annotateError(j, { origin: "react.tldraw", willCrashApp: !0 }),
      children: R ? /* @__PURE__ */ y.jsx(Jxe, { crashingError: R }) : /* @__PURE__ */ y.jsx(M2.Provider, { value: E, children: /* @__PURE__ */ y.jsxs(Qxe, { onMount: n, children: [
        t ?? (M ? /* @__PURE__ */ y.jsx(M, {}) : null),
        /* @__PURE__ */ y.jsx(Wxe, {})
      ] }) })
    })
  ) : null;
}
function Qxe({ children: n, onMount: t }) {
  return Oxe(), sxe(), oxe(), axe(), OY((e) => {
    const r = e.store.props.onMount(e), i = t == null ? void 0 : t(e);
    return () => {
      r == null || r(), i == null || i();
    };
  }), n;
}
function Jxe({ crashingError: n }) {
  throw n;
}
function A5({ children: n }) {
  return /* @__PURE__ */ y.jsx("div", { className: "tl-loading", children: n });
}
function DY({ children: n }) {
  return /* @__PURE__ */ y.jsx("div", { className: "tl-loading", children: n });
}
function OY(n) {
  const t = we(), e = wY((r) => {
    let i;
    return r.run(
      () => {
        i = n == null ? void 0 : n(r), r.emit("mount");
      },
      { history: "ignore" }
    ), window.tldrawReady = !0, i;
  });
  Gn.useLayoutEffect(() => {
    if (t) return e == null ? void 0 : e(t);
  }, [t, e]);
}
function rS({ children: n, className: t = "", ...e }) {
  return /* @__PURE__ */ y.jsx("div", { ...e, className: Vt("tl-html-container", t), children: n });
}
class rR {
  constructor(t) {
    this.editor = t;
  }
}
T(rR, "props"), T(rR, "migrations"), /**
 * The type of the binding util, which should match the binding's type.
 *
 * @public
 */
T(rR, "type");
function k5(n, t, e = {}) {
  const { newPoint: r, handle: i, scaleX: s, scaleY: o } = t, { minWidth: l = 1, maxWidth: u = 1 / 0, minHeight: d = 1, maxHeight: f = 1 / 0 } = e;
  let m = n.props.w * s, v = n.props.h * o;
  const S = new O(0, 0);
  if (m > 0) {
    if (m < l) {
      switch (i) {
        case "top_left":
        case "left":
        case "bottom_left": {
          S.x = m - l;
          break;
        }
        case "top":
        case "bottom": {
          S.x = (m - l) / 2;
          break;
        }
        default:
          S.x = 0;
      }
      m = l;
    }
  } else if (S.x = m, m = -m, m < l) {
    switch (i) {
      case "top_left":
      case "left":
      case "bottom_left": {
        S.x = -m;
        break;
      }
      default:
        S.x = -l;
    }
    m = l;
  }
  if (v > 0) {
    if (v < d) {
      switch (i) {
        case "top_left":
        case "top":
        case "top_right": {
          S.y = v - d;
          break;
        }
        case "right":
        case "left": {
          S.y = (v - d) / 2;
          break;
        }
        default:
          S.y = 0;
      }
      v = d;
    }
  } else if (S.y = v, v = -v, v < d) {
    switch (i) {
      case "top_left":
      case "top":
      case "top_right": {
        S.y = -v;
        break;
      }
      default:
        S.y = -d;
    }
    v = d;
  }
  const { x: w, y: E } = S.rot(n.rotation).add(r);
  return {
    ...n,
    x: w,
    y: E,
    props: {
      w: Math.min(u, m),
      h: Math.min(f, v)
    }
  };
}
class gw extends ad {
  constructor() {
    super(...arguments);
    T(this, "onResize", (e, r) => k5(e, r));
  }
  getGeometry(e) {
    return new Sp({
      width: e.props.w,
      height: e.props.h,
      isFilled: !0
    });
  }
  getHandleSnapGeometry(e) {
    return {
      points: this.getGeometry(e).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(e, r, i) {
    return {
      ...r.props,
      w: Il(e.props.w, r.props.w, i),
      h: Il(e.props.h, r.props.h, i)
    };
  }
}
var wF;
let ewe = (wF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(wF, "id", "idle"), wF);
var CF;
let twe = (CF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "markId", "");
    T(this, "wasFocusedOnEnter", !1);
    T(this, "onEnter", () => {
      this.wasFocusedOnEnter = !this.editor.getIsMenuOpen();
    });
    T(this, "onPointerMove", (e) => {
      if (this.editor.inputs.isDragging) {
        const { originPagePoint: r } = this.editor.inputs, i = this.parent.shapeType, s = Ar();
        this.markId = `creating:${s}`, this.editor.mark(this.markId), this.editor.createShapes([
          {
            id: s,
            type: i,
            x: r.x,
            y: r.y,
            props: {
              w: 1,
              h: 1
            }
          }
        ]).select(s), this.editor.setCurrentTool("select.resizing", {
          ...e,
          target: "selection",
          handle: "bottom_right",
          isCreating: !0,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: this.parent.id,
          onCreate: this.parent.onCreate
        });
      }
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  complete() {
    const { originPagePoint: e } = this.editor.inputs;
    if (!this.wasFocusedOnEnter)
      return;
    this.editor.mark(this.markId);
    const r = this.parent.shapeType, i = Ar();
    this.editor.mark(this.markId), this.editor.createShapes([
      {
        id: i,
        type: r,
        x: e.x,
        y: e.y
      }
    ]);
    const s = this.editor.getShape(i);
    if (!s) {
      this.cancel();
      return;
    }
    let { w: o, h: l } = s.props;
    const u = new O(o / 2, l / 2), d = this.editor.getShapeParentTransform(s);
    d && u.rot(-d.rotation());
    let f = 1;
    this.editor.user.getIsDynamicResizeMode() && (f = 1 / this.editor.getZoomLevel(), o *= f, l *= f, u.mul(f));
    const m = ni(s);
    m.x = s.x - u.x, m.y = s.y - u.y, m.props.w = o, m.props.h = l, "scale" in s.props && (m.props.scale = f), this.editor.updateShape(m), this.editor.setSelectedShapes([i]), this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : this.editor.setCurrentTool("select.idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}, T(CF, "id", "pointing"), CF);
class iR extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onCreate");
  }
}
T(iR, "id", "box"), T(iR, "initial", "idle"), T(iR, "children", () => [ewe, twe]);
function $2(n) {
  const t = we();
  return De("isEditing", () => t.getEditingShapeId() === n, [t, n]);
}
function qd(n) {
  const t = we();
  return D.useMemo(
    function() {
      const i = (d) => {
        if (d.isKilled) return;
        if (d.button === f5) {
          t.dispatch({
            type: "pointer",
            target: "selection",
            handle: n,
            name: "right_click",
            ...Ol(d)
          });
          return;
        }
        if (d.button !== 0) return;
        const f = _M(d.currentTarget);
        function m() {
          f.removeEventListener("pointerup", m), BT(f, d);
        }
        UT(f, d), f.addEventListener("pointerup", m), t.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle: n,
          ...Ol(d)
        }), to(d);
      };
      let s, o;
      function l(d) {
        d.isKilled || d.button === 0 && (d.clientX === s && d.clientY === o || (s = d.clientX, o = d.clientY, t.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle: n,
          ...Ol(d)
        })));
      }
      return {
        onPointerDown: i,
        onPointerMove: l,
        onPointerUp: (d) => {
          d.isKilled || d.button === 0 && t.dispatch({
            name: "pointer_up",
            type: "pointer",
            target: "selection",
            handle: n,
            ...Ol(d)
          });
        }
      };
    },
    [t, n]
  );
}
function nwe(n) {
  const [t, e] = D.useState(() => ({ store: AM(n), opts: n }));
  if (!yG(t.opts, n)) {
    const r = { store: AM(n), opts: n };
    return e(r), r.store;
  }
  return t.store;
}
const rwe = 20, iwe = 8;
function I5(n, t = rwe) {
  return Math.max(iwe, Math.ceil(n / t));
}
class F0 extends Mm {
  constructor(e) {
    super({ ...e, isFilled: !1, isClosed: !1 });
    T(this, "_center");
    T(this, "radius");
    T(this, "start");
    T(this, "end");
    T(this, "largeArcFlag");
    T(this, "sweepFlag");
    T(this, "measure");
    T(this, "angleStart");
    T(this, "angleEnd");
    const { center: r, sweepFlag: i, largeArcFlag: s, start: o, end: l } = e;
    if (o.equals(l)) throw Error("Arc must have different start and end points.");
    this.angleStart = O.Angle(r, o), this.angleEnd = O.Angle(r, l), this.radius = O.Dist(r, o), this.measure = _ye(this.angleStart, this.angleEnd, i, s), this.start = o, this.end = l, this.sweepFlag = i, this.largeArcFlag = s, this._center = r;
  }
  nearestPoint(e) {
    const { _center: r, measure: i, radius: s, angleEnd: o, angleStart: l, start: u, end: d } = this, f = g3(i, l, o, r.angle(e));
    if (f <= 0) return u;
    if (f >= 1) return d;
    const m = r.clone().add(e.clone().sub(r).uni().mul(s));
    let v, S = 1 / 0, w;
    for (const E of [u, d, m])
      w = O.Dist2(e, E), w < S && (v = E, S = w);
    if (!v) throw Error("nearest point not found");
    return v;
  }
  hitTestLineSegment(e, r) {
    const { _center: i, radius: s, measure: o, angleStart: l, angleEnd: u } = this, d = WT(e, r, i, s);
    return d === null ? !1 : d.some((f) => {
      const m = g3(o, l, u, i.angle(f));
      return m >= 0 && m <= 1;
    });
  }
  getVertices() {
    const { _center: e, measure: r, length: i, radius: s, angleStart: o } = this, l = [];
    for (let u = 0, d = I5(Math.abs(i)); u < d + 1; u++) {
      const f = u / d * r, m = o + f;
      l.push(nS(e, s, m));
    }
    return l;
  }
  getSvgPathData(e = !0) {
    const { start: r, end: i, radius: s, largeArcFlag: o, sweepFlag: l } = this;
    return `${e ? `M${r.toFixed()}` : ""} A${s} ${s} 0 ${o} ${l} ${i.toFixed()}`;
  }
  getLength() {
    return this.measure * this.radius;
  }
}
class R5 extends Mm {
  constructor(e) {
    super({ isClosed: !0, ...e });
    T(this, "_center");
    T(this, "radius");
    T(this, "x");
    T(this, "y");
    this.config = e;
    const { x: r = 0, y: i = 0, radius: s } = e;
    this.x = r, this.y = i, this._center = new O(s + r, s + i), this.radius = s;
  }
  getBounds() {
    return new vt(this.x, this.y, this.radius * 2, this.radius * 2);
  }
  getVertices() {
    const { _center: e, radius: r } = this, i = wr * r, s = [];
    for (let o = 0, l = I5(i); o < l; o++) {
      const u = o / l * wr;
      s.push(nS(e, r, u));
    }
    return s;
  }
  nearestPoint(e) {
    const { _center: r, radius: i } = this;
    return r.equals(e) ? O.AddXY(r, i, 0) : r.clone().add(e.clone().sub(r).uni().mul(i));
  }
  hitTestLineSegment(e, r, i = 0) {
    const { _center: s, radius: o } = this;
    return WT(e, r, s, o + i) !== null;
  }
  getSvgPathData() {
    const { _center: e, radius: r } = this;
    return `M${e.x + r},${e.y} a${r},${r} 0 1,0 ${r * 2},0a${r},${r} 0 1,0 -${r * 2},0`;
  }
}
class ha extends pw {
  constructor(e) {
    const { start: r, cp1: i, cp2: s, end: o } = e;
    super({ ...e, points: [r, o] });
    T(this, "a");
    T(this, "b");
    T(this, "c");
    T(this, "d");
    this.a = r, this.b = i, this.c = s, this.d = o;
  }
  getVertices() {
    const e = [], { a: r, b: i, c: s, d: o } = this;
    for (let l = 0, u = 10; l <= u; l++) {
      const d = l / u;
      e.push(
        new O(
          (1 - d) * (1 - d) * (1 - d) * r.x + 3 * ((1 - d) * (1 - d)) * d * i.x + 3 * (1 - d) * (d * d) * s.x + d * d * d * o.x,
          (1 - d) * (1 - d) * (1 - d) * r.y + 3 * ((1 - d) * (1 - d)) * d * i.y + 3 * (1 - d) * (d * d) * s.y + d * d * d * o.y
        )
      );
    }
    return e;
  }
  midPoint() {
    return ha.GetAtT(this, 0.5);
  }
  nearestPoint(e) {
    let r, i = 1 / 0, s, o;
    for (const l of this.segments)
      o = l.nearestPoint(e), s = O.Dist2(o, e), s < i && (r = o, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  getSvgPathData(e = !0) {
    const { a: r, b: i, c: s, d: o } = this;
    return `${e ? `M ${r.toFixed()} ` : ""} C${i.toFixed()} ${s.toFixed()} ${o.toFixed()}`;
  }
  static GetAtT(e, r) {
    const { a: i, b: s, c: o, d: l } = e;
    return new O(
      (1 - r) * (1 - r) * (1 - r) * i.x + 3 * ((1 - r) * (1 - r)) * r * s.x + 3 * (1 - r) * (r * r) * o.x + r * r * r * l.x,
      (1 - r) * (1 - r) * (1 - r) * i.y + 3 * ((1 - r) * (1 - r)) * r * s.y + 3 * (1 - r) * (r * r) * o.y + r * r * r * l.y
    );
  }
  getLength(e = 32) {
    let r, i = this.a, s = 0;
    for (let o = 1; o <= e; o++)
      r = ha.GetAtT(this, o / e), s += O.Dist(i, r), i = r;
    return s;
  }
}
class swe extends Mm {
  constructor(e) {
    super({ ...e, isClosed: !1, isFilled: !1 });
    T(this, "points");
    T(this, "_segments");
    const { points: r } = e;
    this.points = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { points: e } = this, r = e.length, i = r - 2, s = 1.25;
      for (let o = 0; o < r - 1; o++) {
        const l = o === 0 ? e[0] : e[o - 1], u = e[o], d = e[o + 1], f = o === i ? d : e[o + 2], m = u, v = o === 0 ? l : new O(u.x + (d.x - l.x) / 6 * s, u.y + (d.y - l.y) / 6 * s), S = o === i ? d : new O(d.x - (f.x - u.x) / 6 * s, d.y - (f.y - u.y) / 6 * s), w = d;
        this._segments.push(new ha({ start: m, cp1: v, cp2: S, end: w }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((e, r) => e + r.length, 0);
  }
  getVertices() {
    const e = this.segments.reduce((r, i) => r.concat(i.vertices), []);
    return e.push(this.points[this.points.length - 1]), e;
  }
  nearestPoint(e) {
    let r, i = 1 / 0, s, o;
    for (const l of this.segments)
      o = l.nearestPoint(e), s = O.Dist2(o, e), s < i && (r = o, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(e, r) {
    return this.segments.some((i) => i.hitTestLineSegment(e, r));
  }
  getSvgPathData() {
    let e = this.segments.reduce((r, i, s) => r + i.getSvgPathData(s === 0), "");
    return this.isClosed && (e += "Z"), e;
  }
}
class owe extends Mm {
  constructor(e) {
    super({ ...e, isClosed: !0 });
    T(this, "w");
    T(this, "h");
    T(this, "_edges");
    this.config = e;
    const { width: r, height: i } = e;
    this.w = r, this.h = i;
  }
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices: e } = this;
      this._edges = [];
      for (let r = 0, i = e.length; r < i; r++) {
        const s = e[r], o = e[(r + 1) % i];
        this._edges.push(new ap({ start: s, end: o }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const e = Math.max(1, this.w), r = Math.max(1, this.h), i = e / 2, s = r / 2, o = Math.pow(i - s, 2) / Math.pow(i + s, 2), l = cr * (i + s) * (1 + 3 * o / (10 + Math.sqrt(4 - 3 * o))), u = I5(l), d = wr / u, f = Math.cos(d), m = Math.sin(d);
    let v = 0, S = 1, w = 0, E = 1;
    const A = Array(u);
    for (let P = 0; P < u; P++)
      A[P] = new O(i + i * S, s + s * v), w = m * S + f * v, E = f * S - m * v, v = w, S = E;
    return A;
  }
  nearestPoint(e) {
    let r, i = 1 / 0, s, o;
    for (const l of this.edges)
      o = l.nearestPoint(e), s = O.Dist2(o, e), s < i && (r = o, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(e, r) {
    return this.edges.some((i) => i.hitTestLineSegment(e, r));
  }
  getBounds() {
    return new vt(0, 0, this.w, this.h);
  }
  getLength() {
    const { w: e, h: r } = this, i = e / 2, s = r / 2, o = Math.max(0, i), l = Math.max(0, s);
    return EK(o, l);
  }
  getSvgPathData(e = !1) {
    const { w: r, h: i } = this, s = r / 2, o = i / 2, l = Math.max(0, s), u = Math.max(0, o);
    return `${e ? `M${s - l},${o}` : ""} a${l},${u},0,1,1,${l * 2},0a${l},${u},0,1,1,-${l * 2},0`;
  }
}
class awe extends Mm {
  constructor(e) {
    super({ ...e, isClosed: !0 });
    T(this, "w");
    T(this, "h");
    T(this, "a");
    T(this, "b");
    T(this, "c");
    T(this, "d");
    this.config = e;
    const { width: r, height: i } = e;
    if (this.w = r, this.h = i, i > r) {
      const s = r / 2;
      this.a = new F0({
        start: new O(0, s),
        end: new O(r, s),
        center: new O(r / 2, s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.b = new ap({ start: new O(r, s), end: new O(r, i - s) }), this.c = new F0({
        start: new O(r, i - s),
        end: new O(0, i - s),
        center: new O(r / 2, i - s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.d = new ap({ start: new O(0, i - s), end: new O(0, s) });
    } else {
      const s = i / 2;
      this.a = new F0({
        start: new O(s, i),
        end: new O(s, 0),
        center: new O(s, s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.b = new ap({ start: new O(s, 0), end: new O(r - s, 0) }), this.c = new F0({
        start: new O(r - s, 0),
        end: new O(r - s, i),
        center: new O(r - s, s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.d = new ap({ start: new O(r - s, i), end: new O(s, i) });
    }
  }
  nearestPoint(e) {
    let r, i = 1 / 0, s, o;
    const { a: l, b: u, c: d, d: f } = this;
    for (const m of [l, u, d, f])
      o = m.nearestPoint(e), s = O.Dist2(o, e), s < i && (r = o, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(e, r) {
    const { a: i, b: s, c: o, d: l } = this;
    return [i, s, o, l].some((u) => u.hitTestLineSegment(e, r));
  }
  getVertices() {
    const { a: e, b: r, c: i, d: s } = this;
    return [e, r, i, s].reduce((o, l) => (o.push(...l.vertices), o), []);
  }
  getBounds() {
    return new vt(0, 0, this.w, this.h);
  }
  getLength() {
    const { h: e, w: r } = this;
    return e > r ? (cr * (r / 2) + (e - r)) * 2 : (cr * (e / 2) + (r - e)) * 2;
  }
  getSvgPathData() {
    const { a: e, b: r, c: i, d: s } = this;
    return [e, r, i, s].map((o, l) => o.getSvgPathData(l === 0)).join(" ") + " Z";
  }
}
async function s7({ shouldReload: n = !0 } = {}) {
  jme();
  for (const t of kM.connectedInstances)
    await t.close();
  await Promise.all(T5().map((t) => TY(t))), Lme(), n && window.location.reload();
}
typeof window < "u" && (process.env.NODE_ENV === "development" && (window.hardReset = s7), window.__tldraw__hardReset = s7);
function lwe(n, t = "_blank") {
  y5.openWindow(n, t);
}
function cwe({ children: n }) {
  const t = we();
  return De(
    "shouldDisplayHandles",
    () => {
      if (t.isInAny("select.idle", "select.pointing_handle", "select.pointing_shape"))
        return !0;
      if (t.isInAny("select.editing_shape")) {
        const r = t.getOnlySelectedShape();
        return r && t.isShapeOfType(r, "note");
      }
      return !1;
    },
    [t]
  ) ? /* @__PURE__ */ y.jsx("svg", { className: "tl-user-handles tl-overlays__item", children: n }) : null;
}
const { PI: uwe } = Math, K0 = uwe + 1e-4;
function LY(n, t = {}) {
  const { size: e = 16, smoothing: r = 0.5 } = t;
  if (n.length === 0 || e <= 0)
    return { left: [], right: [] };
  const i = n[0], s = n[n.length - 1], o = s.runningLength, l = Math.pow(e * r, 2), u = [], d = [];
  let f = n[0].vector, m = n[0].point, v = m, S = m, w = v, E = !1, A;
  for (let P = 0; P < n.length; P++) {
    A = n[P];
    const { point: R, vector: M } = n[P], j = A.vector.dpr(f), $ = (P < n.length - 1 ? n[P + 1] : n[P]).vector, U = P < n.length - 1 ? $.dpr(A.vector) : 1, F = j < 0 && !E, B = U !== null && U < 0.2;
    if (F || B) {
      if (U > -0.62 && o - A.runningLength > A.radius) {
        const X = f.clone().mul(A.radius);
        f.clone().cpr($) < 0 ? (S = O.Add(R, X), w = O.Sub(R, X)) : (S = O.Sub(R, X), w = O.Add(R, X)), u.push(S), d.push(w);
      } else {
        const X = f.clone().mul(A.radius).per(), te = O.Sub(A.input, X);
        for (let ne = 1 / 13, K = 0; K < 1; K += ne)
          S = O.RotWith(te, A.input, K0 * K), u.push(S), w = O.RotWith(te, A.input, K0 + K0 * -K), d.push(w);
      }
      m = S, v = w, B && (E = !0);
      continue;
    }
    if (E = !1, A === i || A === s) {
      const X = O.Per(M).mul(A.radius);
      u.push(O.Sub(R, X)), d.push(O.Add(R, X));
      continue;
    }
    const G = O.Lrp($, M, U).per().mul(A.radius);
    S = O.Sub(R, G), (P <= 1 || O.Dist2(m, S) > l) && (u.push(S), m = S), w = O.Add(R, G), (P <= 1 || O.Dist2(v, w) > l) && (d.push(w), v = w), f = M;
  }
  return {
    left: u,
    right: d
  };
}
function M5(n, t = {}) {
  const { size: e = 16, start: r = {}, end: i = {}, last: s = !1 } = t, { cap: o = !0 } = r, { cap: l = !0 } = i;
  if (n.length === 0 || e <= 0)
    return [];
  const u = n[0], d = n[n.length - 1], f = d.runningLength, m = r.taper === !1 ? 0 : r.taper === !0 ? Math.max(e, f) : r.taper, v = i.taper === !1 ? 0 : i.taper === !0 ? Math.max(e, f) : i.taper, { left: S, right: w } = LY(n, t), E = u.point, A = n.length > 1 ? n[n.length - 1].point : O.AddXY(u.point, 1, 1);
  if (n.length === 1 && (!(m || v) || s)) {
    const j = O.Add(
      E,
      O.Sub(E, A).uni().per().mul(-u.radius)
    ), $ = [];
    for (let U = 1 / 13, F = U; F <= 1; F += U)
      $.push(O.RotWith(j, E, K0 * 2 * F));
    return $;
  }
  const P = [];
  if (!(m || v && n.length === 1)) if (o)
    for (let j = 1 / 8, $ = j; $ <= 1; $ += j) {
      const U = O.RotWith(w[0], E, K0 * $);
      P.push(U);
    }
  else {
    const j = O.Sub(S[0], w[0]), $ = O.Mul(j, 0.5), U = O.Mul(j, 0.51);
    P.push(
      O.Sub(E, $),
      O.Sub(E, U),
      O.Add(E, U),
      O.Add(E, $)
    );
  }
  const R = [], M = d.vector.clone().per().neg();
  if (v || m && n.length === 1)
    R.push(A);
  else if (l) {
    const j = O.Add(A, O.Mul(M, d.radius));
    for (let $ = 1 / 29, U = $; U < 1; U += $)
      R.push(O.RotWith(j, A, K0 * 3 * U));
  } else
    R.push(
      O.Add(A, O.Mul(M, d.radius)),
      O.Add(A, O.Mul(M, d.radius * 0.99)),
      O.Sub(A, O.Mul(M, d.radius * 0.99)),
      O.Sub(A, O.Mul(M, d.radius))
    );
  return S.concat(R, w.reverse(), P);
}
const dwe = 0.025, hwe = 0.01;
function kh(n, t = {}) {
  var A;
  const { streamline: e = 0.5, size: r = 16, simulatePressure: i = !1 } = t;
  if (n.length === 0) return [];
  const s = 0.15 + (1 - e) * 0.85;
  let o = n.map(O.From), l = 0;
  if (!i) {
    let P = o[0];
    for (; P && !(P.z >= dwe); )
      o.shift(), P = o[0];
  }
  if (!i) {
    let P = o[o.length - 1];
    for (; P && !(P.z >= hwe); )
      o.pop(), P = o[o.length - 1];
  }
  if (o.length === 0)
    return [
      {
        point: O.From(n[0]),
        input: O.From(n[0]),
        pressure: i ? 0.5 : 0.15,
        vector: new O(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let u = o[1];
  for (; u && !(O.Dist2(u, o[0]) > (r / 3) ** 2); )
    o[0].z = Math.max(o[0].z, u.z), o.splice(1, 1), u = o[1];
  const d = o.pop();
  for (u = o[o.length - 1]; u && !(O.Dist2(u, d) > (r / 3) ** 2); )
    o.pop(), u = o[o.length - 1], l++;
  o.push(d);
  const f = t.last || !t.simulatePressure || o.length > 1 && O.Dist2(o[o.length - 1], o[o.length - 2]) < r ** 2 || l > 0;
  if (o.length === 2 && t.simulatePressure) {
    const P = o[1];
    o = o.slice(0, -1);
    for (let R = 1; R < 5; R++) {
      const M = O.Lrp(o[0], P, R / 4);
      M.z = (o[0].z + (P.z - o[0].z)) * R / 4, o.push(M);
    }
  }
  const m = [
    {
      point: o[0],
      input: o[0],
      pressure: i ? 0.5 : o[0].z,
      vector: new O(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let v = 0, S = m[0], w, E;
  f && e > 0 && o.push(o[o.length - 1].clone());
  for (let P = 1, R = o.length; P < R; P++)
    w = !s || t.last && P === R - 1 ? o[P].clone() : o[P].clone().lrp(S.point, 1 - s), !S.point.equals(w) && (E = O.Dist(w, S.point), v += E, !(P < 4 && v < r) && (S = {
      input: o[P],
      // The adjusted point
      point: w,
      // The input pressure (or .5 if not specified)
      pressure: i ? 0.5 : o[P].z,
      // The vector from the current point to the previous point
      vector: O.Sub(S.point, w).uni(),
      // The distance between the current point and the previous point
      distance: E,
      // The total distance so far
      runningLength: v,
      // The stroke point's radius
      radius: 1
    }, m.push(S)));
  if ((A = m[1]) != null && A.vector && (m[0].vector = m[1].vector.clone()), v < 1) {
    const P = Math.max(0.5, ...m.map((R) => R.pressure));
    m.forEach((R) => R.pressure = P);
  }
  return m;
}
const { min: jg } = Math, UN = 0.275;
function z2(n, t) {
  const {
    size: e = 16,
    thinning: r = 0.5,
    simulatePressure: i = !0,
    easing: s = (A) => A,
    start: o = {},
    end: l = {}
  } = t, { easing: u = Js.easeOutQuad } = o, { easing: d = Js.easeOutCubic } = l, f = n[n.length - 1].runningLength;
  let m, v = n[0].pressure, S;
  if (!i && f < e) {
    const A = n.reduce((P, R) => Math.max(P, R.pressure), 0.5);
    return n.forEach((P) => {
      P.pressure = A, P.radius = e * s(0.5 - r * (0.5 - P.pressure));
    }), n;
  } else {
    let A;
    for (let P = 0, R = n.length; P < R && (S = n[P], !(S.runningLength > e * 5)); P++) {
      const M = jg(1, S.distance / e);
      if (i) {
        const j = jg(1, 1 - M);
        A = jg(1, v + (j - v) * (M * UN));
      } else
        A = jg(1, v + (S.pressure - v) * 0.5);
      v = v + (A - v) * 0.5;
    }
    for (let P = 0; P < n.length; P++) {
      if (S = n[P], r) {
        let { pressure: R } = S;
        const M = jg(1, S.distance / e);
        if (i) {
          const j = jg(1, 1 - M);
          R = jg(1, v + (j - v) * (M * UN));
        } else
          R = jg(
            1,
            v + (R - v) * (M * UN)
          );
        S.radius = e * s(0.5 - r * (0.5 - R)), v = R;
      } else
        S.radius = e / 2;
      m === void 0 && (m = S.radius);
    }
  }
  const w = o.taper === !1 ? 0 : o.taper === !0 ? Math.max(e, f) : o.taper, E = l.taper === !1 ? 0 : l.taper === !0 ? Math.max(e, f) : l.taper;
  if (w || E)
    for (let A = 0; A < n.length; A++) {
      S = n[A];
      const { runningLength: P } = S, R = P < w ? u(P / w) : 1, M = f - P < E ? d((f - P) / E) : 1;
      S.radius = Math.max(0.01, S.radius * Math.min(R, M));
    }
  return n;
}
function fwe(n, t = {}) {
  return M5(
    z2(kh(n, t), t),
    t
  );
}
function o7({ scribble: n, zoom: t, color: e, opacity: r, className: i }) {
  if (!n.points.length) return null;
  const s = fwe(n.points, {
    size: n.size / t,
    start: { taper: n.taper, easing: Js.linear },
    last: n.state === "stopping",
    simulatePressure: !1,
    streamline: 0.32
  });
  let o;
  if (s.length < 4) {
    const l = n.size / t / 2, { x: u, y: d } = n.points[n.points.length - 1];
    o = `M ${u - l},${d} a ${l},${l} 0 1,0 ${l * 2},0 a ${l},${l} 0 1,0 ${-l * 2},0`;
  } else
    o = m5(s);
  return /* @__PURE__ */ y.jsx("svg", { className: i && Vt("tl-overlays__item", i), children: /* @__PURE__ */ y.jsx(
    "path",
    {
      className: "tl-scribble",
      d: o,
      fill: e ?? `var(--color-${n.color})`,
      opacity: r ?? n.opacity
    }
  ) });
}
const pwe = ({ bounds: n, rotation: t }) => {
  const e = we();
  return De(
    "should display",
    () => e.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.pointing_shape",
      "select.pointing_selection",
      "text.resizing"
    ),
    [e]
  ) ? /* @__PURE__ */ y.jsx(VK, { bounds: n, rotation: t }) : null;
};
function Ap() {
  const n = we();
  return De("isReadonlyMode", () => n.getInstanceState().isReadonly, [n]);
}
function gwe({
  size: n,
  width: t,
  height: e,
  hideAlternateHandles: r
}) {
  const i = be(n / 3), s = i / 2;
  return /* @__PURE__ */ y.jsxs("svg", { className: "tl-overlays__item", children: [
    /* @__PURE__ */ y.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${be(0 - s)},${be(n)} 
						${be(0 - s)},${be(0 - s)} 
						${be(n)},${be(0 - s)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.top_left",
        "aria-label": "top_left handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "line",
      {
        className: Vt("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: be(t / 2 - n),
        y1: be(0 - s),
        x2: be(t / 2 + n),
        y2: be(0 - s),
        strokeWidth: i,
        "data-testid": "selection.crop.top",
        "aria-label": "top handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "polyline",
      {
        className: Vt("tl-corner-crop-handle", {
          "tl-hidden": r
        }),
        points: `
						${be(t - n)},${be(0 - s)} 
						${be(t + s)},${be(0 - s)} 
						${be(t + s)},${be(n)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.top_right",
        "aria-label": "top_right handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "line",
      {
        className: Vt("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: be(t + s),
        y1: be(e / 2 - n),
        x2: be(t + s),
        y2: be(e / 2 + n),
        strokeWidth: i,
        "data-testid": "selection.crop.right",
        "aria-label": "right handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${be(t + s)},${be(e - n)} 
						${be(t + s)},${be(e + s)}
						${be(t - n)},${be(e + s)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.bottom_right",
        "aria-label": "bottom_right handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "line",
      {
        className: Vt("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: be(t / 2 - n),
        y1: be(e + s),
        x2: be(t / 2 + n),
        y2: be(e + s),
        strokeWidth: i,
        "data-testid": "selection.crop.bottom",
        "aria-label": "bottom handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "polyline",
      {
        className: Vt("tl-corner-crop-handle", {
          "tl-hidden": r
        }),
        points: `
						${be(0 + n)},${be(e + s)} 
						${be(0 - s)},${be(e + s)}
						${be(0 - s)},${be(e - n)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.bottom_left",
        "aria-label": "bottom_left handle"
      }
    ),
    /* @__PURE__ */ y.jsx(
      "line",
      {
        className: Vt("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: be(0 - s),
        y1: be(e / 2 - n),
        x2: be(0 - s),
        y2: be(e / 2 + n),
        strokeWidth: i,
        "data-testid": "selection.crop.left",
        "aria-label": "left handle"
      }
    )
  ] });
}
const mwe = ro(function({
  bounds: t,
  rotation: e
}) {
  const r = we(), i = D.useRef(null), s = Ap(), o = qd("top"), l = qd("right"), u = qd("bottom"), d = qd("left"), f = qd("top_left"), m = qd("top_right"), v = qd("bottom_right"), S = qd("bottom_left"), w = !r.getIsMenuOpen() && r.getInstanceState().cursor.type === "default", E = r.getInstanceState().isCoarsePointer, A = r.getOnlySelectedShape(), P = A && r.isShapeOrAncestorLocked(A), R = A ? r.getShapeUtil(A).expandSelectionOutlinePx(A) : 0;
  if (fw(i, t == null ? void 0 : t.x, t == null ? void 0 : t.y, 1, r.getSelectionRotation(), {
    x: -R,
    y: -R
  }), !t) return null;
  t = t.clone().expandBy(R).zeroFix();
  const M = r.getZoomLevel(), j = r.getInstanceState().isChangingStyle, $ = t.width, U = t.height, F = 8 / M, B = $ < F * 2, G = U < F * 2, X = $ < F * 4, te = U < F * 4, ne = $ < F * 5, K = U < F * 5, Z = E ? 1.75 : 1, oe = 6 / M * Z, fe = (X ? oe / 2 : oe) * (Z * 0.75), ie = (te ? oe / 2 : oe) * (Z * 0.75), ue = (A ? !r.getShapeUtil(A).hideSelectionBoundsFg(A) : !0) && !j;
  let Se = ue && r.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || ue && r.isIn("select.resizing") && A && r.isShapeOfType(A, "text");
  A && Se && r.environment.isFirefox && r.isShapeOfType(A, "embed") && (Se = !1);
  const ke = r.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !j && !s, ce = r.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !j && !s, ye = !E && !(B || G) && (ce || ke) && (A ? !r.getShapeUtil(A).hideRotateHandle(A) : !0) && !P, Fe = E && (!X || !te) && (ce || ke) && (A ? !r.getShapeUtil(A).hideRotateHandle(A) : !0) && !P, Xe = ce && (A ? r.getShapeUtil(A).canResize(A) && !r.getShapeUtil(A).hideResizeHandles(A) : !0) && !ke && !P, je = B || G, nt = B && G, Ze = ne || K, tt = Xe || ke, et = !ye, at = !ce || !Fe, Yt = !ce || !tt, Un = !ce || !tt || je, pt = !ce || !tt || je, Ut = !ce || !tt || nt && !ke;
  let jt = !0, $t = !0;
  if (ke)
    jt = Ze, $t = Ze;
  else if (Xe) {
    jt = je || nt || E;
    const Nr = E && A && A.type === "text";
    $t = jt && !Nr;
  }
  const yn = Math.min(24 / M, U - ie * 3), hi = ce && E && A && r.isShapeOfType(A, "text") && yn * M >= 4;
  return /* @__PURE__ */ y.jsx("svg", { className: "tl-overlays__item tl-selection__fg", "data-testid": "selection-foreground", children: /* @__PURE__ */ y.jsxs("g", { ref: i, children: [
    Se && /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: "tl-selection__fg__outline",
        width: be($),
        height: be(U)
      }
    ),
    /* @__PURE__ */ y.jsx(
      SI,
      {
        "data-testid": "selection.rotate.top-left",
        cx: 0,
        cy: 0,
        targetSize: oe,
        corner: "top_left_rotate",
        cursor: w ? nc("nwse-rotate", e) : void 0,
        isHidden: et
      }
    ),
    /* @__PURE__ */ y.jsx(
      SI,
      {
        "data-testid": "selection.rotate.top-right",
        cx: $ + oe * 3,
        cy: 0,
        targetSize: oe,
        corner: "top_right_rotate",
        cursor: w ? nc("nesw-rotate", e) : void 0,
        isHidden: et
      }
    ),
    /* @__PURE__ */ y.jsx(
      SI,
      {
        "data-testid": "selection.rotate.bottom-left",
        cx: 0,
        cy: U + oe * 3,
        targetSize: oe,
        corner: "bottom_left_rotate",
        cursor: w ? nc("swne-rotate", e) : void 0,
        isHidden: et
      }
    ),
    /* @__PURE__ */ y.jsx(
      SI,
      {
        "data-testid": "selection.rotate.bottom-right",
        cx: $ + oe * 3,
        cy: U + oe * 3,
        targetSize: oe,
        corner: "bottom_right_rotate",
        cursor: w ? nc("senw-rotate", e) : void 0,
        isHidden: et
      }
    ),
    /* @__PURE__ */ y.jsx(
      ywe,
      {
        "data-testid": "selection.rotate.mobile",
        cx: X ? -oe * 1.5 : $ / 2,
        cy: X ? U / 2 : -oe * 1.5,
        size: F,
        isHidden: at
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": jt
        }),
        "data-testid": "selection.resize.top",
        "aria-label": "top target",
        pointerEvents: "all",
        x: 0,
        y: be(0 - (te ? ie * 2 : ie)),
        width: be($),
        height: be(Math.max(1, ie * 2)),
        style: w ? { cursor: nc("ns-resize", e) } : void 0,
        ...o
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": $t
        }),
        "data-testid": "selection.resize.right",
        "aria-label": "right target",
        pointerEvents: "all",
        x: be($ - (X ? 0 : fe)),
        y: 0,
        height: be(U),
        width: be(Math.max(1, fe * 2)),
        style: w ? { cursor: nc("ew-resize", e) } : void 0,
        ...l
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": jt
        }),
        "data-testid": "selection.resize.bottom",
        "aria-label": "bottom target",
        pointerEvents: "all",
        x: 0,
        y: be(U - (te ? 0 : ie)),
        width: be($),
        height: be(Math.max(1, ie * 2)),
        style: w ? { cursor: nc("ns-resize", e) } : void 0,
        ...u
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": $t
        }),
        "data-testid": "selection.resize.left",
        "aria-label": "left target",
        pointerEvents: "all",
        x: be(0 - (X ? fe * 2 : fe)),
        y: 0,
        height: be(U),
        width: be(Math.max(1, fe * 2)),
        style: w ? { cursor: nc("ew-resize", e) } : void 0,
        ...d
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": Yt
        }),
        "data-testid": "selection.target.top-left",
        "aria-label": "top-left target",
        pointerEvents: "all",
        x: be(0 - (X ? fe * 2 : fe * 1.5)),
        y: be(0 - (te ? ie * 2 : ie * 1.5)),
        width: be(fe * 3),
        height: be(ie * 3),
        style: w ? { cursor: nc("nwse-resize", e) } : void 0,
        ...f
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": Un
        }),
        "data-testid": "selection.target.top-right",
        "aria-label": "top-right target",
        pointerEvents: "all",
        x: be($ - (X ? 0 : fe * 1.5)),
        y: be(0 - (te ? ie * 2 : ie * 1.5)),
        width: be(fe * 3),
        height: be(ie * 3),
        style: w ? { cursor: nc("nesw-resize", e) } : void 0,
        ...m
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": Ut
        }),
        "data-testid": "selection.target.bottom-right",
        "aria-label": "bottom-right target",
        pointerEvents: "all",
        x: be($ - (X ? fe : fe * 1.5)),
        y: be(U - (te ? ie : ie * 1.5)),
        width: be(fe * 3),
        height: be(ie * 3),
        style: w ? { cursor: nc("nwse-resize", e) } : void 0,
        ...v
      }
    ),
    /* @__PURE__ */ y.jsx(
      "rect",
      {
        className: Vt("tl-transparent", {
          "tl-hidden": pt
        }),
        "data-testid": "selection.target.bottom-left",
        "aria-label": "bottom-left target",
        pointerEvents: "all",
        x: be(0 - (X ? fe * 3 : fe * 1.5)),
        y: be(U - (te ? 0 : ie * 1.5)),
        width: be(fe * 3),
        height: be(ie * 3),
        style: w ? { cursor: nc("nesw-resize", e) } : void 0,
        ...S
      }
    ),
    Xe && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          "data-testid": "selection.resize.top-left",
          className: Vt("tl-corner-handle", {
            "tl-hidden": Yt
          }),
          "aria-label": "top_left handle",
          x: be(0 - F / 2),
          y: be(0 - F / 2),
          width: be(F),
          height: be(F)
        }
      ),
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          "data-testid": "selection.resize.top-right",
          className: Vt("tl-corner-handle", {
            "tl-hidden": Un
          }),
          "aria-label": "top_right handle",
          x: be($ - F / 2),
          y: be(0 - F / 2),
          width: be(F),
          height: be(F)
        }
      ),
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          "data-testid": "selection.resize.bottom-right",
          className: Vt("tl-corner-handle", {
            "tl-hidden": Ut
          }),
          "aria-label": "bottom_right handle",
          x: be($ - F / 2),
          y: be(U - F / 2),
          width: be(F),
          height: be(F)
        }
      ),
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          "data-testid": "selection.resize.bottom-left",
          className: Vt("tl-corner-handle", {
            "tl-hidden": pt
          }),
          "aria-label": "bottom_left handle",
          x: be(0 - F / 2),
          y: be(U - F / 2),
          width: be(F),
          height: be(F)
        }
      )
    ] }),
    hi && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          "data-testid": "selection.text-resize.left.handle",
          className: "tl-text-handle",
          "aria-label": "bottom_left handle",
          x: be(0 - F / 4),
          y: be(U / 2 - yn / 2),
          rx: F / 4,
          width: be(F / 2),
          height: be(yn)
        }
      ),
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          "data-testid": "selection.text-resize.right.handle",
          className: "tl-text-handle",
          "aria-label": "bottom_left handle",
          rx: F / 4,
          x: be($ - F / 4),
          y: be(U / 2 - yn / 2),
          width: be(F / 2),
          height: be(yn)
        }
      )
    ] }),
    ke && /* @__PURE__ */ y.jsx(
      gwe,
      {
        size: F,
        width: $,
        height: U,
        hideAlternateHandles: Ze
      }
    )
  ] }) });
}), SI = function({
  cx: t,
  cy: e,
  targetSize: r,
  corner: i,
  cursor: s,
  isHidden: o,
  "data-testid": l
}) {
  const u = qd(i);
  return /* @__PURE__ */ y.jsx(
    "rect",
    {
      className: Vt("tl-transparent", "tl-rotate-corner", { "tl-hidden": o }),
      "data-testid": l,
      "aria-label": `${i} target`,
      pointerEvents: "all",
      x: be(t - r * 3),
      y: be(e - r * 3),
      width: be(Math.max(1, r * 3)),
      height: be(Math.max(1, r * 3)),
      cursor: s,
      ...u
    }
  );
}, vwe = Math.sqrt(Math.PI), ywe = function({
  cx: t,
  cy: e,
  size: r,
  isHidden: i,
  "data-testid": s
}) {
  const o = qd("mobile_rotate"), l = we(), u = De("zoom level", () => l.getZoomLevel(), [l]), d = Math.max(14 * (1 / u), 20 / Math.max(1, u));
  return /* @__PURE__ */ y.jsxs("g", { children: [
    /* @__PURE__ */ y.jsx(
      "circle",
      {
        "data-testid": s,
        pointerEvents: "all",
        className: Vt("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": i }),
        cx: t,
        cy: e,
        r: d,
        ...o
      }
    ),
    /* @__PURE__ */ y.jsx(
      "circle",
      {
        className: Vt("tl-mobile-rotate__fg", { "tl-hidden": i }),
        cx: t,
        cy: e,
        r: r / vwe
      }
    )
  ] });
};
function Swe() {
  const n = we();
  return De(
    "is in a valid select state",
    () => n.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.editing_shape",
      "select.pointing_shape",
      "select.pointing_selection",
      "select.pointing_handle"
    ),
    [n]
  ) ? /* @__PURE__ */ y.jsx(WK, {}) : null;
}
function T3(n, t, e) {
  const { arrowheadStart: r, arrowheadEnd: i } = t.props, s = $0(n, t, e), o = s.start.clone(), l = s.end.clone(), u = O.Med(o, l);
  if (O.Equals(o, l))
    return {
      bindings: e,
      isStraight: !0,
      start: {
        handle: o,
        point: o,
        arrowhead: t.props.arrowheadStart
      },
      end: {
        handle: l,
        point: l,
        arrowhead: t.props.arrowheadEnd
      },
      middle: u,
      isValid: !1,
      length: 0
    };
  const d = O.Sub(l, o).uni(), f = IM(n, t, "start"), m = IM(n, t, "end"), v = n.getShapePageTransform(t);
  a7(
    l,
    // <-- will be mutated
    s.start,
    v,
    m
  ), a7(
    o,
    // <-- will be mutated
    s.end,
    v,
    f
  );
  let S = 0, w = 0, E = 0, A = 0, P = z0 * t.props.scale;
  const R = f && m && f.shape === m.shape, M = f && m ? D5(n, f.shape.id, m.shape.id) : "safe";
  M === "safe" && f && m && !R && !f.isExact && !m.isExact && (m.didIntersect && !f.didIntersect ? f.isClosed && o.setTo(l.clone().add(d.clone().mul(z0 * t.props.scale))) : m.didIntersect || m.isClosed && l.setTo(o.clone().sub(d.clone().mul(z0 * t.props.scale))));
  const j = O.Sub(l, o), $ = O.Len(j) ? j.uni() : O.From(j), U = !O.Equals($, d);
  R || (M !== "start-contains-end" && f && r !== "none" && !f.isExact && (E = fm[t.props.size] / 2 + ("size" in f.shape.props ? fm[f.shape.props.size] / 2 : 0), S = (RM + E) * t.props.scale, P += E * t.props.scale), M !== "end-contains-start" && m && i !== "none" && !m.isExact && (A = fm[t.props.size] / 2 + ("size" in m.shape.props ? fm[m.shape.props.size] / 2 : 0), w = (RM + A) * t.props.scale, P += A * t.props.scale));
  const F = o.clone().add($.clone().mul(S * (U ? -1 : 1))), B = l.clone().sub($.clone().mul(w * (U ? -1 : 1)));
  O.DistMin(F, B, P) && (S !== 0 && w !== 0 ? (S *= -1.5, w *= -1.5) : S !== 0 ? S *= -1 : w !== 0 && (w *= -1)), o.add($.clone().mul(S * (U ? -1 : 1))), l.sub($.clone().mul(w * (U ? -1 : 1))), U ? (f && m && l.setTo(O.Add(o, $.clone().mul(-z0 * t.props.scale))), u.setTo(O.Med(s.start, s.end))) : u.setTo(O.Med(o, l));
  const G = O.Dist(o, l);
  return {
    bindings: e,
    isStraight: !0,
    start: {
      handle: s.start,
      point: o,
      arrowhead: t.props.arrowheadStart
    },
    end: {
      handle: s.end,
      point: l,
      arrowhead: t.props.arrowheadEnd
    },
    middle: u,
    isValid: G > 0,
    length: G
  };
}
function a7(n, t, e, r) {
  if (r === void 0 || r.isExact)
    return;
  const i = At.applyToPoint(e, t), s = At.applyToPoint(e, n), o = At.applyToPoint(At.Inverse(r.transform), i), l = At.applyToPoint(At.Inverse(r.transform), s), u = r.isClosed, f = (u ? x5 : r0e)(o, l, r.outline);
  let m;
  if (f !== null && (m = f.sort((w, E) => O.Dist2(w, o) - O.Dist2(E, o))[0] ?? (u ? void 0 : l)), m === void 0)
    return;
  const v = At.applyToPoint(r.transform, m), S = At.applyToPoint(At.Inverse(e), v);
  n.setTo(S), r.didIntersect = !0;
}
function bwe(n, t, e) {
  const { arrowheadEnd: r, arrowheadStart: i } = t.props, s = t.props.bend;
  if (Math.abs(s) > Math.abs(t.props.bend * (_we * t.props.scale)))
    return T3(n, t, e);
  const o = $0(n, t, e), l = O.Med(o.start, o.end), u = O.Sub(o.end, o.start), d = O.Len(u) ? u.uni() : O.From(u), f = O.Add(l, d.per().mul(-s)), m = IM(n, t, "start"), v = IM(n, t, "end"), S = o.start.clone(), w = o.end.clone(), E = f.clone();
  if (O.Equals(S, w))
    return {
      bindings: e,
      isStraight: !0,
      start: {
        handle: S,
        point: S,
        arrowhead: t.props.arrowheadStart
      },
      end: {
        handle: w,
        point: w,
        arrowhead: t.props.arrowheadEnd
      },
      middle: E,
      isValid: !1,
      length: 0
    };
  const A = t.props.bend < 0, P = A ? zT : _K, R = l7(S, w, E), M = O.Angle(R.center, S), j = O.Angle(R.center, w), $ = P(M, j);
  if (R.length === 0 || R.size === 0 || !g9(R.length) || !g9(R.size))
    return T3(n, t, e);
  const U = S.clone(), F = w.clone(), B = E.clone(), G = n.getShapePageTransform(t);
  let X = 0, te = 0, ne = z0 * t.props.scale;
  if (m && !m.isExact) {
    const ke = At.applyToPoint(G, U), ce = At.applyToPoint(G, R.center), ye = At.applyToPoint(G, F), Fe = At.Inverse(m.transform), Xe = At.applyToPoint(Fe, ke), je = At.applyToPoint(Fe, ce), nt = At.applyToPoint(Fe, ye), { isClosed: Ze } = m, tt = Ze ? x3 : H9;
    let et, at = tt(je, R.radius, m.outline);
    if (at) {
      const Yt = je.angle(Xe), Un = je.angle(nt), pt = P(Yt, Un);
      at = at.filter(
        (jt) => P(Yt, je.angle(jt)) <= pt
      );
      const Ut = pt * 0.25;
      at.sort(
        Ze ? (jt, $t) => Math.abs(P(Yt, je.angle(jt)) - Ut) < Math.abs(P(Yt, je.angle($t)) - Ut) ? -1 : 1 : (jt, $t) => P(Yt, je.angle(jt)) < P(Yt, je.angle($t)) ? -1 : 1
      ), et = at[0] ?? (Ze ? void 0 : Xe);
    } else
      et = Ze ? void 0 : Xe;
    if (et && (U.setTo(
      n.getPointInShapeSpace(t, At.applyToPoint(m.transform, et))
    ), m.didIntersect = !0, i !== "none")) {
      const Yt = fm[t.props.size] / 2 + ("size" in m.shape.props ? fm[m.shape.props.size] / 2 : 0);
      X = (RM + Yt) * t.props.scale, ne += Yt * t.props.scale;
    }
  }
  if (v && !v.isExact) {
    const ke = At.applyToPoint(G, U), ce = At.applyToPoint(G, F), ye = At.applyToPoint(G, R.center), Fe = At.Inverse(v.transform), Xe = At.applyToPoint(Fe, ke), je = At.applyToPoint(Fe, ye), nt = At.applyToPoint(Fe, ce), Ze = v.isClosed, tt = Ze ? x3 : H9;
    let et, at = tt(je, R.radius, v.outline);
    if (at) {
      const Yt = je.angle(Xe), Un = je.angle(nt), pt = P(Yt, Un), Ut = pt * 0.75;
      at = at.filter(
        (jt) => P(Yt, je.angle(jt)) <= pt
      ), at.sort(
        Ze ? (jt, $t) => Math.abs(P(Yt, je.angle(jt)) - Ut) < Math.abs(P(Yt, je.angle($t)) - Ut) ? -1 : 1 : (jt, $t) => P(Yt, je.angle(jt)) < P(Yt, je.angle($t)) ? -1 : 1
      ), at[0] ? et = at[0] : et = Ze ? void 0 : nt;
    } else
      et = Ze ? void 0 : nt;
    if (et && (F.setTo(
      n.getPointInShapeSpace(t, At.applyToPoint(v.transform, et))
    ), v.didIntersect = !0, r !== "none")) {
      const Yt = fm[t.props.size] / 2 + ("size" in v.shape.props ? fm[v.shape.props.size] / 2 : 0);
      te = (RM + Yt) * t.props.scale, ne += Yt * t.props.scale;
    }
  }
  let K = O.Angle(R.center, U), Z = O.Angle(R.center, F), oe = P(K, Z), fe = oe * R.radius;
  const ie = U.clone(), ue = F.clone();
  if (X !== 0 && ie.setTo(R.center).add(
    O.FromAngle(K + oe * (X / fe * (A ? 1 : -1))).mul(R.radius)
  ), te !== 0 && ue.setTo(R.center).add(
    O.FromAngle(Z + oe * (te / fe * (A ? -1 : 1))).mul(R.radius)
  ), O.DistMin(ie, ue, ne) && (X !== 0 && te !== 0 ? (X *= -1.5, te *= -1.5) : X !== 0 ? X *= -2 : te !== 0 && (te *= -2)), X !== 0 && U.setTo(R.center).add(
    O.FromAngle(K + oe * (X / fe * (A ? 1 : -1))).mul(R.radius)
  ), te !== 0 && F.setTo(R.center).add(
    O.FromAngle(Z + oe * (te / fe * (A ? -1 : 1))).mul(R.radius)
  ), m && v && !m.isExact && !v.isExact) {
    K = O.Angle(R.center, U), Z = O.Angle(R.center, F), oe = P(K, Z), fe = oe * R.radius;
    const ke = D5(
      n,
      m.shape.id,
      v.shape.id
    );
    ke === "double-bound" && fe < 30 ? (U.setTo(S), F.setTo(w), B.setTo(E)) : ke === "safe" && (m && !m.didIntersect && U.setTo(S), (v && !v.didIntersect || P(M, K) > P(M, Z)) && F.setTo(R.center).add(
      O.FromAngle(
        K + oe * (Math.min(0.9, z0 * t.props.scale / fe) * (A ? 1 : -1))
      ).mul(R.radius)
    ));
  }
  xwe(
    R.center,
    R.radius,
    U,
    F,
    B,
    $,
    A
  ), U.equals(F) && (U.setTo(B.clone().addXY(1, 1)), F.setTo(B.clone().subXY(1, 1))), S.setTo(U), w.setTo(F), E.setTo(B);
  const Se = l7(S, w, E);
  return {
    bindings: e,
    isStraight: !1,
    start: {
      point: S,
      handle: o.start,
      arrowhead: t.props.arrowheadStart
    },
    end: {
      point: w,
      handle: o.end,
      arrowhead: t.props.arrowheadEnd
    },
    middle: E,
    handleArc: R,
    bodyArc: Se,
    isValid: Se.length !== 0 && isFinite(Se.center.x) && isFinite(Se.center.y)
  };
}
function l7(n, t, e) {
  const r = h5(n, t, e), i = O.Dist(r, n), s = +O.Clockwise(n, e, t), o = ((n.y - t.y) ** 2 + (n.x - t.x) ** 2) ** 0.5, l = ((t.y - e.y) ** 2 + (t.x - e.x) ** 2) ** 0.5, u = ((e.y - n.y) ** 2 + (e.x - n.x) ** 2) ** 0.5, d = Math.acos((l * l + u * u - o * o) / (2 * l * u)) * 2, f = +(cr > d), m = (wr - d) * (s ? 1 : -1), v = m * i;
  return {
    center: r,
    radius: i,
    size: m,
    length: v,
    largeArcFlag: f,
    sweepFlag: s
  };
}
function xwe(n, t, e, r, i, s, o) {
  const l = O.Angle(n, e), u = O.Angle(n, r);
  let d = zT(l, u);
  if (o || (d = wr - d), i.setTo(n).add(O.FromAngle(l + d * (0.5 * (o ? 1 : -1))).mul(t)), d > s) {
    i.rotWith(n, cr);
    const f = r.clone();
    r.setTo(e), e.setTo(f);
  }
}
const wwe = 8;
function Cwe(n) {
  return Math.abs(n.props.bend) < wwe * n.props.scale;
}
function IM(n, t, e) {
  const r = n.getBindingsFromShape(t, "arrow").find((u) => u.props.terminal === e);
  if (!r) return;
  const i = n.getShape(r.toId);
  if (!i) return;
  const s = n.getShapePageTransform(i), o = n.getShapeGeometry(i), l = o instanceof ld ? o.children[0].vertices : o.vertices;
  return {
    shape: i,
    transform: s,
    isClosed: o.isClosed,
    isExact: r.props.isExact,
    didIntersect: !1,
    outline: l
  };
}
function c7(n, t, e, r) {
  const i = n.getShape(e.toId);
  if (i) {
    const { point: s, size: o } = n.getShapeGeometry(i).bounds, l = O.Add(
      s,
      O.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        e.props.isPrecise || r ? e.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        o
      )
    ), u = At.applyToPoint(n.getShapePageTransform(i), l);
    return At.applyToPoint(At.Inverse(t), u);
  } else
    return new O(0, 0);
}
function Ml(n, t) {
  const e = n.getBindingsFromShape(t, "arrow");
  return {
    start: e.find((r) => r.props.terminal === "start"),
    end: e.find((r) => r.props.terminal === "end")
  };
}
const Ewe = eve("arrow info", (n, t) => {
  const e = Ml(n, t);
  return Cwe(t) ? T3(n, t, e) : bwe(n, t, e);
});
function yh(n, t) {
  const e = typeof t == "string" ? t : t.id;
  return Ewe.get(n, e);
}
function $0(n, t, e) {
  var l, u;
  const r = n.getShapePageTransform(t), i = D5(
    n,
    (l = e.start) == null ? void 0 : l.toId,
    (u = e.end) == null ? void 0 : u.toId
  ), s = e.start ? c7(
    n,
    r,
    e.start,
    i === "double-bound" || i === "start-contains-end"
  ) : O.From(t.props.start), o = e.end ? c7(
    n,
    r,
    e.end,
    i === "double-bound" || i === "end-contains-start"
  ) : O.From(t.props.end);
  return { start: s, end: o };
}
function OE(n, t, e, r) {
  const i = typeof t == "string" ? t : t.id, s = typeof e == "string" ? e : e.id, o = n.getBindingsFromShape(i, "arrow").filter((u) => u.props.terminal === r.terminal);
  o.length > 1 && n.deleteBindings(o.slice(1));
  const l = o[0];
  l ? n.updateBinding({
    ...l,
    toId: s,
    props: r
  }) : n.createBinding({
    type: "arrow",
    fromId: i,
    toId: s,
    props: r
  });
}
function sR(n, t, e) {
  const r = n.getBindingsFromShape(t, "arrow").filter((i) => i.props.terminal === e);
  n.deleteBindings(r);
}
const z0 = 10, RM = 10, _we = 10, fm = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function D5(n, t, e) {
  if (!t || !e) return "safe";
  if (t === e) return "double-bound";
  const r = n.getShapePageBounds(t), i = n.getShapePageBounds(e);
  if (r && i) {
    if (r.contains(i)) return "start-contains-end";
    if (i.contains(r)) return "end-contains-start";
  }
  return "safe";
}
class oR extends rR {
  getDefaultProps() {
    return {
      isPrecise: !1,
      isExact: !1,
      normalizedAnchor: { x: 0.5, y: 0.5 }
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding: t }) {
    BN(this.editor, this.editor.getShape(t.fromId));
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter: t }) {
    BN(this.editor, this.editor.getShape(t.fromId));
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter: t
  }) {
    BN(this.editor, t);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({ binding: t }) {
    jY(this.editor, t.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding: t
  }) {
    const e = this.editor.getShape(t.fromId);
    e && MM({
      editor: this.editor,
      arrow: e,
      terminal: t.props.terminal
    });
  }
}
T(oR, "type", "arrow"), T(oR, "props", WG), T(oR, "migrations", GG);
function jY(n, t) {
  var A;
  const e = n.getShape(t);
  if (!e) return;
  const r = Ml(n, e), { start: i, end: s } = r, o = i ? n.getShape(i.toId) : void 0, l = s ? n.getShape(s.toId) : void 0, u = n.getAncestorPageId(e);
  if (!u) return;
  let d;
  if (o && l)
    d = n.findCommonAncestor([o, l]) ?? u;
  else if (o || l) {
    const P = (A = o || l) == null ? void 0 : A.parentId;
    P && P === e.parentId ? d = e.parentId : d = u;
  } else
    return;
  d && d !== e.parentId && n.reparentShapes([t], d);
  const f = n.getShape(t);
  if (!f) throw Error("no reparented arrow");
  const m = n.getShapeNearestSibling(f, o), v = n.getShapeNearestSibling(f, l);
  let S;
  if (m && v)
    S = m.index > v.index ? m : v;
  else if (m && !v)
    S = m;
  else if (v && !m)
    S = v;
  else
    return;
  let w;
  const E = n.getSortedChildIdsForParent(S.parentId).map((P) => n.getShape(P)).filter((P) => P.index > S.index);
  if (E.length) {
    const P = E.find((R) => R.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      f.index > S.index && // ...but below the next non-arrow sibling...
      (!P || f.index < P.index)
    )
      return;
    w = $1(S.index, E[0].index);
  } else
    w = id(S.index);
  w !== f.index && n.updateShapes([{ id: t, type: "arrow", index: w }]);
}
function BN(n, t) {
  const e = Ml(n, t);
  for (const r of ["start", "end"]) {
    const i = e[r];
    if (!i) continue;
    const s = n.getShape(i.toId), o = n.getAncestorPageId(t) === n.getAncestorPageId(s);
    (!s || !o) && MM({ editor: n, arrow: t, terminal: r, unbind: !0 });
  }
  jY(n, t.id);
}
function MM({
  editor: n,
  arrow: t,
  terminal: e,
  unbind: r = !1,
  useHandle: i = !1
}) {
  const s = yh(n, t);
  if (!s)
    throw new Error("expected arrow info");
  const o = i ? s.start.handle : s.start.point, l = i ? s.end.handle : s.end.point, u = e === "start" ? o : l, d = {
    id: t.id,
    type: "arrow",
    props: {
      [e]: { x: u.x, y: u.y },
      bend: t.props.bend
    }
  };
  if (!s.isStraight) {
    const f = e === "start" ? o : s.start.handle, m = e === "end" ? l : s.end.handle, v = O.Med(f, m), S = O.Sub(f, m).per().uni().mul(s.handleArc.radius * 2 * Math.sign(t.props.bend)), w = WT(
      s.handleArc.center,
      O.Add(v, S),
      s.handleArc.center,
      s.handleArc.radius
    );
    ii((w == null ? void 0 : w.length) === 1);
    const E = O.Dist(v, w[0]) * Math.sign(t.props.bend);
    vm(E, d.props.bend) || (d.props.bend = E);
  }
  n.updateShape(d), r && sR(n, t, e);
}
const NY = [oR], Oo = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
}, eo = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
}, Qx = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
}, dp = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
}, Twe = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
}, Ch = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
}, Pwe = 20, Awe = 4.25, tu = 16;
/*!
 * canvas-size
 * v1.2.6
 * https://github.com/jhildenbiddle/canvas-size
 * (c) 2015-2023 John Hildenbiddle <http://hildenbiddle.com>
 * MIT license
 */
function kwe(n, t) {
  var e = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (e != null) {
    var r, i, s, o, l = [], u = !0, d = !1;
    try {
      if (s = (e = e.call(n)).next, t === 0) {
        if (Object(e) !== e) return;
        u = !1;
      } else for (; !(u = (r = s.call(e)).done) && (l.push(r.value), l.length !== t); u = !0) ;
    } catch (f) {
      d = !0, i = f;
    } finally {
      try {
        if (!u && e.return != null && (o = e.return(), Object(o) !== o)) return;
      } finally {
        if (d) throw i;
      }
    }
    return l;
  }
}
function u7(n, t) {
  var e = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), e.push.apply(e, r);
  }
  return e;
}
function rc(n) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u7(Object(e), !0).forEach(function(r) {
      Iwe(n, r, e[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(e)) : u7(Object(e)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(e, r));
    });
  }
  return n;
}
function Iwe(n, t, e) {
  return t = $we(t), t in n ? Object.defineProperty(n, t, {
    value: e,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[t] = e, n;
}
function Rwe(n, t) {
  if (n == null) return {};
  var e = {}, r = Object.keys(n), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(t.indexOf(i) >= 0) && (e[i] = n[i]);
  return e;
}
function Mwe(n, t) {
  if (n == null) return {};
  var e = Rwe(n, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (i = 0; i < s.length; i++)
      r = s[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (e[r] = n[r]);
  }
  return e;
}
function d7(n, t) {
  return Owe(n) || kwe(n, t) || FY(n, t) || Nwe();
}
function bI(n) {
  return Dwe(n) || Lwe(n) || FY(n) || jwe();
}
function Dwe(n) {
  if (Array.isArray(n)) return P3(n);
}
function Owe(n) {
  if (Array.isArray(n)) return n;
}
function Lwe(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
}
function FY(n, t) {
  if (n) {
    if (typeof n == "string") return P3(n, t);
    var e = Object.prototype.toString.call(n).slice(8, -1);
    if (e === "Object" && n.constructor && (e = n.constructor.name), e === "Map" || e === "Set") return Array.from(n);
    if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return P3(n, t);
  }
}
function P3(n, t) {
  (t == null || t > n.length) && (t = n.length);
  for (var e = 0, r = new Array(t); e < t; e++) r[e] = n[e];
  return r;
}
function jwe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Nwe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Fwe(n, t) {
  if (typeof n != "object" || n === null) return n;
  var e = n[Symbol.toPrimitive];
  if (e !== void 0) {
    var r = e.call(n, t || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(n);
}
function $we(n) {
  var t = Fwe(n, "string");
  return typeof t == "symbol" ? t : String(t);
}
function k1(n) {
  var t = n.sizes.shift(), e = Math.max(Math.ceil(t[0]), 1), r = Math.max(Math.ceil(t[1]), 1), i = [e - 1, r - 1, 1, 1], s = Date.now(), o = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, l, u;
  o ? (l = new OffscreenCanvas(1, 1), u = new OffscreenCanvas(e, r)) : (l = document.createElement("canvas"), l.width = 1, l.height = 1, u = document.createElement("canvas"), u.width = e, u.height = r);
  var d = l.getContext("2d"), f = u.getContext("2d");
  f && (f.fillRect.apply(f, i), d.drawImage(u, e - 1, r - 1, 1, 1, 0, 0, 1, 1));
  var m = d && d.getImageData(0, 0, 1, 1).data[3] !== 0, v = Date.now() - s;
  return [l, u].forEach(function(S) {
    S.height = 0, S.width = 0;
  }), o ? (postMessage({
    width: e,
    height: r,
    benchmark: v,
    isTestPass: m
  }), !m && n.sizes.length && k1(n)) : m ? n.onSuccess(e, r, v) : (n.onError(e, r, v), n.sizes.length && k1(n)), m;
}
var HN = {
  area: [16384, 14188, 11402, 11180, 10836, 8192, 4096, 1],
  height: [8388607, 65535, 32767, 16384, 8192, 4096, 1],
  width: [4194303, 65535, 32767, 16384, 8192, 4096, 1]
}, zwe = ["onError", "onSuccess"], U0 = {
  max: null,
  min: 1,
  sizes: [],
  step: 1024,
  usePromise: !1,
  useWorker: !1,
  onError: Function.prototype,
  onSuccess: Function.prototype
}, LE = {};
function VN(n) {
  var t = n.width === n.height, e = n.height === 1, r = n.width === 1, i = [];
  if (!n.width || !n.height)
    n.sizes.forEach(function(f) {
      var m = t || e ? f : 1, v = t || r ? f : 1;
      i.push([m, v]);
    });
  else
    for (var s = n.min || U0.min, o = n.step || U0.step, l = Math.max(n.width, n.height); l >= s; ) {
      var u = t || e ? l : 1, d = t || r ? l : 1;
      i.push([u, d]), l -= o;
    }
  return i;
}
function xI(n) {
  var t = window && "HTMLCanvasElement" in window, e = window && "OffscreenCanvas" in window, r = Date.now(), i = n.onError, s = n.onSuccess, o = Mwe(n, zwe), l = null;
  if (!t)
    return !1;
  if (n.useWorker && e) {
    var u = `
            var canvasTest = `.concat(k1.toString(), `;
            onmessage = function(e) {
                canvasTest(e.data);
            };
        `), d = new Blob([u], {
      type: "application/javascript"
    }), f = URL.createObjectURL(d);
    l = new Worker(f), URL.revokeObjectURL(f), l.onmessage = function(m) {
      var v = m.data, S = v.width, w = v.height, E = v.benchmark, A = v.isTestPass;
      A ? (LE[r].onSuccess(S, w, E), delete LE[r]) : LE[r].onError(S, w, E);
    };
  }
  if (n.usePromise)
    return new Promise(function(m, v) {
      var S = rc(rc({}, n), {}, {
        onError: function(P, R, M) {
          var j;
          if (n.sizes.length === 0)
            j = !0;
          else {
            var $ = n.sizes.slice(-1), U = d7($, 1), F = d7(U[0], 2), B = F[0], G = F[1];
            j = P === B && R === G;
          }
          i(P, R, M), j && v({
            width: P,
            height: R,
            benchmark: M
          });
        },
        onSuccess: function(P, R, M) {
          s(P, R, M), m({
            width: P,
            height: R,
            benchmark: M
          });
        }
      });
      if (l) {
        var w = S.onError, E = S.onSuccess;
        LE[r] = {
          onError: w,
          onSuccess: E
        }, l.postMessage(o);
      } else
        k1(S);
    });
  if (l)
    LE[r] = {
      onError: i,
      onSuccess: s
    }, l.postMessage(o);
  else
    return k1(n);
}
var WN = {
  maxArea: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = VN({
      width: t.max,
      height: t.max,
      min: t.min,
      step: t.step,
      sizes: bI(HN.area)
    }), r = rc(rc(rc({}, U0), t), {}, {
      sizes: e
    });
    return xI(r);
  },
  maxHeight: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = VN({
      width: 1,
      height: t.max,
      min: t.min,
      step: t.step,
      sizes: bI(HN.height)
    }), r = rc(rc(rc({}, U0), t), {}, {
      sizes: e
    });
    return xI(r);
  },
  maxWidth: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = VN({
      width: t.max,
      height: 1,
      min: t.min,
      step: t.step,
      sizes: bI(HN.width)
    }), r = rc(rc(rc({}, U0), t), {}, {
      sizes: e
    });
    return xI(r);
  },
  test: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = rc(rc({}, U0), t);
    return e.sizes = bI(e.sizes), e.width && e.height && (e.sizes = [[e.width, e.height]]), xI(e);
  }
};
let GN = null;
function Uwe() {
  return GN || (GN = Bwe()), GN;
}
async function Bwe() {
  const n = await WN.maxWidth({ usePromise: !0 }), t = await WN.maxHeight({ usePromise: !0 }), e = await WN.maxArea({ usePromise: !0 });
  return {
    maxWidth: n.width,
    maxHeight: t.height,
    maxArea: e.width * e.height
  };
}
const h7 = 8192, Hwe = 4096 * 4096;
async function Vwe(n, t) {
  if (n <= h7 && t <= h7 && n * t <= Hwe)
    return [n, t];
  const { maxWidth: e, maxHeight: r, maxArea: i } = await Uwe(), s = n / t;
  if (n > e && (n = e, t = n / s), t > r && (t = r, n = t * s), n * t > i) {
    const o = Math.sqrt(i / (n * t));
    n *= o, t *= o;
  }
  return [n, t];
}
function Wwe(n, t) {
  const e = n.w / t.w, r = n.h / t.h;
  return e <= 1 && r <= 1 ? n : e > r ? {
    w: n.w / e,
    h: n.h / e
  } : {
    w: n.w / r,
    h: n.h / r
  };
}
function Gwe(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Kwe(n) {
  const t = new URL(n).host.replace("www.", "");
  for (const e of $T)
    if ($Y(e.hostnames, t)) {
      const r = e.fromEmbedUrl(n);
      if (r)
        return {
          definition: e,
          url: r,
          embedUrl: n
        };
    }
}
const Ywe = (n) => n.split("*").map((t) => Gwe(t)).join(".+"), $Y = (n, t) => !!n.find((e) => {
  const r = new RegExp(Ywe(e));
  return t.match(r);
});
function Xwe(n) {
  const t = new URL(n).host.replace("www.", "");
  for (const e of $T)
    if ($Y(e.hostnames, t)) {
      const r = e.toEmbedUrl(n);
      if (r)
        return {
          definition: e,
          embedUrl: r,
          url: n
        };
    }
}
function zY(n) {
  return Xwe(n) ?? Kwe(n);
}
function pm(n) {
  try {
    return zY(n);
  } catch (t) {
    console.error(t);
  }
}
/*!
 * MIT License
 * Adapted (mostly copied) the work of https://github.com/fregante/text-field-edit
 * Copyright (c) Federico Brigante <opensource@bfred.it> (bfred.it)
 */
const B0 = "  ", Na = class Na {
  static insertTextFirefox(t, e) {
    t.setRangeText(
      e,
      t.selectionStart || 0,
      t.selectionEnd || 0,
      "end"
      // Without this, the cursor is either at the beginning or text remains selected
    ), t.dispatchEvent(
      new InputEvent("input", {
        data: e,
        inputType: "insertText",
        isComposing: !1
        // TODO: fix @types/jsdom, this shouldn't be required
      })
    );
  }
  /**
   * Inserts text at the cursor’s position, replacing any selection, with **undo** support and by
   * firing the input event.
   */
  static insert(t, e) {
    const r = t.ownerDocument, i = r.activeElement;
    i !== t && t.focus(), r.execCommand("insertText", !1, e) || Na.insertTextFirefox(t, e), i === r.body ? t.blur() : i instanceof HTMLElement && i !== t && i.focus();
  }
  /**
   * Replaces the entire content, equivalent to field.value = text but with **undo** support and by
   * firing the input event.
   */
  static set(t, e) {
    t.select(), Na.insert(t, e);
  }
  /** Get the selected text in a field or an empty string if nothing is selected. */
  static getSelection(t) {
    const { selectionStart: e, selectionEnd: r } = t;
    return t.value.slice(
      e || void 0,
      r || void 0
    );
  }
  /**
   * Adds the wrappingText before and after field’s selection (or cursor). If endWrappingText is
   * provided, it will be used instead of wrappingText at on the right.
   */
  static wrapSelection(t, e, r) {
    const { selectionStart: i, selectionEnd: s } = t, o = Na.getSelection(t);
    Na.insert(t, e + o + (r ?? e)), t.selectionStart = (i || 0) + e.length, t.selectionEnd = (s || 0) + e.length;
  }
  /** Finds and replaces strings and regex in the field’s value. */
  static replace(t, e, r) {
    let i = 0;
    t.value.replace(e, (...s) => {
      const o = i + s[s.length - 2], l = s[0].length;
      t.selectionStart = o, t.selectionEnd = o + l;
      const u = typeof r == "string" ? r : r(...s);
      return Na.insert(t, u), t.selectionStart = o, i += u.length - l, u;
    });
  }
  static findLineEnd(t, e) {
    const r = t.lastIndexOf(`
`, e - 1) + 1;
    return t.charAt(r) !== "	" ? e : r + 1;
  }
  static indent(t) {
    var l;
    const { selectionStart: e, selectionEnd: r, value: i } = t, s = i.slice(e, r), o = (l = /\n/g.exec(s)) == null ? void 0 : l.length;
    if (o && o > 0) {
      const u = i.lastIndexOf(`
`, e - 1) + 1, d = t.value.slice(u, r - 1), f = d.replace(
        /^|\n/g,
        // Match all line starts
        `$&${B0}`
      ), m = f.length - d.length;
      t.setSelectionRange(u, r - 1), Na.insert(t, f), t.setSelectionRange(e + 1, r + m);
    } else
      Na.insert(t, B0);
  }
  // The first line should always be unindented
  // The last line should only be unindented if the selection includes any characters after \n
  static unindent(t) {
    const { selectionStart: e, selectionEnd: r, value: i } = t, s = i.lastIndexOf(`
`, e - 1) + 1, o = Na.findLineEnd(i, r), l = t.value.slice(s, o), u = l.replace(/(^|\n)(\t| {1,2})/g, "$1"), d = l.length - u.length;
    t.setSelectionRange(s, o), Na.insert(t, u);
    const f = /\t| {1,2}/.exec(i.slice(s, e)), m = f ? f[0].length : 0, v = e - m;
    t.setSelectionRange(
      e - m,
      Math.max(v, r - d)
    );
  }
  static indentCE(t) {
    var u;
    const e = window.getSelection(), r = t.innerText, i = wI(t) ?? 0, s = wI(t) ?? 0, o = r.slice(i, s), l = (u = /\n/g.exec(o)) == null ? void 0 : u.length;
    if (l && l > 0) {
      const d = r.lastIndexOf(`
`, i - 1) + 1, f = r.slice(d, s - 1), v = f.replace(
        /^|\n/g,
        // Match all line starts
        `$&${B0}`
      ).length - f.length;
      e && e.setBaseAndExtent(
        t,
        i + 1,
        t,
        s + v
      );
    } else {
      const d = window.getSelection();
      t.innerText = r.slice(0, i) + B0 + r.slice(i), d == null || d.setBaseAndExtent(t, i + 1, t, i + 2);
    }
  }
  static unindentCE(t) {
    const e = window.getSelection(), r = t.innerText, i = wI(t) ?? 0, s = wI(t) ?? 0, o = r.lastIndexOf(`
`, i - 1) + 1, l = Na.findLineEnd(r, s), u = r.slice(o, l), d = u.replace(/(^|\n)(\t| {1,2})/g, "$1"), f = u.length - d.length;
    if (e) {
      e.setBaseAndExtent(t, o, t, l);
      const m = /\t| {1,2}/.exec(r.slice(o, i)), v = m ? m[0].length : 0, S = i - v;
      e.setBaseAndExtent(
        t,
        i - v,
        t,
        Math.max(S, s - f)
      );
    }
  }
  static normalizeText(t) {
    return t.replace(Na.fixNewLines, `
`);
  }
  static normalizeTextForDom(t) {
    return t.replace(Na.fixNewLines, `
`).split(`
`).map((e) => e || " ").join(`
`);
  }
};
T(Na, "fixNewLines", /\r?\n|\r/g);
let Jx = Na;
function wI(n) {
  if (typeof window.getSelection > "u") return;
  const t = window.getSelection();
  if (!t) return;
  let e = 0;
  if (t.rangeCount !== 0) {
    const r = t.getRangeAt(0), i = r.cloneRange();
    i.selectNodeContents(n), i.setEnd(r.endContainer, r.endOffset), e = i.toString().length;
  }
  return e;
}
const qwe = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function UY(n) {
  return qwe.test(n);
}
function Zwe(n) {
  return n.replace(/\t/g, B0);
}
function Qwe(n) {
  const t = n.split(`
`);
  for (; t[0] && t[0].trim().length === 0; )
    t.shift();
  let e = 1 / 0;
  for (const r of t)
    if (r.trim().length > 0) {
      const i = r.length - r.trimStart().length;
      e = Math.min(e, i);
    }
  return t.map((r) => r.slice(e)).join(`
`);
}
function Jwe(n) {
  return n.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
function eCe(n) {
  return Jwe(Qwe(Zwe(n)));
}
function tCe(n, {
  maxImageDimension: t,
  maxAssetSize: e,
  acceptedImageMimeTypes: r,
  acceptedVideoMimeTypes: i
}, { toasts: s, msg: o }) {
  n.registerExternalAssetHandler("file", async ({ file: l }) => {
    const u = l.name;
    let d = l;
    const f = r.includes(d.type), m = i.includes(d.type);
    !f && !m && s.addToast({
      title: o("assets.files.type-not-allowed"),
      severity: "error"
    }), ii(f || m, `File type not allowed: ${d.type}`), d.size > e && s.addToast({
      title: o("assets.files.size-too-big"),
      severity: "error"
    }), ii(
      d.size <= e,
      `File size too big: ${(d.size / 1024).toFixed()}kb > ${(e / 1024).toFixed()}kb`
    ), d.type === "video/quicktime" && (d = new File([d], d.name, { type: "video/mp4" }));
    let v = f ? await mh.getImageSize(d) : await mh.getVideoSize(d);
    const S = await mh.isAnimated(d) || m, w = wme(await d.arrayBuffer());
    if (isFinite(t)) {
      const P = Wwe(v, { w: t, h: t });
      v !== P && mh.isStaticImageType(d.type) && (v = P);
    }
    const A = {
      id: Zv.createId(w),
      type: f ? "image" : "video",
      typeName: "asset",
      props: {
        name: u,
        src: "",
        w: v.w,
        h: v.h,
        fileSize: d.size,
        mimeType: d.type,
        isAnimated: S
      }
    };
    return A.props.src = await n.uploadAsset(A, d), Zv.create(A);
  }), n.registerExternalAssetHandler("url", async ({ url: l }) => {
    var d, f, m, v, S;
    let u;
    try {
      const E = await (await Th(l, {
        method: "GET",
        mode: "no-cors"
      })).text(), A = new DOMParser().parseFromString(E, "text/html");
      u = {
        image: ((d = A.head.querySelector('meta[property="og:image"]')) == null ? void 0 : d.getAttribute("content")) ?? "",
        favicon: ((f = A.head.querySelector('link[rel="apple-touch-icon"]')) == null ? void 0 : f.getAttribute("href")) ?? ((m = A.head.querySelector('link[rel="icon"]')) == null ? void 0 : m.getAttribute("href")) ?? "",
        title: ((v = A.head.querySelector('meta[property="og:title"]')) == null ? void 0 : v.getAttribute("content")) ?? l,
        description: ((S = A.head.querySelector('meta[property="og:description"]')) == null ? void 0 : S.getAttribute("content")) ?? ""
      }, u.image.startsWith("http") || (u.image = new URL(u.image, l).href), u.favicon.startsWith("http") || (u.favicon = new URL(u.favicon, l).href);
    } catch (w) {
      console.error(w), s.addToast({
        title: o("assets.url.failed"),
        severity: "error"
      }), u = { image: "", favicon: "", title: "", description: "" };
    }
    return {
      id: Zv.createId(s3(l)),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: l,
        description: u.description,
        image: u.image,
        favicon: u.favicon,
        title: u.title
      },
      meta: {}
    };
  }), n.registerExternalContentHandler("svg-text", async ({ point: l, text: u }) => {
    const d = l ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), f = new DOMParser().parseFromString(u, "image/svg+xml").querySelector("svg");
    if (!f)
      throw new Error("No <svg/> element present");
    let m = parseFloat(f.getAttribute("width") || "0"), v = parseFloat(f.getAttribute("height") || "0");
    if (!(m && v)) {
      document.body.appendChild(f);
      const w = f.getBoundingClientRect();
      document.body.removeChild(f), m = w.width, v = w.height;
    }
    const S = await n.getAssetForExternalContent({
      type: "file",
      file: new File([u], "asset.svg", { type: "image/svg+xml" })
    });
    if (!S) throw Error("Could not create an asset");
    f7(n, [S], d);
  }), n.registerExternalContentHandler("embed", ({ point: l, url: u, embed: d }) => {
    const f = l ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), { width: m, height: v } = d, S = Ar(), w = {
      id: S,
      type: "embed",
      x: f.x - (m || 450) / 2,
      y: f.y - (v || 450) / 2,
      props: {
        w: m,
        h: v,
        url: u
      }
    };
    n.createShapes([w]).select(S);
  }), n.registerExternalContentHandler("files", async ({ point: l, files: u }) => {
    const d = l ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), f = new O(d.x, d.y), m = [];
    await Promise.all(
      u.map(async (v, S) => {
        if (v.size > e)
          return s.addToast({
            title: o("assets.files.size-too-big"),
            severity: "error"
          }), console.warn(
            `File size too big: ${(v.size / 1024).toFixed()}kb > ${(e / 1024).toFixed()}kb`
          ), null;
        if (!v.type)
          throw new Error("No mime type");
        if (!r.concat(i).includes(v.type))
          return s.addToast({
            title: o("assets.files.type-not-allowed"),
            severity: "error"
          }), console.warn(`${v.name} not loaded - Extension not allowed.`), null;
        try {
          const w = await n.getAssetForExternalContent({ type: "file", file: v });
          if (!w)
            throw Error("Could not create an asset");
          m[S] = w;
        } catch (w) {
          return s.addToast({
            title: o("assets.files.upload-failed"),
            severity: "error"
          }), console.error(w), null;
        }
      })
    ), f7(n, xn(m), f);
  }), n.registerExternalContentHandler("text", async ({ point: l, text: u }) => {
    const d = l ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), f = n.getShapeUtil("text").getDefaultProps(), m = eCe(u), v = n.getOnlySelectedShape();
    if (v && "text" in v.props) {
      n.updateShapes([
        {
          id: v.id,
          type: v.type,
          props: {
            text: m
          }
        }
      ]);
      return;
    }
    let S, w, E, A = "middle";
    const P = m.split(`
`).length > 1, R = UY(m);
    P && (A = P ? R ? "end" : "start" : "middle");
    const M = n.textMeasure.measureText(m, {
      ...Oo,
      fontFamily: Ch[f.font],
      fontSize: Qx[f.size],
      maxWidth: null
    }), j = Math.min(
      P ? n.getViewportPageBounds().width * 0.9 : 920,
      Math.max(200, n.getViewportPageBounds().width * 0.9)
    );
    if (M.w > j) {
      const $ = n.textMeasure.measureText(m, {
        ...Oo,
        fontFamily: Ch[f.font],
        fontSize: Qx[f.size],
        maxWidth: j
      });
      S = $.w, w = $.h, E = !1, A = R ? "end" : "start";
    } else
      S = M.w, w = M.h, E = !0;
    d.y - w / 2 < n.getViewportPageBounds().minY + 40 && (d.y = n.getViewportPageBounds().minY + 40 + w / 2), n.createShapes([
      {
        id: Ar(),
        type: "text",
        x: d.x - S / 2,
        y: d.y - w / 2,
        props: {
          text: m,
          // if the text has more than one line, align it to the left
          textAlign: A,
          autoSize: E,
          w: S
        }
      }
    ]);
  }), n.registerExternalContentHandler("url", async ({ point: l, url: u }) => {
    const d = pm(u);
    if (d)
      return n.putExternalContent({
        type: "embed",
        url: d.url,
        point: l,
        embed: d.definition
      });
    const f = l ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), m = Zv.createId(s3(u)), v = nCe(n, u, f);
    let S = n.getAsset(m), w = !1;
    if (!S) {
      w = !0;
      try {
        const E = await n.getAssetForExternalContent({ type: "url", url: u });
        if (!E) throw Error("Could not create an asset");
        S = E;
      } catch {
        s.addToast({
          title: o("assets.url.failed"),
          severity: "error"
        });
        return;
      }
    }
    n.run(() => {
      w && n.createAssets([S]), n.updateShapes([
        {
          id: v.id,
          type: v.type,
          props: {
            assetId: S.id
          }
        }
      ]);
    });
  });
}
async function f7(n, t, e) {
  if (!t.length) return [];
  const r = O.From(e), i = [];
  for (let s = 0; s < t.length; s++) {
    const o = t[s];
    switch (o.type) {
      case "bookmark": {
        i.push({
          id: Ar(),
          type: "bookmark",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: o.id,
            url: o.props.src
          }
        }), r.x += 300;
        break;
      }
      case "image": {
        i.push({
          id: Ar(),
          type: "image",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: o.id,
            w: o.props.w,
            h: o.props.h
          }
        }), r.x += o.props.w;
        break;
      }
      case "video":
        i.push({
          id: Ar(),
          type: "video",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: o.id,
            w: o.props.w,
            h: o.props.h
          }
        }), r.x += o.props.w;
    }
  }
  return n.run(() => {
    const s = t.filter((o) => !n.getAsset(o.id));
    s.length && n.createAssets(s), n.createShapes(i).select(...i.map((o) => o.id)), BY(n, e);
  }), i.map((s) => s.id);
}
function BY(n, t) {
  const e = n.getViewportPageBounds();
  let r = n.getSelectionPageBounds();
  if (r) {
    const i = r.center.sub(t);
    n.updateShapes(
      n.getSelectedShapes().map((s) => {
        const o = n.getShapeParentTransform(s).decompose().rotation, l = O.Rot(i, -o);
        return {
          id: s.id,
          type: s.type,
          x: s.x - l.x,
          y: s.y - l.y
        };
      })
    );
  }
  r = n.getSelectionPageBounds(), r && !e.contains(r) && n.zoomToSelection();
}
function nCe(n, t, e) {
  const r = {
    id: Ar(),
    type: "bookmark",
    x: e.x - 150,
    y: e.y - 160,
    opacity: 1,
    props: {
      assetId: null,
      url: t
    }
  };
  return n.run(() => {
    n.createShapes([r]).select(r.id), BY(n, e);
  }), n.getShape(r.id);
}
var EF;
let rCe = (EF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
    T(this, "onKeyUp", (e) => {
      var r;
      if (e.key === "Enter") {
        if (this.editor.getInstanceState().isReadonly) return null;
        const i = this.editor.getOnlySelectedShape();
        i && this.editor.getShapeUtil(i).canEdit(i) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(i.id), (r = this.editor.root.getCurrent()) == null || r.transition("editing_shape", {
          ...e,
          target: "shape",
          shape: i
        }));
      }
    });
  }
}, T(EF, "id", "idle"), EF);
var _F;
let iCe = (_F = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shape");
    T(this, "markId", "");
    T(this, "onEnter", () => {
      this.didTimeout = !1;
      const e = this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
        filter: (r) => !r.isLocked && this.editor.canBindShapes({ fromShape: "arrow", toShape: r, binding: "arrow" }),
        margin: 0,
        hitInside: !0,
        renderingOnly: !0
      });
      e ? this.editor.setHintingShapes([e.id]) : this.createArrowShape(), this.startPreciseTimeout();
    });
    T(this, "onExit", () => {
      this.shape = void 0, this.editor.setHintingShapes([]), this.clearPreciseTimeout();
    });
    T(this, "onPointerMove", () => {
      if (this.editor.inputs.isDragging) {
        if (this.shape || this.createArrowShape(), !this.shape) throw Error("expected shape");
        this.updateArrowShapeEndHandle(), this.editor.setCurrentTool("select.dragging_handle", {
          shape: this.shape,
          handle: { id: "end", type: "vertex", index: "a3", x: 0, y: 0 },
          isCreating: !0,
          onInteractionEnd: "arrow"
        });
      }
    });
    T(this, "onPointerUp", () => {
      this.cancel();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
    T(this, "preciseTimeout", -1);
    T(this, "didTimeout", !1);
  }
  cancel() {
    this.shape && this.editor.bailToMark(this.markId), this.editor.setHintingShapes([]), this.parent.transition("idle");
  }
  createArrowShape() {
    var f;
    const { originPagePoint: e } = this.editor.inputs, r = Ar();
    this.markId = `creating:${r}`, this.editor.mark(this.markId), this.editor.createShape({
      id: r,
      type: "arrow",
      x: e.x,
      y: e.y,
      props: {
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const i = this.editor.getShape(r);
    if (!i) throw Error("expected shape");
    const s = this.editor.getShapeHandles(i);
    if (!s) throw Error("expected handles for arrow");
    const o = this.editor.getShapeUtil("arrow"), l = this.shape, u = s.find((m) => m.id === "start"), d = (f = o.onHandleDrag) == null ? void 0 : f.call(o, i, {
      handle: { ...u, x: 0, y: 0 },
      isPrecise: !0,
      initial: l
    });
    d && this.editor.updateShapes([d]), this.shape = this.editor.getShape(r), this.editor.select(r);
  }
  updateArrowShapeEndHandle() {
    var i, s;
    const e = this.shape;
    if (!e) throw Error("expected shape");
    const r = this.editor.getShapeHandles(e);
    if (!r) throw Error("expected handles for arrow");
    {
      const o = this.editor.getShapeUtil("arrow"), l = this.shape, u = r.find((f) => f.id === "start"), d = (i = o.onHandleDrag) == null ? void 0 : i.call(o, e, {
        handle: { ...u, x: 0, y: 0 },
        isPrecise: this.didTimeout,
        // sure about that?
        initial: l
      });
      d && this.editor.updateShapes([d]);
    }
    {
      const o = this.editor.getShapeUtil("arrow"), l = this.shape, u = this.editor.getPointInShapeSpace(e, this.editor.inputs.currentPagePoint), d = r.find((m) => m.id === "end"), f = (s = o.onHandleDrag) == null ? void 0 : s.call(o, this.editor.getShape(e), {
        handle: { ...d, x: u.x, y: u.y },
        isPrecise: !1,
        // sure about that?
        initial: l
      });
      f && this.editor.updateShapes([f]);
    }
    this.shape = this.editor.getShape(e.id);
  }
  startPreciseTimeout() {
    this.preciseTimeout = this.editor.timers.setTimeout(() => {
      this.getIsActive() && (this.didTimeout = !0);
    }, 320);
  }
  clearPreciseTimeout() {
    clearTimeout(this.preciseTimeout);
  }
}, T(_F, "id", "pointing"), _F);
class aR extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "arrow");
  }
}
T(aR, "id", "arrow"), T(aR, "initial", "idle"), T(aR, "children", () => [rCe, iCe]);
class O5 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "initialShape");
    T(this, "shapeType", this.parent.id === "highlight" ? "highlight" : "draw");
    T(this, "util", this.editor.getShapeUtil(this.shapeType));
    T(this, "isPen", !1);
    T(this, "isPenOrStylus", !1);
    T(this, "segmentMode", "free");
    T(this, "didJustShiftClickToExtendPreviousShapeLine", !1);
    T(this, "pagePointWhereCurrentSegmentChanged", {});
    T(this, "pagePointWhereNextSegmentChanged", null);
    T(this, "lastRecordedPoint", {});
    T(this, "mergeNextPoint", !1);
    T(this, "currentLineLength", 0);
    T(this, "canDraw", !1);
    T(this, "markId", null);
    T(this, "onEnter", (e) => {
      this.markId = null, this.info = e, this.canDraw = !this.editor.getIsMenuOpen(), this.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone(), this.canDraw && this.startShape();
    });
    T(this, "onPointerMove", () => {
      const { inputs: e } = this.editor;
      if (this.isPen && !e.isPen) {
        if (this.markId) {
          this.editor.bailToMark(this.markId), this.startShape();
          return;
        }
      } else
        !this.canDraw && e.isDragging && (this.startShape(), this.canDraw = !0);
      this.canDraw && (this.isPenOrStylus ? O.Dist(e.currentPagePoint, this.lastRecordedPoint) >= 1 / this.editor.getZoomLevel() ? (this.lastRecordedPoint = e.currentPagePoint.clone(), this.mergeNextPoint = !1) : this.mergeNextPoint = !0 : this.mergeNextPoint = !1, this.updateDrawingShape());
    });
    T(this, "onKeyDown", (e) => {
      if (e.key === "Shift")
        switch (this.segmentMode) {
          case "free": {
            this.segmentMode = "starting_straight", this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
            break;
          }
          case "starting_free":
            this.segmentMode = "starting_straight";
        }
      this.updateDrawingShape();
    });
    T(this, "onKeyUp", (e) => {
      if (e.key === "Shift")
        switch (this.editor.snaps.clearIndicators(), this.segmentMode) {
          case "straight": {
            this.segmentMode = "starting_free", this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
            break;
          }
          case "starting_straight": {
            this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
            break;
          }
        }
      this.updateDrawingShape();
    });
    T(this, "onExit", () => {
      this.editor.snaps.clearIndicators(), this.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.editor.inputs.isDragging || (this.markId && this.editor.bailToMark(this.markId), this.cancel());
    });
  }
  canClose() {
    return this.shapeType !== "highlight";
  }
  getIsClosed(e, r, i) {
    if (!this.canClose()) return !1;
    const s = eo[r], o = e[0].points[0], l = e[e.length - 1], u = l.points[l.points.length - 1];
    return o !== u && this.currentLineLength > s * 4 * i && O.DistMin(o, u, s * 2 * i);
  }
  startShape() {
    const {
      inputs: { originPagePoint: e, isPen: r }
    } = this.editor;
    this.markId = "draw start " + Ii(), this.editor.mark(this.markId);
    const { z: i = 0.5 } = this.info.point;
    this.isPen = r, this.isPenOrStylus = r || i > 0 && i < 0.5 || i > 0.5 && i < 1;
    const s = this.isPenOrStylus ? i * 1.25 : 0.5;
    if (this.segmentMode = this.editor.inputs.shiftKey ? "straight" : "free", this.didJustShiftClickToExtendPreviousShapeLine = !1, this.lastRecordedPoint = e.clone(), this.initialShape) {
      const l = this.editor.getShape(this.initialShape.id);
      if (l && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = !0;
        const u = Io(l.props.segments);
        if (!u) throw Error("Expected a previous segment!");
        const d = Io(u.points);
        if (!d) throw Error("Expected a previous point!");
        const { x: f, y: m } = this.editor.getPointInShapeSpace(l, e).toFixed(), v = {
          type: this.segmentMode,
          points: [
            {
              x: d.x,
              y: d.y,
              z: +s.toFixed(2)
            },
            {
              x: f,
              y: m,
              z: +s.toFixed(2)
            }
          ]
        }, S = At.applyToPoint(
          this.editor.getShapePageTransform(l.id),
          d
        );
        this.pagePointWhereCurrentSegmentChanged = S, this.pagePointWhereNextSegmentChanged = null;
        const w = [...l.props.segments, v];
        this.currentLineLength < eo[l.props.size] * 4 && (this.currentLineLength = this.getLineLength(w));
        const E = {
          id: l.id,
          type: this.shapeType,
          props: {
            segments: w
          }
        };
        this.canClose() && (E.props.isClosed = this.getIsClosed(
          w,
          l.props.size,
          l.props.scale
        )), this.editor.updateShapes([E]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = e.clone();
    const o = Ar();
    this.editor.createShapes([
      {
        id: o,
        type: this.shapeType,
        x: e.x,
        y: e.y,
        props: {
          isPen: this.isPenOrStylus,
          scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,
          segments: [
            {
              type: this.segmentMode,
              points: [
                {
                  x: 0,
                  y: 0,
                  z: +s.toFixed(2)
                }
              ]
            }
          ]
        }
      }
    ]), this.currentLineLength = 0, this.initialShape = this.editor.getShape(o);
  }
  updateDrawingShape() {
    const { initialShape: e } = this, { inputs: r } = this.editor;
    if (!e) return;
    const {
      id: i,
      props: { size: s, scale: o }
    } = e, l = this.editor.getShape(i);
    if (!l) return;
    const { segments: u } = l.props, { x: d, y: f, z: m } = this.editor.getPointInShapeSpace(l, r.currentPagePoint).toFixed(), v = this.isPenOrStylus ? +(r.currentPagePoint.z * 1.25).toFixed(2) : 0.5, S = { x: d, y: f, z: v };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged: w } = this;
        if (w === null)
          throw Error("We should have a point where the segment changed");
        if (O.Dist2(w, r.currentPagePoint) > this.editor.options.dragDistanceSquared) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "straight";
          const A = Io(u);
          if (!A) throw Error("Expected a previous segment!");
          const P = Io(A.points);
          if (!P) throw Error("Expected a previous last point!");
          let R;
          const M = this.editor.getPointInShapeSpace(l, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
          if (A.type === "straight") {
            this.currentLineLength += O.Dist(P, M), R = {
              type: "straight",
              points: [{ ...P }, M]
            };
            const $ = this.editor.getShapePageTransform(l);
            this.pagePointWhereCurrentSegmentChanged = At.applyToPoint($, P);
          } else
            R = {
              type: "straight",
              points: [M, S]
            };
          const j = {
            id: i,
            type: this.shapeType,
            props: {
              segments: [...u, R]
            }
          };
          this.canClose() && (j.props.isClosed = this.getIsClosed(
            u,
            s,
            o
          )), this.editor.updateShapes([j]);
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged: w } = this;
        if (w === null)
          throw Error("We should have a point where the segment changed");
        if (O.Dist2(w, r.currentPagePoint) > this.editor.options.dragDistanceSquared) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          const A = u.slice(), P = A[A.length - 1], R = Io(P.points);
          if (!R)
            throw Error("No previous point!");
          const M = {
            type: "free",
            points: [
              ...O.PointsBetween(R, S, 6).map((U) => ({
                x: op(U.x),
                y: op(U.y),
                z: op(U.z)
              }))
            ]
          }, j = [...A, M];
          this.currentLineLength < eo[l.props.size] * 4 && (this.currentLineLength = this.getLineLength(j));
          const $ = {
            id: i,
            type: this.shapeType,
            props: {
              segments: j
            }
          };
          this.canClose() && ($.props.isClosed = this.getIsClosed(
            j,
            s,
            o
          )), this.editor.updateShapes([$]);
        }
        break;
      }
      case "straight": {
        const w = u.slice(), E = w[w.length - 1], { pagePointWhereCurrentSegmentChanged: A } = this, { ctrlKey: P, currentPagePoint: R } = this.editor.inputs;
        if (!A)
          throw Error("We should have a point where the segment changed");
        let M, j = !1;
        this.didJustShiftClickToExtendPreviousShapeLine ? this.editor.inputs.isDragging && (j = !P, this.didJustShiftClickToExtendPreviousShapeLine = !1) : j = !P;
        let $ = this.editor.getPointInShapeSpace(l, R).toFixed().toJson(), U = !1, F;
        if ((this.editor.user.getIsSnapMode() ? !P : P) && w.length > 2) {
          let X, te = 8 / this.editor.getZoomLevel();
          for (let ne = 0, K = u.length - 2; ne < K; ne++) {
            const Z = u[ne];
            if (!Z) break;
            if (Z.type === "free") continue;
            const oe = Z.points[0], fe = Io(Z.points);
            if (!(oe && fe)) continue;
            const ie = O.NearestPointOnLineSegment(
              oe,
              fe,
              $
            );
            if (O.DistMin(ie, $, te)) {
              X = ie.toFixed().toJson(), te = O.Dist(ie, $), F = Z;
              break;
            }
          }
          X && (U = !0, $ = X);
        }
        if (U && F) {
          const X = this.editor.getShapePageTransform(l), te = F.points[0], ne = Io(F.points);
          if (!ne) throw Error("Expected a last point!");
          const K = At.applyToPoint(X, te), Z = At.applyToPoint(X, ne), oe = At.applyToPoint(X, $);
          this.editor.snaps.setIndicators([
            {
              id: Ii(),
              type: "points",
              points: [K, oe, Z]
            }
          ]);
        } else {
          if (this.editor.snaps.clearIndicators(), j) {
            const X = O.Angle(A, R), ne = EM(X, 24) - X;
            M = O.RotWith(
              R,
              A,
              ne
            );
          } else
            M = R;
          $ = this.editor.getPointInShapeSpace(l, M).toFixed().toJson();
        }
        this.currentLineLength += O.Dist(E.points[0], $), w[w.length - 1] = {
          ...E,
          type: "straight",
          points: [E.points[0], $]
        };
        const G = {
          id: i,
          type: this.shapeType,
          props: {
            segments: w
          }
        };
        this.canClose() && (G.props.isClosed = this.getIsClosed(
          u,
          s,
          o
        )), this.editor.updateShapes([G]);
        break;
      }
      case "free": {
        const w = u.slice(), E = w[w.length - 1], A = [...E.points];
        if (A.length && this.mergeNextPoint) {
          const { z: R } = A[A.length - 1];
          A[A.length - 1] = {
            x: S.x,
            y: S.y,
            z: R ? Math.max(R, S.z) : S.z
          };
        } else
          this.currentLineLength += O.Dist(A[A.length - 1], S), A.push(S);
        w[w.length - 1] = {
          ...E,
          points: A
        }, this.currentLineLength < eo[l.props.size] * 4 && (this.currentLineLength = this.getLineLength(w));
        const P = {
          id: i,
          type: this.shapeType,
          props: {
            segments: w
          }
        };
        if (this.canClose() && (P.props.isClosed = this.getIsClosed(
          w,
          s,
          o
        )), this.editor.updateShapes([P]), A.length > this.editor.options.maxPointsPerDrawShape) {
          this.editor.updateShapes([{ id: i, type: this.shapeType, props: { isComplete: !0 } }]);
          const R = Ar(), M = this.editor.getShape(i).props;
          this.editor.createShapes([
            {
              id: R,
              type: this.shapeType,
              x: op(r.currentPagePoint.x),
              y: op(r.currentPagePoint.y),
              props: {
                isPen: this.isPenOrStylus,
                scale: M.scale,
                segments: [
                  {
                    type: "free",
                    points: [{ x: 0, y: 0, z: this.isPenOrStylus ? +(m * 1.25).toFixed() : 0.5 }]
                  }
                ]
              }
            }
          ]), this.initialShape = ni(this.editor.getShape(R)), this.mergeNextPoint = !1, this.lastRecordedPoint = r.currentPagePoint.clone(), this.currentLineLength = 0;
        }
        break;
      }
    }
  }
  getLineLength(e) {
    let r = 0;
    for (const i of e)
      for (let s = 0; s < i.points.length - 1; s++) {
        const o = i.points[s], l = i.points[s + 1];
        r += O.Dist2(l, o);
      }
    return Math.sqrt(r);
  }
  complete() {
    if (!this.canDraw) {
      this.cancel();
      return;
    }
    const { initialShape: e } = this;
    e && (this.editor.updateShapes([
      { id: e.id, type: e.type, props: { isComplete: !0 } }
    ]), this.parent.transition("idle"));
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
T(O5, "id", "drawing");
var TF;
let HY = (TF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("drawing", e);
    });
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(TF, "id", "idle"), TF);
class ZE extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "draw");
    T(this, "onExit", () => {
      const e = this.children.drawing;
      e.initialShape = void 0;
    });
  }
}
T(ZE, "id", "draw"), T(ZE, "initial", "idle"), T(ZE, "isLockable", !1), T(ZE, "children", () => [HY, O5]);
class A3 extends iR {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "frame");
    T(this, "onCreate", (e) => {
      if (!e) return;
      const r = this.editor.getShapePageBounds(e), i = [], s = this.editor.getShapeAncestors(e).map((o) => o.id);
      this.editor.getSortedChildIdsForParent(e.parentId).map((o) => {
        const l = this.editor.getShape(o);
        if (!l || l.id === e.id || l.isLocked) return;
        const u = this.editor.getShapePageBounds(l);
        u && r.contains(u) && sCe(l, s, e) && i.push(l.id);
      }), this.editor.reparentShapes(i, e.id), this.editor.getInstanceState().isToolLocked ? this.editor.setCurrentTool("frame") : this.editor.setCurrentTool("select.idle");
    });
  }
}
T(A3, "id", "frame"), T(A3, "initial", "idle");
function sCe(n, t, e) {
  return t.includes(n.id) ? !1 : n.parentId === e.parentId;
}
var PF;
let oCe = (PF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onKeyUp", (e) => {
      var r;
      if (e.key === "Enter") {
        if (this.editor.getInstanceState().isReadonly) return null;
        const i = this.editor.getOnlySelectedShape();
        i && this.editor.getShapeUtil(i).canEdit(i) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(i.id), (r = this.editor.root.getCurrent()) == null || r.transition("editing_shape", {
          ...e,
          target: "shape",
          shape: i
        }));
      }
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(PF, "id", "idle"), PF);
var AF;
let aCe = (AF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "markId", "");
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onPointerMove", (e) => {
      if (this.editor.inputs.isDragging) {
        const { originPagePoint: r } = this.editor.inputs, i = Ar();
        this.markId = `creating:${i}`, this.editor.mark(this.markId), this.editor.createShapes([
          {
            id: i,
            type: "geo",
            x: r.x,
            y: r.y,
            props: {
              w: 1,
              h: 1,
              geo: this.editor.getStyleForNextShape(od),
              scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
            }
          }
        ]).select(i).setCurrentTool("select.resizing", {
          ...e,
          target: "selection",
          handle: "bottom_right",
          isCreating: !0,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: "geo"
        });
      }
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  complete() {
    const { originPagePoint: e } = this.editor.inputs, r = Ar();
    this.markId = `creating:${r}`, this.editor.mark(this.markId);
    const i = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1, s = this.editor.getStyleForNextShape(od), o = s === "star" ? { w: 200, h: 190 } : s === "cloud" ? { w: 300, h: 180 } : { w: 200, h: 200 };
    this.editor.createShapes([
      {
        id: r,
        type: "geo",
        x: e.x,
        y: e.y,
        props: {
          geo: this.editor.getStyleForNextShape(od),
          scale: i,
          ...o
        }
      }
    ]);
    const l = this.editor.getShape(r);
    if (!l) return;
    const { w: u, h: d } = l.props, f = new O(u / 2, d / 2).mul(i), m = this.editor.getShapeParentTransform(l);
    m && f.rot(-m.rotation()), this.editor.select(r), this.editor.updateShape({
      id: l.id,
      type: "geo",
      x: l.x - f.x,
      y: l.y - f.y,
      props: {
        geo: this.editor.getStyleForNextShape(od),
        w: u * i,
        h: d * i
      }
    }), this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : this.editor.setCurrentTool("select", {});
  }
  cancel() {
    this.parent.transition("idle");
  }
}, T(AF, "id", "pointing"), AF);
class lR extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "geo");
  }
}
T(lR, "id", "geo"), T(lR, "initial", "idle"), T(lR, "children", () => [oCe, aCe]);
class QE extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "highlight");
    T(this, "onExit", () => {
      const e = this.children.drawing;
      e.initialShape = void 0;
    });
  }
}
T(QE, "id", "highlight"), T(QE, "initial", "idle"), T(QE, "children", () => [HY, O5]), T(QE, "isLockable", !1);
var kF;
let lCe = (kF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeId", "");
    T(this, "onEnter", (e) => {
      this.shapeId = e.shapeId, this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onPointerDown", () => {
      this.parent.transition("pointing", { shapeId: this.shapeId });
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(kF, "id", "idle"), kF);
const p7 = 2;
var IF;
let cCe = (IF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shape", {});
    T(this, "markId");
    T(this, "onEnter", (e) => {
      const { inputs: r } = this.editor, { currentPagePoint: i } = r;
      this.markId = void 0;
      const s = e.shapeId && this.editor.getShape(e.shapeId);
      if (s && r.shiftKey) {
        this.markId = `creating:${s.id}`, this.editor.mark(this.markId), this.shape = s;
        const o = this.editor.getShapeHandles(this.shape);
        if (!o) return;
        const l = o.filter((S) => S.type === "vertex").sort(fa), u = l[l.length - 1], d = l[l.length - 2], f = At.applyToPoint(
          this.editor.getShapeParentTransform(this.shape),
          new O(this.shape.x, this.shape.y)
        ), m = O.Sub(i, f).addXY(0.1, 0.1), v = ni(this.shape.props.points);
        if (O.DistMin(u, d, p7) || O.DistMin(m, u, p7))
          v[u.id] = {
            id: u.id,
            index: u.index,
            x: m.x,
            y: m.y
          };
        else {
          const S = id(u.index);
          v[S] = {
            id: S,
            index: S,
            x: m.x,
            y: m.y
          };
        }
        this.editor.updateShapes([
          {
            id: this.shape.id,
            type: this.shape.type,
            props: {
              points: v
            }
          }
        ]);
      } else {
        const o = Ar();
        this.markId = `creating:${o}`, this.editor.mark(this.markId), this.editor.createShapes([
          {
            id: o,
            type: "line",
            x: i.x,
            y: i.y,
            props: {
              scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
            }
          }
        ]), this.editor.select(o), this.shape = this.editor.getShape(o);
      }
    });
    T(this, "onPointerMove", () => {
      if (this.shape && this.editor.inputs.isDragging) {
        const e = this.editor.getShapeHandles(this.shape);
        if (!e)
          throw this.markId && this.editor.bailToMark(this.markId), Error("No handles found");
        const r = Io(e);
        this.editor.setCurrentTool("select.dragging_handle", {
          shape: this.shape,
          isCreating: !0,
          // remove the offset that we added to the handle when we created it
          handle: { ...r, x: r.x - 0.1, y: r.y - 0.1 },
          onInteractionEnd: "line"
        });
      }
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.parent.transition("idle"), this.markId && this.editor.bailToMark(this.markId), this.editor.snaps.clearIndicators();
    });
  }
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id }), this.editor.snaps.clearIndicators();
  }
  cancel() {
    this.markId && this.editor.bailToMark(this.markId), this.parent.transition("idle", { shapeId: this.shape.id }), this.editor.snaps.clearIndicators();
  }
}, T(IF, "id", "pointing"), IF);
class cR extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "line");
  }
}
T(cR, "id", "line"), T(cR, "initial", "idle"), T(cR, "children", () => [lCe, cCe]);
var RF;
let uCe = (RF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(RF, "id", "idle"), RF);
function ei(n, t) {
  var i;
  const e = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = n.getShape(s);
    if (!o) continue;
    n.getShapeUtil(o).onDragShapesOut && e.add(o);
    const l = n.getShape(o.parentId);
    l && n.getShapeUtil(l).onDragShapesOut && e.add(l);
  }
  const r = /* @__PURE__ */ new Map();
  for (const s of e) {
    const o = VY(n, s);
    o.length && r.set(s, o);
  }
  for (const [s, o] of r) {
    const l = n.getShapeUtil(s), u = xn(o.map((d) => n.getShape(d)));
    (i = l.onDragShapesOut) == null || i.call(l, s, u);
  }
}
function VY(n, t) {
  const e = n.getSortedChildIdsForParent(t.id);
  if (e.length === 0) return [];
  const r = n.getShapePageBounds(t);
  if (!r) return [];
  let i, s, o;
  const l = [];
  for (const u of e) {
    const d = n.getShapePageBounds(u);
    if (!d)
      continue;
    if (!r.includes(d)) {
      l.push(u);
      continue;
    }
    i ?? (i = n.getShapeGeometry(t)), s ?? (s = n.getShapePageTransform(t)), o ?? (o = s.applyToPoints(i.vertices));
    const f = n.getShapePageTransform(u).clone().invert().applyToPoints(o), { vertices: m, isClosed: v } = n.getShapeGeometry(u);
    if (!m.some((S) => yc(S, f))) {
      if (v) {
        if (pY(f, m))
          continue;
      } else if (o0e(f, m))
        continue;
      l.push(u);
    }
  }
  return l;
}
function DM(n, t, e = !1) {
  n.select(t), n.setEditingShape(t), n.setCurrentTool("select.editing_shape", {
    target: "shape",
    shape: t
  }), e && n.emit("select-all-text", { shapeId: t.id }), WY(n);
}
const dCe = 16;
function WY(n) {
  const t = n.getSelectionPageBounds(), e = n.getViewportPageBounds();
  if (t && !e.contains(t)) {
    const r = t.clone().expandBy(dCe / n.getZoomLevel()).expand(e), i = e.clone().translate({
      x: (r.center.x - e.center.x) * 2,
      y: (r.center.y - e.center.y) * 2
    });
    n.zoomToBounds(i, {
      animation: {
        duration: n.options.animationMediumMs
      },
      inset: 0
    });
  }
}
const hCe = 0, Or = 200, U2 = new O(Or / 2, Or / 2), GY = 10, fCe = (n) => [
  [
    ["a1"],
    new O(Or * 0.5, Or * -0.5 - n.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new O(Or * 1.5 + n.options.adjacentShapeMargin, Or * 0.5)
  ],
  // r
  [
    ["a3"],
    new O(Or * 0.5, Or * 1.5 + n.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new O(Or * -0.5 - n.options.adjacentShapeMargin, Or * 0.5)
  ]
  // l
];
function pCe(n, t) {
  if (t === 1) return fCe(n);
  const e = Or * t, r = n.options.adjacentShapeMargin * t;
  return [
    [["a1"], new O(e * 0.5, e * -0.5 - r)],
    // t
    [["a2"], new O(e * 1.5 + r, e * 0.5)],
    // r
    [["a3"], new O(e * 0.5, e * 1.5 + r)],
    // b
    [["a4"], new O(e * -0.5 - r, e * 0.5)]
    // l
  ];
}
function KY(n, t, e, r, i, s) {
  return Object.fromEntries(
    pCe(n, s).map(([o, l], u) => {
      const d = l.clone();
      return u === 0 && i ? d.y -= i : u === 2 && r && (d.y += r), [o, d.rot(e).add(t)];
    })
  );
}
function YY(n, t, e, r) {
  const i = new Set(n.getSelectedShapeIds()), s = (Or + n.options.adjacentShapeMargin + r) ** 2, o = /* @__PURE__ */ new Map(), l = [];
  for (const f of n.getCurrentPageShapes()) {
    if (!n.isShapeOfType(f, "note") || e !== f.props.scale || i.has(f.id))
      continue;
    const m = n.getShapePageTransform(f.id);
    t === m.rotation() && (o.set(f, n.getShapePageBounds(f).center), l.push(
      ...Object.values(
        KY(
          n,
          m.point(),
          t,
          f.props.growY,
          r,
          e
        )
      )
    ));
  }
  const u = l.length;
  let d;
  for (const [f, m] of o)
    for (let v = 0; v < u; v++)
      d = l[v], d && (O.Dist2(m, d) > s || n.isPointInShape(f, d) && (l[v] = void 0));
  return xn(l);
}
function XY(n, t, e, r, i = !1) {
  let s;
  const o = n.getCurrentPageShapesSorted(), l = (Or + n.options.adjacentShapeMargin ** 2) ** t.props.scale;
  for (let u = o.length - 1; u >= 0; u--) {
    const d = o[u];
    if (d.type === "note" && d.id !== t.id) {
      const f = n.getShapePageBounds(d);
      if (f && O.Dist2(f.center, e) < l && n.isPointInShape(d, e)) {
        s = d;
        break;
      }
    }
  }
  if (n.complete(), !s || i) {
    n.mark("creating note shape");
    const u = Ar();
    n.createShape({
      id: u,
      type: "note",
      x: e.x,
      y: e.y,
      rotation: r,
      opacity: t.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...t.props,
        // ...except for these values, which should reset to their defaults
        text: "",
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const d = n.getShape(u);
    if (!d) return;
    const f = n.getPointInParentSpace(
      d,
      O.Sub(
        e,
        O.Rot(U2.clone().mul(d.props.scale), r)
      )
    );
    n.updateShape({
      id: u,
      type: "note",
      x: f.x,
      y: f.y
    }), s = n.getShape(u);
  }
  return WY(n), s;
}
var MF;
let gCe = (MF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "dragged", !1);
    T(this, "info", {});
    T(this, "wasFocusedOnEnter", !1);
    T(this, "markId", "");
    T(this, "shape", {});
    T(this, "onEnter", () => {
      const { editor: e } = this;
      if (this.wasFocusedOnEnter = !e.getIsMenuOpen(), this.wasFocusedOnEnter) {
        const r = Ar();
        this.markId = `creating:${r}`, e.mark(this.markId);
        const i = this.editor.inputs.originPagePoint.clone(), s = g7(
          this.editor,
          i,
          this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
        );
        s && i.sub(s), this.shape = m7(this.editor, r, i);
      }
    });
    T(this, "onPointerMove", (e) => {
      if (this.editor.inputs.isDragging) {
        if (!this.wasFocusedOnEnter) {
          const r = Ar(), i = this.editor.inputs.originPagePoint.clone(), s = g7(
            this.editor,
            i,
            this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          );
          s && i.sub(s), this.shape = m7(this.editor, r, i);
        }
        this.editor.setCurrentTool("select.translating", {
          ...e,
          target: "shape",
          shape: this.shape,
          onInteractionEnd: "note",
          isCreating: !0,
          onCreate: () => {
            this.editor.setEditingShape(this.shape.id), this.editor.setCurrentTool("select.editing_shape");
          }
        });
      }
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
  }
  complete() {
    this.wasFocusedOnEnter && (this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : (this.editor.setEditingShape(this.shape.id), this.editor.setCurrentTool("select.editing_shape", {
      ...this.info,
      target: "shape",
      shape: this.shape
    })));
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}, T(MF, "id", "pointing"), MF);
function g7(n, t, e) {
  let r = GY / n.getZoomLevel(), i;
  for (const s of YY(n, 0, e, 0)) {
    const o = O.Sub(t, s), l = o.len();
    l < r && (r = l, i = o);
  }
  return i;
}
function m7(n, t, e) {
  n.createShape({
    id: t,
    type: "note",
    x: e.x,
    y: e.y,
    props: {
      scale: n.user.getIsDynamicResizeMode() ? 1 / n.getZoomLevel() : 1
    }
  }).select(t);
  const r = n.getShape(t), i = n.getShapeGeometry(r).bounds;
  return n.updateShapes([
    {
      id: t,
      type: "note",
      x: r.x - i.width / 2,
      y: r.y - i.height / 2
    }
  ]), n.getShape(t);
}
class uR extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "note");
  }
}
T(uR, "id", "note"), T(uR, "initial", "idle"), T(uR, "children", () => [uCe, gCe]);
function mCe(n) {
  const t = n.getShapeAtPoint(n.inputs.currentPagePoint, {
    hitInside: !1,
    hitLabels: !1,
    margin: n.options.hitTestMargin / n.getZoomLevel(),
    renderingOnly: !0
  });
  if (!t) return n.setHoveredShape(null);
  let e;
  const r = n.getOutermostSelectableShape(t);
  return r === t || r.id === n.getFocusedGroupId() || n.getSelectedShapeIds().includes(r.id) ? e = t : e = r, n.setHoveredShape(e.id);
}
const lp = sG(
  mCe,
  process.env.NODE_ENV === "test" ? 0 : 32
);
var DF;
let vCe = (DF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerMove", (e) => {
      switch (e.target) {
        case "shape":
        case "canvas":
          lp(this.editor);
      }
    });
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
    T(this, "onExit", () => {
      lp.cancel();
    });
    T(this, "onKeyDown", (e) => {
      var r;
      if (e.key === "Enter") {
        if (this.editor.getInstanceState().isReadonly) return null;
        const i = this.editor.getOnlySelectedShape();
        i && this.editor.getShapeUtil(i).canEdit(i) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(i.id), (r = this.editor.root.getCurrent()) == null || r.transition("editing_shape", {
          ...e,
          target: "shape",
          shape: i
        }));
      }
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(DF, "id", "idle"), DF);
var OF;
let yCe = (OF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shape");
    T(this, "markId", "");
    T(this, "onExit", () => {
      this.editor.setHintingShapes([]);
    });
    T(this, "onPointerMove", (e) => {
      if (this.editor.inputs.isDragging) {
        const {
          inputs: { originPagePoint: r }
        } = this.editor, i = Ar();
        this.markId = `creating:${i}`, this.editor.mark(this.markId);
        const s = this.createTextShape(i, r, !1);
        if (!s) {
          this.cancel();
          return;
        }
        this.shape = this.editor.getShape(s), this.editor.select(i), this.editor.setCurrentTool("select.resizing", {
          ...e,
          target: "selection",
          handle: "right",
          isCreating: !0,
          creationCursorOffset: { x: 18, y: 1 },
          onInteractionEnd: "text",
          onCreate: () => {
            this.editor.setEditingShape(s.id), this.editor.setCurrentTool("select.editing_shape");
          }
        });
      }
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  complete() {
    var s;
    this.editor.mark("creating text shape");
    const e = Ar(), { currentPagePoint: r } = this.editor.inputs;
    this.createTextShape(e, r, !0) && (this.editor.select(e), this.editor.setEditingShape(e), this.editor.setCurrentTool("select"), (s = this.editor.root.getCurrent()) == null || s.transition("editing_shape"));
  }
  cancel() {
    this.parent.transition("idle"), this.editor.bailToMark(this.markId);
  }
  createTextShape(e, r, i) {
    this.editor.createShape({
      id: e,
      type: "text",
      x: r.x,
      y: r.y,
      props: {
        text: "",
        autoSize: i,
        w: 20,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const s = this.editor.getShape(e);
    if (!s) {
      this.cancel();
      return;
    }
    const o = this.editor.getShapePageBounds(s), l = new O();
    if (i)
      switch (s.props.textAlign) {
        case "start": {
          l.x = 0;
          break;
        }
        case "middle": {
          l.x = -o.width / 2;
          break;
        }
        case "end": {
          l.x = -o.width;
          break;
        }
      }
    else
      l.x = 0;
    if (l.y = -o.height / 2, kl(s.parentId)) {
      const u = this.editor.getShapeParentTransform(s);
      l.rot(-u.rotation());
    }
    return this.editor.updateShape({
      ...s,
      x: s.x + l.x,
      y: s.y + l.y
    }), s;
  }
}, T(OF, "id", "pointing"), OF);
class JE extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeType", "text");
  }
}
T(JE, "id", "text"), T(JE, "initial", "idle"), T(JE, "children", () => [vCe, yCe]), T(JE, "isLockable", !1);
const SCe = [
  JE,
  ZE,
  lR,
  uR,
  cR,
  A3,
  aR,
  QE
];
function uu() {
  return Pp({ isDarkMode: KT() });
}
function B2(n) {
  return {
    key: `${Ph.id}:${n}`,
    getElement: async () => {
      const t = bCe(n);
      if (!t) return null;
      const e = t.$$_url, r = t.$$_fontface;
      if (!e || !r) return null;
      const i = await (await Th(e)).blob(), s = await Xy.blobToDataUrl(i), o = r.replace(e, s);
      return /* @__PURE__ */ y.jsx("style", { children: o });
    }
  };
}
function bCe(n) {
  const t = UG[n];
  for (const e of document.fonts)
    if (t.includes(e.family))
      return e;
  return null;
}
function L5(n) {
  return {
    key: `${Ph.id}:${n}`,
    getElement: async () => n !== "pattern" ? null : /* @__PURE__ */ y.jsx(xCe, {})
  };
}
function xCe() {
  const n = uu(), t = 8 / 12;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs("mask", { id: "hash_pattern_mask", children: [
      /* @__PURE__ */ y.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      /* @__PURE__ */ y.jsxs("g", { strokeLinecap: "round", stroke: "black", children: [
        /* @__PURE__ */ y.jsx("line", { x1: t * 1, y1: t * 3, x2: t * 3, y2: t * 1 }),
        /* @__PURE__ */ y.jsx("line", { x1: t * 5, y1: t * 7, x2: t * 7, y2: t * 5 }),
        /* @__PURE__ */ y.jsx("line", { x1: t * 9, y1: t * 11, x2: t * 11, y2: t * 9 })
      ] })
    ] }),
    /* @__PURE__ */ y.jsx(
      "pattern",
      {
        id: OM(1, n.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ y.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: n.solid, mask: "url(#hash_pattern_mask)" })
      }
    )
  ] });
}
function j5() {
  return {
    key: `${Ph.id}:pattern`,
    component: _Ce
  };
}
const e1 = 8, v7 = (n, t, e) => new Promise((r, i) => {
  const s = e1 * t * n, o = document.createElement("canvas");
  o.width = s, o.height = s;
  const l = o.getContext("2d");
  if (!l) return;
  l.fillStyle = e ? vM.darkMode.solid : vM.lightMode.solid, l.fillRect(0, 0, s, s), l.globalCompositeOperation = "destination-out", l.lineCap = "round", l.lineWidth = 1.25 * t * n;
  const u = 8 / 12, d = (f) => f * t * n;
  l.beginPath(), l.moveTo(d(u * 1), d(u * 3)), l.lineTo(d(u * 3), d(u * 1)), l.moveTo(d(u * 5), d(u * 7)), l.lineTo(d(u * 7), d(u * 5)), l.moveTo(d(u * 9), d(u * 11)), l.lineTo(d(u * 11), d(u * 9)), l.stroke(), o.toBlob((f) => {
    !f || qi.throwToBlob.get() ? i() : r(f);
  });
}), y7 = (n, t) => {
  const e = document.createElement("canvas");
  e.width = n[0], e.height = n[1];
  const r = e.getContext("2d");
  return r ? (t(r), e.toDataURL()) : "";
};
let KN = null;
function wCe() {
  return KN || (KN = {
    white: y7([1, 1], (n) => {
      n.fillStyle = "#f8f9fa", n.fillRect(0, 0, 1, 1);
    }),
    black: y7([1, 1], (n) => {
      n.fillStyle = "#212529", n.fillRect(0, 0, 1, 1);
    })
  }), KN;
}
function qY(n) {
  return Math.ceil(Math.log2(Math.max(1, n)));
}
function OM(n, t) {
  const e = qY(n);
  return `tldraw_hash_pattern_${t}_${e}`;
}
function ZY(n) {
  const t = [], r = qY(n);
  for (let i = 0; i <= r; i++)
    t.push(Math.pow(2, i));
  return t;
}
function CCe(n) {
  const t = wCe();
  return ZY(n).flatMap((e) => [
    { zoom: e, url: t.white, theme: "light" },
    { zoom: e, url: t.black, theme: "dark" }
  ]);
}
function ECe() {
  const n = we(), t = De("devicePixelRatio", () => n.getInstanceState().devicePixelRatio, [
    n
  ]), e = De("maxZoom", () => Math.ceil(Io(n.getCameraOptions().zoomSteps)), [
    n
  ]), [r, i] = D.useState(!1), [s, o] = D.useState(
    () => CCe(e)
  );
  return D.useEffect(() => {
    if (process.env.NODE_ENV === "test") {
      i(!0);
      return;
    }
    const u = Promise.all(
      ZY(e).flatMap((f) => [
        v7(t, f, !1).then((m) => ({
          zoom: f,
          theme: "light",
          url: URL.createObjectURL(m)
        })),
        v7(t, f, !0).then((m) => ({
          zoom: f,
          theme: "dark",
          url: URL.createObjectURL(m)
        }))
      ])
    );
    let d = !1;
    return u.then((f) => {
      d || (o(f), i(!0));
    }), () => {
      d = !0, i(!1), u.then((f) => {
        for (const { url: m } of f)
          URL.revokeObjectURL(m);
      });
    };
  }, [t, e]), { defs: /* @__PURE__ */ y.jsx(y.Fragment, { children: s.map((u) => {
    const d = OM(u.zoom, u.theme);
    return /* @__PURE__ */ y.jsx(
      "pattern",
      {
        id: d,
        width: e1,
        height: e1,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ y.jsx("image", { href: u.url, width: e1, height: e1 })
      },
      d
    );
  }) }), isReady: r };
}
function _Ce() {
  const n = we(), t = D.useRef(null), { defs: e, isReady: r } = ECe();
  return D.useEffect(() => {
    if (r && n.environment.isSafari) {
      const i = QY(t.current);
      i && n.timers.requestAnimationFrame(() => {
        i.style.display = "none", n.timers.requestAnimationFrame(() => {
          i.style.display = "";
        });
      });
    }
  }, [n, r]), /* @__PURE__ */ y.jsx("g", { ref: t, "data-testid": r ? "ready-pattern-fill-defs" : void 0, children: e });
}
function QY(n) {
  return n.classList.contains("tl-html-layer") ? n : n.parentElement ? QY(n.parentElement) : null;
}
const ua = Gn.memo(function({
  theme: t,
  d: e,
  color: r,
  fill: i,
  scale: s
}) {
  switch (i) {
    case "none":
      return null;
    case "solid":
      return /* @__PURE__ */ y.jsx("path", { fill: t[r].semi, d: e });
    case "semi":
      return /* @__PURE__ */ y.jsx("path", { fill: t.solid, d: e });
    case "fill":
      return /* @__PURE__ */ y.jsx("path", { fill: t[r].fill, d: e });
    case "pattern":
      return /* @__PURE__ */ y.jsx(TCe, { theme: t, color: r, fill: i, d: e, scale: s });
  }
});
function TCe({ d: n, color: t, theme: e }) {
  const r = we(), i = SY(), s = De("zoomLevel", () => r.getZoomLevel(), [r]), o = r.getZoomLevel() <= 0.18;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx("path", { fill: e[t].pattern, d: n }),
    /* @__PURE__ */ y.jsx(
      "path",
      {
        fill: i ? `url(#${OM(1, e.id)})` : o ? e[t].semi : `url(#${OM(s, e.id)})`,
        d: n
      }
    )
  ] });
}
function PCe(n) {
  return n.replace(/\s/g, " ");
}
function k3(n, t, e) {
  const { padding: r = 0 } = e;
  if (t.length === 0) return null;
  const i = vt.From(t[0].box);
  for (const { box: d } of t)
    i.union(d);
  const s = r + (e.offsetX ?? 0), o = (e.offsetY ?? 0) + e.fontSize / 2 + (e.verticalTextAlign === "start" ? r : e.verticalTextAlign === "end" ? e.height - r - i.height : (Math.ceil(e.height) - i.height) / 2);
  let l = null;
  const u = [];
  for (const { text: d, box: f } of t)
    l !== null && f.y > l && u.push(
      /* @__PURE__ */ y.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: s,
          y: f.y + o,
          children: `
`
        },
        u.length
      )
    ), u.push(
      /* @__PURE__ */ y.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: f.x + s,
          y: f.y + o,
          unicodeBidi: "plaintext",
          children: PCe(d)
        },
        u.length
      )
    ), l = f.y;
  return /* @__PURE__ */ y.jsx(
    "text",
    {
      fontSize: e.fontSize,
      fontFamily: e.fontFamily,
      fontStyle: e.fontStyle,
      fontWeight: e.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: e.stroke,
      strokeWidth: e.strokeWidth,
      fill: e.fill,
      children: u
    }
  );
}
function ACe(n, t, e, r) {
  if ((n === "start-legacy" || n === "end-legacy") && e.length !== 0) {
    const i = vt.From(e[0].box);
    for (const { box: s } of e)
      i.union(s);
    if (n === "start-legacy")
      return (r - 2 * t - i.width) / 2;
    if (n === "end-legacy")
      return -(r - 2 * t - i.width) / 2;
  }
}
function kCe(n) {
  return n === "start-legacy" || n === "middle-legacy" || n === "end-legacy";
}
function H2({
  fontSize: n,
  font: t,
  align: e,
  verticalAlign: r,
  text: i,
  labelColor: s,
  bounds: o,
  padding: l = 16,
  stroke: u = !0
}) {
  const d = we(), f = uu(), m = {
    fontSize: n,
    fontFamily: UG[t],
    textAlign: e,
    verticalTextAlign: r,
    width: Math.ceil(o.width),
    height: Math.ceil(o.height),
    padding: l,
    lineHeight: Oo.lineHeight,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "wrap",
    offsetX: 0,
    offsetY: 0,
    fill: s,
    stroke: void 0,
    strokeWidth: void 0
  }, v = d.textMeasure.measureTextSpans(i, m), S = ACe(e, l, v, o.width);
  S && (m.offsetX = S), m.offsetX += o.x, m.offsetY += o.y;
  const w = k3(d, v, m);
  let E = null;
  return u && (m.fill = f.background, m.stroke = f.background, m.strokeWidth = 2, E = k3(d, v, m)), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    E,
    w
  ] });
}
const ICe = D.forwardRef(function({
  isEditing: t,
  text: e,
  handleFocus: r,
  handleChange: i,
  handleKeyDown: s,
  handleBlur: o,
  handleInputPointerDown: l,
  handleDoubleClick: u
}, d) {
  return /* @__PURE__ */ y.jsx(
    "textarea",
    {
      ref: d,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      readOnly: !t,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: e,
      onFocus: r,
      onChange: i,
      onKeyDown: s,
      onBlur: o,
      onTouchEnd: to,
      onContextMenu: t ? to : void 0,
      onPointerDown: l,
      onDoubleClick: u,
      onDragStart: qn
    }
  );
});
function RCe(n, t, e) {
  const r = we(), i = D.useRef(null), s = De("isEditing", () => r.getEditingShapeId() === n, [r]), o = De("isEditingAnything", () => !!r.getEditingShapeId(), [
    r
  ]);
  D.useEffect(() => {
    function f({ shapeId: m }) {
      var v;
      m === n && ((v = i.current) == null || v.select());
    }
    return r.on("select-all-text", f), () => {
      r.off("select-all-text", f);
    };
  }, [r, n, s]), D.useEffect(() => {
    var f, m, v, S;
    s && (document.activeElement !== i.current && ((f = i.current) == null || f.focus()), r.getInstanceState().isCoarsePointer && ((m = i.current) == null || m.select()), r.environment.isSafari && ((v = i.current) == null || v.blur(), (S = i.current) == null || S.focus()));
  }, [r, s]);
  const l = D.useCallback(
    (f) => {
      if (r.getEditingShapeId() === n)
        switch (f.key) {
          case "Enter": {
            (f.ctrlKey || f.metaKey) && r.complete();
            break;
          }
        }
    },
    [r, n]
  ), u = D.useCallback(
    (f) => {
      if (r.getEditingShapeId() !== n) return;
      let m = Jx.normalizeText(f.currentTarget.value);
      const v = m.replace(/\t/g, B0);
      if (v !== m) {
        const S = f.currentTarget.selectionStart;
        f.currentTarget.value = v, f.currentTarget.selectionStart = S + (v.length - m.length), f.currentTarget.selectionEnd = S + (v.length - m.length), m = v;
      }
      r.updateShape({
        id: n,
        type: t,
        props: { text: m }
      });
    },
    [r, n, t]
  ), d = D.useCallback(
    (f) => {
      r.dispatch({
        ...Ol(f),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: r.getShape(n)
      }), to(f);
    },
    [r, n]
  );
  return {
    rInput: i,
    handleFocus: F1,
    handleBlur: F1,
    handleKeyDown: l,
    handleChange: u,
    handleInputPointerDown: d,
    handleDoubleClick: to,
    isEmpty: e.trim().length === 0,
    isEditing: s,
    isEditingAnything: o
  };
}
const V2 = Gn.memo(function({
  id: t,
  type: e,
  text: r,
  labelColor: i,
  font: s,
  fontSize: o,
  lineHeight: l,
  align: u,
  verticalAlign: d,
  wrap: f,
  isSelected: m,
  padding: v = 0,
  onKeyDown: S,
  classNamePrefix: w,
  style: E,
  textWidth: A,
  textHeight: P
}) {
  const { rInput: R, isEmpty: M, isEditing: j, isEditingAnything: $, ...U } = RCe(
    t,
    e,
    r
  ), [F, B] = D.useState(r);
  D.useEffect(() => {
    j || B(r);
  }, [j, r]);
  const G = Jx.normalizeTextForDom(r), X = G.length > 0, te = kCe(u);
  if (!j && !X)
    return null;
  const ne = w || "tl-text";
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      className: `${ne}-label tl-text-wrapper`,
      "data-font": s,
      "data-align": u,
      "data-hastext": !M,
      "data-isediting": j,
      "data-iseditinganything": $,
      "data-textwrap": !!f,
      "data-isselected": m,
      style: {
        justifyContent: u === "middle" || te ? "center" : u,
        alignItems: d === "middle" ? "center" : d,
        padding: v,
        ...E
      },
      children: /* @__PURE__ */ y.jsxs(
        "div",
        {
          className: `${ne}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize: o,
            lineHeight: Math.floor(o * l) + "px",
            minHeight: Math.floor(o * l) + "px",
            minWidth: Math.ceil(A || 0),
            color: i,
            width: A ? Math.ceil(A) : void 0,
            height: P ? Math.ceil(P) : void 0
          },
          children: [
            /* @__PURE__ */ y.jsx("div", { className: `${ne} tl-text tl-text-content`, dir: "auto", children: G.split(`
`).map((K, Z) => /* @__PURE__ */ y.jsx("div", { dir: "auto", children: K }, Z)) }),
            ($ || m) && /* @__PURE__ */ y.jsx(
              ICe,
              {
                ref: R,
                text: r,
                isEditing: j,
                ...U,
                handleKeyDown: S ?? U.handleKeyDown
              },
              F
            )
          ]
        }
      )
    }
  );
});
function fh(n, t, e = {}) {
  const {
    closed: r = !1,
    snap: i = 1,
    start: s = "outset",
    end: o = "outset",
    lengthRatio: l = 2,
    style: u = "dashed"
  } = e;
  let d = 0, f = 0, m = 1, v = 0, S = 0;
  switch (u) {
    case "dashed": {
      m = 1, d = Math.min(t * l, n / 4);
      break;
    }
    case "dotted": {
      m = 100, d = t / m;
      break;
    }
    default:
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
  }
  return r || (s === "outset" ? (n += d / 2, S += d / 2) : s === "skip" && (n -= d, S -= d), o === "outset" ? n += d / 2 : o === "skip" && (n -= d)), f = Math.floor(n / d / (2 * m)), f -= f % i, f < 3 && u === "dashed" ? n / t < 4 ? (d = n, f = 1, v = 0) : (d = n * (1 / 3), v = n * (1 / 3)) : (d = n / f / (2 * m), r ? (S = d / 2, v = (n - f * d) / f) : v = (n - f * d) / Math.max(1, f - 1)), {
    strokeDasharray: [d, v].join(" "),
    strokeDashoffset: S.toString()
  };
}
const S7 = /* @__PURE__ */ new WeakMap();
function N5(n, t) {
  const e = S7.get(t);
  if (e) return e;
  const r = yh(n, t);
  let i = 0, s = 0;
  const o = r.isStraight ? new ap({
    start: O.From(r.start.point),
    end: O.From(r.end.point)
  }) : new F0({
    center: O.Cast(r.handleArc.center),
    start: O.Cast(r.start.point),
    end: O.Cast(r.end.point),
    sweepFlag: r.bodyArc.sweepFlag,
    largeArcFlag: r.bodyArc.largeArcFlag
  });
  if (t.props.text.trim()) {
    const u = o.bounds, d = I3(t), { w: f, h: m } = n.textMeasure.measureText(t.props.text, {
      ...Oo,
      fontFamily: Ch[t.props.font],
      fontSize: d,
      maxWidth: null
    });
    if (i = f, s = m, u.width > u.height) {
      i = Math.max(Math.min(f, 64), Math.min(u.width - 64, f));
      const { w: v, h: S } = n.textMeasure.measureText(
        t.props.text,
        {
          ...Oo,
          fontFamily: Ch[t.props.font],
          fontSize: d,
          maxWidth: i
        }
      );
      i = v, s = S;
    }
    if (i > 16 * d) {
      i = 16 * d;
      const { w: v, h: S } = n.textMeasure.measureText(
        t.props.text,
        {
          ...Oo,
          fontFamily: Ch[t.props.font],
          fontSize: d,
          maxWidth: i
        }
      );
      i = v, s = S;
    }
  }
  const l = new O(i, s).addScalar(Awe * 2 * t.props.scale);
  return S7.set(t, l), l;
}
function JY(n) {
  const t = eo[n.props.size];
  return (Pwe + (t - eo.s) * 2 + (t === eo.xl ? 20 : 0)) * n.props.scale;
}
function MCe(n, t, e) {
  const r = N5(n, t), i = JY(t), s = O.Nudge(e.start.point, e.end.point, i), o = O.Nudge(e.end.point, e.start.point, i), l = x5(
    s,
    o,
    vt.FromCenter(e.middle, r).corners
  );
  if (!l || l.length !== 2)
    return { start: 0.5, end: 0.5 };
  let [u, d] = l;
  O.Dist2(u, s) > O.Dist2(d, s) && ([d, u] = l);
  const f = s.add(O.Sub(e.middle, u)), m = o.add(O.Sub(e.middle, d)), v = O.Dist(e.start.point, f) / e.length, S = O.Dist(e.start.point, m) / e.length;
  return { start: v, end: S };
}
function DCe(n, t, e) {
  const r = N5(n, t), i = JY(t), s = Math.sign(t.props.bend), o = i / e.handleArc.radius * s, l = O.Angle(e.bodyArc.center, e.start.point) - o, u = O.Angle(e.bodyArc.center, e.end.point) + o, d = nS(e.bodyArc.center, e.bodyArc.radius, l), f = nS(e.bodyArc.center, e.bodyArc.radius, u), m = [], v = b7(
    e.bodyArc.center,
    e.bodyArc.radius,
    l,
    u,
    s,
    vt.FromCenter(d, r).corners
  );
  m.push(
    new Xi({
      points: vt.FromCenter(d, r).corners,
      debugColor: "lime",
      isFilled: !1,
      ignore: !0
    })
  );
  const S = b7(
    e.bodyArc.center,
    e.bodyArc.radius,
    l,
    u,
    s,
    vt.FromCenter(f, r).corners
  );
  m.push(
    new Xi({
      points: vt.FromCenter(f, r).corners,
      debugColor: "lime",
      isFilled: !1,
      ignore: !0
    })
  );
  for (const F of [
    ...v ?? [],
    ...S ?? [],
    d,
    f
  ])
    m.push(
      new R5({
        x: F.x - 3,
        y: F.y - 3,
        radius: 3,
        isFilled: !1,
        debugColor: "magenta",
        ignore: !0
      })
    );
  const w = (v && x7(e.start.point, v)) ?? e.middle, E = (S && x7(e.end.point, S)) ?? e.middle, A = O.Angle(e.bodyArc.center, e.start.point), P = O.Angle(e.bodyArc.center, e.end.point), R = O.Angle(e.bodyArc.center, w), M = O.Angle(e.bodyArc.center, E);
  if (Bg(A, R, s) > Bg(A, M, s))
    return { start: 0.5, end: 0.5, dbg: m };
  const j = Bg(A, P, s), $ = Bg(A, R, s) / j, U = Bg(A, M, s) / j;
  return { start: $, end: U, dbg: m };
}
function dR(n, t) {
  let e;
  const r = [], i = yh(n, t), s = !!i.bindings.start, o = !!i.bindings.end, l = i.start.arrowhead !== "none", u = i.end.arrowhead !== "none";
  if (i.isStraight) {
    const f = MCe(n, t, i);
    let m = Zs(
      t.props.labelPosition,
      l || s ? f.start : 0,
      u || o ? f.end : 1
    );
    m = m >= 0.48 && m <= 0.52 ? 0.5 : m, e = O.Lrp(i.start.point, i.end.point, m);
  } else {
    const f = DCe(n, t, i);
    f.dbg && r.push(...f.dbg);
    let m = Zs(
      t.props.labelPosition,
      l || s ? f.start : 0,
      u || o ? f.end : 1
    );
    m = m >= 0.48 && m <= 0.52 ? 0.5 : m;
    const v = OCe(
      O.Angle(i.bodyArc.center, i.start.point),
      O.Angle(i.bodyArc.center, i.end.point),
      Math.sign(t.props.bend),
      m
    );
    e = nS(i.bodyArc.center, i.bodyArc.radius, v);
  }
  const d = N5(n, t);
  return { box: vt.FromCenter(e, d), debugGeom: r };
}
function b7(n, t, e, r, i, s) {
  const o = x3(n, t, s), l = Bg(e, r, i);
  return o == null ? void 0 : o.filter((u) => {
    const d = Bg(e, O.Angle(n, u), i);
    return d >= 0 && d <= l;
  });
}
function x7(n, t) {
  let e = null, r = -1 / 0;
  for (const i of t) {
    const s = O.Dist2(n, i);
    s > r && (e = i, r = s);
  }
  return e;
}
function OCe(n, t, e, r) {
  const i = Bg(n, t, e);
  return n + i * r * e * -1;
}
function I3(n) {
  return Twe[n.props.size] * n.props.scale;
}
function LCe(n, t, e) {
  const r = t === "end" ? n.end.point : n.start.point, i = t === "end" ? n.start.point : n.end.point, s = n.isStraight ? O.Dist(i, r) : Math.abs(n.bodyArc.length), o = Math.max(Math.min(s / 5, e * 3), e);
  let l;
  if (n.isStraight)
    l = O.Nudge(r, i, o);
  else {
    const u = i0e(r, o, n.handleArc.center, n.handleArc.radius);
    l = t === "end" ? n.handleArc.sweepFlag ? u[0] : u[1] : n.handleArc.sweepFlag ? u[1] : u[0];
  }
  return O.IsNaN(l) && (l = n.start.point), {
    point: r,
    int: l
  };
}
function jCe({ point: n, int: t }) {
  const e = O.RotWith(t, n, cr / 6), r = O.RotWith(t, n, -cr / 6);
  return `M ${e.x} ${e.y} L ${n.x} ${n.y} L ${r.x} ${r.y}`;
}
function NCe({ point: n, int: t }) {
  const e = O.RotWith(t, n, cr / 6), r = O.RotWith(t, n, -cr / 6);
  return `M ${e.x} ${e.y} L ${n.x} ${n.y} L ${r.x} ${r.y} Z`;
}
function FCe({ point: n, int: t }) {
  const e = O.Sub(t, n).div(2), r = O.Add(n, O.Rot(e, ri)), i = O.Sub(n, O.Rot(e, ri));
  return `M ${r.x} ${r.y} L ${t.x} ${t.y} L ${i.x} ${i.y} Z`;
}
function $Ce({ point: n, int: t }) {
  const e = O.Lrp(n, t, 0.45), r = O.Dist(e, n);
  return `M ${e.x - r},${e.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function zCe({ point: n, int: t }) {
  const e = O.Lrp(n, t, 0.75), r = O.RotWith(e, n, cr / 4), i = O.RotWith(e, n, -cr / 4), s = O.Lrp(r, i, 0.5);
  return s.add(O.Sub(s, n)), `M ${s.x} ${s.y} L ${r.x} ${r.y} ${n.x} ${n.y} L ${i.x} ${i.y} Z`;
}
function UCe({ int: n, point: t }) {
  const e = O.Lrp(t, n, 0.85), r = O.Sub(e, t).div(2), i = O.Add(t, O.Rot(r, ri)), s = O.Sub(t, O.Rot(r, ri)), o = O.Add(e, O.Rot(r, ri)), l = O.Sub(e, O.Rot(r, ri));
  return `M ${i.x} ${i.y} L ${o.x} ${o.y} L ${l.x} ${l.y} L ${s.x} ${s.y} Z`;
}
function BCe({ int: n, point: t }) {
  const e = O.Sub(n, t).div(2), r = O.Add(t, O.Rot(e, ri)), i = O.Sub(t, O.Rot(e, ri));
  return `M ${r.x} ${r.y} L ${i.x} ${i.y}`;
}
function LM(n, t, e) {
  const r = t === "end" ? n.end.arrowhead : n.start.arrowhead;
  if (r === "none") return;
  const i = LCe(n, t, e);
  if (i) {
    switch (r) {
      case "bar":
        return BCe(i);
      case "square":
        return UCe(i);
      case "diamond":
        return zCe(i);
      case "dot":
        return $Ce(i);
      case "inverted":
        return FCe(i);
      case "arrow":
        return jCe(i);
      case "triangle":
        return NCe(i);
    }
    return "";
  }
}
function HCe(n) {
  const {
    start: t,
    end: e,
    handleArc: { radius: r, largeArcFlag: i, sweepFlag: s }
  } = n;
  return `M${t.handle.x},${t.handle.y} A${r} ${r} 0 ${i} ${s} ${e.handle.x},${e.handle.y}`;
}
function eX(n) {
  const {
    start: t,
    end: e,
    bodyArc: { radius: r, largeArcFlag: i, sweepFlag: s }
  } = n;
  return `M${t.point.x},${t.point.y} A${r} ${r} 0 ${i} ${s} ${e.point.x},${e.point.y}`;
}
function tX(n, t) {
  return `M${n.x},${n.y}L${t.x},${t.y}`;
}
function VCe(n) {
  return tX(n.start.handle, n.end.handle);
}
function nX(n) {
  return tX(n.start.point, n.end.point);
}
let WCe = 0;
class hR extends ad {
  constructor() {
    super(...arguments);
    T(this, "canEdit", () => !0);
    T(this, "canSnap", () => !1);
    T(this, "hideResizeHandles", () => !0);
    T(this, "hideRotateHandle", () => !0);
    T(this, "hideSelectionBoundsBg", () => !0);
    T(this, "hideSelectionBoundsFg", () => !0);
    T(this, "canBeLaidOut", (e) => {
      const r = Ml(this.editor, e);
      return !r.start && !r.end;
    });
    T(this, "onHandleDrag", (e, { handle: r, isPrecise: i }) => {
      const s = r.id, o = Ml(this.editor, e);
      if (s === "middle") {
        const { start: U, end: F } = $0(this.editor, e, o), B = O.Sub(F, U), G = O.Per(B), X = O.Med(F, U), te = O.Sub(X, G), ne = O.Add(X, G), K = O.NearestPointOnLineSegment(te, ne, r, !1);
        let Z = O.Dist(K, X);
        return O.Clockwise(K, F, X) && (Z *= -1), { id: e.id, type: e.type, props: { bend: Z } };
      }
      const l = { id: e.id, type: "arrow", props: {} }, u = o[s], f = o[s === "start" ? "end" : "start"];
      if (this.editor.inputs.ctrlKey)
        return sR(this.editor, e, s), l.props[s] = {
          x: r.x,
          y: r.y
        }, l;
      const m = this.editor.getShapePageTransform(e.id).applyToPoint(r), v = this.editor.getShapeAtPoint(m, {
        hitInside: !0,
        hitFrameInside: !0,
        margin: 0,
        filter: (U) => !U.isLocked && this.editor.canBindShapes({ fromShape: e, toShape: U, binding: "arrow" })
      });
      if (!v)
        return sR(this.editor, e, s), l.props[s] = {
          x: r.x,
          y: r.y
        }, l;
      const S = this.editor.getShapeGeometry(v), w = vt.ZeroFix(S.bounds), A = this.editor.getShapePageTransform(l.id).applyToPoint(r), P = this.editor.getPointInShapeSpace(v, A);
      let R = i;
      R || (!u || u && v.id !== u.toId) && (R = this.editor.inputs.pointerVelocity.len() < 0.5), i || (S.isClosed || (R = !0), f && v.id === f.toId && f.props.isPrecise && (R = !0));
      const M = {
        x: (P.x - w.minX) / w.width,
        y: (P.y - w.minY) / w.height
      };
      R && O.Dist(P, w.center) < Math.max(4, Math.min(Math.min(w.width, w.height) * 0.15, 16)) / this.editor.getZoomLevel() && (M.x = 0.5, M.y = 0.5);
      const j = {
        terminal: s,
        normalizedAnchor: M,
        isPrecise: R,
        isExact: this.editor.inputs.altKey
      };
      OE(this.editor, e, v.id, j), this.editor.setHintingShapes([v.id]);
      const $ = Ml(this.editor, e);
      return $.start && $.end && $.start.toId === $.end.toId && O.Equals($.start.props.normalizedAnchor, $.end.props.normalizedAnchor) && OE(this.editor, e, $.end.toId, {
        ...$.end.props,
        normalizedAnchor: {
          x: $.end.props.normalizedAnchor.x + 0.05,
          y: $.end.props.normalizedAnchor.y
        }
      }), l;
    });
    T(this, "onTranslateStart", (e) => {
      const r = Ml(this.editor, e), i = $0(this.editor, e, r), s = this.editor.getShapePageTransform(e.id), o = this.editor.getSelectedShapeIds();
      if (!(r.start && (o.includes(r.start.toId) || this.editor.isAncestorSelected(r.start.toId)) || r.end && (o.includes(r.end.toId) || this.editor.isAncestorSelected(r.end.toId)))) {
        C7.set(e, {
          pagePosition: s.applyToPoint(e),
          terminalBindings: NT(i, (l, u) => {
            const d = r[l];
            return d ? {
              binding: d,
              shapePosition: u,
              pagePosition: s.applyToPoint(u)
            } : null;
          })
        }), r.start && (MM({
          editor: this.editor,
          arrow: e,
          terminal: "start",
          useHandle: !0
        }), e = this.editor.getShape(e.id)), r.end && MM({
          editor: this.editor,
          arrow: e,
          terminal: "end",
          useHandle: !0
        });
        for (const l of [
          "start",
          "end"
          /* END */
        ]) {
          const u = r[l];
          u && this.editor.updateBinding({
            ...u,
            props: { ...u.props, isPrecise: !0 }
          });
        }
      }
    });
    T(this, "onTranslate", (e, r) => {
      const i = C7.get(e);
      if (!i) return;
      const s = this.editor.getShapePageTransform(r.id), o = O.Sub(
        s.applyToPoint(r),
        i.pagePosition
      );
      for (const l of Object.values(i.terminalBindings)) {
        if (!l) continue;
        const u = O.Add(l.pagePosition, O.Mul(o, 0.5)), d = this.editor.getShapeAtPoint(u, {
          hitInside: !0,
          hitFrameInside: !0,
          margin: 0,
          filter: (f) => !f.isLocked && this.editor.canBindShapes({ fromShape: r, toShape: f, binding: "arrow" })
        });
        if ((d == null ? void 0 : d.id) === l.binding.toId) {
          const f = vt.ZeroFix(this.editor.getShapeGeometry(d).bounds), m = this.editor.getPointInShapeSpace(d, u), v = {
            x: (m.x - f.minX) / f.width,
            y: (m.y - f.minY) / f.height
          };
          OE(this.editor, r, d.id, {
            ...l.binding.props,
            normalizedAnchor: v,
            isPrecise: !0
          });
        } else
          sR(this.editor, r, l.binding.props.terminal);
      }
    });
    T(this, "_resizeInitialBindings", new vp());
    T(this, "onResize", (e, r) => {
      const { scaleX: i, scaleY: s } = r, o = this._resizeInitialBindings.get(
        e,
        () => Ml(this.editor, e)
      ), l = $0(this.editor, e, o), { start: u, end: d } = ni(e.props);
      let { bend: f } = e.props;
      o.start || (u.x = l.start.x * i, u.y = l.start.y * s), o.end || (d.x = l.end.x * i, d.y = l.end.y * s);
      const m = Math.abs(i), v = Math.abs(s), S = o != null && o.start ? O.From(o.start.props.normalizedAnchor) : null, w = o != null && o.end ? O.From(o.end.props.normalizedAnchor) : null;
      return i < 0 && s >= 0 ? (f !== 0 && (f *= -1, f *= Math.max(m, v)), S && (S.x = 1 - S.x), w && (w.x = 1 - w.x)) : i >= 0 && s < 0 ? (f !== 0 && (f *= -1, f *= Math.max(m, v)), S && (S.y = 1 - S.y), w && (w.y = 1 - w.y)) : i >= 0 && s >= 0 ? f !== 0 && (f *= Math.max(m, v)) : i < 0 && s < 0 && (f !== 0 && (f *= Math.max(m, v)), S && (S.x = 1 - S.x, S.y = 1 - S.y), w && (w.x = 1 - w.x, w.y = 1 - w.y)), o.start && S && OE(this.editor, e, o.start.toId, {
        ...o.start.props,
        normalizedAnchor: S.toJson()
      }), o.end && w && OE(this.editor, e, o.end.toId, {
        ...o.end.props,
        normalizedAnchor: w.toJson()
      }), {
        props: {
          start: u,
          end: d,
          bend: f
        }
      };
    });
    T(this, "onDoubleClickHandle", (e, r) => {
      switch (r.id) {
        case "start":
          return {
            id: e.id,
            type: e.type,
            props: {
              ...e.props,
              arrowheadStart: e.props.arrowheadStart === "none" ? "arrow" : "none"
            }
          };
        case "end":
          return {
            id: e.id,
            type: e.type,
            props: {
              ...e.props,
              arrowheadEnd: e.props.arrowheadEnd === "none" ? "arrow" : "none"
            }
          };
      }
    });
    T(this, "onEditEnd", (e) => {
      const {
        id: r,
        type: i,
        props: { text: s }
      } = e;
      s.trimEnd() !== e.props.text && this.editor.updateShapes([
        {
          id: r,
          type: i,
          props: {
            text: s.trimEnd()
          }
        }
      ]);
    });
  }
  canBind({ toShapeType: e }) {
    return e !== "arrow";
  }
  getDefaultProps() {
    return {
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(e) {
    const r = yh(this.editor, e), i = [], s = r.isStraight ? new ap({
      start: O.From(r.start.point),
      end: O.From(r.end.point)
    }) : new F0({
      center: O.Cast(r.handleArc.center),
      start: O.Cast(r.start.point),
      end: O.Cast(r.end.point),
      sweepFlag: r.bodyArc.sweepFlag,
      largeArcFlag: r.bodyArc.largeArcFlag
    });
    let o;
    if (e.props.text.trim()) {
      const l = dR(this.editor, e);
      i.push(...l.debugGeom), o = new Sp({
        x: l.box.x,
        y: l.box.y,
        width: l.box.w,
        height: l.box.h,
        isFilled: !0,
        isLabel: !0
      });
    }
    return new ld({
      children: [...o ? [s, o] : [s], ...i]
    });
  }
  getHandles(e) {
    const r = yh(this.editor, e);
    return [
      {
        id: "start",
        type: "vertex",
        index: "a0",
        x: r.start.handle.x,
        y: r.start.handle.y
      },
      {
        id: "middle",
        type: "virtual",
        index: "a2",
        x: r.middle.x,
        y: r.middle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: r.end.handle.x,
        y: r.end.handle.y
      }
    ].filter(Boolean);
  }
  component(e) {
    const r = uu(), i = this.editor.getOnlySelectedShape(), s = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getInstanceState().isReadonly, o = yh(this.editor, e);
    if (!(o != null && o.isValid)) return null;
    const l = dR(this.editor, e), u = e.id === this.editor.getOnlySelectedShapeId(), f = this.editor.getEditingShapeId() === e.id || e.props.text;
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(xm, { id: e.id, style: { minWidth: 50, minHeight: 50 }, children: /* @__PURE__ */ y.jsx(
        w7,
        {
          shape: e,
          shouldDisplayHandles: s && (i == null ? void 0 : i.id) === e.id
        }
      ) }),
      f && /* @__PURE__ */ y.jsx(
        V2,
        {
          id: e.id,
          classNamePrefix: "tl-arrow",
          type: "arrow",
          font: e.props.font,
          fontSize: I3(e),
          lineHeight: Oo.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          text: e.props.text,
          labelColor: r[e.props.labelColor].solid,
          textWidth: l.box.w,
          isSelected: u,
          padding: 0,
          style: {
            transform: `translate(${l.box.center.x}px, ${l.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(e) {
    const r = $2(e.id), i = yh(this.editor, e);
    if (!i) return null;
    const { start: s, end: o } = $0(this.editor, e, i == null ? void 0 : i.bindings), l = this.editor.getShapeGeometry(e), u = l.bounds, d = e.props.text.trim() ? l.children[1] : null;
    if (O.Equals(s, o)) return null;
    const f = eo[e.props.size] * e.props.scale, m = i.start.arrowhead && LM(i, "start", f), v = i.end.arrowhead && LM(i, "end", f), S = i.isStraight ? nX(i) : eX(i), w = m && i.start.arrowhead !== "arrow" || v && i.end.arrowhead !== "arrow" || !!d, E = (e.id + "_clip").replace(":", "_");
    return r && d ? /* @__PURE__ */ y.jsx(
      "rect",
      {
        x: be(d.x),
        y: be(d.y),
        width: d.w,
        height: d.h,
        rx: 3.5 * e.props.scale,
        ry: 3.5 * e.props.scale
      }
    ) : /* @__PURE__ */ y.jsxs("g", { children: [
      w && /* @__PURE__ */ y.jsx("defs", { children: /* @__PURE__ */ y.jsxs("mask", { id: E, children: [
        /* @__PURE__ */ y.jsx(
          "rect",
          {
            x: u.minX - 100,
            y: u.minY - 100,
            width: u.w + 200,
            height: u.h + 200,
            fill: "white"
          }
        ),
        d && /* @__PURE__ */ y.jsx(
          "rect",
          {
            x: be(d.x),
            y: be(d.y),
            width: d.w,
            height: d.h,
            fill: "black",
            rx: 3.5 * e.props.scale,
            ry: 3.5 * e.props.scale
          }
        ),
        m && /* @__PURE__ */ y.jsx(
          "path",
          {
            d: m,
            fill: i.start.arrowhead === "arrow" ? "none" : "black",
            stroke: "none"
          }
        ),
        v && /* @__PURE__ */ y.jsx(
          "path",
          {
            d: v,
            fill: i.end.arrowhead === "arrow" ? "none" : "black",
            stroke: "none"
          }
        )
      ] }) }),
      /* @__PURE__ */ y.jsxs("g", { ...w ? { mask: `url(#${E})` } : void 0, children: [
        w && /* @__PURE__ */ y.jsx(
          "rect",
          {
            x: u.minX - 100,
            y: u.minY - 100,
            width: u.width + 200,
            height: u.height + 200,
            opacity: 0
          }
        ),
        /* @__PURE__ */ y.jsx("path", { d: S })
      ] }),
      m && /* @__PURE__ */ y.jsx("path", { d: m }),
      v && /* @__PURE__ */ y.jsx("path", { d: v }),
      d && /* @__PURE__ */ y.jsx(
        "rect",
        {
          x: be(d.x),
          y: be(d.y),
          width: d.w,
          height: d.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  toSvg(e, r) {
    r.addExportDef(L5(e.props.fill)), e.props.text && r.addExportDef(B2(e.props.font));
    const i = Pp(r), s = 1 / e.props.scale;
    return /* @__PURE__ */ y.jsxs("g", { transform: `scale(${s})`, children: [
      /* @__PURE__ */ y.jsx(w7, { shape: e, shouldDisplayHandles: !1 }),
      /* @__PURE__ */ y.jsx(
        H2,
        {
          fontSize: I3(e),
          font: e.props.font,
          align: "middle",
          verticalAlign: "middle",
          text: e.props.text,
          labelColor: i[e.props.labelColor].solid,
          bounds: dR(this.editor, e).box,
          padding: 4 * e.props.scale
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      j5(),
      {
        key: "arrow:dot",
        component: KCe
      },
      {
        key: "arrow:cross",
        component: YCe
      }
    ];
  }
  getInterpolatedProps(e, r, i) {
    return {
      ...r.props,
      start: {
        x: Il(e.props.start.x, r.props.start.x, i),
        y: Il(e.props.start.y, r.props.start.y, i)
      },
      end: {
        x: Il(e.props.end.x, r.props.end.x, i),
        y: Il(e.props.end.y, r.props.end.y, i)
      },
      bend: Il(e.props.bend, r.props.bend, i),
      labelPosition: Il(e.props.labelPosition, r.props.labelPosition, i)
    };
  }
}
T(hR, "type", "arrow"), T(hR, "props", HG), T(hR, "migrations", VG);
function GCe(n, t) {
  const e = yh(n, t);
  return e.isStraight ? O.Dist(e.start.handle, e.end.handle) : Math.abs(e.handleArc.length);
}
const w7 = ro(function({
  shape: t,
  shouldDisplayHandles: e
}) {
  const r = we(), i = uu(), s = yh(r, t), o = vt.ZeroFix(r.getShapeGeometry(t).bounds), l = Ml(r, t), u = Gn.useMemo(() => r.environment.isSafari ? WCe += 1 : 0, [t]);
  if (!(s != null && s.isValid)) return null;
  const d = eo[t.props.size] * t.props.scale, f = s.start.arrowhead && LM(s, "start", d), m = s.end.arrowhead && LM(s, "end", d), v = s.isStraight ? nX(s) : eX(s);
  let S = null;
  if (e) {
    const j = 2 / r.getZoomLevel(), { strokeDasharray: $, strokeDashoffset: U } = fh(
      GCe(r, t),
      j,
      {
        end: "skip",
        start: "skip",
        lengthRatio: 2.5
      }
    );
    S = l.start || l.end ? /* @__PURE__ */ y.jsx(
      "path",
      {
        className: "tl-arrow-hint",
        d: s.isStraight ? VCe(s) : HCe(s),
        strokeDasharray: $,
        strokeDashoffset: U,
        strokeWidth: j,
        markerStart: l.start ? l.start.props.isExact ? "" : l.start.props.isPrecise ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
        markerEnd: l.end ? l.end.props.isExact ? "" : l.end.props.isPrecise ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
        opacity: 0.16
      }
    ) : null;
  }
  const { strokeDasharray: w, strokeDashoffset: E } = fh(
    s.isStraight ? s.length : Math.abs(s.bodyArc.length),
    d,
    {
      style: t.props.dash
    }
  ), A = dR(r, t), P = !(s.start.arrowhead === "none" || s.start.arrowhead === "arrow"), R = !(s.end.arrowhead === "none" || s.end.arrowhead === "arrow"), M = (t.id + "_clip_" + u).replace(":", "_");
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx("defs", { children: /* @__PURE__ */ y.jsxs("mask", { id: M, children: [
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          x: be(-100 + o.minX),
          y: be(-100 + o.minY),
          width: be(o.width + 200),
          height: be(o.height + 200),
          fill: "white"
        }
      ),
      t.props.text.trim() && /* @__PURE__ */ y.jsx(
        "rect",
        {
          x: A.box.x,
          y: A.box.y,
          width: A.box.w,
          height: A.box.h,
          fill: "black",
          rx: 4,
          ry: 4
        }
      ),
      f && P && /* @__PURE__ */ y.jsx("path", { d: f, fill: s.start.arrowhead === "arrow" ? "none" : "black", stroke: "none" }),
      m && R && /* @__PURE__ */ y.jsx("path", { d: m, fill: s.end.arrowhead === "arrow" ? "none" : "black", stroke: "none" })
    ] }) }),
    /* @__PURE__ */ y.jsxs(
      "g",
      {
        fill: "none",
        stroke: i[t.props.color].solid,
        strokeWidth: d,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          S,
          /* @__PURE__ */ y.jsxs("g", { mask: `url(#${M})`, children: [
            /* @__PURE__ */ y.jsx(
              "rect",
              {
                x: be(o.minX - 100),
                y: be(o.minY - 100),
                width: be(o.width + 200),
                height: be(o.height + 200),
                opacity: 0
              }
            ),
            /* @__PURE__ */ y.jsx("path", { d: v, strokeDasharray: w, strokeDashoffset: E })
          ] }),
          f && P && t.props.fill !== "none" && /* @__PURE__ */ y.jsx(
            ua,
            {
              theme: i,
              d: f,
              color: t.props.color,
              fill: t.props.fill,
              scale: t.props.scale
            }
          ),
          m && R && t.props.fill !== "none" && /* @__PURE__ */ y.jsx(
            ua,
            {
              theme: i,
              d: m,
              color: t.props.color,
              fill: t.props.fill,
              scale: t.props.scale
            }
          ),
          f && /* @__PURE__ */ y.jsx("path", { d: f }),
          m && /* @__PURE__ */ y.jsx("path", { d: m })
        ]
      }
    )
  ] });
}), C7 = /* @__PURE__ */ new WeakMap();
function KCe() {
  return /* @__PURE__ */ y.jsx("marker", { id: "arrowhead-dot", className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ y.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function YCe() {
  return /* @__PURE__ */ y.jsxs("marker", { id: "arrowhead-cross", className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    /* @__PURE__ */ y.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    /* @__PURE__ */ y.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
const E7 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function ew({ url: n, zoomLevel: t }) {
  return /* @__PURE__ */ y.jsx(
    "a",
    {
      className: Vt("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": t < 0.32
      }),
      href: n,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: to,
      onPointerUp: to,
      title: n,
      draggable: !1,
      children: /* @__PURE__ */ y.jsx(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${E7}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${E7}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const _7 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E", XCe = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function F5(n) {
  return XCe.map((e) => {
    const { offsetX: r, offsetY: i, blur: s, spread: o, color: l } = e, u = new O(r, i), { x: d, y: f } = u.rot(-n);
    return `${d}px ${f}px ${s}px ${o}px ${l}`;
  }).join(", ");
}
const qCe = 300, rX = 320, ZCe = 46, QCe = 101;
class fR extends gw {
  constructor() {
    super(...arguments);
    T(this, "canResize", () => !1);
    T(this, "hideSelectionBoundsFg", () => !0);
    T(this, "onBeforeCreate", (e) => T7(this.editor, e));
    T(this, "onBeforeUpdate", (e, r) => {
      if (e.props.url !== r.props.url)
        if (bc.isValid(r.props.url))
          eEe(this.editor, r);
        else
          return { ...r, props: { ...r.props, url: e.props.url } };
      if (e.props.assetId !== r.props.assetId)
        return T7(this.editor, r);
    });
  }
  getDefaultProps() {
    return {
      url: "",
      w: qCe,
      h: rX,
      assetId: null
    };
  }
  component(e) {
    const r = e.props.assetId ? this.editor.getAsset(e.props.assetId) : null, i = this.editor.getShapePageTransform(e).rotation(), s = JCe(e);
    return /* @__PURE__ */ y.jsx(rS, { children: /* @__PURE__ */ y.jsxs(
      "div",
      {
        className: "tl-bookmark__container",
        style: {
          boxShadow: F5(i),
          maxHeight: e.props.h
        },
        children: [
          (!r || r.props.image) && /* @__PURE__ */ y.jsxs("div", { className: "tl-bookmark__image_container", children: [
            r ? /* @__PURE__ */ y.jsx(
              "img",
              {
                className: "tl-bookmark__image",
                draggable: !1,
                referrerPolicy: "strict-origin-when-cross-origin",
                src: r == null ? void 0 : r.props.image,
                alt: (r == null ? void 0 : r.props.title) || ""
              }
            ) : /* @__PURE__ */ y.jsx("div", { className: "tl-bookmark__placeholder" }),
            (r == null ? void 0 : r.props.image) && /* @__PURE__ */ y.jsx(ew, { url: e.props.url, zoomLevel: this.editor.getZoomLevel() })
          ] }),
          /* @__PURE__ */ y.jsxs("div", { className: "tl-bookmark__copy_container", children: [
            r != null && r.props.title ? /* @__PURE__ */ y.jsx("h2", { className: "tl-bookmark__heading", children: r.props.title }) : null,
            r != null && r.props.description && (r != null && r.props.image) ? /* @__PURE__ */ y.jsx("p", { className: "tl-bookmark__description", children: r.props.description }) : null,
            /* @__PURE__ */ y.jsxs(
              "a",
              {
                className: "tl-bookmark__link",
                href: e.props.url || "",
                target: "_blank",
                rel: "noopener noreferrer",
                onPointerDown: to,
                onPointerUp: to,
                onClick: to,
                children: [
                  r != null && r.props.favicon ? /* @__PURE__ */ y.jsx(
                    "img",
                    {
                      className: "tl-bookmark__favicon",
                      src: r == null ? void 0 : r.props.favicon,
                      referrerPolicy: "strict-origin-when-cross-origin",
                      alt: `favicon of ${s}`
                    }
                  ) : /* @__PURE__ */ y.jsx(
                    "div",
                    {
                      className: "tl-hyperlink__icon",
                      style: {
                        mask: `url("${_7}") center 100% / 100% no-repeat`,
                        WebkitMask: `url("${_7}") center 100% / 100% no-repeat`
                      }
                    }
                  ),
                  /* @__PURE__ */ y.jsx("span", { children: s })
                ]
              }
            )
          ] })
        ]
      }
    ) });
  }
  indicator(e) {
    return /* @__PURE__ */ y.jsx(
      "rect",
      {
        width: be(e.props.w),
        height: be(e.props.h),
        rx: "6",
        ry: "6"
      }
    );
  }
}
T(fR, "type", "bookmark"), T(fR, "props", qG), T(fR, "migrations", ZG);
function T7(n, t) {
  const e = t.props.assetId ? n.getAsset(t.props.assetId) : null;
  let r = rX;
  return e && (e.props.image || (e.props.title ? r = QCe : r = ZCe)), {
    ...t,
    props: {
      ...t.props,
      h: r
    }
  };
}
const JCe = (n) => {
  try {
    return new URL(n.props.url).hostname.replace(/^www\./, "");
  } catch {
    return n.props.url;
  }
};
function eEe(n, t) {
  const { url: e } = t.props, r = Zv.createId(s3(e));
  n.getAsset(r) ? t.props.assetId !== r && n.updateShapes([
    {
      id: t.id,
      type: t.type,
      props: { assetId: r }
    }
  ]) : (n.updateShapes([
    {
      id: t.id,
      type: t.type,
      props: { assetId: null }
    }
  ]), tEe(n, t));
}
const tEe = hG(async (n, t) => {
  if (n.isDisposed) return;
  const { url: e } = t.props, r = await n.getAssetForExternalContent({ type: "url", url: e });
  r && n.run(() => {
    n.createAssets([r]), n.updateShapes([
      {
        id: t.id,
        type: t.type,
        props: { assetId: r.id }
      }
    ]);
  });
}, 500);
function iS(n, t = !1) {
  const e = n.length;
  if (e < 2)
    return "";
  let r = n[0].point, i = n[1].point;
  if (e === 2)
    return `M${ar(r)}L${ar(i)}`;
  let s = "";
  for (let o = 2, l = e - 1; o < l; o++)
    r = n[o].point, i = n[o + 1].point, s += Rl(r, i);
  return t ? `M${Rl(n[0].point, n[1].point)}Q${ar(n[1].point)}${Rl(
    n[1].point,
    n[2].point
  )}T${s}${Rl(n[e - 1].point, n[0].point)}${Rl(
    n[0].point,
    n[1].point
  )}Z` : `M${ar(n[0].point)}Q${ar(n[1].point)}${Rl(
    n[1].point,
    n[2].point
  )}${n.length > 3 ? "T" : ""}${s}L${ar(n[e - 1].point)}`;
}
function nEe(n, t = {}) {
  const { start: e = {}, end: r = {} } = t, { cap: i = !0 } = e, { cap: s = !0 } = r;
  ii(!e.taper && !r.taper, "cap taper not supported here"), ii(!e.easing && !r.easing, "cap easing not supported here"), ii(i && s, "cap must be true");
  const o = kh(n, t);
  z2(o, t);
  const l = rEe(o);
  let u = "";
  for (const d of l)
    u += sEe(d, t);
  return u;
}
function rEe(n) {
  if (n.length <= 2) return [n];
  const t = [];
  let e = [n[0]], r = O.Sub(n[1].point, n[0].point).uni(), i, s, o, l, u;
  for (let d = 1, f = n.length; d < f - 1; d++) {
    if (o = n[d - 1], l = n[d], u = n[d + 1], i = O.Sub(u.point, l.point).uni(), s = O.Dpr(r, i), r = i, s < -0.8) {
      const m = {
        ...l,
        point: l.input
      };
      e.push(m), t.push(YN(e)), e = [m];
      continue;
    }
    if (e.push(l), !(s > 0.7) && (O.Dist2(o.point, l.point) + O.Dist2(l.point, u.point)) / ((o.radius + l.radius + u.radius) / 3) ** 2 < 1.5) {
      e.push(l), t.push(YN(e)), e = [l];
      continue;
    }
  }
  return e.push(n[n.length - 1]), t.push(YN(e)), t;
}
function YN(n) {
  const t = n[0];
  let e;
  for (; n.length > 2 && (e = n[1], O.Dist2(t.point, e.point) < ((t.radius + e.radius) / 2 * 0.5) ** 2); )
    n.splice(1, 1);
  const r = n[n.length - 1];
  let i;
  for (; n.length > 2 && (i = n[n.length - 2], O.Dist2(r.point, i.point) < ((r.radius + i.radius) / 2 * 0.5) ** 2); )
    n.splice(n.length - 2, 1);
  return n.length > 1 && (n[0] = {
    ...n[0],
    vector: O.Sub(n[0].point, n[1].point).uni()
  }, n[n.length - 1] = {
    ...n[n.length - 1],
    vector: O.Sub(
      n[n.length - 2].point,
      n[n.length - 1].point
    ).uni()
  }), n;
}
function iEe(n, t, e) {
  return "M " + n + " " + t + " m -" + e + ", 0 a " + e + "," + e + " 0 1,1 " + e * 2 + ",0 a " + e + "," + e + " 0 1,1 -" + e * 2 + ",0";
}
function sEe(n, t = {}) {
  if (n.length === 0) return "";
  if (n.length === 1)
    return iEe(n[0].point.x, n[0].point.y, n[0].radius);
  const { left: e, right: r } = LY(n, t);
  r.reverse();
  let i = `M${ar(e[0])}T`;
  for (let s = 1; s < e.length; s++)
    i += Rl(e[s - 1], e[s]);
  {
    const s = n[n.length - 1], o = s.radius, l = s.vector.clone().per().neg(), u = O.Add(s.point, O.Mul(l, o)), d = O.Add(s.point, O.Mul(l, -o));
    i += `${ar(u)}A${be(o)},${be(
      o
    )} 0 0 1 ${ar(d)}T`;
  }
  for (let s = 1; s < r.length; s++)
    i += Rl(r[s - 1], r[s]);
  {
    const s = n[0], o = s.radius, l = s.vector.clone().per(), u = O.Add(s.point, O.Mul(l, o)), d = O.Add(s.point, O.Mul(l, -o));
    i += `${ar(u)}A${be(o)},${be(
      o
    )} 0 0 1 ${ar(d)}Z`;
  }
  return i;
}
const oEe = (n) => n * 0.65 + wye(n * cr / 2) * 0.35, aEe = (n) => ({
  size: n,
  thinning: 0.5,
  streamline: qx(n, [9, 16], [0.64, 0.74], !0),
  // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
  smoothing: 0.62,
  easing: Js.easeOutSine,
  simulatePressure: !0
}), lEe = (n) => ({
  size: 1 + n * 1.2,
  thinning: 0.62,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: oEe
}), P7 = (n) => ({
  size: n,
  thinning: 0,
  streamline: qx(n, [9, 16], [0.64, 0.74], !0),
  // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: Js.linear
}), cEe = (n) => ({
  size: n,
  thinning: 0,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: Js.linear
});
function $5({
  strokeWidth: n,
  showAsComplete: t
}) {
  return {
    size: 1 + n,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: !1,
    easing: Js.easeOutSine,
    last: t
  };
}
function R3(n, t, e, r) {
  const i = n.isComplete || e;
  return r ? n.isPen ? { ...cEe(t), last: i } : { ...P7(t), last: i } : n.dash === "draw" ? n.isPen ? { ...lEe(t), last: i } : { ...aEe(t), last: i } : { ...P7(t), last: i };
}
function tw(n) {
  const t = [];
  for (const e of n)
    if (e.type === "free" || e.points.length < 2)
      t.push(...e.points.map(O.Cast));
    else {
      const r = Math.max(
        4,
        Math.floor(O.Dist(e.points[0], e.points[1]) / 16)
      );
      t.push(...O.PointsBetween(e.points[0], e.points[1], r));
    }
  return t;
}
function uEe(n, t) {
  return {
    draw: "none",
    solid: "none",
    dotted: `0.1 ${t * 2}`,
    dashed: `${t * 2} ${t * 2}`
  }[n.props.dash];
}
class pR extends ad {
  constructor() {
    super(...arguments);
    T(this, "hideResizeHandles", (e) => XN(e));
    T(this, "hideRotateHandle", (e) => XN(e));
    T(this, "hideSelectionBoundsFg", (e) => XN(e));
    T(this, "onResize", (e, r) => {
      const { scaleX: i, scaleY: s } = r, o = [];
      for (const l of e.props.segments)
        o.push({
          ...l,
          points: l.points.map(({ x: u, y: d, z: f }) => ({
            x: op(i * u),
            y: op(s * d),
            z: f
          }))
        });
      return {
        props: {
          segments: o
        }
      };
    });
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: !1,
      isClosed: !1,
      isPen: !1,
      scale: 1
    };
  }
  getGeometry(e) {
    const r = tw(e.props.segments), i = (eo[e.props.size] + 1) * e.props.scale;
    if (e.props.segments.length === 1) {
      const o = vt.FromPoints(r);
      if (o.width < i * 2 && o.height < i * 2)
        return new R5({
          x: -i,
          y: -i,
          radius: i,
          isFilled: !0
        });
    }
    const s = kh(
      r,
      R3(e.props, i, e.props.isPen, !0)
    ).map((o) => o.point);
    return e.props.isClosed ? new Xi({
      points: s,
      isFilled: e.props.fill !== "none"
    }) : new pw({
      points: s
    });
  }
  component(e) {
    return /* @__PURE__ */ y.jsx(xm, { id: e.id, children: /* @__PURE__ */ y.jsx(A7, { shape: e, zoomLevel: this.editor.getZoomLevel() }) });
  }
  indicator(e) {
    var m;
    const r = tw(e.props.segments);
    let i = (eo[e.props.size] + 1) * e.props.scale;
    const s = this.editor.getZoomLevel();
    !(s < 0.5 && s < 1.5 / i) && !e.props.isPen && e.props.dash === "draw" && r.length === 1 && (i += dd(e.id)() * (i / 6));
    const l = e.props.isComplete || ((m = Io(e.props.segments)) == null ? void 0 : m.type) === "straight", u = R3(e.props, i, l, !0), d = kh(r, u), f = d.length > 1 ? iS(d, e.props.isClosed) : iX(r[0], i);
    return /* @__PURE__ */ y.jsx("path", { d: f });
  }
  toSvg(e, r) {
    r.addExportDef(L5(e.props.fill));
    const i = 1 / e.props.scale;
    return /* @__PURE__ */ y.jsx("g", { transform: `scale(${i})`, children: /* @__PURE__ */ y.jsx(A7, { shape: e, zoomLevel: 1 }) });
  }
  getCanvasSvgDefs() {
    return [j5()];
  }
  expandSelectionOutlinePx(e) {
    const r = e.props.dash === "draw" ? 1.6 : 1;
    return eo[e.props.size] * r / 2 * e.props.scale;
  }
}
T(pR, "type", "draw"), T(pR, "props", JG), T(pR, "migrations", eK);
function iX(n, t) {
  const e = (t + 1) * 0.5;
  return `M ${n.x} ${n.y} m -${e}, 0 a ${e},${e} 0 1,0 ${e * 2},0 a ${e},${e} 0 1,0 -${e * 2},0`;
}
function XN(n) {
  return n.props.segments.length === 1 && n.props.segments[0].points.length < 2;
}
function A7({ shape: n, zoomLevel: t }) {
  var m;
  const e = uu(), r = tw(n.props.segments), i = n.props.isComplete || ((m = Io(n.props.segments)) == null ? void 0 : m.type) === "straight";
  let s = (eo[n.props.size] + 1) * n.props.scale;
  const o = t < 0.5 && t < 1.5 / s;
  !o && !n.props.isPen && n.props.dash === "draw" && r.length === 1 && (s += dd(n.id)() * (s / 6));
  const l = R3(n.props, s, i, o);
  if (!o && n.props.dash === "draw")
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      n.props.isClosed && n.props.fill && r.length > 1 ? /* @__PURE__ */ y.jsx(
        ua,
        {
          d: iS(
            kh(r, l),
            n.props.isClosed
          ),
          theme: e,
          color: n.props.color,
          fill: n.props.isClosed ? n.props.fill : "none",
          scale: n.props.scale
        }
      ) : null,
      /* @__PURE__ */ y.jsx(
        "path",
        {
          d: nEe(r, l),
          strokeLinecap: "round",
          fill: e[n.props.color].solid
        }
      )
    ] });
  const u = kh(r, l), d = u.length < 2, f = d ? iX(r[0], 0) : iS(u, n.props.isClosed);
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(
      ua,
      {
        d: f,
        theme: e,
        color: n.props.color,
        fill: d || n.props.isClosed ? n.props.fill : "none",
        scale: n.props.scale
      }
    ),
    /* @__PURE__ */ y.jsx(
      "path",
      {
        d: f,
        strokeLinecap: "round",
        fill: d ? e[n.props.color].solid : "none",
        stroke: e[n.props.color].solid,
        strokeWidth: s,
        strokeDasharray: d ? "none" : uEe(n, s),
        strokeDashoffset: "0"
      }
    )
  ] });
}
function dEe(n, t, e = {}) {
  const { newPoint: r, handle: i, scaleX: s, scaleY: o } = t, { minWidth: l = 1, maxWidth: u = 1 / 0, minHeight: d = 1, maxHeight: f = 1 / 0 } = e;
  let m = n.props.w * s, v = n.props.h * o;
  const S = new O(0, 0);
  if (m > 0) {
    if (m < l) {
      switch (i) {
        case "top_left":
        case "left":
        case "bottom_left": {
          S.x = m - l;
          break;
        }
        case "top":
        case "bottom": {
          S.x = (m - l) / 2;
          break;
        }
        default:
          S.x = 0;
      }
      m = l;
    }
  } else if (S.x = m, m = -m, m < l) {
    switch (i) {
      case "top_left":
      case "left":
      case "bottom_left": {
        S.x = -m;
        break;
      }
      default:
        S.x = -l;
    }
    m = l;
  }
  if (v > 0) {
    if (v < d) {
      switch (i) {
        case "top_left":
        case "top":
        case "top_right": {
          S.y = v - d;
          break;
        }
        case "right":
        case "left": {
          S.y = (v - d) / 2;
          break;
        }
        default:
          S.y = 0;
      }
      v = d;
    }
  } else if (S.y = v, v = -v, v < d) {
    switch (i) {
      case "top_left":
      case "top":
      case "top_right": {
        S.y = -v;
        break;
      }
      default:
        S.y = -d;
    }
    v = d;
  }
  const { x: w, y: E } = S.rot(n.rotation).add(r);
  return {
    x: w,
    y: E,
    props: {
      w: Math.min(u, m),
      h: Math.min(f, v)
    }
  };
}
const hEe = (n) => Object.entries(n).filter(([t, e]) => e).map(([t]) => t).join(" ");
class gR extends gw {
  constructor() {
    super(...arguments);
    T(this, "hideSelectionBoundsFg", (e) => !this.canResize(e));
    T(this, "canEdit", () => !0);
    T(this, "canResize", (e) => {
      var r, i;
      return !!((i = (r = pm(e.props.url)) == null ? void 0 : r.definition) != null && i.doesResize);
    });
    T(this, "canEditInReadOnly", () => !0);
    T(this, "isAspectRatioLocked", (e) => {
      const r = pm(e.props.url);
      return (r == null ? void 0 : r.definition.isAspectRatioLocked) ?? !1;
    });
    T(this, "onResize", (e, r) => {
      const i = this.isAspectRatioLocked(e), s = pm(e.props.url);
      let o = (s == null ? void 0 : s.definition.minWidth) ?? 200, l = (s == null ? void 0 : s.definition.minHeight) ?? 200;
      if (i) {
        const u = e.props.w / e.props.h;
        u > 1 ? o *= u : l /= u;
      }
      return dEe(e, r, { minWidth: o, minHeight: l });
    });
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  component(e) {
    const { w: r, h: i, url: s } = e.props, o = $2(e.id), l = D.useMemo(() => zY(s), [s]), u = De(
      "is hovering",
      () => {
        const { editingShapeId: S, hoveredShapeId: w } = this.editor.getCurrentPageState();
        if (S && w !== S) {
          const E = this.editor.getShape(S);
          if (E && this.editor.isShapeOfType(E, "embed"))
            return !0;
        }
        return !1;
      },
      []
    ), d = this.editor.getShapePageTransform(e).rotation(), f = o || u;
    if (typeof window < "u" && (window !== window.top || window.self !== window.parent) && (l == null ? void 0 : l.definition.type) === "tldraw") return null;
    if ((l == null ? void 0 : l.definition.type) === "github_gist") {
      const S = l.url.split("/").pop();
      if (!S) throw Error("No gist id!");
      return /* @__PURE__ */ y.jsx(rS, { className: "tl-embed-container", id: e.id, children: /* @__PURE__ */ y.jsx(
        fEe,
        {
          id: S,
          width: be(r),
          height: be(i),
          isInteractive: f,
          pageRotation: d
        }
      ) });
    }
    const v = hEe({
      ...iye,
      ...(l == null ? void 0 : l.definition.overridePermissions) ?? {}
    });
    return /* @__PURE__ */ y.jsx(rS, { className: "tl-embed-container", id: e.id, children: l != null && l.definition ? /* @__PURE__ */ y.jsx(
      "iframe",
      {
        className: "tl-embed",
        sandbox: v,
        src: l.embedUrl,
        width: be(r),
        height: be(i),
        draggable: !1,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        style: {
          border: 0,
          pointerEvents: f ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: f ? "" : "-1",
          boxShadow: F5(d),
          borderRadius: (l == null ? void 0 : l.definition.overrideOutlineRadius) ?? 8,
          background: l == null ? void 0 : l.definition.backgroundColor
        }
      }
    ) : null });
  }
  indicator(e) {
    const r = D.useMemo(() => pm(e.props.url), [e.props.url]);
    return /* @__PURE__ */ y.jsx(
      "rect",
      {
        width: be(e.props.w),
        height: be(e.props.h),
        rx: (r == null ? void 0 : r.definition.overrideOutlineRadius) ?? 8,
        ry: (r == null ? void 0 : r.definition.overrideOutlineRadius) ?? 8
      }
    );
  }
}
T(gR, "type", "embed"), T(gR, "props", tK), T(gR, "migrations", nK);
function fEe({
  id: n,
  file: t,
  isInteractive: e,
  width: r,
  height: i,
  style: s,
  pageRotation: o
}) {
  return /* @__PURE__ */ y.jsx(
    "iframe",
    {
      className: "tl-embed",
      draggable: !1,
      width: be(r),
      height: be(i),
      frameBorder: "0",
      scrolling: "no",
      seamless: !0,
      referrerPolicy: "no-referrer-when-downgrade",
      style: {
        ...s,
        pointerEvents: e ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: e ? "" : "-1",
        boxShadow: F5(o)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${n}.js${t ? `?file=${t}` : ""}`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
const pEe = D.forwardRef(({ id: n, name: t, isEditing: e }, r) => {
  const i = we(), s = D.useCallback(
    (u) => {
      u.key === "Enter" && !u.nativeEvent.isComposing && (to(u), u.currentTarget.blur(), i.setEditingShape(null));
    },
    [i]
  ), o = D.useCallback(
    (u) => {
      const d = i.getShape(n);
      if (!d) return;
      const f = d.props.name, m = u.currentTarget.value.trim();
      f !== m && i.updateShapes([
        {
          id: n,
          type: "frame",
          props: { name: m }
        }
      ]);
    },
    [n, i]
  ), l = D.useCallback(
    (u) => {
      const d = i.getShape(n);
      if (!d) return;
      const f = d.props.name, m = u.currentTarget.value;
      f !== m && i.updateShapes([
        {
          id: n,
          type: "frame",
          props: { name: m }
        }
      ]);
    },
    [n, i]
  );
  return /* @__PURE__ */ y.jsxs("div", { className: `tl-frame-label ${e ? "tl-frame-label__editing" : ""}`, children: [
    /* @__PURE__ */ y.jsx(
      "input",
      {
        className: "tl-frame-name-input",
        ref: r,
        style: { display: e ? void 0 : "none" },
        value: t,
        autoFocus: !0,
        onKeyDown: s,
        onBlur: o,
        onChange: l
      }
    ),
    sX(t, "Frame") + "​"
  ] });
}), gEe = function({
  id: t,
  name: e,
  width: r,
  height: i
}) {
  const s = we(), o = De(
    "shape rotation",
    () => ym(s.getShapePageTransform(t).rotation()),
    [s, t]
  ), l = $2(t), u = D.useRef(null), d = D.useCallback(
    (w) => {
      const E = Ol(w);
      w.preventDefault(), s.getEditingShapeId() !== t && s.dispatch({
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: s.getShape(t),
        ...E
      });
    },
    [s, t]
  );
  D.useEffect(() => {
    const w = u.current;
    w && l && (w.focus(), w.select());
  }, [u, l]);
  const m = ((o + Math.PI / 4) * (2 / Math.PI) + 4) % 4, v = ["top", "left", "bottom", "right"][Math.floor(m)];
  let S;
  switch (v) {
    case "top":
      S = "";
      break;
    case "right":
      S = `translate(${be(r)}px, 0px) rotate(90deg)`;
      break;
    case "bottom":
      S = `translate(${be(r)}px, ${be(
        i
      )}px) rotate(180deg)`;
      break;
    case "left":
      S = `translate(0px, ${be(i)}px) rotate(270deg)`;
      break;
  }
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: l ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${Math.ceil(v === "top" || v === "bottom" ? r : i)}px + var(--space-5))`,
        bottom: "100%",
        transform: `${S} scale(var(--tl-scale)) translateX(calc(-1 * var(--space-3))`
      },
      onPointerDown: d,
      children: /* @__PURE__ */ y.jsx("div", { className: "tl-frame-heading-hit-area", children: /* @__PURE__ */ y.jsx(pEe, { ref: u, id: t, name: e, isEditing: l }) })
    }
  );
};
function sX(n, t) {
  return n.match(/^\s*$/) ? t : n;
}
class mR extends gw {
  constructor() {
    super(...arguments);
    T(this, "canEdit", () => !0);
    T(this, "canReceiveNewChildrenOfType", (e, r) => !e.isLocked);
    T(this, "canDropShapes", (e, r) => !e.isLocked);
    T(this, "onDragShapesOver", (e, r) => {
      r.every((i) => i.parentId === e.id) || this.editor.reparentShapes(r, e.id);
    });
    T(this, "onDragShapesOut", (e, r) => {
      const i = this.editor.getShape(e.parentId);
      i && this.editor.isShapeOfType(i, "group") ? this.editor.reparentShapes(r, i.id) : this.editor.reparentShapes(r, this.editor.getCurrentPageId());
    });
    T(this, "onResize", (e, r) => k5(e, r));
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "" };
  }
  getGeometry(e) {
    return new Sp({
      width: e.props.w,
      height: e.props.h,
      isFilled: !1
    });
  }
  component(e) {
    const r = this.editor.getShapeGeometry(e).bounds, i = uu(), s = De(
      "is creating this shape",
      () => {
        const o = this.editor.getStateDescendant("select.resizing");
        if (!o || !o.getIsActive()) return !1;
        const l = o == null ? void 0 : o.info;
        return l ? l.isCreating && this.editor.getOnlySelectedShapeId() === e.id : !1;
      },
      [e.id]
    );
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(xm, { children: /* @__PURE__ */ y.jsx(
        "rect",
        {
          className: Vt("tl-frame__body", { "tl-frame__creating": s }),
          width: r.width,
          height: r.height,
          fill: i.solid,
          stroke: i.text
        }
      ) }),
      s ? null : /* @__PURE__ */ y.jsx(
        gEe,
        {
          id: e.id,
          name: e.props.name,
          width: r.width,
          height: r.height
        }
      )
    ] });
  }
  toSvg(e, r) {
    const i = Pp({ isDarkMode: r.isDarkMode }), l = ((ym(
      this.editor.getShapePageTransform(e.id).rotation()
    ) + Math.PI / 4) * (2 / Math.PI) + 4) % 4, u = Math.floor(l);
    let d;
    switch (u) {
      case 0:
        d = "";
        break;
      case 3:
        d = `translate(${be(e.props.w)}, 0) rotate(90)`;
        break;
      case 2:
        d = `translate(${be(e.props.w)}, ${be(
          e.props.h
        )}) rotate(180)`;
        break;
      case 1:
        d = `translate(0, ${be(e.props.h)}) rotate(270)`;
        break;
      default:
        throw Error("labelSide out of bounds");
    }
    const f = {
      fontSize: 12,
      fontFamily: "Inter, sans-serif",
      textAlign: "start",
      width: e.props.w,
      height: 32,
      padding: 0,
      lineHeight: 1,
      fontStyle: "normal",
      fontWeight: "normal",
      overflow: "truncate-ellipsis",
      verticalTextAlign: "middle"
    }, m = this.editor.textMeasure.measureTextSpans(
      sX(e.props.name, "Frame") + "​",
      f
    ), v = m[0], S = Io(m), w = S.box.w + S.box.x - v.box.x, E = k3(this.editor, m, {
      offsetY: -f.height - 2,
      ...f
    });
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          width: e.props.w,
          height: e.props.h,
          fill: i.solid,
          stroke: i.black.solid,
          strokeWidth: 1,
          rx: 1,
          ry: 1
        }
      ),
      /* @__PURE__ */ y.jsxs("g", { transform: d, children: [
        /* @__PURE__ */ y.jsx(
          "rect",
          {
            x: -8,
            y: -f.height - 4,
            width: w + 16,
            height: f.height,
            fill: i.background,
            rx: 4,
            ry: 4
          }
        ),
        E
      ] })
    ] });
  }
  indicator(e) {
    const r = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ y.jsx(
      "rect",
      {
        width: be(r.width),
        height: be(r.height),
        className: "tl-frame-indicator"
      }
    );
  }
  providesBackgroundForChildren() {
    return !0;
  }
}
T(mR, "type", "frame"), T(mR, "props", rK), T(mR, "migrations", iK);
function k7(n, t) {
  return n > t ? (cr * (t / 2) + (n - t)) * 2 : (cr * (n / 2) + (t - n)) * 2;
}
function oX(n, t) {
  return z5(n, t).map((e, r) => e.getSvgPathData(r === 0)).join(" ") + " Z";
}
function mEe(n, t, e, r) {
  const i = n / 4, s = t / 4, o = dd(r), l = e * 0.75, u = (R) => R.addXY(o() * l, o() * l), d = new O(n / 2, t), f = new O(0, s * 1.2), m = new O(n / 2, s * 0.9), v = new O(n, s * 1.2), S = u(new O(n / 2, t)), w = u(new O(0, s * 1.2)), E = u(new O(n / 2, s * 0.9)), A = u(new O(n, s * 1.2));
  return [
    new ha({
      start: d,
      cp1: new O(i * 1.5, s * 3),
      cp2: new O(0, s * 2.5),
      end: f
    }),
    new ha({
      start: f,
      cp1: new O(0, -s * 0.32),
      cp2: new O(i * 1.85, -s * 0.32),
      end: m
    }),
    new ha({
      start: m,
      cp1: new O(i * 2.15, -s * 0.32),
      cp2: new O(n, -s * 0.32),
      end: v
    }),
    new ha({
      start: v,
      cp1: new O(n, s * 2.5),
      cp2: new O(i * 2.5, s * 3),
      end: S
    }),
    new ha({
      start: S,
      cp1: new O(i * 1.5, s * 3),
      cp2: new O(0, s * 2.5),
      end: w
    }),
    new ha({
      start: w,
      cp1: new O(0, -s * 0.32),
      cp2: new O(i * 1.85, -s * 0.32),
      end: E
    }),
    new ha({
      start: E,
      cp1: new O(i * 2.15, -s * 0.32),
      cp2: new O(n, -s * 0.32),
      end: A
    }),
    new ha({
      start: A,
      cp1: new O(n, s * 2.5),
      cp2: new O(i * 2.5, s * 3),
      end: d
    })
  ].map((R, M) => R.getSvgPathData(M === 0)).join(" ") + " Z";
}
function z5(n, t) {
  const e = n / 4, r = t / 4;
  return [
    new ha({
      start: new O(n / 2, t),
      cp1: new O(e * 1.5, r * 3),
      cp2: new O(0, r * 2.5),
      end: new O(0, r * 1.2)
    }),
    new ha({
      start: new O(0, r * 1.2),
      cp1: new O(0, -r * 0.32),
      cp2: new O(e * 1.85, -r * 0.32),
      end: new O(n / 2, r * 0.9)
    }),
    new ha({
      start: new O(n / 2, r * 0.9),
      cp1: new O(e * 2.15, -r * 0.32),
      cp2: new O(n, -r * 0.32),
      end: new O(n, r * 1.2)
    }),
    new ha({
      start: new O(n, r * 1.2),
      cp1: new O(n, r * 2.5),
      cp2: new O(e * 2.5, r * 3),
      end: new O(n / 2, t)
    })
  ];
}
function vEe(n) {
  return {
    size: 1 + n,
    thinning: 0.25,
    end: { taper: n },
    start: { taper: n },
    streamline: 0,
    smoothing: 1,
    simulatePressure: !1
  };
}
function yEe(n, t, e, r) {
  const i = dd(n), s = t / 2, o = e / 2, l = EK(s, o), u = [], d = wr * i(), f = wr + ri / 2 + Math.abs(i()) * ri, m = Math.max(16, l / 10);
  for (let v = 0; v < m; v++) {
    const S = v / (m - 1), w = d + S * f, E = Math.cos(w), A = Math.sin(w);
    u.push(
      new O(
        s * E + t * 0.5 + 0.05 * i(),
        o * A + e / 2 + 0.05 * i(),
        Math.min(
          1,
          0.5 + Math.abs(0.5 - (i() > 0 ? Js.easeInOutSine(S) : Js.easeInExpo(S))) / 2
        )
      )
    );
  }
  return kh(u, vEe(r));
}
function SEe(n, t, e, r) {
  return iS(yEe(n, t, e, r));
}
function M3(n) {
  let t = "M";
  const e = n.length;
  let r, i, s;
  for (let o = 0, l = e; o < l; o += 3)
    r = n[o], i = n[o + 1], s = n[o + 2], t += `${ar(r)}L${ar(i)}Q${ar(s)}`;
  return t += `${ar(n[0])}`, t;
}
function D3(n, t, e, r, i) {
  const s = [], o = dd(n);
  let l = t[0], u;
  const d = t.length;
  for (let f = 0, m = d * i; f < m; f++) {
    u = O.AddXY(t[(f + 1) % d], o() * e, o() * e);
    const v = O.Sub(u, l), S = O.Len(v), w = O.Div(v, S).mul(Math.min(S / 4, r));
    s.push(O.Add(l, w), O.Add(u, w.neg()), u), l = u;
  }
  return s;
}
function bEe(n, t, e) {
  const r = Math.min(n, t) / 2, i = Math.max(n, t) - r * 2, o = (Math.PI * (r * 2) + 2 * i) / e, l = n > t ? [
    {
      type: "straight",
      start: new O(r, 0),
      delta: new O(1, 0)
    },
    {
      type: "arc",
      center: new O(n - r, r),
      startAngle: -cr / 2
    },
    {
      type: "straight",
      start: new O(n - r, t),
      delta: new O(-1, 0)
    },
    {
      type: "arc",
      center: new O(r, r),
      startAngle: cr / 2
    }
  ] : [
    {
      type: "straight",
      start: new O(n, r),
      delta: new O(0, 1)
    },
    {
      type: "arc",
      center: new O(r, t - r),
      startAngle: 0
    },
    {
      type: "straight",
      start: new O(0, t - r),
      delta: new O(0, -1)
    },
    {
      type: "arc",
      center: new O(r, r),
      startAngle: cr
    }
  ];
  let u = 0;
  const d = [];
  for (let f = 0; f < e; f++) {
    const m = l[0];
    m.type === "straight" ? d.push(O.Add(m.start, O.Mul(m.delta, u))) : d.push(
      nS(m.center, r, m.startAngle + u / r)
    ), u += o;
    let v = m.type === "straight" ? i : cr * r;
    for (; u > v; )
      u -= v, l.push(l.shift()), v = l[0].type === "straight" ? i : cr * r;
  }
  return d;
}
const xEe = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
}, wEe = 0.2;
function W2(n, t, e, r) {
  const i = dd(e), s = k7(n, t), o = Math.max(
    Math.ceil(s / xEe[r]),
    6,
    Math.ceil(s / Math.min(n, t))
  ), l = s / o * wEe, u = Math.max(n - l * 2, 1), d = Math.max(t - l * 2, 1), m = k7(u, d) / o, v = (n - u) / 2, S = (t - d) / 2, w = bEe(u, d, o).map((M) => M.addXY(v, S)), E = n < 20 ? 0 : l * 0.3, A = t < 20 ? 0 : l * 0.3, P = w.slice(0);
  for (let M = 0; M < Math.floor(o / 2); M++)
    P[M] = O.AddXY(
      P[M],
      i() * E,
      i() * A
    ), P[o - M - 1] = O.AddXY(
      P[o - M - 1],
      i() * E,
      i() * A
    );
  const R = [];
  for (let M = 0; M < P.length; M++) {
    const j = M === P.length - 1 ? 0 : M + 1, $ = P[M], U = P[j], F = w[M], B = w[j], G = O.Dist(F, B), X = m - G, ne = O.Dist($, U) / G, K = (Math.max(v, S) + X) * ne, Z = O.Lrp(F, B, 0.5).add(
      O.Sub(B, F).uni().per().mul(K)
    );
    Z.x < 0 ? Z.x = 0 : Z.x > n && (Z.x = n), Z.y < 0 ? Z.y = 0 : Z.y > t && (Z.y = t);
    const oe = h5($, U, Z), fe = O.Dist(
      oe || O.Average([$, U]),
      $
    );
    R.push({
      leftPoint: $,
      rightPoint: U,
      arcPoint: Z,
      center: oe,
      radius: fe
    });
  }
  return R;
}
function CEe(n, t, e, r) {
  const i = [], s = W2(n, t, e, r);
  for (const { center: o, radius: l, leftPoint: u, rightPoint: d } of s)
    i.push(...Tye(u, d, o, l, 10));
  return i;
}
function O3(n, t, e, r) {
  const i = W2(n, t, e, r);
  let s = `M${i[0].leftPoint.toFixed()}`;
  for (const { leftPoint: o, rightPoint: l, radius: u, center: d } of i) {
    if (d === null) {
      s += ` L${l.toFixed()}`;
      continue;
    }
    const f = O.Clockwise(o, l, d) ? "0" : "1";
    s += ` A${be(u)},${be(u)} 0 ${f},1 ${l.toFixed()}`;
  }
  return s += " Z", s;
}
const EEe = {
  s: 0.5,
  m: 0.7,
  l: 0.9,
  xl: 1.6
};
function _Ee(n, t, e, r) {
  const i = dd(e), s = EEe[r], o = W2(n, t, e, r), d = o.reduce((S, w) => S + O.Dist2(w.leftPoint, w.rightPoint), 0) / o.length > (s * 15) ** 2 ? (S) => S.addXY(i() * s * 2, i() * s * 2) : (S) => S;
  let f = `M${o[0].leftPoint.toFixed()}`, m = d(o[0].leftPoint), v = `M${m.toFixed()}`;
  for (const { leftPoint: S, center: w, rightPoint: E, radius: A, arcPoint: P } of o) {
    if (w === null) {
      f += ` L${E.toFixed()}`;
      const F = d(E);
      v += ` L${F.toFixed()}`, m = F;
      continue;
    }
    const R = O.Clockwise(S, E, w) ? "0" : "1";
    f += ` A${be(A)},${be(A)} 0 ${R},1 ${E.toFixed()}`;
    const M = d(E), j = d(P), $ = h5(m, M, j);
    if (!Number.isFinite($.x) || !Number.isFinite($.y)) {
      v += ` L${M.toFixed()}`, m = M;
      continue;
    }
    const U = Math.abs(O.Dist($, m));
    v += ` A${be(U)},${be(
      U
    )} 0 ${R},1 ${M.toFixed()}`, m = M;
  }
  return f + v + " Z";
}
function L3(n, t) {
  switch (n.geo) {
    case "x-box":
      return TEe(n.w, n.h, t, n.dash);
    case "check-box":
      return PEe(n.w, n.h);
    default:
      return;
  }
}
function TEe(n, t, e, r) {
  const i = r === "draw" ? 0.62 : 0;
  if (r === "dashed")
    return [
      [new O(0, 0), new O(n / 2, t / 2)],
      [new O(n, t), new O(n / 2, t / 2)],
      [new O(0, t), new O(n / 2, t / 2)],
      [new O(n, 0), new O(n / 2, t / 2)]
    ];
  const s = (l) => Math.max(0, Math.min(n, l)), o = (l) => Math.max(0, Math.min(t, l));
  return [
    [
      new O(s(e * i), o(e * i)),
      new O(s(n - e * i), o(t - e * i))
    ],
    [
      new O(s(e * i), o(t - e * i)),
      new O(s(n - e * i), o(e * i))
    ]
  ];
}
function PEe(n, t) {
  const e = Math.min(n, t) * 0.82, r = (n - e) / 2, i = (t - e) / 2, s = (l) => Math.max(0, Math.min(n, l)), o = (l) => Math.max(0, Math.min(t, l));
  return [
    [
      new O(s(r + e * 0.25), o(i + e * 0.52)),
      new O(s(r + e * 0.45), o(i + e * 0.82))
    ],
    [
      new O(s(r + e * 0.45), o(i + e * 0.82)),
      new O(s(r + e * 0.82), o(i + e * 0.22))
    ]
  ];
}
function I7({ shape: n, shouldScale: t }) {
  const e = t ? n.props.scale : 1, r = we(), i = uu(), { id: s, props: o } = n, { w: l, color: u, fill: d, dash: f, growY: m, size: v } = o, S = eo[v] * e, w = o.h + m;
  switch (o.geo) {
    case "cloud":
      if (f === "solid") {
        const E = O3(l, w, s, v);
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: E, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx("path", { d: E, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
      } else if (f === "draw") {
        const E = _Ee(l, w, s, v);
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: E, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx("path", { d: E, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
      } else {
        const E = O3(l, w, s, v), A = W2(l, w, s, v);
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: E, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx(
            "g",
            {
              strokeWidth: S,
              stroke: i[u].solid,
              fill: "none",
              pointerEvents: "all",
              children: A.map(({ leftPoint: P, rightPoint: R, center: M, radius: j }, $) => {
                const U = M ? j * ym(
                  ym(O.Angle(M, R)) - ym(O.Angle(M, P))
                ) : O.Dist(P, R), { strokeDasharray: F, strokeDashoffset: B } = fh(
                  U,
                  S,
                  {
                    style: f,
                    start: "outset",
                    end: "outset"
                  }
                );
                return /* @__PURE__ */ y.jsx(
                  "path",
                  {
                    d: M ? `M${P.x},${P.y}A${j},${j},0,0,1,${R.x},${R.y}` : `M${P.x},${P.y}L${R.x},${R.y}`,
                    strokeDasharray: F,
                    strokeDashoffset: B
                  },
                  $
                );
              })
            }
          )
        ] });
      }
    case "ellipse": {
      const E = t ? (
        // cached
        r.getShapeGeometry(n)
      ) : (
        // not cached
        r.getShapeUtil(n).getGeometry(n)
      ), A = E.getSvgPathData(!0);
      if (f === "dashed" || f === "dotted") {
        const P = E.length, { strokeDasharray: R, strokeDashoffset: M } = fh(
          P < 64 ? P * 2 : P,
          S,
          {
            style: f,
            snap: 4,
            closed: !0
          }
        );
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: A, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx(
            "path",
            {
              d: A,
              strokeWidth: S,
              fill: "none",
              stroke: i[u].solid,
              strokeDasharray: R,
              strokeDashoffset: M
            }
          )
        ] });
      } else {
        const R = (t ? (
          // cached
          r.getShapeGeometry(n)
        ) : (
          // not cached
          r.getShapeUtil(n).getGeometry(n)
        )).getSvgPathData(!0);
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: R, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx("path", { d: R, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
      }
    }
    case "oval": {
      const E = t ? (
        // cached
        r.getShapeGeometry(n)
      ) : (
        // not cached
        r.getShapeUtil(n).getGeometry(n)
      ), A = E.getSvgPathData(!0);
      if (f === "dashed" || f === "dotted") {
        const P = E.getLength(), { strokeDasharray: R, strokeDashoffset: M } = fh(
          P < 64 ? P * 2 : P,
          S,
          {
            style: f,
            snap: 4,
            start: "outset",
            end: "outset",
            closed: !0
          }
        );
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: A, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx(
            "path",
            {
              d: A,
              strokeWidth: S,
              fill: "none",
              stroke: i[u].solid,
              strokeDasharray: R,
              strokeDashoffset: M
            }
          )
        ] });
      } else
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: A, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx("path", { d: A, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
    }
    case "heart":
      if (f === "dashed" || f === "dotted" || f === "solid") {
        const E = oX(l, w), A = z5(l, w);
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: E, color: u, fill: d, scale: e }),
          A.map((P, R) => {
            const { strokeDasharray: M, strokeDashoffset: j } = fh(
              P.length,
              S,
              {
                style: f,
                snap: 1,
                start: "outset",
                end: "outset",
                closed: !0
              }
            );
            return /* @__PURE__ */ y.jsx(
              "path",
              {
                d: P.getSvgPathData(),
                strokeWidth: S,
                fill: "none",
                stroke: i[u].solid,
                strokeDasharray: M,
                strokeDashoffset: j,
                pointerEvents: "all"
              },
              `curve_${R}`
            );
          })
        ] });
      } else {
        const E = mEe(l, w, S, n.id);
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: E, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx("path", { d: E, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
      }
    default: {
      const E = t ? (
        // cached
        r.getShapeGeometry(n)
      ) : (
        // not cached
        r.getShapeUtil(n).getGeometry(n)
      ), A = E instanceof ld ? E.children[0].vertices : E.vertices, P = L3(n.props, S);
      if (f === "solid") {
        let R = "M" + A[0] + "L" + A.slice(1) + "Z";
        if (P)
          for (const [M, j] of P)
            R += `M${M.x},${M.y}L${j.x},${j.y}`;
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: R, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsx("path", { d: R, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
      } else if (f === "dashed" || f === "dotted") {
        const R = "M" + A[0] + "L" + A.slice(1) + "Z";
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(ua, { theme: i, d: R, color: u, fill: d, scale: e }),
          /* @__PURE__ */ y.jsxs(
            "g",
            {
              strokeWidth: S,
              stroke: i[u].solid,
              fill: "none",
              pointerEvents: "all",
              children: [
                Array.from(Array(A.length)).map((M, j) => {
                  const $ = O.ToFixed(A[j]), U = O.ToFixed(A[(j + 1) % A.length]), F = O.Dist($, U), { strokeDasharray: B, strokeDashoffset: G } = fh(
                    F,
                    S,
                    {
                      style: f,
                      start: "outset",
                      end: "outset"
                    }
                  );
                  return /* @__PURE__ */ y.jsx(
                    "line",
                    {
                      x1: $.x,
                      y1: $.y,
                      x2: U.x,
                      y2: U.y,
                      strokeDasharray: B,
                      strokeDashoffset: G
                    },
                    j
                  );
                }),
                P && P.map(([M, j], $) => {
                  const U = O.Dist(M, j), { strokeDasharray: F, strokeDashoffset: B } = fh(
                    U,
                    S,
                    {
                      style: f,
                      start: "skip",
                      end: "skip",
                      snap: f === "dotted" ? 4 : void 0
                    }
                  );
                  return /* @__PURE__ */ y.jsx(
                    "path",
                    {
                      d: `M${M.x},${M.y}L${j.x},${j.y}`,
                      stroke: i[u].solid,
                      strokeWidth: S,
                      fill: "none",
                      strokeDasharray: F,
                      strokeDashoffset: B
                    },
                    `line_fg_${$}`
                  );
                })
              ]
            }
          )
        ] });
      } else if (f === "draw") {
        let R = M3(
          D3(s, A, S / 3, S * 2, 2)
        );
        if (P)
          for (const [j, $] of P)
            R += `M${j.toFixed()}L${$.toFixed()}`;
        const M = M3(
          D3(s, A, 0, S * 2, 1)
        );
        return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsx(
            ua,
            {
              theme: i,
              d: M,
              color: u,
              fill: d,
              scale: e
            }
          ),
          /* @__PURE__ */ y.jsx("path", { d: R, stroke: i[u].solid, strokeWidth: S, fill: "none" })
        ] });
      }
    }
  }
}
const R7 = 17 * 3;
class vR extends gw {
  constructor() {
    super(...arguments);
    T(this, "canEdit", () => !0);
    T(this, "onEditEnd", (e) => {
      const {
        id: r,
        type: i,
        props: { text: s }
      } = e;
      s.trimEnd() !== e.props.text && this.editor.updateShapes([
        {
          id: r,
          type: i,
          props: {
            text: s.trimEnd()
          }
        }
      ]);
    });
    T(this, "onResize", (e, { handle: r, newPoint: i, scaleX: s, scaleY: o, initialShape: l }) => {
      const u = l.props.w / l.props.scale, d = l.props.h / l.props.scale, f = l.props.growY / l.props.scale;
      let m = u * s, v = (d + f) * o, S = 0, w = 0;
      const E = R7;
      if (e.props.text.trim()) {
        let $ = Math.max(Math.abs(m), E), U = Math.max(Math.abs(v), E);
        $ < E && U === E && ($ = E), $ === E && U < E && (U = E);
        const F = CI(this.editor, {
          ...e,
          props: {
            ...e.props,
            w: $ * e.props.scale,
            h: U * e.props.scale
          }
        }), B = Math.max(Math.abs(m), F.w) * Math.sign(m), G = Math.max(Math.abs(v), F.h) * Math.sign(v);
        S = Math.abs(B) - Math.abs(m), w = Math.abs(G) - Math.abs(v), m = B, v = G;
      }
      const A = m * e.props.scale, P = v * e.props.scale, R = new O(0, 0);
      s < 0 && (R.x += A), (r === "left" || r === "top_left" || r === "bottom_left") && (R.x += s < 0 ? S : -S), o < 0 && (R.y += P), (r === "top" || r === "top_left" || r === "top_right") && (R.y += o < 0 ? w : -w);
      const { x: M, y: j } = R.rot(e.rotation).add(i);
      return {
        x: M,
        y: j,
        props: {
          w: Math.max(Math.abs(A), 1),
          h: Math.max(Math.abs(P), 1),
          growY: 0
        }
      };
    });
    T(this, "onBeforeCreate", (e) => {
      if (!e.props.text)
        return e.props.growY ? {
          ...e,
          props: {
            ...e.props,
            growY: 0
          }
        } : void 0;
      const r = e.props.h / e.props.scale, i = CI(this.editor, e).h;
      let s = null;
      if (i > r ? s = i - r : e.props.growY && (s = 0), s !== null)
        return {
          ...e,
          props: {
            ...e.props,
            // scale the growY
            growY: s * e.props.scale
          }
        };
    });
    T(this, "onBeforeUpdate", (e, r) => {
      const i = e.props.text, s = r.props.text;
      if (i === s && e.props.font === r.props.font && e.props.size === r.props.size)
        return;
      if (i && !s)
        return {
          ...r,
          props: {
            ...r.props,
            growY: 0
          }
        };
      const o = e.props.w / e.props.scale, l = e.props.h / e.props.scale, u = e.props.growY / e.props.scale, d = CI(this.editor, r);
      if (!i && s && s.length === 1) {
        let m = Math.max(o, d.w), v = Math.max(l, d.h);
        const S = R7;
        return o < S && l < S && (m = Math.max(m, S), v = Math.max(v, S), m = Math.max(m, v), v = Math.max(m, v)), {
          ...r,
          props: {
            ...r.props,
            // Scale the results
            w: m * r.props.scale,
            h: v * r.props.scale,
            growY: 0
          }
        };
      }
      let f = null;
      if (d.h > l ? f = d.h - l : u && (f = 0), f !== null) {
        const m = r.props.w / r.props.scale;
        return {
          ...r,
          props: {
            ...r.props,
            // Scale the results
            growY: f * r.props.scale,
            w: Math.max(m, d.w) * r.props.scale
          }
        };
      }
      if (d.w > o)
        return {
          ...r,
          props: {
            ...r.props,
            // Scale the results
            w: d.w * r.props.scale
          }
        };
    });
    T(this, "onDoubleClick", (e) => {
      if (this.editor.inputs.altKey)
        switch (e.props.geo) {
          case "rectangle":
            return {
              ...e,
              props: {
                geo: "check-box"
              }
            };
          case "check-box":
            return {
              ...e,
              props: {
                geo: "rectangle"
              }
            };
        }
    });
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      font: "draw",
      text: "",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(e) {
    const r = Math.max(1, e.props.w), i = Math.max(1, e.props.h + e.props.growY), s = r / 2, o = i / 2, l = e.props.fill !== "none";
    let u;
    switch (e.props.geo) {
      case "cloud": {
        u = new Xi({
          points: CEe(r, i, e.id, e.props.size),
          isFilled: l
        });
        break;
      }
      case "triangle": {
        u = new Xi({
          points: [new O(s, 0), new O(r, i), new O(0, i)],
          isFilled: l
        });
        break;
      }
      case "diamond": {
        u = new Xi({
          points: [new O(s, 0), new O(r, o), new O(s, i), new O(0, o)],
          isFilled: l
        });
        break;
      }
      case "pentagon": {
        u = new Xi({
          points: TN(r, i, 5),
          isFilled: l
        });
        break;
      }
      case "hexagon": {
        u = new Xi({
          points: TN(r, i, 6),
          isFilled: l
        });
        break;
      }
      case "octagon": {
        u = new Xi({
          points: TN(r, i, 8),
          isFilled: l
        });
        break;
      }
      case "ellipse": {
        u = new owe({
          width: r,
          height: i,
          isFilled: l
        });
        break;
      }
      case "oval": {
        u = new awe({
          width: r,
          height: i,
          isFilled: l
        });
        break;
      }
      case "star": {
        const M = wr / 5 / 2, j = Math.floor(5 / 4) * 2, $ = 5 * 2 - j, U = 0, F = Math.floor(5 / 2) * 2, B = Math.cos(-ri + j * M) * r / 2, G = Math.cos(-ri + $ * M) * r / 2, X = Math.sin(-ri + U * M) * i / 2, te = Math.sin(-ri + F * M) * i / 2, ne = r - Math.abs(B - G), K = i - Math.abs(te - X), Z = r / 2 + G - (r / 2 - B), oe = i / 2 + X - (i / 2 - te), fe = 1, ie = (r - Z) / 2, ue = (i - oe) / 2, Se = (r + ne) / 2, ke = (i + K) / 2, ce = Se * fe / 2, ye = ke * fe / 2;
        u = new Xi({
          points: Array.from(Array(5 * 2)).map((Fe, Xe) => {
            const je = -ri + Xe * M;
            return new O(
              ie + (Xe % 2 ? ce : Se) * Math.cos(je),
              ue + (Xe % 2 ? ye : ke) * Math.sin(je)
            );
          }),
          isFilled: l
        });
        break;
      }
      case "rhombus": {
        const R = Math.min(r * 0.38, i * 0.38);
        u = new Xi({
          points: [new O(R, 0), new O(r, 0), new O(r - R, i), new O(0, i)],
          isFilled: l
        });
        break;
      }
      case "rhombus-2": {
        const R = Math.min(r * 0.38, i * 0.38);
        u = new Xi({
          points: [new O(0, 0), new O(r - R, 0), new O(r, i), new O(R, i)],
          isFilled: l
        });
        break;
      }
      case "trapezoid": {
        const R = Math.min(r * 0.38, i * 0.38);
        u = new Xi({
          points: [new O(R, 0), new O(r - R, 0), new O(r, i), new O(0, i)],
          isFilled: l
        });
        break;
      }
      case "arrow-right": {
        const R = Math.min(r, i) * 0.38, M = i * 0.16;
        u = new Xi({
          points: [
            new O(0, M),
            new O(r - R, M),
            new O(r - R, 0),
            new O(r, i / 2),
            new O(r - R, i),
            new O(r - R, i - M),
            new O(0, i - M)
          ],
          isFilled: l
        });
        break;
      }
      case "arrow-left": {
        const R = Math.min(r, i) * 0.38, M = i * 0.16;
        u = new Xi({
          points: [
            new O(R, 0),
            new O(R, M),
            new O(r, M),
            new O(r, i - M),
            new O(R, i - M),
            new O(R, i),
            new O(0, i / 2)
          ],
          isFilled: l
        });
        break;
      }
      case "arrow-up": {
        const R = r * 0.16, M = Math.min(r, i) * 0.38;
        u = new Xi({
          points: [
            new O(r / 2, 0),
            new O(r, M),
            new O(r - R, M),
            new O(r - R, i),
            new O(R, i),
            new O(R, M),
            new O(0, M)
          ],
          isFilled: l
        });
        break;
      }
      case "arrow-down": {
        const R = r * 0.16, M = Math.min(r, i) * 0.38;
        u = new Xi({
          points: [
            new O(R, 0),
            new O(r - R, 0),
            new O(r - R, i - M),
            new O(r, i - M),
            new O(r / 2, i),
            new O(0, i - M),
            new O(R, i - M)
          ],
          isFilled: l
        });
        break;
      }
      case "check-box":
      case "x-box":
      case "rectangle": {
        u = new Sp({
          width: r,
          height: i,
          isFilled: l
        });
        break;
      }
      case "heart": {
        const M = z5(r, i).reduce((j, $) => (j.push(...$.vertices), j), []);
        u = new Xi({
          points: M,
          isFilled: l
        });
        break;
      }
      default:
        ma(e.props.geo);
    }
    const d = CI(this.editor, e), f = r / e.props.scale, m = i / e.props.scale, v = Math.min(100, f / 2), S = Math.min(
      dp[e.props.size] * Oo.lineHeight + tu * 2,
      m / 2
    ), w = Math.min(
      f,
      Math.max(d.w, Math.min(v, Math.max(1, f - 8)))
    ), E = Math.min(
      m,
      Math.max(d.h, Math.min(S, Math.max(1, m - 8)))
    ), A = L3(e.props, eo[e.props.size] * e.props.scale), P = A ? A.map((R) => new pw({ points: R })) : [];
    return new ld({
      children: [
        u,
        new Sp({
          x: e.props.align === "start" ? 0 : e.props.align === "end" ? (f - w) * e.props.scale : (f - w) / 2 * e.props.scale,
          y: e.props.verticalAlign === "start" ? 0 : e.props.verticalAlign === "end" ? (m - E) * e.props.scale : (m - E) / 2 * e.props.scale,
          width: w * e.props.scale,
          height: E * e.props.scale,
          isFilled: !0,
          isLabel: !0
        }),
        ...P
      ]
    });
  }
  getHandleSnapGeometry(e) {
    const r = this.getGeometry(e), i = r.children[0];
    switch (e.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline: i, points: [...i.getVertices(), r.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline: i, points: [r.bounds.center] };
      default:
        ma(e.props.geo);
    }
  }
  component(e) {
    const { id: r, type: i, props: s } = e, { fill: o, font: l, align: u, verticalAlign: d, size: f, text: m } = s, v = e.id === this.editor.getOnlySelectedShapeId(), S = uu(), E = this.editor.getEditingShapeId() !== null || e.props.text;
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(xm, { id: r, children: /* @__PURE__ */ y.jsx(I7, { shape: e, shouldScale: !0 }) }),
      E && /* @__PURE__ */ y.jsx(
        rS,
        {
          style: {
            overflow: "hidden",
            width: e.props.w,
            height: e.props.h + s.growY
          },
          children: /* @__PURE__ */ y.jsx(
            V2,
            {
              id: r,
              type: i,
              font: l,
              fontSize: dp[f] * e.props.scale,
              lineHeight: Oo.lineHeight,
              padding: tu * e.props.scale,
              fill: o,
              align: u,
              verticalAlign: d,
              text: m,
              isSelected: v,
              labelColor: S[s.labelColor].solid,
              wrap: !0
            }
          )
        }
      ),
      e.props.url && /* @__PURE__ */ y.jsx(ew, { url: e.props.url, zoomLevel: this.editor.getZoomLevel() })
    ] });
  }
  indicator(e) {
    const { id: r, props: i } = e, { w: s, size: o } = i, l = i.h + i.growY, u = eo[o], d = this.editor.getShapeGeometry(e);
    switch (i.geo) {
      case "ellipse":
        return i.dash === "draw" ? /* @__PURE__ */ y.jsx("path", { d: SEe(r, s, l, u) }) : /* @__PURE__ */ y.jsx("path", { d: d.getSvgPathData(!0) });
      case "heart":
        return /* @__PURE__ */ y.jsx("path", { d: oX(s, l) });
      case "oval":
        return /* @__PURE__ */ y.jsx("path", { d: d.getSvgPathData(!0) });
      case "cloud":
        return /* @__PURE__ */ y.jsx("path", { d: O3(s, l, r, o) });
      default: {
        const f = this.editor.getShapeGeometry(e), m = f instanceof ld ? f.children[0].vertices : f.vertices;
        let v;
        if (i.dash === "draw") {
          const w = D3(
            r,
            m,
            0,
            u * 2 * e.props.scale,
            1
          );
          v = M3(w);
        } else
          v = "M" + m[0] + "L" + m.slice(1) + "Z";
        const S = L3(e.props, u);
        if (S)
          for (const [w, E] of S)
            v += `M${w.x},${w.y}L${E.x},${E.y}`;
        return /* @__PURE__ */ y.jsx("path", { d: v });
      }
    }
  }
  toSvg(e, r) {
    const i = {
      ...e,
      props: {
        ...e.props,
        w: e.props.w / e.props.scale,
        h: e.props.h / e.props.scale
      }
    }, s = i.props;
    r.addExportDef(L5(s.fill));
    let o;
    if (s.text) {
      r.addExportDef(B2(s.font));
      const l = Pp(r), u = new vt(0, 0, s.w, s.h + s.growY);
      o = /* @__PURE__ */ y.jsx(
        H2,
        {
          fontSize: dp[s.size],
          font: s.font,
          align: s.align,
          verticalAlign: s.verticalAlign,
          text: s.text,
          labelColor: l[s.labelColor].solid,
          bounds: u,
          padding: 16
        }
      );
    }
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(I7, { shouldScale: !1, shape: i }),
      o
    ] });
  }
  getCanvasSvgDefs() {
    return [j5()];
  }
}
T(vR, "type", "geo"), T(vR, "props", sK), T(vR, "migrations", oK);
function CI(n, t) {
  const { text: e, font: r, size: i, w: s } = t.props;
  if (!e)
    return { w: 0, h: 0 };
  const o = n.textMeasure.measureText("w", {
    ...Oo,
    fontFamily: Ch[r],
    fontSize: dp[i],
    maxWidth: 100
    // ?
  }), l = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  }, u = n.textMeasure.measureText(e, {
    ...Oo,
    fontFamily: Ch[r],
    fontSize: dp[i],
    minWidth: o.w,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(o.w + l[i]),
      // The actual text size
      Math.ceil(s / t.props.scale - tu * 2)
    )
  });
  return {
    w: u.w + tu * 2,
    h: u.h + tu * 2
  };
}
function AEe() {
  const [n, t] = D.useState(!1);
  return D.useEffect(() => {
    const r = CSS.supports("color", "color(display-p3 1 1 1)"), i = matchMedia("(color-gamut: p3)");
    t(r && i.matches);
    const s = () => t(r && i.matches);
    return i.addEventListener("change", s), () => i.removeEventListener("change", s);
  }, []), De(qi.forceSrgb) || !n ? "srgb" : "p3";
}
const M7 = 0.35, D7 = 0.82;
class yR extends ad {
  constructor() {
    super(...arguments);
    T(this, "hideResizeHandles", (e) => EI(e));
    T(this, "hideRotateHandle", (e) => EI(e));
    T(this, "hideSelectionBoundsFg", (e) => EI(e));
    T(this, "onResize", (e, r) => {
      const { scaleX: i, scaleY: s } = r, o = [];
      for (const l of e.props.segments)
        o.push({
          ...l,
          points: l.points.map(({ x: u, y: d, z: f }) => ({
            x: i * u,
            y: s * d,
            z: f
          }))
        });
      return {
        props: {
          segments: o
        }
      };
    });
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: !1,
      isPen: !1,
      scale: 1
    };
  }
  getGeometry(e) {
    const r = Wv(e);
    if (EI(e))
      return new R5({
        x: -r / 2,
        y: -r / 2,
        radius: r / 2,
        isFilled: !0
      });
    const { strokePoints: i, sw: s } = O7(e, r, !0), o = $5({ strokeWidth: s, showAsComplete: !0 });
    return z2(i, o), new Xi({
      points: M5(i, o),
      isFilled: !0
    });
  }
  component(e) {
    const r = qN(this.editor, e), i = Wv(e);
    return /* @__PURE__ */ y.jsx(xm, { id: e.id, children: /* @__PURE__ */ y.jsx(
      _I,
      {
        shape: e,
        forceSolid: r,
        strokeWidth: i,
        opacity: M7
      }
    ) });
  }
  backgroundComponent(e) {
    const r = qN(this.editor, e), i = Wv(e);
    return /* @__PURE__ */ y.jsx(xm, { id: e.id, children: /* @__PURE__ */ y.jsx(
      _I,
      {
        shape: e,
        forceSolid: r,
        strokeWidth: i,
        opacity: D7
      }
    ) });
  }
  indicator(e) {
    const r = qN(this.editor, e), i = Wv(e), { strokePoints: s, sw: o } = O7(e, i, r), l = tw(e.props.segments);
    let u;
    return s.length < 2 ? u = IEe(l[0], o) : u = iS(s, !1), /* @__PURE__ */ y.jsx("path", { d: u });
  }
  toSvg(e) {
    const r = Wv(e), i = r < 1.5, s = 1 / e.props.scale;
    return /* @__PURE__ */ y.jsx("g", { transform: `scale(${s})`, children: /* @__PURE__ */ y.jsx(
      _I,
      {
        forceSolid: i,
        strokeWidth: r,
        shape: e,
        opacity: M7
      }
    ) });
  }
  toBackgroundSvg(e) {
    const r = Wv(e), i = r < 1.5, s = 1 / e.props.scale;
    return /* @__PURE__ */ y.jsx("g", { transform: `scale(${s})`, children: /* @__PURE__ */ y.jsx(
      _I,
      {
        forceSolid: i,
        strokeWidth: r,
        shape: e,
        opacity: D7
      }
    ) });
  }
}
T(yR, "type", "highlight"), T(yR, "props", cK), T(yR, "migrations", uK);
function kEe(n) {
  return `M ${n.x} ${n.y} m -${0.1}, 0 a ${0.1},${0.1} 0 1,0 ${0.1 * 2},0 a ${0.1},${0.1} 0 1,0 -${0.1 * 2},0`;
}
function IEe(n, t) {
  const e = t / 2;
  return `M ${n.x} ${n.y} m -${e}, 0 a ${e},${e} 0 1,0 ${e * 2},0 a ${e},${e} 0 1,0 -${e * 2},0`;
}
function O7(n, t, e) {
  var u;
  const r = tw(n.props.segments), i = n.props.isComplete || ((u = Io(n.props.segments)) == null ? void 0 : u.type) === "straight";
  let s = t;
  !e && !n.props.isPen && r.length === 1 && (s += dd(n.id)() * (t / 6));
  const o = $5({
    strokeWidth: s,
    showAsComplete: i
  });
  return { strokePoints: kh(r, o), sw: s };
}
function Wv(n) {
  return Qx[n.props.size] * 1.12 * n.props.scale;
}
function EI(n) {
  return n.props.segments.length === 1 && n.props.segments[0].points.length < 2;
}
function _I({
  strokeWidth: n,
  forceSolid: t,
  shape: e,
  opacity: r
}) {
  var v;
  const i = uu(), s = tw(e.props.segments);
  let o = n;
  !t && !e.props.isPen && s.length === 1 && (o += dd(e.id)() * (o / 6));
  const l = $5({
    strokeWidth: o,
    showAsComplete: e.props.isComplete || ((v = Io(e.props.segments)) == null ? void 0 : v.type) === "straight"
  }), u = kh(s, l), d = u.length > 1 ? iS(u, !1) : kEe(e.props.segments[0].points[0]), f = AEe(), m = i[e.props.color].highlight[f];
  return /* @__PURE__ */ y.jsx(
    "path",
    {
      d,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: m,
      strokeWidth: o,
      opacity: r
    }
  );
}
function qN(n, t) {
  return De(
    "forceSolid",
    () => {
      const e = Wv(t), r = n.getZoomLevel();
      return e / r < 1.5;
    },
    [n]
  );
}
function aX() {
  return /* @__PURE__ */ y.jsxs(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ y.jsx("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        /* @__PURE__ */ y.jsx("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        /* @__PURE__ */ y.jsx("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}
function lX(n, t, e) {
  const r = we(), [i, s] = D.useState(null), o = t ? r.getAsset(t) : null, u = r.getCulledShapes().has(n), d = D.useRef(!1);
  D.useEffect(() => {
    i && (d.current = !0);
  }, [i]);
  const f = o && "w" in o.props ? e / o.props.w : 1, m = De("zoom level", () => r.getZoomLevel() * f, [
    r,
    f
  ]);
  return D.useEffect(() => {
    if (u) return;
    let v = !1;
    const S = r.timers.setTimeout(
      async () => {
        const w = await r.resolveAssetUrl(t, {
          screenScale: m
        });
        v || s(w);
      },
      d.current ? 500 : 0
    );
    return () => {
      clearTimeout(S), v = !0;
    };
  }, [t, o == null ? void 0 : o.props.src, u, m, r]), { asset: o, url: i };
}
function cX() {
  const [n, t] = D.useState(!1);
  return D.useEffect(() => {
    if (typeof window > "u" || !("matchMedia" in window)) return;
    const e = window.matchMedia("(prefers-reduced-motion: reduce)"), r = () => {
      t(e.matches);
    };
    return r(), e.addEventListener("change", r), () => e.removeEventListener("change", r);
  }, []), n;
}
async function REe(n) {
  const e = await (await Th(n)).blob();
  return Xy.blobToDataUrl(e);
}
class SR extends gw {
  constructor() {
    super(...arguments);
    T(this, "isAspectRatioLocked", () => !0);
    T(this, "canCrop", () => !0);
    T(this, "onResize", (e, r) => {
      let i = k5(e, r);
      const { flipX: s, flipY: o } = r.initialShape.props;
      return i = {
        ...i,
        props: {
          ...i.props,
          flipX: r.scaleX < 0 !== s,
          flipY: r.scaleY < 0 !== o
        }
      }, i;
    });
    T(this, "onDoubleClick", (e) => {
      const r = e.props.assetId ? this.editor.getAsset(e.props.assetId) : void 0;
      !r || !(r.props.src && this.isAnimated(e)) || this.editor.updateShapes([
        {
          type: "image",
          id: e.id,
          props: {
            playing: !e.props.playing
          }
        }
      ]);
    });
    T(this, "onDoubleClickEdge", (e) => {
      const r = e.props;
      if (!r || this.editor.getCroppingShapeId() !== e.id)
        return;
      const i = ni(r.crop) || {
        topLeft: { x: 0, y: 0 },
        bottomRight: { x: 1, y: 1 }
      }, s = 1 / (i.bottomRight.x - i.topLeft.x) * e.props.w, o = 1 / (i.bottomRight.y - i.topLeft.y) * e.props.h, l = new O(i.topLeft.x * s, i.topLeft.y * o).rot(e.rotation), u = {
        id: e.id,
        type: e.type,
        x: e.x - l.x,
        y: e.y - l.y,
        props: {
          crop: {
            topLeft: { x: 0, y: 0 },
            bottomRight: { x: 1, y: 1 }
          },
          w: s,
          h: o
        }
      };
      this.editor.updateShapes([u]);
    });
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: !0,
      url: "",
      crop: null,
      flipX: !1,
      flipY: !1
    };
  }
  isAnimated(e) {
    const r = e.props.assetId ? this.editor.getAsset(e.props.assetId) : void 0;
    return r ? "mimeType" in r.props && mh.isAnimatedImageType(r == null ? void 0 : r.props.mimeType) || "isAnimated" in r.props && r.props.isAnimated : !1;
  }
  component(e) {
    var E;
    const r = this.editor.getCroppingShapeId() === e.id, i = cX(), [s, o] = D.useState(""), [l, u] = D.useState(""), d = e.id === this.editor.getOnlySelectedShapeId(), { asset: f, url: m } = lX(e.id, e.props.assetId, e.props.w);
    if (D.useEffect(() => {
      if (m) {
        let A = !1;
        const P = Xx();
        return P.onload = () => {
          A || u(m);
        }, P.src = m, () => {
          A = !0;
        };
      }
    }, [m, e]), D.useEffect(() => {
      if (m && this.isAnimated(e)) {
        let A = !1;
        const P = Xx();
        return P.onload = () => {
          if (A) return;
          const R = document.createElement("canvas");
          R.width = P.width, R.height = P.height;
          const M = R.getContext("2d");
          M && (M.drawImage(P, 0, 0), o(R.toDataURL()), u(m));
        }, P.crossOrigin = "anonymous", P.src = m, () => {
          A = !0;
        };
      }
    }, [i, m, e]), (f == null ? void 0 : f.type) === "bookmark")
      throw Error("Bookmark assets can't be rendered as images");
    const v = d && r && this.editor.isIn("select.crop"), S = i && (((E = f == null ? void 0 : f.props.mimeType) == null ? void 0 : E.includes("video")) || this.isAnimated(e)), w = L7(e);
    return f != null && f.props.src ? l ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      v && /* @__PURE__ */ y.jsx("div", { style: w, children: /* @__PURE__ */ y.jsx(
        "img",
        {
          className: "tl-image",
          crossOrigin: this.isAnimated(e) ? "anonymous" : void 0,
          src: !e.props.playing || S ? s : l,
          referrerPolicy: "strict-origin-when-cross-origin",
          style: {
            opacity: 0.1
          },
          draggable: !1
        }
      ) }),
      /* @__PURE__ */ y.jsxs(
        rS,
        {
          id: e.id,
          style: { overflow: "hidden", width: e.props.w, height: e.props.h },
          children: [
            /* @__PURE__ */ y.jsxs("div", { className: "tl-image-container", style: w, children: [
              /* @__PURE__ */ y.jsx(
                "img",
                {
                  className: Vt("tl-image", {
                    "tl-flip-x": e.props.flipX && !e.props.flipY,
                    "tl-flip-y": e.props.flipY && !e.props.flipX,
                    "tl-flip-xy": e.props.flipY && e.props.flipX
                  }),
                  crossOrigin: this.isAnimated(e) ? "anonymous" : void 0,
                  src: !e.props.playing || S ? s : l,
                  referrerPolicy: "strict-origin-when-cross-origin",
                  draggable: !1
                }
              ),
              this.isAnimated(e) && !e.props.playing && /* @__PURE__ */ y.jsx("div", { className: "tl-image__tg", children: "GIF" })
            ] }),
            e.props.url && /* @__PURE__ */ y.jsx(ew, { url: e.props.url, zoomLevel: this.editor.getZoomLevel() })
          ]
        }
      )
    ] }) : null : /* @__PURE__ */ y.jsxs(
      rS,
      {
        id: e.id,
        style: {
          overflow: "hidden",
          width: e.props.w,
          height: e.props.h,
          color: "var(--color-text-3)",
          backgroundColor: f ? "transparent" : "var(--color-low)",
          border: f ? "none" : "1px solid var(--color-low-border)"
        },
        children: [
          /* @__PURE__ */ y.jsx("div", { className: "tl-image-container", style: w, children: f ? null : /* @__PURE__ */ y.jsx(aX, {}) }),
          "url" in e.props && e.props.url && /* @__PURE__ */ y.jsx(ew, { url: e.props.url, zoomLevel: this.editor.getZoomLevel() })
        ]
      }
    );
  }
  indicator(e) {
    return this.editor.getCroppingShapeId() === e.id ? null : /* @__PURE__ */ y.jsx("rect", { width: be(e.props.w), height: be(e.props.h) });
  }
  async toSvg(e) {
    if (!e.props.assetId || !this.editor.getAsset(e.props.assetId)) return null;
    let i = await this.editor.resolveAssetUrl(e.props.assetId, {
      shouldResolveToOriginal: !0
    });
    if (!i) return null;
    (i.startsWith("blob:") || i.startsWith("http") || i.startsWith("/") || i.startsWith("./")) && (i = await REe(i) || "");
    const s = L7(e), o = e.props.crop;
    if (s.transform && o) {
      const { transform: l, width: u, height: d } = s, f = (o.bottomRight.x - o.topLeft.x) * u, m = (o.bottomRight.y - o.topLeft.y) * d, v = [
        new O(0, 0),
        new O(f, 0),
        new O(f, m),
        new O(0, m)
      ], S = `cropClipPath_${e.id.replace(":", "_")}`;
      return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsx("defs", { children: /* @__PURE__ */ y.jsx("clipPath", { id: S, children: /* @__PURE__ */ y.jsx("polygon", { points: v.map((w) => `${w.x},${w.y}`).join(" ") }) }) }),
        /* @__PURE__ */ y.jsx("g", { clipPath: `url(#${S})`, children: /* @__PURE__ */ y.jsx("image", { href: i, width: u, height: d, style: { transform: l } }) })
      ] });
    } else
      return /* @__PURE__ */ y.jsx("image", { href: i, width: e.props.w, height: e.props.h });
  }
}
T(SR, "type", "image"), T(SR, "props", dK), T(SR, "migrations", hK);
function L7(n) {
  const t = n.props.crop, e = t == null ? void 0 : t.topLeft;
  if (!e)
    return {
      width: n.props.w,
      height: n.props.h
    };
  const r = 1 / (t.bottomRight.x - t.topLeft.x) * n.props.w, i = 1 / (t.bottomRight.y - t.topLeft.y) * n.props.h, s = -e.x * r, o = -e.y * i;
  return {
    transform: `translate(${s}px, ${o}px)`,
    width: r,
    height: i
  };
}
function uX(n) {
  return {
    size: n,
    thinning: 0.4,
    streamline: 0,
    smoothing: 0.5,
    simulatePressure: !0,
    last: !0
  };
}
function dX(n, t, e) {
  const r = t.vertices, i = uX(e);
  return kh(r, i);
}
function MEe(n, t, e) {
  const r = uX(e);
  return M5(
    z2(dX(n, t, e), r),
    r
  );
}
function DEe(n, t, e) {
  const r = MEe(n, t, e);
  return m5(r);
}
function OEe(n, t, e) {
  if (n.props.dash === "draw") {
    const r = dX(n, t, e);
    return iS(r);
  }
  return t.getSvgPathData();
}
function hX(n, t, e) {
  let r = `M ${ar(t[0])}L`, i = `M ${ar(t[0])}L`;
  const s = e / 3, o = e * 2, l = dd(n);
  let u = t[0], d, f = t[0], m;
  const v = t.length;
  for (let S = 0, w = v - 1; S < w; S++) {
    d = t[S + 1], m = O.AddXY(t[S + 1], l() * s, l() * s);
    const E = O.Sub(d, u), A = O.Len(E), P = O.Div(E, A).mul(Math.min(A / 4, o)), R = O.Add(u, P), M = O.Add(d, P.neg()), j = O.Sub(m, f), $ = O.Len(j), U = O.Div(j, $).mul(Math.min($ / 4, o)), F = O.Add(f, U), B = O.Add(m, U.neg());
    S === w - 1 ? (r += `${ar(R)}L ${ar(d)}`, i += `${ar(F)}L ${ar(m)}`) : (r += `${ar(R)}L ${ar(M)}Q ${ar(d)}`, i += `${ar(F)}L ${ar(B)}Q ${ar(m)}`, u = d, f = m);
  }
  return [r, r + i];
}
const LEe = new vp();
class bR extends ad {
  constructor() {
    super(...arguments);
    T(this, "hideResizeHandles", () => !0);
    T(this, "hideRotateHandle", () => !0);
    T(this, "hideSelectionBoundsFg", () => !0);
    T(this, "hideSelectionBoundsBg", () => !0);
    //   Events
    T(this, "onResize", (e, r) => {
      const { scaleX: i, scaleY: s } = r;
      return {
        props: {
          points: NT(e.props.points, (o, { id: l, index: u, x: d, y: f }) => ({
            id: l,
            index: u,
            x: d * i,
            y: f * s
          }))
        }
      };
    });
    T(this, "onHandleDrag", (e, { handle: r }) => {
      if (r.type === "vertex")
        return {
          ...e,
          props: {
            ...e.props,
            points: {
              ...e.props.points,
              [r.id]: { id: r.id, index: r.index, x: r.x, y: r.y }
            }
          }
        };
    });
  }
  getDefaultProps() {
    const [e, r] = z1(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [e]: { id: e, index: e, x: 0, y: 0 },
        [r]: { id: r, index: r, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(e) {
    return n1(e);
  }
  getHandles(e) {
    return LEe.get(e.props, () => {
      const r = n1(e), i = t1(e), s = i.map((o) => ({
        ...o,
        id: o.index,
        type: "vertex",
        canSnap: !0
      }));
      for (let o = 0; o < i.length - 1; o++) {
        const l = $1(i[o].index, i[o + 1].index), d = r.segments[o].midPoint();
        s.push({
          id: l,
          type: "create",
          index: l,
          x: d.x,
          y: d.y,
          canSnap: !0
        });
      }
      return s.sort(fa);
    });
  }
  component(e) {
    return /* @__PURE__ */ y.jsx(xm, { id: e.id, children: /* @__PURE__ */ y.jsx(j7, { shape: e }) });
  }
  indicator(e) {
    const r = eo[e.props.size] * e.props.scale, i = n1(e), { dash: s } = e.props;
    let o;
    if (e.props.spline === "line") {
      const l = i.points;
      if (s === "solid" || s === "dotted" || s === "dashed")
        o = "M" + l[0] + "L" + l.slice(1);
      else {
        const [u] = hX(e.id, l, r);
        o = u;
      }
    } else
      o = OEe(e, i, r);
    return /* @__PURE__ */ y.jsx("path", { d: o });
  }
  toSvg(e) {
    return /* @__PURE__ */ y.jsx(j7, { shouldScale: !0, shape: e });
  }
  getHandleSnapGeometry(e) {
    const r = t1(e);
    return {
      points: r,
      getSelfSnapPoints: (i) => {
        const s = this.getHandles(e).filter((o) => o.type === "vertex").findIndex((o) => o.id === i.id);
        return r.filter((o, l) => Math.abs(l - s) > 1).map(O.From);
      },
      getSelfSnapOutline: (i) => {
        const s = this.getHandles(e).filter((l) => l.type === "vertex").findIndex((l) => l.id === i.id), o = n1(e).segments.filter(
          (l, u) => u !== s - 1 && u !== s
        );
        return o.length ? new ld({ children: o }) : null;
      }
    };
  }
  getInterpolatedProps(e, r, i) {
    const s = t1(e), o = t1(r), l = [], u = [];
    let d = CG;
    if (s.length > o.length)
      for (let f = 0; f < s.length; f++)
        l[f] = { ...s[f] }, o[f] === void 0 ? u[f] = { ...o[o.length - 1], id: d } : u[f] = { ...o[f], id: d }, d = id(d);
    else if (o.length > s.length)
      for (let f = 0; f < o.length; f++)
        u[f] = { ...o[f] }, s[f] === void 0 ? l[f] = {
          ...s[s.length - 1],
          id: d
        } : l[f] = { ...s[f], id: d }, d = id(d);
    else
      for (let f = 0; f < o.length; f++)
        l[f] = s[f], u[f] = o[f];
    return {
      ...r.props,
      points: Object.fromEntries(
        l.map((f, m) => {
          const v = u[m];
          return [
            f.id,
            {
              ...f,
              x: Il(f.x, v.x, i),
              y: Il(f.y, v.y, i)
            }
          ];
        })
      )
    };
  }
}
T(bR, "type", "line"), T(bR, "props", fK), T(bR, "migrations", pK);
function t1(n) {
  return Object.values(n.props.points).sort(fa);
}
function n1(n) {
  const t = t1(n).map(O.From);
  switch (n.props.spline) {
    case "cubic":
      return new swe({ points: t });
    case "line":
      return new pw({ points: t });
  }
}
function j7({
  shape: n,
  shouldScale: t = !1
}) {
  const e = uu(), r = n1(n), { dash: i, color: s, size: o } = n.props, l = 1 / n.props.scale, u = t ? l : 1, d = eo[o] * n.props.scale;
  if (n.props.spline === "line") {
    if (i === "solid") {
      const f = r.points, m = "M" + f[0] + "L" + f.slice(1);
      return /* @__PURE__ */ y.jsx(
        "path",
        {
          d: m,
          stroke: e[s].solid,
          strokeWidth: d,
          fill: "none",
          transform: `scale(${u})`
        }
      );
    }
    if (i === "dashed" || i === "dotted")
      return /* @__PURE__ */ y.jsx("g", { stroke: e[s].solid, strokeWidth: d, transform: `scale(${u})`, children: r.segments.map((f, m) => {
        const { strokeDasharray: v, strokeDashoffset: S } = fh(
          f.length,
          d,
          {
            style: i,
            start: m > 0 ? "outset" : "none",
            end: m < r.segments.length - 1 ? "outset" : "none"
          }
        );
        return /* @__PURE__ */ y.jsx(
          "path",
          {
            strokeDasharray: v,
            strokeDashoffset: S,
            d: f.getSvgPathData(!0),
            fill: "none"
          },
          m
        );
      }) });
    if (i === "draw") {
      const f = r.points, [m, v] = hX(n.id, f, d);
      return /* @__PURE__ */ y.jsx(
        "path",
        {
          d: v,
          stroke: e[s].solid,
          strokeWidth: d,
          fill: "none",
          transform: `scale(${u})`
        }
      );
    }
  }
  if (n.props.spline === "cubic") {
    const f = r.getSvgPathData();
    if (i === "solid")
      return /* @__PURE__ */ y.jsx(
        "path",
        {
          strokeWidth: d,
          stroke: e[s].solid,
          fill: "none",
          d: f,
          transform: `scale(${u})`
        }
      );
    if (i === "dashed" || i === "dotted")
      return /* @__PURE__ */ y.jsx("g", { stroke: e[s].solid, strokeWidth: d, transform: `scale(${u})`, children: r.segments.map((m, v) => {
        const { strokeDasharray: S, strokeDashoffset: w } = fh(
          m.length,
          d,
          {
            style: i,
            start: v > 0 ? "outset" : "none",
            end: v < r.segments.length - 1 ? "outset" : "none"
          }
        );
        return /* @__PURE__ */ y.jsx(
          "path",
          {
            strokeDasharray: S,
            strokeDashoffset: w,
            d: m.getSvgPathData(),
            fill: "none"
          },
          v
        );
      }) });
    if (i === "draw")
      return /* @__PURE__ */ y.jsx(
        "path",
        {
          d: DEe(n, r, d),
          strokeWidth: 1,
          stroke: e[s].solid,
          fill: e[s].solid,
          transform: `scale(${u})`
        }
      );
  }
}
const fX = D.createContext(null);
function jEe({
  assetUrls: n,
  children: t
}) {
  return D.useEffect(() => {
    for (const e of Object.values(n.icons)) {
      const r = Xx();
      r.src = e, r.decode();
    }
    for (const e of Object.values(n.embedIcons)) {
      const r = Xx();
      r.src = e, r.decode();
    }
  }, [n]), /* @__PURE__ */ y.jsx(fX.Provider, { value: n, children: t });
}
function U5() {
  const n = D.useContext(fX);
  if (!n)
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  return n;
}
const j3 = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-json.short": "JSON",
  "action.copy-as-json": "Copy as JSON",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-json.short": "JSON",
  "action.export-as-json": "Export as JSON",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-json.short": "JSON",
  "action.export-all-as-json": "Export as JSON",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle Select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.url.failed": "Couldn't load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.cloud": "Cloud",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus-2": "Rhombus 2",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.asset": "Asset",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.help": "Help",
  "menu.view": "View",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.default-project-name": "Shared Project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.readonly-link": "Read-only",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project can't be shared because it's too large. We're working on it!",
  "share-menu.upload-failed": "Sorry, we couldn't upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project…",
  "share-menu.copied": "Copied link",
  "status.offline": "Offline",
  "status.online": "Online",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following You",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About",
  "help-menu.docs": "Documentation & API",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site's URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "edit-pages-dialog.move-down": "Move down",
  "edit-pages-dialog.move-up": "Move up",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "home-project-dialog.title": "Home project",
  "home-project-dialog.description": "This is your local home project. It's just for you!",
  "rename-project-dialog.title": "Rename project",
  "rename-project-dialog.cancel": "Cancel",
  "rename-project-dialog.rename": "Rename",
  "home-project-dialog.ok": "Ok",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "tool-panel.drawing": "Drawing",
  "tool-panel.shapes": "Shapes",
  "tool-panel.more": "More",
  "debug-panel.more": "More",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn't look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don't ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Don't ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Don't ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don't ask again",
  "cursor-chat.type-to-chat": "Type to chat..."
}, NEe = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]), S0 = {
  locale: "en",
  label: "English",
  messages: j3,
  dir: "ltr"
};
async function FEe(n, t) {
  if (!(await Th(t.translations.en)).ok)
    return console.warn("No main translations found."), S0;
  if (n === "en")
    return S0;
  const r = B1.find((l) => l.locale === n);
  if (!r)
    return console.warn(`No translation found for locale ${n}`), S0;
  const s = await (await Th(t.translations[r.locale])).json();
  if (!s)
    return console.warn(`No messages found for locale ${n}`), S0;
  const o = [];
  for (const l in S0.messages)
    s[l] || o.push(l);
  return o.length > 0 && process.env.NODE_ENV === "development" && console.warn(`Language ${n}: missing messages for keys:
${o.join(`
`)}`), {
    locale: n,
    label: r.label,
    dir: NEe.has(r.locale) ? "rtl" : "ltr",
    messages: { ...S0.messages, ...s }
  };
}
const pX = D.createContext(null);
function gX() {
  const n = D.useContext(pX);
  if (!n)
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  return n;
}
const $Ee = ro(function({
  overrides: t,
  children: e
}) {
  const i = we().user.getLocale(), s = U5(), [o, l] = D.useState(() => t && t.en ? {
    locale: "en",
    label: "English",
    dir: "ltr",
    messages: { ...j3, ...t.en }
  } : {
    locale: "en",
    label: "English",
    dir: "ltr",
    messages: j3
  });
  return D.useEffect(() => {
    let u = !1;
    async function d() {
      const f = await FEe(i, s);
      f && !u && (t && t[i] ? l({
        ...f,
        messages: { ...f.messages, ...t[i] }
      }) : l(f));
    }
    return d(), () => {
      u = !0;
    };
  }, [s, i, t]), /* @__PURE__ */ y.jsx(pX.Provider, { value: o, children: e });
});
function Dn() {
  const n = gX();
  return D.useCallback(
    function(e) {
      return n.messages[e] ?? e;
    },
    [n]
  );
}
class xR extends ad {
  constructor() {
    super(...arguments);
    T(this, "canEdit", () => !0);
    T(this, "hideResizeHandles", () => !0);
    T(this, "hideSelectionBoundsFg", () => !1);
    T(this, "onBeforeCreate", (e) => N7(this.editor, e));
    T(this, "onBeforeUpdate", (e, r) => {
      if (!(e.props.text === r.props.text && e.props.font === r.props.font && e.props.size === r.props.size))
        return N7(this.editor, r);
    });
    T(this, "onEditEnd", (e) => {
      const {
        id: r,
        type: i,
        props: { text: s }
      } = e;
      s.trimEnd() !== e.props.text && this.editor.updateShapes([
        {
          id: r,
          type: i,
          props: {
            text: s.trimEnd()
          }
        }
      ]);
    });
  }
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      text: "",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(e) {
    const { labelHeight: r, labelWidth: i } = mX(this.editor, e), { scale: s } = e.props, o = r * s, l = i * s, u = Or * s, d = TI(e);
    return new ld({
      children: [
        new Sp({ width: u, height: d, isFilled: !0 }),
        new Sp({
          x: e.props.align === "start" ? 0 : e.props.align === "end" ? u - l : (u - l) / 2,
          y: e.props.verticalAlign === "start" ? 0 : e.props.verticalAlign === "end" ? d - o : (d - o) / 2,
          width: l,
          height: o,
          isFilled: !0,
          isLabel: !0
        })
      ]
    });
  }
  getHandles(e) {
    const { scale: r } = e.props;
    if (this.editor.getInstanceState().isCoarsePointer) return [];
    const s = this.editor.getZoomLevel();
    if (s * r < 0.25) return [];
    const o = TI(e), l = Or * r, u = hCe / s * r;
    return s * r < 0.5 ? [
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: l / 2,
        y: o + u
      }
    ] : [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: l / 2,
        y: -u
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: l + u,
        y: o / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: l / 2,
        y: o + u
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -u,
        y: o / 2
      }
    ];
  }
  component(e) {
    const {
      id: r,
      type: i,
      props: { scale: s, color: o, font: l, size: u, align: d, text: f, verticalAlign: m, fontSizeAdjustment: v }
    } = e, S = BEe(r), w = uu(), E = Or * s, A = TI(e), P = De(
      "shape rotation",
      () => {
        var j;
        return ((j = this.editor.getShapePageTransform(r)) == null ? void 0 : j.rotation()) ?? 0;
      },
      [this.editor]
    ), R = De("zoom", () => this.editor.getZoomLevel() < 0.35 / s, [
      s,
      this.editor
    ]), M = e.id === this.editor.getOnlySelectedShapeId();
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "div",
        {
          id: r,
          className: "tl-note__container",
          style: {
            width: E,
            height: A,
            backgroundColor: w[o].note.fill,
            borderBottom: R ? `${3 * s}px solid rgb(15, 23, 31, .2)` : "none",
            boxShadow: R ? "none" : HEe(e.id, P, s)
          },
          children: /* @__PURE__ */ y.jsx(
            V2,
            {
              id: r,
              type: i,
              font: l,
              fontSize: (v || dp[u]) * s,
              lineHeight: Oo.lineHeight,
              align: d,
              verticalAlign: m,
              text: f,
              isNote: !0,
              isSelected: M,
              labelColor: w[o].note.text,
              wrap: !0,
              padding: 16 * s,
              onKeyDown: S
            }
          )
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ y.jsx(ew, { url: e.props.url, zoomLevel: this.editor.getZoomLevel() })
    ] });
  }
  indicator(e) {
    const { scale: r } = e.props;
    return /* @__PURE__ */ y.jsx(
      "rect",
      {
        rx: r,
        width: be(Or * r),
        height: be(TI(e))
      }
    );
  }
  toSvg(e, r) {
    e.props.text && r.addExportDef(B2(e.props.font));
    const i = Pp({ isDarkMode: r.isDarkMode }), s = VEe(e);
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx("rect", { x: 5, y: 5, rx: 1, width: Or - 10, height: s.h, fill: "rgba(0,0,0,.1)" }),
      /* @__PURE__ */ y.jsx(
        "rect",
        {
          rx: 1,
          width: Or,
          height: s.h,
          fill: i[e.props.color].note.fill
        }
      ),
      /* @__PURE__ */ y.jsx(
        H2,
        {
          fontSize: e.props.fontSizeAdjustment || dp[e.props.size],
          font: e.props.font,
          align: e.props.align,
          verticalAlign: e.props.verticalAlign,
          text: e.props.text,
          labelColor: i[e.props.color].note.text,
          bounds: s,
          stroke: !1
        }
      )
    ] });
  }
}
T(xR, "type", "note"), T(xR, "props", gK), T(xR, "migrations", mK);
function N7(n, t) {
  const { labelHeight: e, fontSizeAdjustment: r } = mX(n, t), i = Math.max(0, e - Or);
  if (i !== t.props.growY || r !== t.props.fontSizeAdjustment)
    return {
      ...t,
      props: {
        ...t.props,
        growY: i,
        fontSizeAdjustment: r
      }
    };
}
function zEe(n, t) {
  const { text: e } = t.props;
  if (!e)
    return { labelHeight: dp[t.props.size] * Oo.lineHeight + tu * 2, labelWidth: 100, fontSizeAdjustment: 0 };
  const r = dp[t.props.size];
  let i = 0, s = 0, o = Or, l = Or;
  const u = 1;
  do {
    i = Math.min(r, r - s);
    const d = n.textMeasure.measureText(e, {
      ...Oo,
      fontFamily: Ch[t.props.font],
      fontSize: i,
      maxWidth: Or - tu * 2 - u,
      disableOverflowWrapBreaking: !0
    });
    if (o = d.h + tu * 2, l = d.w + tu * 2, i <= 14) {
      const f = n.textMeasure.measureText(e, {
        ...Oo,
        fontFamily: Ch[t.props.font],
        fontSize: i,
        maxWidth: Or - tu * 2 - u
      });
      o = f.h + tu * 2, l = f.w + tu * 2;
      break;
    }
    if (d.scrollWidth.toFixed(0) === d.w.toFixed(0))
      break;
  } while (s++ < 50);
  return {
    labelHeight: o,
    labelWidth: l,
    fontSizeAdjustment: i
  };
}
const UEe = new vp();
function mX(n, t) {
  return UEe.get(t, () => zEe(n, t));
}
function BEe(n) {
  const t = we(), e = gX();
  return D.useCallback(
    (r) => {
      const i = t.getShape(n);
      if (!i) return;
      const s = r.key === "Tab", o = (r.metaKey || r.ctrlKey) && r.key === "Enter";
      if (s || o) {
        r.preventDefault();
        const l = t.getShapePageTransform(n), u = l.rotation(), d = !!(e.dir === "rtl" || UY(i.props.text)), f = (Or + t.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (o && !r.shiftKey ? i.props.growY : 0)) * i.props.scale, m = new O(
          s ? r.shiftKey != d ? -1 : 1 : 0,
          o ? r.shiftKey ? -1 : 1 : 0
        ).mul(f).add(U2.clone().mul(i.props.scale)).rot(u).add(l.point()), v = XY(t, i, m, u);
        v && (t.mark("editing adjacent shape"), DM(
          t,
          v,
          !0
          /* selectAll */
        ));
      }
    },
    [n, t, e.dir]
  );
}
function TI(n) {
  return (Or + n.props.growY) * n.props.scale;
}
function HEe(n, t, e) {
  const r = dd(n), i = Math.abs(r()) + 0.5, s = Math.cos(t), o = 5 * e, l = 4 * e, u = 6 * e, d = 7 * e;
  return `0px ${o - i}px ${o}px -${o}px rgba(15, 23, 31, .6),
	0px ${(l + i * d) * Math.max(0, s)}px ${u + i * d}px -${l + i * u}px rgba(15, 23, 31, ${(0.3 + i * 0.1).toFixed(2)}), 
	0px ${48 * e}px ${10 * e}px -${10 * e}px inset rgba(15, 23, 44, ${((0.022 + r() * 5e-3) * ((1 + s) / 2)).toFixed(2)})`;
}
function VEe(n) {
  return new vt(0, 0, Or, Or + n.props.growY);
}
function WEe(n, {
  initialBounds: t,
  scaleX: e,
  scaleY: r,
  newPoint: i
}) {
  const s = Math.max(0.01, Math.min(Math.abs(e), Math.abs(r))), o = new O(0, 0);
  e < 0 && (o.x = -(t.width * s)), r < 0 && (o.y = -(t.height * s));
  const { x: l, y: u } = O.Add(i, o.rot(n.rotation));
  return {
    x: l,
    y: u,
    props: {
      scale: s * n.props.scale
    }
  };
}
const GEe = new vp();
class wR extends ad {
  constructor() {
    super(...arguments);
    T(this, "canEdit", () => !0);
    T(this, "isAspectRatioLocked", () => !0);
    T(this, "onResize", (e, r) => {
      const { newPoint: i, initialBounds: s, initialShape: o, scaleX: l, handle: u } = r;
      if (r.mode === "scale_shape" || u !== "right" && u !== "left")
        return {
          id: e.id,
          type: e.type,
          ...WEe(e, r)
        };
      {
        const d = Math.max(1, Math.abs(s.width * l)), { x: f, y: m } = l < 0 ? O.Sub(i, O.FromAngle(e.rotation).mul(d)) : i;
        return {
          id: e.id,
          type: e.type,
          x: f,
          y: m,
          props: {
            w: d / o.props.scale,
            autoSize: !1
          }
        };
      }
    });
    T(this, "onEditEnd", (e) => {
      const {
        id: r,
        type: i,
        props: { text: s }
      } = e, o = e.props.text.trimEnd();
      o.length === 0 ? this.editor.deleteShapes([e.id]) : o !== e.props.text && this.editor.updateShapes([
        {
          id: r,
          type: i,
          props: {
            text: s.trimEnd()
          }
        }
      ]);
    });
    T(this, "onBeforeUpdate", (e, r) => {
      if (!r.props.autoSize) return;
      const i = e.props.size !== r.props.size || e.props.textAlign !== r.props.textAlign || e.props.font !== r.props.font || e.props.scale !== 1 && r.props.scale === 1, s = e.props.text !== r.props.text;
      if (!i && !s) return;
      const o = this.getMinDimensions(e), l = F7(this.editor, r.props), u = o.width * e.props.scale, d = o.height * e.props.scale, f = l.width * r.props.scale, m = l.height * r.props.scale;
      let v;
      switch (r.props.textAlign) {
        case "middle": {
          v = new O((f - u) / 2, s ? 0 : (m - d) / 2);
          break;
        }
        case "end": {
          v = new O(f - u, s ? 0 : (m - d) / 2);
          break;
        }
        default: {
          if (s) break;
          v = new O(0, (m - d) / 2);
          break;
        }
      }
      if (v) {
        v.rot(r.rotation);
        const { x: S, y: w } = r;
        return {
          ...r,
          x: S - v.x,
          y: w - v.y,
          props: { ...r.props, w: f }
        };
      } else
        return {
          ...r,
          props: { ...r.props, w: f }
        };
    });
  }
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      text: "",
      font: "draw",
      textAlign: "start",
      autoSize: !0,
      scale: 1
    };
  }
  getMinDimensions(e) {
    return GEe.get(e.props, (r) => F7(this.editor, r));
  }
  getGeometry(e) {
    const { scale: r } = e.props, { width: i, height: s } = this.getMinDimensions(e);
    return new Sp({
      width: i * r,
      height: s * r,
      isFilled: !0,
      isLabel: !0
    });
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(e) {
    const {
      id: r,
      props: { font: i, size: s, text: o, color: l, scale: u, textAlign: d }
    } = e, { width: f, height: m } = this.getMinDimensions(e), v = e.id === this.editor.getOnlySelectedShapeId(), S = uu(), w = KEe(r);
    return /* @__PURE__ */ y.jsx(
      V2,
      {
        id: r,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font: i,
        fontSize: Qx[s],
        lineHeight: Oo.lineHeight,
        align: d,
        verticalAlign: "middle",
        text: o,
        labelColor: S[l].solid,
        isSelected: v,
        textWidth: f,
        textHeight: m,
        style: {
          transform: `scale(${u})`,
          transformOrigin: "top left"
        },
        wrap: !0,
        onKeyDown: w
      }
    );
  }
  indicator(e) {
    const r = this.editor.getShapeGeometry(e).bounds, i = we();
    return e.props.autoSize && i.getEditingShapeId() === e.id ? null : /* @__PURE__ */ y.jsx("rect", { width: be(r.width), height: be(r.height) });
  }
  toSvg(e, r) {
    e.props.text && r.addExportDef(B2(e.props.font));
    const i = this.editor.getShapeGeometry(e).bounds, s = i.width / (e.props.scale ?? 1), o = i.height / (e.props.scale ?? 1), l = Pp(r);
    return /* @__PURE__ */ y.jsx(
      H2,
      {
        fontSize: Qx[e.props.size],
        font: e.props.font,
        align: e.props.textAlign,
        verticalAlign: "middle",
        text: e.props.text,
        labelColor: l[e.props.color].solid,
        bounds: new vt(0, 0, s, o),
        padding: 0
      }
    );
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
}
T(wR, "type", "text"), T(wR, "props", vK), T(wR, "migrations", yK);
function F7(n, t) {
  const { font: e, text: r, autoSize: i, size: s, w: o } = t, l = i ? 16 : Math.max(16, o), u = Qx[s], d = i ? null : (
    // `measureText` floors the number so we need to do the same here to avoid issues.
    Math.floor(Math.max(l, o))
  ), f = n.textMeasure.measureText(r, {
    ...Oo,
    fontFamily: Ch[e],
    fontSize: u,
    maxWidth: d
  });
  return i && (f.w += 1), {
    width: Math.max(l, f.w),
    height: Math.max(u, f.h)
  };
}
function KEe(n) {
  const t = we();
  return D.useCallback(
    (e) => {
      if (t.getEditingShapeId() === n)
        switch (e.key) {
          case "Enter": {
            (e.ctrlKey || e.metaKey) && t.complete();
            break;
          }
          case "Tab": {
            qn(e), e.shiftKey ? Jx.unindent(e.currentTarget) : Jx.indent(e.currentTarget);
            break;
          }
        }
    },
    [t, n]
  );
}
class CR extends gw {
  constructor() {
    super(...arguments);
    T(this, "canEdit", () => !0);
    T(this, "isAspectRatioLocked", () => !0);
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: !0,
      url: ""
    };
  }
  component(e) {
    const { editor: r } = this, i = r.getShapeGeometry(e).bounds.w * r.getZoomLevel() >= 110, { asset: s, url: o } = lX(e.id, e.props.assetId, e.props.w), { time: l, playing: u } = e.props, d = $2(e.id), f = cX(), m = D.useRef(null), v = D.useCallback(
      (R) => {
        const M = R.currentTarget;
        M && r.updateShapes([
          {
            type: "video",
            id: e.id,
            props: {
              playing: !0,
              time: M.currentTime
            }
          }
        ]);
      },
      [e.id, r]
    ), S = D.useCallback(
      (R) => {
        const M = R.currentTarget;
        M && r.updateShapes([
          {
            type: "video",
            id: e.id,
            props: {
              playing: !1,
              time: M.currentTime
            }
          }
        ]);
      },
      [e.id, r]
    ), w = D.useCallback(
      (R) => {
        const M = R.currentTarget;
        M && d && r.updateShapes([
          {
            type: "video",
            id: e.id,
            props: {
              time: M.currentTime
            }
          }
        ]);
      },
      [d, e.id, r]
    ), [E, A] = D.useState(!1), P = D.useCallback(
      (R) => {
        const M = R.currentTarget;
        M && (l !== M.currentTime && (M.currentTime = l), u || M.pause(), A(!0));
      },
      [u, l]
    );
    return D.useEffect(() => {
      const R = m.current;
      R && (E && !d && l !== R.currentTime && (R.currentTime = l), d && document.activeElement !== R && R.focus());
    }, [d, E, l]), D.useEffect(() => {
      if (f) {
        const R = m.current;
        if (!R) return;
        R.pause(), R.currentTime = 0;
      }
    }, [m, f]), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        rS,
        {
          id: e.id,
          style: {
            color: "var(--color-text-3)",
            backgroundColor: s ? "transparent" : "var(--color-low)",
            border: s ? "none" : "1px solid var(--color-low-border)"
          },
          children: /* @__PURE__ */ y.jsx("div", { className: "tl-counter-scaled", children: /* @__PURE__ */ y.jsx("div", { className: "tl-video-container", children: s != null && s.props.src ? o ? /* @__PURE__ */ y.jsx(
            "video",
            {
              ref: m,
              style: d ? { pointerEvents: "all" } : void 0,
              className: `tl-video tl-video-shape-${e.id.split(":")[1]}`,
              width: "100%",
              height: "100%",
              draggable: !1,
              playsInline: !0,
              autoPlay: !0,
              muted: !0,
              loop: !0,
              disableRemotePlayback: !0,
              disablePictureInPicture: !0,
              controls: d && i,
              onPlay: v,
              onPause: S,
              onTimeUpdate: w,
              onLoadedData: P,
              hidden: !E,
              children: /* @__PURE__ */ y.jsx("source", { src: o })
            }
          ) : null : /* @__PURE__ */ y.jsx(aX, {}) }) })
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ y.jsx(ew, { url: e.props.url, zoomLevel: r.getZoomLevel() })
    ] });
  }
  indicator(e) {
    return /* @__PURE__ */ y.jsx("rect", { width: be(e.props.w), height: be(e.props.h) });
  }
  toSvg(e) {
    return /* @__PURE__ */ y.jsx("image", { href: YEe(e.id), width: e.props.w, height: e.props.h });
  }
}
T(CR, "type", "video"), T(CR, "props", SK), T(CR, "migrations", bK);
function YEe(n) {
  const t = n.split(":")[1], e = document.querySelector(`.tl-video-shape-${t}`);
  if (e) {
    const r = document.createElement("canvas");
    return r.width = e.videoWidth, r.height = e.videoHeight, r.getContext("2d").drawImage(e, 0, 0), r.toDataURL("image/png");
  } else throw new Error("Video with not found when attempting serialization.");
}
const vX = [
  wR,
  fR,
  pR,
  vR,
  xR,
  bR,
  mR,
  hR,
  yR,
  gR,
  SR,
  CR
];
function XEe(n) {
  return n.sideEffects.register({
    instance_page_state: {
      afterChange: (t, e) => {
        if (t.croppingShapeId !== e.croppingShapeId) {
          const r = n.isIn("select.crop");
          !t.croppingShapeId && e.croppingShapeId ? r || n.setCurrentTool("select.crop.idle") : t.croppingShapeId && !e.croppingShapeId && r && n.setCurrentTool("select.idle");
        }
        t.editingShapeId !== e.editingShapeId && (!t.editingShapeId && e.editingShapeId ? n.isIn("select.editing_shape") || n.setCurrentTool("select.editing_shape") : t.editingShapeId && !e.editingShapeId && n.isIn("select.editing_shape") && n.setCurrentTool("select.idle"));
      }
    }
  });
}
class yX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "scribbleId", "id");
    T(this, "markId", "");
    T(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    T(this, "onEnter", (e) => {
      this.markId = "erase scribble begin", this.editor.mark(this.markId), this.info = e;
      const { originPagePoint: r } = this.editor.inputs;
      this.excludedShapeIds = new Set(
        this.editor.getCurrentPageShapes().filter((s) => {
          if (this.editor.isShapeOrAncestorLocked(s)) return !0;
          if (this.editor.isShapeOfType(s, "group") || this.editor.isShapeOfType(s, "frame")) {
            const o = this.editor.getPointInShapeSpace(s, r);
            return this.editor.getShapeGeometry(s).bounds.containsPoint(o);
          }
          return !1;
        }).map((s) => s.id)
      );
      const i = this.editor.scribbles.addScribble({
        color: "muted-1",
        size: 12
      });
      this.scribbleId = i.id, this.update();
    });
    T(this, "pushPointToScribble", () => {
      const { x: e, y: r } = this.editor.inputs.currentPagePoint;
      this.editor.scribbles.addPoint(this.scribbleId, e, r);
    });
    T(this, "onExit", () => {
      this.editor.scribbles.stop(this.scribbleId);
    });
    T(this, "onPointerMove", () => {
      this.update();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
  }
  update() {
    const { editor: e, excludedShapeIds: r } = this, i = e.getErasingShapeIds(), s = e.getZoomLevel(), o = e.getCurrentPageShapes(), {
      inputs: { currentPagePoint: l, previousPagePoint: u }
    } = e;
    this.pushPointToScribble();
    const d = new Set(i), f = this.editor.options.hitTestMargin / s;
    for (const m of o) {
      if (e.isShapeOfType(m, "group")) continue;
      const v = e.getShapeMask(m.id);
      if (v && !yc(l, v))
        continue;
      const S = e.getShapeGeometry(m), w = e.getShapePageTransform(m);
      if (!S || !w) continue;
      const E = w.clone().invert(), A = E.applyToPoint(u), P = E.applyToPoint(l), { bounds: R } = S;
      R.minX - f > Math.max(A.x, P.x) || R.minY - f > Math.max(A.y, P.y) || R.maxX + f < Math.min(A.x, P.x) || R.maxY + f < Math.min(A.y, P.y) || S.hitTestLineSegment(A, P, f) && d.add(e.getOutermostSelectableShape(m).id);
    }
    this.editor.setErasingShapes([...d].filter((m) => !r.has(m)));
  }
  complete() {
    const { editor: e } = this;
    e.deleteShapes(e.getCurrentPageState().erasingShapeIds), e.setErasingShapes([]), this.parent.transition("idle");
  }
  cancel() {
    const { editor: e } = this;
    e.setErasingShapes([]), e.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}
T(yX, "id", "erasing");
var LF;
let qEe = (LF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(LF, "id", "idle"), LF);
var jF;
let ZEe = (jF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      const e = this.editor.getZoomLevel(), r = this.editor.getCurrentPageShapesSorted(), {
        inputs: { currentPagePoint: i }
      } = this.editor, s = /* @__PURE__ */ new Set(), o = s.size;
      for (let l = r.length, u = l - 1; u >= 0; u--) {
        const d = r[u];
        if (!(this.editor.isShapeOrAncestorLocked(d) || this.editor.isShapeOfType(d, "group")) && this.editor.isPointInShape(d, i, {
          hitInside: !1,
          margin: this.editor.options.hitTestMargin / e
        })) {
          const f = this.editor.getOutermostSelectableShape(d);
          if (this.editor.isShapeOfType(f, "frame") && s.size > o)
            break;
          s.add(f.id);
        }
      }
      this.editor.setErasingShapes([...s]);
    });
    T(this, "onLongPress", (e) => {
      this.startErasing(e);
    });
    T(this, "onPointerMove", (e) => {
      this.editor.inputs.isDragging && this.startErasing(e);
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  startErasing(e) {
    this.parent.transition("erasing", e);
  }
  complete() {
    const e = this.editor.getErasingShapeIds();
    e.length && (this.editor.mark("erase end"), this.editor.deleteShapes(e)), this.editor.setErasingShapes([]), this.parent.transition("idle");
  }
  cancel() {
    this.editor.setErasingShapes([]), this.parent.transition("idle");
  }
}, T(jF, "id", "pointing"), jF);
class r1 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
  }
}
T(r1, "id", "eraser"), T(r1, "initial", "idle"), T(r1, "isLockable", !1), T(r1, "children", () => [qEe, ZEe, yX]);
class SX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "initialCamera", new O());
    T(this, "onEnter", () => {
      this.initialCamera = O.From(this.editor.getCamera()), this.update();
    });
    T(this, "onPointerMove", () => {
      this.update();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.parent.transition("idle");
    });
    T(this, "onComplete", () => {
      this.complete();
    });
  }
  update() {
    const { initialCamera: e, editor: r } = this, { currentScreenPoint: i, originScreenPoint: s } = r.inputs, o = O.Sub(i, s).div(r.getZoomLevel());
    o.len2() !== 0 && r.setCamera(e.clone().add(o));
  }
  complete() {
    const { editor: e } = this, { pointerVelocity: r } = e.inputs, i = Math.min(r.len(), 2);
    i > 0.1 && this.editor.slideCamera({ speed: i, direction: r }), this.parent.transition("idle");
  }
}
T(SX, "id", "dragging");
var NF;
let QEe = (NF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "grab", rotation: 0 });
    });
    T(this, "onPointerDown", (e) => {
      this.parent.transition("pointing", e);
    });
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select");
    });
  }
}, T(NF, "id", "idle"), NF);
var FF;
let JEe = (FF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      this.editor.stopCameraAnimation(), this.editor.setCursor({ type: "grabbing", rotation: 0 });
    });
    T(this, "onLongPress", () => {
      this.startDragging();
    });
    T(this, "onPointerMove", () => {
      this.editor.inputs.isDragging && this.startDragging();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.complete();
    });
  }
  startDragging() {
    this.parent.transition("dragging");
  }
  complete() {
    this.parent.transition("idle");
  }
}, T(FF, "id", "pointing"), FF);
class i1 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onDoubleClick", (e) => {
      if (e.phase === "settle") {
        const { currentScreenPoint: r } = this.editor.inputs;
        this.editor.zoomIn(r, {
          animation: { duration: 220, easing: Js.easeOutQuint }
        });
      }
    });
    T(this, "onTripleClick", (e) => {
      if (e.phase === "settle") {
        const { currentScreenPoint: r } = this.editor.inputs;
        this.editor.zoomOut(r, {
          animation: { duration: 320, easing: Js.easeOutQuint }
        });
      }
    });
    T(this, "onQuadrupleClick", (e) => {
      if (e.phase === "settle") {
        const r = this.editor.getZoomLevel(), {
          inputs: { currentScreenPoint: i }
        } = this.editor;
        r === 1 ? this.editor.zoomToFit({ animation: { duration: 400, easing: Js.easeOutQuint } }) : this.editor.resetZoom(i, {
          animation: { duration: 320, easing: Js.easeOutQuint }
        });
      }
    });
  }
}
T(i1, "id", "hand"), T(i1, "initial", "idle"), T(i1, "isLockable", !1), T(i1, "children", () => [QEe, JEe, SX]);
var $F;
let e1e = ($F = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onPointerDown", (e) => {
      this.parent.transition("lasering", e);
    });
  }
}, T($F, "id", "idle"), $F);
class bX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "scribbleId", "id");
    T(this, "onEnter", () => {
      const e = this.editor.scribbles.addScribble({
        color: "laser",
        opacity: 0.7,
        size: 4,
        delay: 1200,
        shrink: 0.05,
        taper: !0
      });
      this.scribbleId = e.id, this.pushPointToScribble();
    });
    T(this, "onExit", () => {
      this.editor.scribbles.stop(this.scribbleId);
    });
    T(this, "onPointerMove", () => {
      this.pushPointToScribble();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "pushPointToScribble", () => {
      const { x: e, y: r } = this.editor.inputs.currentPagePoint;
      this.editor.scribbles.addPoint(this.scribbleId, e, r);
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
  }
  complete() {
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}
T(bX, "id", "lasering");
class s1 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    });
  }
}
T(s1, "id", "laser"), T(s1, "initial", "idle"), T(s1, "children", () => [e1e, bX]), T(s1, "isLockable", !1);
class xX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "initialSelectedShapeIds", []);
    T(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    T(this, "isWrapMode", !1);
    // The shape that the brush started on
    T(this, "initialStartShape", null);
    T(this, "onEnter", (e) => {
      const { altKey: r, currentPagePoint: i } = this.editor.inputs;
      if (this.isWrapMode = this.editor.user.getIsWrapMode(), r) {
        this.parent.transition("scribble_brushing", e);
        return;
      }
      this.excludedShapeIds = new Set(
        this.editor.getCurrentPageShapes().filter(
          (s) => this.editor.isShapeOfType(s, "group") || this.editor.isShapeOrAncestorLocked(s)
        ).map((s) => s.id)
      ), this.info = e, this.initialSelectedShapeIds = this.editor.getSelectedShapeIds().slice(), this.initialStartShape = this.editor.getShapesAtPoint(i)[0], this.hitTestShapes();
    });
    T(this, "onExit", () => {
      this.initialSelectedShapeIds = [], this.editor.updateInstanceState({ brush: null });
    });
    T(this, "onTick", ({ elapsed: e }) => {
      const { editor: r } = this;
      r.edgeScrollManager.updateEdgeScrolling(e);
    });
    T(this, "onPointerMove", () => {
      this.hitTestShapes();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", (e) => {
      this.editor.setSelectedShapes(this.initialSelectedShapeIds), this.parent.transition("idle", e);
    });
    T(this, "onKeyDown", (e) => {
      this.editor.inputs.altKey ? this.parent.transition("scribble_brushing", e) : this.hitTestShapes();
    });
    T(this, "onKeyUp", () => {
      this.hitTestShapes();
    });
    T(this, "onInterrupt", () => {
      this.editor.updateInstanceState({ brush: null });
    });
  }
  complete() {
    this.hitTestShapes(), this.parent.transition("idle");
  }
  hitTestShapes() {
    const { editor: e, excludedShapeIds: r, isWrapMode: i } = this, {
      inputs: { originPagePoint: s, currentPagePoint: o, shiftKey: l, ctrlKey: u }
    } = e, d = new Set(l ? this.initialSelectedShapeIds : []), f = i ? !u : u, m = vt.FromPoints([s, o]), { corners: v } = m;
    let S, w, E, A, P, R;
    const M = e.getCurrentPageShapes(), j = e.getCurrentPageId();
    e: for (let F = 0, B = M.length; F < B; F++) {
      if (E = M[F], r.has(E.id) || d.has(E.id) || (A = e.getShapePageBounds(E), !A)) continue e;
      if (m.contains(A)) {
        this.handleHit(E, o, j, d, v);
        continue e;
      }
      if (f || e.isShapeOfType(E, "frame"))
        continue e;
      if (m.collides(A)) {
        if (P = e.getShapePageTransform(E), !P) continue e;
        R = P.clone().invert().applyToPoints(v);
        const G = e.getShapeGeometry(E);
        t: for (let X = 0; X < 4; X++)
          if (S = R[X], w = R[(X + 1) % 4], G.hitTestLineSegment(S, w, 0)) {
            this.handleHit(E, o, j, d, v);
            break t;
          }
      }
    }
    e.getInstanceState().isCoarsePointer;
    const $ = e.getInstanceState().brush;
    (!$ || !m.equals($)) && e.updateInstanceState({ brush: { ...m.toJson() } });
    const U = e.getSelectedShapeIds();
    (U.length !== d.size || U.some((F) => !d.has(F))) && e.setSelectedShapes(Array.from(d));
  }
  handleHit(e, r, i, s, o) {
    if (e.parentId === i) {
      s.add(e.id);
      return;
    }
    const l = this.editor.getOutermostSelectableShape(e), u = this.editor.getShapeMask(l.id);
    u && !pY(u, o) && !yc(r, u) || s.add(l.id);
  }
}
T(xX, "id", "brushing");
const nw = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
class wX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e, this.updateCursor();
    });
    T(this, "onPointerMove", () => {
      this.editor.inputs.isDragging && this.startResizing();
    });
    T(this, "onLongPress", () => {
      this.startResizing();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    // override onPinchStart: TLEventHandlers['onPinchStart'] = (info) => {
    // 	this.parent.transition('pinching', info)
    // }
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  updateCursor() {
    const e = this.editor.getSelectedShapes(), r = nw[this.info.handle];
    this.editor.setCursor({
      type: r,
      rotation: e.length === 1 ? this.editor.getSelectionRotation() : 0
    });
  }
  startResizing() {
    this.editor.getInstanceState().isReadonly || this.parent.transition("resizing", this.info);
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
T(wX, "id", "pointing_resize_handle");
const Kc = 8;
class B5 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "markId", "");
    T(this, "snapshot", {});
    T(this, "onEnter", (e) => {
      this.info = e, this.markId = "cropping", this.editor.mark(this.markId), this.snapshot = this.createSnapshot(), this.updateShapes();
    });
    T(this, "onPointerMove", () => {
      this.updateShapes();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "getDefaultCrop", () => ({
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    }));
  }
  updateCursor() {
    if (!this.editor.getSelectedShapes()[0]) return;
    const r = nw[this.info.handle];
    this.editor.setCursor({ type: r, rotation: this.editor.getSelectionRotation() });
  }
  updateShapes() {
    const { shape: e, cursorHandleOffset: r } = this.snapshot;
    if (!e || !this.editor.getShapeUtil("image")) return;
    const s = e.props, o = this.editor.inputs.currentPagePoint.clone().sub(r), l = this.editor.inputs.originPagePoint.clone().sub(r), u = o.clone().sub(l).rot(-e.rotation), d = s.crop ?? this.getDefaultCrop(), f = ni(d), m = new O(e.x, e.y), v = new O(0, 0), S = 1 / (d.bottomRight.x - d.topLeft.x) * s.w, w = 1 / (d.bottomRight.y - d.topLeft.y) * s.h;
    let E = !1;
    switch (this.info.handle) {
      case "top":
      case "top_left":
      case "top_right": {
        if (w < Kc) break;
        E = !0, f.topLeft.y = f.topLeft.y + u.y / w, w * (f.bottomRight.y - f.topLeft.y) < Kc ? (f.topLeft.y = f.bottomRight.y - Kc / w, v.y = (f.topLeft.y - d.topLeft.y) * w) : f.topLeft.y <= 0 ? (f.topLeft.y = 0, v.y = (f.topLeft.y - d.topLeft.y) * w) : v.y = u.y;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        if (w < Kc) break;
        E = !0, f.bottomRight.y = Math.min(1, f.bottomRight.y + u.y / w), w * (f.bottomRight.y - f.topLeft.y) < Kc && (f.bottomRight.y = f.topLeft.y + Kc / w);
        break;
      }
    }
    switch (this.info.handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        if (S < Kc) break;
        E = !0, f.topLeft.x = f.topLeft.x + u.x / S, S * (f.bottomRight.x - f.topLeft.x) < Kc ? (f.topLeft.x = f.bottomRight.x - Kc / S, v.x = (f.topLeft.x - d.topLeft.x) * S) : f.topLeft.x <= 0 ? (f.topLeft.x = 0, v.x = (f.topLeft.x - d.topLeft.x) * S) : v.x = u.x;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        if (S < Kc) break;
        E = !0, f.bottomRight.x = Math.min(1, f.bottomRight.x + u.x / S), S * (f.bottomRight.x - f.topLeft.x) < Kc && (f.bottomRight.x = f.topLeft.x + Kc / S);
        break;
      }
    }
    if (!E) return;
    m.add(v.rot(e.rotation));
    const A = {
      id: e.id,
      type: e.type,
      x: m.x,
      y: m.y,
      props: {
        crop: f,
        w: (f.bottomRight.x - f.topLeft.x) * S,
        h: (f.bottomRight.y - f.topLeft.y) * w
      }
    };
    this.editor.updateShapes([A]), this.updateCursor();
  }
  complete() {
    this.updateShapes(), ei(this.editor, [this.snapshot.shape.id]), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  createSnapshot() {
    const e = this.editor.getSelectionRotation(), {
      inputs: { originPagePoint: r }
    } = this.editor, i = this.editor.getOnlySelectedShape(), s = this.editor.getSelectionRotatedPageBounds(), o = O.RotWith(
      s.getHandlePoint(this.info.handle),
      s.point,
      e
    ), l = O.Sub(r, o);
    return {
      shape: i,
      cursorHandleOffset: l
    };
  }
}
T(B5, "id", "cropping");
function CX(n, t = !1) {
  const e = n.getZoomLevel(), {
    inputs: { currentPagePoint: r }
  } = n;
  return (
    // hovered shape at point
    // selected shape at point
    n.getShapeAtPoint(r, {
      hitInside: !1,
      hitLabels: t,
      margin: n.options.hitTestMargin / e,
      renderingOnly: !0
    }) ?? n.getSelectedShapeAtPoint(r)
  );
}
function EX(n, t, e) {
  if (!t)
    throw Error("Needs to translate a cropped shape!");
  const { crop: r } = t.props;
  if (!r)
    return;
  const i = n.inputs.shiftKey ? Math.abs(e.x) < Math.abs(e.y) ? "x" : "y" : null;
  i === "x" ? e.x = 0 : i === "y" && (e.y = 0), e.rot(-t.rotation);
  const s = 1 / (r.bottomRight.x - r.topLeft.x) * t.props.w, o = 1 / (r.bottomRight.y - r.topLeft.y) * t.props.h, l = r.bottomRight.y - r.topLeft.y, u = r.bottomRight.x - r.topLeft.x, d = ni(r);
  return d.topLeft.x = Math.min(1 - u, Math.max(0, d.topLeft.x - e.x / s)), d.topLeft.y = Math.min(1 - l, Math.max(0, d.topLeft.y - e.y / o)), d.bottomRight.x = d.topLeft.x + u, d.bottomRight.y = d.topLeft.y + l, {
    id: t.id,
    type: t.type,
    props: {
      crop: d
    }
  };
}
var zF;
let t1e = (zF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      this.editor.setCursor({ type: "default", rotation: 0 });
      const e = this.editor.getOnlySelectedShape();
      e && this.editor.setCroppingShape(e.id);
    });
    T(this, "onExit", () => {
      this.editor.setCursor({ type: "default", rotation: 0 });
    });
    T(this, "onCancel", () => {
      this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
    });
    T(this, "onPointerDown", (e) => {
      var r;
      if (!this.editor.getIsMenuOpen()) {
        if (e.ctrlKey) {
          this.cancel(), this.editor.root.handleEvent(e);
          return;
        }
        switch (e.target) {
          case "canvas": {
            const i = CX(this.editor);
            if (i && !this.editor.isShapeOfType(i, "group")) {
              this.onPointerDown({
                ...e,
                shape: i,
                target: "shape"
              });
              return;
            }
            this.cancel(), this.editor.root.handleEvent(e);
            break;
          }
          case "shape": {
            if (e.shape.id === this.editor.getCroppingShapeId()) {
              this.editor.setCurrentTool("select.crop.pointing_crop", e);
              return;
            } else
              (r = this.editor.getShapeUtil(e.shape)) != null && r.canCrop(e.shape) ? (this.editor.setCroppingShape(e.shape.id), this.editor.setSelectedShapes([e.shape.id]), this.editor.setCurrentTool("select.crop.pointing_crop", e)) : (this.cancel(), this.editor.root.handleEvent(e));
            break;
          }
          case "selection": {
            switch (e.handle) {
              case "mobile_rotate":
              case "top_left_rotate":
              case "top_right_rotate":
              case "bottom_left_rotate":
              case "bottom_right_rotate": {
                this.editor.setCurrentTool("select.pointing_rotate_handle", {
                  ...e,
                  onInteractionEnd: "select.crop.idle"
                });
                break;
              }
              case "top":
              case "right":
              case "bottom":
              case "left":
              case "top_left":
              case "top_right":
              case "bottom_left":
              case "bottom_right": {
                this.editor.setCurrentTool("select.crop.pointing_crop_handle", {
                  ...e,
                  onInteractionEnd: "select.crop.idle"
                });
                break;
              }
              default:
                this.cancel();
            }
            break;
          }
        }
      }
    });
    T(this, "onDoubleClick", (e) => {
      var o;
      if (this.editor.inputs.shiftKey || e.phase !== "up") return;
      const r = this.editor.getCroppingShapeId();
      if (!r) return;
      const i = this.editor.getShape(r);
      if (!i) return;
      const s = this.editor.getShapeUtil(i);
      if (s) {
        if (e.target === "selection") {
          (o = s.onDoubleClickEdge) == null || o.call(s, i);
          return;
        }
        this.cancel(), this.editor.root.handleEvent(e);
      }
    });
    T(this, "onKeyDown", () => {
      this.nudgeCroppingImage(!1);
    });
    T(this, "onKeyRepeat", () => {
      this.nudgeCroppingImage(!0);
    });
    T(this, "onKeyUp", (e) => {
      switch (e.code) {
        case "Enter": {
          this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
          break;
        }
      }
    });
  }
  cancel() {
    this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
  }
  nudgeCroppingImage(e = !1) {
    const {
      editor: {
        inputs: { keys: r }
      }
    } = this, i = r.has("ShiftLeft"), s = new O(0, 0);
    if (r.has("ArrowLeft") && (s.x += 1), r.has("ArrowRight") && (s.x -= 1), r.has("ArrowUp") && (s.y += 1), r.has("ArrowDown") && (s.y -= 1), s.equals(new O(0, 0))) return;
    i && s.mul(10);
    const o = this.editor.getShape(this.editor.getCroppingShapeId());
    if (!o) return;
    const l = EX(this.editor, o, s);
    l && (e || this.editor.mark("translate crop"), this.editor.updateShapes([l]));
  }
}, T(zF, "id", "idle"), zF);
class _X extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onCancel", () => {
      this.editor.setCurrentTool("select.crop.idle", {});
    });
    T(this, "onPointerMove", (e) => {
      this.editor.inputs.isDragging && this.editor.setCurrentTool("select.crop.translating_crop", e);
    });
    T(this, "onPointerUp", (e) => {
      this.editor.setCurrentTool("select.crop.idle", e);
    });
  }
}
T(_X, "id", "pointing_crop");
class H5 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd);
      const r = this.editor.getSelectedShapes()[0];
      if (!r) return;
      const i = nw[this.info.handle];
      this.editor.setCursor({ type: i, rotation: this.editor.getSelectionRotation() }), this.editor.setCroppingShape(r.id);
    });
    T(this, "onExit", () => {
      this.editor.setCursor({ type: "default", rotation: 0 }), this.parent.setCurrentToolIdMask(void 0);
    });
    T(this, "onPointerMove", () => {
      this.editor.inputs.isDragging && this.startCropping();
    });
    T(this, "onLongPress", () => {
      this.startCropping();
    });
    T(this, "onPointerUp", () => {
      this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  startCropping() {
    this.editor.getInstanceState().isReadonly || this.parent.transition("cropping", {
      ...this.info,
      onInteractionEnd: this.info.onInteractionEnd
    });
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
}
T(H5, "id", "pointing_crop_handle");
class TX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "markId", "translating crop");
    T(this, "snapshot", {});
    T(this, "onEnter", (e) => {
      this.info = e, this.snapshot = this.createSnapshot(), this.editor.mark(this.markId), this.editor.setCursor({ type: "move", rotation: 0 }), this.updateShapes();
    });
    T(this, "onExit", () => {
      this.editor.setCursor({ type: "default", rotation: 0 });
    });
    T(this, "onPointerMove", () => {
      this.updateShapes();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onKeyDown", (e) => {
      switch (e.key) {
        case "Alt":
        case "Shift": {
          this.updateShapes();
          return;
        }
      }
    });
    T(this, "onKeyUp", (e) => {
      switch (e.key) {
        case "Enter": {
          this.complete();
          return;
        }
        case "Alt":
        case "Shift":
          this.updateShapes();
      }
    });
  }
  complete() {
    this.updateShapes(), this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  createSnapshot() {
    return { shape: this.editor.getOnlySelectedShape() };
  }
  updateShapes() {
    const e = this.snapshot.shape;
    if (!e) return;
    const { originPagePoint: r, currentPagePoint: i } = this.editor.inputs, s = i.clone().sub(r), o = EX(this.editor, e, s);
    o && this.editor.updateShapes([o]);
  }
}
T(TX, "id", "translating_crop");
class ER extends Tt {
  constructor() {
    super(...arguments);
    T(this, "markId", "");
    T(this, "onEnter", () => {
      this.didCancel = !1, this.markId = "crop", this.editor.mark(this.markId);
    });
    T(this, "didCancel", !1);
    T(this, "onExit", () => {
      this.didCancel ? this.editor.bailToMark(this.markId) : this.editor.squashToMark(this.markId);
    });
    T(this, "onCancel", () => {
      this.didCancel = !0;
    });
  }
}
T(ER, "id", "crop"), T(ER, "initial", "idle"), T(ER, "children", () => [
  t1e,
  TX,
  _X,
  H5,
  B5
]);
class PX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeId", "");
    T(this, "initialHandle", {});
    T(this, "initialAdjacentHandle", null);
    T(this, "initialPagePoint", {});
    T(this, "markId", "");
    T(this, "initialPageTransform");
    T(this, "initialPageRotation");
    T(this, "info", {});
    T(this, "isPrecise", !1);
    T(this, "isPreciseId", null);
    T(this, "pointingId", null);
    T(this, "onEnter", (e) => {
      const { shape: r, isCreating: i, handle: s } = e;
      if (this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.shapeId = r.id, this.markId = i ? `creating:${r.id}` : "dragging handle", i || this.editor.mark(this.markId), this.initialHandle = ni(s), this.editor.isShapeOfType(r, "line") && this.initialHandle.type === "create") {
        this.editor.updateShape({
          ...r,
          props: {
            points: {
              ...r.props.points,
              [s.index]: { id: s.index, index: s.index, x: s.x, y: s.y }
            }
          }
        });
        const d = this.editor.getShapeHandles(r).find((f) => f.index === s.index);
        this.initialHandle = ni(d);
      }
      this.initialPageTransform = this.editor.getShapePageTransform(r), this.initialPageRotation = this.initialPageTransform.rotation(), this.initialPagePoint = this.editor.inputs.originPagePoint.clone(), this.editor.setCursor({ type: i ? "cross" : "grabbing", rotation: 0 });
      const o = this.editor.getShapeHandles(r).sort(fa), l = o.findIndex((u) => u.id === e.handle.id);
      this.initialAdjacentHandle = null;
      for (let u = l + 1; u < o.length; u++) {
        const d = o[u];
        if (d.type === "vertex" && d.id !== "middle" && d.id !== e.handle.id) {
          this.initialAdjacentHandle = d;
          break;
        }
      }
      if (!this.initialAdjacentHandle)
        for (let u = o.length - 1; u >= 0; u--) {
          const d = o[u];
          if (d.type === "vertex" && d.id !== "middle" && d.id !== e.handle.id) {
            this.initialAdjacentHandle = d;
            break;
          }
        }
      if (this.editor.isShapeOfType(r, "arrow")) {
        const u = Ml(this.editor, r)[e.handle.id];
        this.isPrecise = !1, u ? (this.editor.setHintingShapes([u.toId]), this.isPrecise = u.props.isPrecise, this.isPrecise ? this.isPreciseId = u.toId : this.resetExactTimeout()) : this.editor.setHintingShapes([]);
      }
      this.update(), this.editor.select(this.shapeId);
    });
    // Only relevant to arrows
    T(this, "exactTimeout", -1);
    T(this, "onPointerMove", () => {
      this.update();
    });
    T(this, "onKeyDown", () => {
      this.update();
    });
    T(this, "onKeyUp", () => {
      this.update();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.update(), this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onExit", () => {
      this.parent.setCurrentToolIdMask(void 0), this.editor.setHintingShapes([]), this.editor.snaps.clearIndicators(), this.editor.setCursor({ type: "default", rotation: 0 });
    });
  }
  // Only relevant to arrows
  resetExactTimeout() {
    this.exactTimeout !== -1 && this.clearExactTimeout(), this.exactTimeout = this.editor.timers.setTimeout(() => {
      this.getIsActive() && !this.isPrecise && (this.isPrecise = !0, this.isPreciseId = this.pointingId, this.update()), this.exactTimeout = -1;
    }, 750);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    this.exactTimeout !== -1 && (clearTimeout(this.exactTimeout), this.exactTimeout = -1);
  }
  complete() {
    this.editor.snaps.clearIndicators(), ei(this.editor, [this.shapeId]);
    const { onInteractionEnd: e } = this.info;
    if (this.editor.getInstanceState().isToolLocked && e) {
      this.editor.setCurrentTool(e, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.editor.snaps.clearIndicators();
    const { onInteractionEnd: e } = this.info;
    if (e) {
      this.editor.setCurrentTool(e, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  update() {
    var F;
    const { editor: e, shapeId: r, initialPagePoint: i } = this, { initialHandle: s, initialPageRotation: o, initialAdjacentHandle: l } = this, u = this.editor.getHintingShapeIds(), d = this.editor.user.getIsSnapMode(), {
      snaps: f,
      inputs: { currentPagePoint: m, shiftKey: v, ctrlKey: S, altKey: w, pointerVelocity: E }
    } = e, A = this.info.shape, P = e.getShape(r);
    if (!P) return;
    const R = e.getShapeUtil(P);
    let M = m.clone().sub(i).rot(-o).add(s);
    if (v && l && s.id !== "middle") {
      const B = O.Angle(l, M), X = EM(B, 24) - B;
      M = O.RotWith(M, l, X);
    }
    e.snaps.clearIndicators();
    let j = { ...s, x: M.x, y: M.y };
    if (s.canSnap && (d ? !S : S)) {
      if (!e.getShapePageTransform(P.id)) throw Error("Expected a page transform");
      const G = f.handles.snapHandle({ currentShapeId: r, handle: j });
      G && (G.nudge.rot(-e.getShapeParentTransform(P).rotation()), M.add(G.nudge), j = { ...s, x: M.x, y: M.y });
    }
    const $ = (F = R.onHandleDrag) == null ? void 0 : F.call(R, P, {
      handle: j,
      isPrecise: this.isPrecise || w,
      initial: A
    }), U = { id: P.id, type: P.type, ...$ };
    if (s.type === "vertex" && this.editor.isShapeOfType(P, "arrow")) {
      const B = Ml(e, P)[s.id];
      B ? u[0] !== B.toId && (e.setHintingShapes([B.toId]), this.pointingId = B.toId, this.isPrecise = E.len() < 0.5 || w, this.isPreciseId = this.isPrecise ? B.toId : null, this.resetExactTimeout()) : u.length > 0 && (e.setHintingShapes([]), this.pointingId = null, this.isPrecise = !1, this.isPreciseId = null, this.resetExactTimeout());
    }
    $ && e.updateShapes([U]);
  }
}
T(PX, "id", "dragging_handle");
function AX(n) {
  return n.isLabel ? [n] : n instanceof ld ? n.children.filter((t) => t.isLabel) : [];
}
class kX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "hitShapeForPointerUp", null);
    T(this, "onEnter", () => {
      const e = this.editor.getEditingShape();
      if (!e) throw Error("Entered editing state without an editing shape");
      this.hitShapeForPointerUp = null, lp(this.editor), this.editor.select(e);
    });
    T(this, "onExit", () => {
      var s;
      const { editingShapeId: e } = this.editor.getCurrentPageState();
      if (!e) return;
      this.editor.setEditingShape(null), lp.cancel();
      const r = this.editor.getShape(e), i = this.editor.getShapeUtil(r);
      (s = i.onEditEnd) == null || s.call(i, r);
    });
    T(this, "onPointerMove", (e) => {
      if (this.hitShapeForPointerUp && this.editor.inputs.isDragging) {
        if (this.editor.getInstanceState().isReadonly || this.hitShapeForPointerUp.isLocked) return;
        this.editor.select(this.hitShapeForPointerUp), this.parent.transition("translating", e), this.hitShapeForPointerUp = null;
        return;
      }
      switch (e.target) {
        case "shape":
        case "canvas": {
          lp(this.editor);
          return;
        }
      }
    });
    T(this, "onPointerDown", (e) => {
      switch (this.hitShapeForPointerUp = null, e.target) {
        case "shape": {
          const { shape: r } = e, i = this.editor.getEditingShape();
          if (!i)
            throw Error("Expected an editing shape!");
          const s = this.editor.getShapeUtil(r).getGeometry(r), o = AX(s), l = o.length === 1 ? o[0] : void 0, u = this.editor.isShapeOfType(i, "text") && i.props.text.trim() === "";
          if (l && !u) {
            const d = this.editor.getPointInShapeSpace(
              r,
              this.editor.inputs.currentPagePoint
            );
            if (l.bounds.containsPoint(d, 0) && l.hitTestPoint(d)) {
              if (r.id === i.id)
                return;
              this.hitShapeForPointerUp = r, this.editor.mark("editing on pointer up"), this.editor.select(r.id);
              return;
            }
          } else {
            if (r.id === i.id)
              this.editor.isShapeOfType(r, "frame") && (this.editor.setEditingShape(null), this.parent.transition("idle", e));
            else {
              this.parent.transition("pointing_shape", e);
              return;
            }
            return;
          }
          break;
        }
      }
      this.parent.transition("idle", e), this.editor.root.handleEvent(e);
    });
    T(this, "onPointerUp", (e) => {
      const r = this.hitShapeForPointerUp;
      if (!r) return;
      this.hitShapeForPointerUp = null;
      const i = this.editor.getShapeUtil(r);
      if (!r.isLocked) {
        if (this.editor.getInstanceState().isReadonly && !i.canEditInReadOnly(r)) {
          this.parent.transition("pointing_shape", e);
          return;
        }
        this.editor.select(r.id), this.editor.setEditingShape(r.id), lp(this.editor);
      }
    });
    T(this, "onComplete", (e) => {
      this.parent.transition("idle", e);
    });
    T(this, "onCancel", (e) => {
      this.parent.transition("idle", e);
    });
  }
}
T(kX, "id", "editing_shape");
function $7(n) {
  const t = n.getOnlySelectedShape();
  return !!(t && !n.isShapeOrAncestorLocked(t) && n.getShapeUtil(t).canCrop(t));
}
function jM(n) {
  const t = n.getSelectedShapeIds(), { shiftKey: e, altKey: r, currentPagePoint: i } = n.inputs, s = n.getShapeAtPoint(i, {
    hitInside: !1,
    margin: n.options.hitTestMargin / n.getZoomLevel(),
    hitLabels: !0,
    renderingOnly: !0,
    filter: (o) => !o.isLocked
  });
  if (s) {
    const o = n.getOutermostSelectableShape(s);
    if (e && !r)
      n.cancelDoubleClick(), t.includes(o.id) ? (n.mark("deselecting shape"), n.deselect(o)) : (n.mark("shift selecting shape"), n.setSelectedShapes([...t, o.id]));
    else {
      let l;
      o === s || o.id === n.getFocusedGroupId() || t.includes(o.id) ? l = s : l = o, l && !t.includes(l.id) && (n.mark("selecting shape"), n.select(l.id));
    }
  } else {
    if (e)
      return;
    {
      t.length > 0 && (n.mark("selecting none"), n.selectNone());
      const o = n.getFocusedGroupId();
      if (kl(o)) {
        const l = n.getShape(o);
        n.isPointInShape(l, i, { margin: 0, hitInside: !0 }) || n.setFocusedGroup(null);
      }
    }
  }
}
const n1e = [
  "Delete",
  "Backspace",
  "[",
  "]",
  "Enter",
  " ",
  "Shift",
  "Tab"
];
var UF;
let r1e = (UF = class extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      this.parent.setCurrentToolIdMask(void 0), lp(this.editor), this.editor.setCursor({ type: "default", rotation: 0 });
    });
    T(this, "onExit", () => {
      lp.cancel();
    });
    T(this, "onPointerMove", () => {
      lp(this.editor);
    });
    T(this, "onPointerDown", (e) => {
      if (this.editor.getIsMenuOpen()) return;
      const r = e.ctrlKey && $7(this.editor);
      if (e.ctrlKey && !r) {
        if (e.target === "shape" && this.isDarwin && this.editor.inputs.keys.has("ControlLeft") && !this.editor.isShapeOrAncestorLocked(e.shape)) {
          this.parent.transition("pointing_shape", e);
          return;
        }
        this.parent.transition("brushing", e);
        return;
      }
      switch (e.target) {
        case "canvas": {
          const i = CX(this.editor);
          if (i && !i.isLocked) {
            this.onPointerDown({
              ...e,
              shape: i,
              target: "shape"
            });
            return;
          }
          const s = this.editor.getSelectedShapeIds(), o = this.editor.getOnlySelectedShape(), {
            inputs: { currentPagePoint: l }
          } = this.editor;
          if ((s.length > 1 || o && !this.editor.getShapeUtil(o).hideSelectionBoundsBg(o)) && z7(this.editor, l)) {
            this.onPointerDown({
              ...e,
              target: "selection"
            });
            return;
          }
          this.parent.transition("pointing_canvas", e);
          break;
        }
        case "shape": {
          const { shape: i } = e;
          if (this.isOverArrowLabelTest(i)) {
            this.parent.transition("pointing_arrow_label", e);
            break;
          }
          if (this.editor.isShapeOrAncestorLocked(i)) {
            this.parent.transition("pointing_canvas", e);
            break;
          }
          this.parent.transition("pointing_shape", e);
          break;
        }
        case "handle": {
          if (this.editor.getInstanceState().isReadonly) break;
          this.editor.inputs.altKey ? this.parent.transition("pointing_shape", e) : this.parent.transition("pointing_handle", e);
          break;
        }
        case "selection": {
          switch (e.handle) {
            case "mobile_rotate":
            case "top_left_rotate":
            case "top_right_rotate":
            case "bottom_left_rotate":
            case "bottom_right_rotate": {
              this.parent.transition("pointing_rotate_handle", e);
              break;
            }
            case "top":
            case "right":
            case "bottom":
            case "left":
            case "top_left":
            case "top_right":
            case "bottom_left":
            case "bottom_right": {
              r ? this.parent.transition("crop.pointing_crop_handle", e) : this.parent.transition("pointing_resize_handle", e);
              break;
            }
            default: {
              const i = this.editor.getHoveredShape();
              if (i && !this.editor.getSelectedShapeIds().includes(i.id) && !i.isLocked) {
                this.onPointerDown({
                  ...e,
                  shape: i,
                  target: "shape"
                });
                return;
              }
              this.parent.transition("pointing_selection", e);
            }
          }
          break;
        }
      }
    });
    T(this, "onDoubleClick", (e) => {
      var r, i, s, o;
      if (!(this.editor.inputs.shiftKey || e.phase !== "up"))
        switch (e.target) {
          case "canvas": {
            const l = this.editor.getHoveredShape(), u = l && !this.editor.isShapeOfType(l, "group") ? l : this.editor.getSelectedShapeAtPoint(this.editor.inputs.currentPagePoint) ?? this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
              margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
              hitInside: !1
            }), d = this.editor.getFocusedGroupId();
            if (u) {
              if (this.editor.isShapeOfType(u, "group")) {
                jM(this.editor);
                return;
              } else {
                const f = this.editor.getShape(u.parentId);
                if (f && this.editor.isShapeOfType(f, "group") && !(d && f.id === d)) {
                  jM(this.editor);
                  return;
                }
              }
              this.onDoubleClick({
                ...e,
                shape: u,
                target: "shape"
              });
              return;
            }
            this.editor.inputs.shiftKey || this.handleDoubleClickOnCanvas(e);
            break;
          }
          case "selection": {
            if (this.editor.getInstanceState().isReadonly) break;
            const l = this.editor.getOnlySelectedShape();
            if (l) {
              const u = this.editor.getShapeUtil(l);
              if (!this.canInteractWithShapeInReadOnly(l))
                return;
              if (e.handle === "right" || e.handle === "left" || e.handle === "top" || e.handle === "bottom") {
                const d = (r = u.onDoubleClickEdge) == null ? void 0 : r.call(u, l);
                if (d) {
                  this.editor.mark("double click edge"), this.editor.updateShapes([d]), ei(this.editor, [l.id]);
                  return;
                }
              }
              if (u.canCrop(l) && !this.editor.isShapeOrAncestorLocked(l)) {
                this.parent.transition("crop", e);
                return;
              }
              this.shouldStartEditingShape(l) && this.startEditingShape(
                l,
                e,
                !0
                /* select all */
              );
            }
            break;
          }
          case "shape": {
            const { shape: l } = e, u = this.editor.getShapeUtil(l);
            if (l.type !== "video" && l.type !== "embed" && this.editor.getInstanceState().isReadonly)
              break;
            if (u.onDoubleClick) {
              const d = (i = u.onDoubleClick) == null ? void 0 : i.call(u, l);
              if (d) {
                this.editor.updateShapes([d]);
                return;
              } else if (u.canCrop(l) && !this.editor.isShapeOrAncestorLocked(l)) {
                this.editor.mark("select and crop"), this.editor.select((s = e.shape) == null ? void 0 : s.id), this.parent.transition("crop", e);
                return;
              }
            }
            this.shouldStartEditingShape(l) ? this.startEditingShape(
              l,
              e,
              !0
              /* select all */
            ) : this.handleDoubleClickOnCanvas(e);
            break;
          }
          case "handle": {
            if (this.editor.getInstanceState().isReadonly) break;
            const { shape: l, handle: u } = e, d = this.editor.getShapeUtil(l), f = (o = d.onDoubleClickHandle) == null ? void 0 : o.call(d, l, u);
            f ? this.editor.updateShapes([f]) : this.shouldStartEditingShape(l) && this.startEditingShape(
              l,
              e,
              !0
              /* select all */
            );
          }
        }
    });
    T(this, "onRightClick", (e) => {
      switch (e.target) {
        case "canvas": {
          const r = this.editor.getHoveredShape(), i = r && !this.editor.isShapeOfType(r, "group") ? r : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
            margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
            hitInside: !1,
            hitLabels: !0,
            hitLocked: !0,
            hitFrameInside: !1,
            renderingOnly: !0
          });
          if (i) {
            this.onRightClick({
              ...e,
              shape: i,
              target: "shape"
            });
            return;
          }
          const s = this.editor.getSelectedShapeIds(), o = this.editor.getOnlySelectedShape(), {
            inputs: { currentPagePoint: l }
          } = this.editor;
          if ((s.length > 1 || o && !this.editor.getShapeUtil(o).hideSelectionBoundsBg(o)) && z7(this.editor, l)) {
            this.onRightClick({
              ...e,
              target: "selection"
            });
            return;
          }
          this.editor.selectNone();
          break;
        }
        case "shape": {
          const { selectedShapeIds: r } = this.editor.getCurrentPageState(), { shape: i } = e, s = this.editor.getOutermostSelectableShape(
            i,
            (o) => !r.includes(o.id)
          );
          !r.includes(s.id) && !this.editor.findShapeAncestor(
            s,
            (o) => r.includes(o.id)
          ) && (this.editor.mark("selecting shape"), this.editor.setSelectedShapes([s.id]));
          break;
        }
      }
    });
    T(this, "onCancel", () => {
      this.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() && this.editor.getSelectedShapeIds().length > 0 ? this.editor.popFocusedGroupId() : (this.editor.mark("clearing selection"), this.editor.selectNone());
    });
    T(this, "onKeyDown", (e) => {
      switch (e.code) {
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          this.nudgeSelectedShapes(!1);
          return;
        }
      }
      if (qi.editOnType.get() && !n1e.includes(e.key) && !e.altKey && !e.ctrlKey) {
        const r = this.editor.getOnlySelectedShape();
        if (r && // If it's a note shape, then edit on type
        this.editor.isShapeOfType(r, "note") && // If it's not locked or anything
        this.shouldStartEditingShape(r)) {
          this.startEditingShape(
            r,
            {
              ...e,
              target: "shape",
              shape: r
            },
            !0
            /* select all */
          );
          return;
        }
      }
    });
    T(this, "onKeyRepeat", (e) => {
      switch (e.code) {
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          this.nudgeSelectedShapes(!0);
          break;
        }
      }
    });
    T(this, "onKeyUp", (e) => {
      switch (e.code) {
        case "Enter": {
          const r = this.editor.getSelectedShapes();
          if (r.every((s) => this.editor.isShapeOfType(s, "group"))) {
            this.editor.setSelectedShapes(
              r.flatMap((s) => this.editor.getSortedChildIdsForParent(s.id))
            );
            return;
          }
          const i = this.editor.getOnlySelectedShape();
          if (i && this.shouldStartEditingShape(i)) {
            this.startEditingShape(
              i,
              {
                ...e,
                target: "shape",
                shape: i
              },
              !0
              /* select all */
            );
            return;
          }
          $7(this.editor) && this.parent.transition("crop", e);
          break;
        }
      }
    });
    T(this, "isDarwin", window.navigator.userAgent.toLowerCase().indexOf("mac") > -1);
  }
  shouldStartEditingShape(e = this.editor.getOnlySelectedShape()) {
    return !e || this.editor.isShapeOrAncestorLocked(e) && e.type !== "embed" || !this.canInteractWithShapeInReadOnly(e) ? !1 : this.editor.getShapeUtil(e).canEdit(e);
  }
  startEditingShape(e, r, i) {
    this.editor.isShapeOrAncestorLocked(e) && e.type !== "embed" || (this.editor.mark("editing shape"), DM(this.editor, e, i), this.parent.transition("editing_shape", r));
  }
  isOverArrowLabelTest(e) {
    if (!e) return !1;
    const r = this.editor.getPointInShapeSpace(
      e,
      this.editor.inputs.currentPagePoint
    );
    if (this.editor.isShapeOfType(e, "arrow")) {
      const i = this.editor.getShapeGeometry(e).children[1];
      if (i && yc(r, i.vertices))
        return !0;
    }
    return !1;
  }
  handleDoubleClickOnCanvas(e) {
    if (this.editor.getInstanceState().isReadonly) return;
    this.editor.mark("creating text shape");
    const r = Ar(), { x: i, y: s } = this.editor.inputs.currentPagePoint;
    this.editor.createShapes([
      {
        id: r,
        type: "text",
        x: i,
        y: s,
        props: {
          text: "",
          autoSize: !0
        }
      }
    ]);
    const o = this.editor.getShape(r);
    if (!o) return;
    const l = this.editor.getShapeUtil(o);
    this.editor.getInstanceState().isReadonly && !l.canEditInReadOnly(o) || (this.editor.setEditingShape(r), this.editor.select(r), this.parent.transition("editing_shape", e));
  }
  nudgeSelectedShapes(e = !1) {
    const {
      editor: {
        inputs: { keys: r }
      }
    } = this, i = r.has("ShiftLeft"), s = new O(0, 0);
    if (r.has("ArrowLeft") && (s.x -= 1), r.has("ArrowRight") && (s.x += 1), r.has("ArrowUp") && (s.y -= 1), r.has("ArrowDown") && (s.y += 1), s.equals(new O(0, 0))) return;
    e || this.editor.mark("nudge shapes");
    const { gridSize: o } = this.editor.getDocumentSettings(), l = this.editor.getInstanceState().isGridMode ? i ? o * o1e : o : i ? i1e : s1e, u = this.editor.getSelectedShapeIds();
    this.editor.nudgeShapes(u, s.mul(l)), ei(this.editor, u);
  }
  canInteractWithShapeInReadOnly(e) {
    return !!(!this.editor.getInstanceState().isReadonly || this.editor.getShapeUtil(e).canEditInReadOnly(e));
  }
}, T(UF, "id", "idle"), UF);
const i1e = 10, s1e = 1, o1e = 5;
function z7(n, t) {
  const e = n.getSelectionRotatedPageBounds();
  if (!e) return !1;
  const r = n.getSelectionRotation();
  return r ? yc(
    t,
    e.corners.map((i) => O.RotWith(i, e.point, r))
  ) : e.containsPoint(t);
}
class IX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "shapeId", "");
    T(this, "markId", "");
    T(this, "wasAlreadySelected", !1);
    T(this, "didDrag", !1);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      const { shape: r } = e;
      this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.info = e, this.shapeId = r.id, this.didDrag = !1, this.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === r.id, this.updateCursor();
      const s = this.editor.getShapeGeometry(r).children[1];
      if (!s)
        throw Error(`Expected to find an arrow label geometry for shape: ${r.id}`);
      const { currentPagePoint: o } = this.editor.inputs, l = this.editor.getPointInShapeSpace(r, o);
      this._labelDragOffset = O.Sub(s.center, l), this.markId = "label-drag start", this.editor.mark(this.markId), this.editor.setSelectedShapes([this.shapeId]);
    });
    T(this, "onExit", () => {
      this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 });
    });
    T(this, "_labelDragOffset", new O(0, 0));
    T(this, "onPointerMove", () => {
      const { isDragging: e } = this.editor.inputs;
      if (!e) return;
      const r = this.editor.getShape(this.shapeId);
      if (!r) return;
      const i = yh(this.editor, r), s = this.editor.getShapeGeometry(r), o = s.children[0], l = this.editor.getPointInShapeSpace(
        r,
        this.editor.inputs.currentPagePoint
      ), u = o.nearestPoint(
        O.Add(l, this._labelDragOffset)
      );
      let d;
      if (i.isStraight) {
        const f = O.Dist(i.start.point, i.end.point);
        d = 1 - O.Dist(i.end.point, u) / f;
      } else {
        const { _center: f, measure: m, angleEnd: v, angleStart: S } = s.children[0];
        d = g3(m, S, v, f.angle(u));
      }
      isNaN(d) && (d = 0.5), this.didDrag = !0, this.editor.updateShape({
        id: r.id,
        type: r.type,
        props: { labelPosition: d }
      });
    });
    T(this, "onPointerUp", () => {
      const e = this.editor.getShape(this.shapeId);
      e && (this.didDrag || !this.wasAlreadySelected ? this.complete() : (this.editor.setEditingShape(e.id), this.editor.setCurrentTool("select.editing_shape")));
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  updateCursor() {
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
T(IX, "id", "pointing_arrow_label");
class RX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "onEnter", () => {
      const { inputs: e } = this.editor;
      e.shiftKey || this.editor.getSelectedShapeIds().length > 0 && (this.editor.mark("selecting none"), this.editor.selectNone());
    });
    T(this, "onPointerMove", (e) => {
      this.editor.inputs.isDragging && this.parent.transition("brushing", e);
    });
    T(this, "onPointerUp", () => {
      jM(this.editor), this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onInterrupt", () => {
      this.parent.transition("idle");
    });
  }
  complete() {
    this.parent.transition("idle");
  }
}
T(RX, "id", "pointing_canvas");
class MX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e;
      const { shape: r } = e;
      if (this.editor.isShapeOfType(r, "arrow")) {
        const i = Ml(this.editor, r)[e.handle.id];
        i && this.editor.setHintingShapes([i.toId]);
      }
      this.editor.setCursor({ type: "grabbing", rotation: 0 });
    });
    T(this, "onExit", () => {
      this.editor.setHintingShapes([]), this.editor.setCursor({ type: "default", rotation: 0 });
    });
    T(this, "onPointerUp", () => {
      const { shape: e, handle: r } = this.info;
      if (this.editor.isShapeOfType(e, "note")) {
        const { editor: i } = this, s = U7(i, e, r, !1);
        if (s) {
          DM(
            i,
            s,
            !0
            /* selectAll */
          );
          return;
        }
      }
      this.parent.transition("idle", this.info);
    });
    T(this, "onPointerMove", () => {
      const { editor: e } = this;
      e.inputs.isDragging && this.startDraggingHandle();
    });
    T(this, "onLongPress", () => {
      this.startDraggingHandle();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  startDraggingHandle() {
    const { editor: e } = this;
    if (e.getInstanceState().isReadonly) return;
    const { shape: r, handle: i } = this.info;
    if (e.isShapeOfType(r, "note")) {
      const s = U7(e, r, i, !0);
      if (s) {
        const o = e.getPointInParentSpace(s, e.inputs.originPagePoint).sub(O.Rot(U2.clone().mul(r.props.scale), s.rotation));
        e.updateShape({ ...s, x: o.x, y: o.y }), e.setHoveredShape(s.id).select(s.id).setCurrentTool("select.translating", {
          ...this.info,
          target: "shape",
          shape: e.getShape(s),
          onInteractionEnd: "note",
          isCreating: !0,
          onCreate: () => {
            DM(
              e,
              s,
              !0
              /* selectAll */
            );
          }
        });
        return;
      }
    }
    this.parent.transition("dragging_handle", this.info);
  }
  cancel() {
    this.parent.transition("idle");
  }
}
T(MX, "id", "pointing_handle");
function U7(n, t, e, r) {
  const i = n.getShapePageTransform(t.id), s = i.point(), o = i.rotation(), u = KY(
    n,
    s,
    o,
    t.props.growY,
    0,
    t.props.scale
  )[e.index];
  if (u)
    return XY(n, t, u, o, r);
}
class DX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.info = e, this.updateCursor();
    });
    T(this, "onExit", () => {
      this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 });
    });
    T(this, "onPointerMove", () => {
      this.editor.inputs.isDragging && this.startRotating();
    });
    T(this, "onLongPress", () => {
      this.startRotating();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  updateCursor() {
    this.editor.setCursor({
      type: nw[this.info.handle],
      rotation: this.editor.getSelectionRotation()
    });
  }
  startRotating() {
    this.editor.getInstanceState().isReadonly || this.parent.transition("rotating", this.info);
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
T(DX, "id", "pointing_rotate_handle");
class OX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e;
    });
    T(this, "onPointerUp", (e) => {
      jM(this.editor), this.parent.transition("idle", e);
    });
    T(this, "onPointerMove", (e) => {
      this.editor.inputs.isDragging && this.startTranslating(e);
    });
    T(this, "onLongPress", (e) => {
      this.startTranslating(e);
    });
    T(this, "onDoubleClick", (e) => {
      var s, o;
      const r = this.editor.getHoveredShape(), i = r && !this.editor.isShapeOfType(r, "group") ? r : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
        hitInside: !0,
        margin: 0,
        renderingOnly: !0
      });
      if (i) {
        this.parent.transition("idle"), (o = (s = this.parent).onDoubleClick) == null || o.call(s, {
          ...e,
          target: "shape",
          shape: this.editor.getShape(i)
        });
        return;
      }
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  startTranslating(e) {
    this.editor.getInstanceState().isReadonly || this.parent.transition("translating", e);
  }
  cancel() {
    this.parent.transition("idle");
  }
}
T(OX, "id", "pointing_selection");
class LX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "hitShape", {});
    T(this, "hitShapeForPointerUp", {});
    T(this, "isDoubleClick", !1);
    T(this, "didSelectOnEnter", !1);
    T(this, "onEnter", (e) => {
      const r = this.editor.getSelectedShapeIds(), i = this.editor.getSelectionRotatedPageBounds(), s = this.editor.getFocusedGroupId(), {
        inputs: { currentPagePoint: o, shiftKey: l, altKey: u }
      } = this.editor;
      this.hitShape = e.shape, this.isDoubleClick = !1;
      const d = this.editor.getOutermostSelectableShape(e.shape), f = this.editor.findShapeAncestor(
        d,
        (m) => r.includes(m.id)
      );
      if (
        // If the shape has an onClick handler
        this.editor.getShapeUtil(e.shape).onClick || // ...or if the shape is the focused layer (e.g. group)
        d.id === s || // ...or if the shape is within the selection
        r.includes(d.id) || // ...or if an ancestor of the shape is selected
        f || // ...or if the current point is NOT within the selection bounds
        r.length > 1 && (i != null && i.containsPoint(o))
      ) {
        this.didSelectOnEnter = !1, this.hitShapeForPointerUp = d;
        return;
      }
      this.didSelectOnEnter = !0, l && !u ? (this.editor.cancelDoubleClick(), r.includes(d.id) || (this.editor.mark("shift selecting shape"), this.editor.setSelectedShapes([...r, d.id]))) : (this.editor.mark("selecting shape"), this.editor.setSelectedShapes([d.id]));
    });
    T(this, "onPointerUp", (e) => {
      var f;
      const r = this.editor.getSelectedShapeIds(), i = this.editor.getFocusedGroupId(), s = this.editor.getZoomLevel(), {
        inputs: { currentPagePoint: o, shiftKey: l }
      } = this.editor, u = this.editor.getShapeAtPoint(o, {
        margin: this.editor.options.hitTestMargin / s,
        hitInside: !0,
        renderingOnly: !0
      }) ?? this.hitShape, d = u ? this.editor.getOutermostSelectableShape(u) : this.hitShapeForPointerUp;
      if (d) {
        const m = this.editor.getShapeUtil(d);
        if (m.onClick) {
          const v = (f = m.onClick) == null ? void 0 : f.call(m, d);
          if (v) {
            this.editor.mark("shape on click"), this.editor.updateShapes([v]), this.parent.transition("idle", e);
            return;
          }
        }
        if (d.id === i) {
          r.length > 0 ? (this.editor.mark("clearing shape ids"), this.editor.setSelectedShapes([])) : this.editor.popFocusedGroupId(), this.parent.transition("idle", e);
          return;
        }
      }
      if (!this.didSelectOnEnter) {
        const m = this.editor.getOutermostSelectableShape(
          u,
          // if a group is selected, we want to stop before reaching that group
          // so we can drill down into the group
          (v) => !r.includes(v.id)
        );
        if (r.includes(m.id))
          if (l)
            this.editor.mark("deselecting on pointer up"), this.editor.deselect(d);
          else if (r.includes(d.id)) {
            if (r.length === 1) {
              const v = this.editor.getShapeUtil(d).getGeometry(d), S = AX(v), w = S.length === 1 ? S[0] : void 0;
              if (w) {
                const E = this.editor.getPointInShapeSpace(
                  d,
                  o
                );
                if (w.bounds.containsPoint(E, 0) && w.hitTestPoint(E)) {
                  this.editor.run(() => {
                    this.editor.mark("editing on pointer up"), this.editor.select(d.id);
                    const A = this.editor.getShapeUtil(d);
                    this.editor.getInstanceState().isReadonly && !A.canEditInReadOnly(d) || (this.editor.setEditingShape(d.id), this.editor.setCurrentTool("select.editing_shape"), this.isDoubleClick && this.editor.emit("select-all-text", { shapeId: d.id }));
                  });
                  return;
                }
              }
            }
            this.editor.mark("selecting on pointer up"), this.editor.select(d.id);
          } else
            this.editor.mark("selecting on pointer up"), this.editor.select(d);
        else if (l) {
          const v = this.editor.getShapeAncestors(m);
          this.editor.mark("shift deselecting on pointer up"), this.editor.setSelectedShapes([
            ...this.editor.getSelectedShapeIds().filter((S) => !v.find((w) => w.id === S)),
            m.id
          ]);
        } else
          this.editor.mark("selecting on pointer up"), this.editor.setSelectedShapes([m.id]);
      }
      this.parent.transition("idle", e);
    });
    T(this, "onDoubleClick", () => {
      this.isDoubleClick = !0;
    });
    T(this, "onPointerMove", (e) => {
      this.editor.inputs.isDragging && this.startTranslating(e);
    });
    T(this, "onLongPress", (e) => {
      this.startTranslating(e);
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.cancel();
    });
    T(this, "onInterrupt", () => {
      this.cancel();
    });
  }
  startTranslating(e) {
    this.editor.getInstanceState().isReadonly || (this.editor.focus(), this.parent.transition("translating", e));
  }
  cancel() {
    this.parent.transition("idle");
  }
}
T(LX, "id", "pointing_shape");
class jX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "markId", "");
    // A switch to detect when the user is holding ctrl
    T(this, "didHoldCommand", !1);
    // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
    // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
    // so we allow passing a further offset into this state to negate such issues
    T(this, "creationCursorOffset", { x: 0, y: 0 });
    T(this, "snapshot", {});
    T(this, "onEnter", (e) => {
      const { isCreating: r = !1, creationCursorOffset: i = { x: 0, y: 0 } } = e;
      this.info = e, this.didHoldCommand = !1, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.creationCursorOffset = i, this.snapshot = this._createSnapshot(), r ? (this.markId = `creating:${this.editor.getOnlySelectedShape().id}`, this.editor.setCursor({ type: "cross", rotation: 0 })) : (this.markId = "starting resizing", this.editor.mark(this.markId)), this.handleResizeStart(), this.updateShapes();
    });
    T(this, "onTick", ({ elapsed: e }) => {
      const { editor: r } = this;
      r.edgeScrollManager.updateEdgeScrolling(e);
    });
    T(this, "onPointerMove", () => {
      this.updateShapes();
    });
    T(this, "onKeyDown", () => {
      this.updateShapes();
    });
    T(this, "onKeyUp", () => {
      this.updateShapes();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onExit", () => {
      this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 }), this.editor.snaps.clearIndicators();
    });
    T(this, "_createSnapshot", () => {
      const e = this.editor.getSelectedShapeIds(), r = this.editor.getSelectionRotation(), {
        inputs: { originPagePoint: i }
      } = this.editor, s = this.editor.getSelectionRotatedPageBounds(), o = O.RotWith(
        s.getHandlePoint(this.info.handle),
        s.point,
        r
      ), l = O.Sub(i, o), u = /* @__PURE__ */ new Map(), d = [];
      e.forEach((m) => {
        const v = this.editor.getShape(m);
        if (v) {
          if (v.type === "frame" && d.push({
            id: m,
            children: xn(
              this.editor.getSortedChildIdsForParent(v).map((S) => this.editor.getShape(S))
            )
          }), u.set(v.id, this._createShapeSnapshot(v)), this.editor.isShapeOfType(v, "frame") && e.length === 1)
            return;
          this.editor.visitDescendants(v.id, (S) => {
            const w = this.editor.getShape(S);
            if (w && (u.set(w.id, this._createShapeSnapshot(w)), this.editor.isShapeOfType(w, "frame")))
              return !1;
          });
        }
      });
      const f = ![...u.values()].some(
        (m) => !TK(m.pageRotation, r) || m.isAspectRatioLocked
      );
      return {
        shapeSnapshots: u,
        selectionBounds: s,
        cursorHandleOffset: l,
        selectionRotation: r,
        selectedShapeIds: e,
        canShapesDeform: f,
        initialSelectionPageBounds: this.editor.getSelectionPageBounds(),
        frames: d
      };
    });
    T(this, "_createShapeSnapshot", (e) => {
      const r = this.editor.getShapePageTransform(e), i = this.editor.getShapeUtil(e);
      return {
        shape: e,
        bounds: this.editor.getShapeGeometry(e).bounds,
        pageTransform: r,
        pageRotation: At.Decompose(r).rotation,
        isAspectRatioLocked: i.isAspectRatioLocked(e)
      };
    });
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  complete() {
    var e, r;
    if (ei(this.editor, this.snapshot.selectedShapeIds), this.handleResizeEnd(), this.info.isCreating && this.info.onCreate) {
      (r = (e = this.info).onCreate) == null || r.call(e, this.editor.getOnlySelectedShape());
      return;
    }
    if (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
      return;
    }
    this.parent.transition("idle");
  }
  handleResizeStart() {
    const { shapeSnapshots: e } = this.snapshot, r = [];
    e.forEach(({ shape: i }) => {
      var l;
      const s = this.editor.getShapeUtil(i), o = (l = s.onResizeStart) == null ? void 0 : l.call(s, i);
      o && r.push(o);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  handleResizeEnd() {
    const { shapeSnapshots: e } = this.snapshot, r = [];
    e.forEach(({ shape: i }) => {
      var u;
      const s = this.editor.getShape(i.id), o = this.editor.getShapeUtil(i), l = (u = o.onResizeEnd) == null ? void 0 : u.call(o, i, s);
      l && r.push(l);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  updateShapes() {
    const { altKey: e, shiftKey: r } = this.editor.inputs, {
      frames: i,
      shapeSnapshots: s,
      selectionBounds: o,
      cursorHandleOffset: l,
      selectedShapeIds: u,
      selectionRotation: d,
      canShapesDeform: f
    } = this.snapshot;
    let m = r || !f;
    if (s.size === 1) {
      const B = [...s.values()][0];
      this.editor.isShapeOfType(B.shape, "text") && (m = !(this.info.handle === "left" || this.info.handle === "right"));
    }
    const { ctrlKey: v } = this.editor.inputs, S = this.editor.inputs.currentPagePoint.clone().sub(l).sub(this.creationCursorOffset), w = this.editor.inputs.originPagePoint.clone().sub(l);
    if (this.editor.getInstanceState().isGridMode && !v) {
      const { gridSize: B } = this.editor.getDocumentSettings();
      S.snapToGrid(B);
    }
    const E = this.info.handle, A = B7(E, Math.PI);
    if (this.editor.snaps.clearIndicators(), (this.editor.user.getIsSnapMode() ? !v : v) && d % ri === 0) {
      const { nudge: B } = this.editor.snaps.shapeBounds.snapResizeShapes({
        dragDelta: O.Sub(S, w),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: B7(E, d),
        isAspectRatioLocked: m,
        isResizingFromCenter: e
      });
      S.add(B);
    }
    const R = O.RotWith(
      e ? o.center : o.getHandlePoint(A),
      o.point,
      d
    ), M = O.Sub(S, R).rot(
      -d
    ), j = O.Sub(w, R).rot(
      -d
    ), $ = O.DivV(M, j);
    Number.isFinite($.x) || ($.x = 1), Number.isFinite($.y) || ($.y = 1);
    const U = E === "top" || E === "bottom", F = E === "left" || E === "right";
    m ? F ? $.y = Math.abs($.x) : U ? $.x = Math.abs($.y) : Math.abs($.x) > Math.abs($.y) ? $.y = Math.abs($.x) * ($.y < 0 ? -1 : 1) : $.x = Math.abs($.y) * ($.x < 0 ? -1 : 1) : (U && ($.x = 1), F && ($.y = 1)), this.info.isCreating || this.updateCursor({
      dragHandle: E,
      isFlippedX: $.x < 0,
      isFlippedY: $.y < 0,
      rotation: d
    });
    for (const B of s.keys()) {
      const G = s.get(B);
      this.editor.resizeShape(B, $, {
        initialShape: G.shape,
        initialBounds: G.bounds,
        initialPageTransform: G.pageTransform,
        dragHandle: E,
        mode: u.length === 1 && B === u[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: R,
        isAspectRatioLocked: m,
        scaleAxisRotation: d,
        skipStartAndEndCallbacks: !0
      });
    }
    if (this.editor.inputs.ctrlKey) {
      this.didHoldCommand = !0;
      for (const { id: B, children: G } of i) {
        if (!G.length) continue;
        const X = s.get(B).shape, te = this.editor.getShape(B);
        if (!(X && te)) continue;
        const ne = te.x - X.x, K = te.y - X.y, Z = new O(ne, K).rot(-X.rotation);
        if (Z.x !== 0 || Z.y !== 0)
          for (const oe of G)
            this.editor.updateShape({
              id: oe.id,
              type: oe.type,
              x: oe.x - Z.x,
              y: oe.y - Z.y
            });
      }
    } else if (this.didHoldCommand) {
      this.didHoldCommand = !1;
      for (const { children: B } of i)
        if (B.length)
          for (const G of B)
            this.editor.updateShape({
              id: G.id,
              type: G.type,
              x: G.x,
              y: G.y
            });
    }
  }
  // ---
  updateCursor({
    dragHandle: e,
    isFlippedX: r,
    isFlippedY: i,
    rotation: s
  }) {
    const o = { ...this.editor.getInstanceState().cursor };
    switch (e) {
      case "top_left":
      case "bottom_right": {
        o.type = "nwse-resize", r !== i && (o.type = "nesw-resize");
        break;
      }
      case "top_right":
      case "bottom_left": {
        o.type = "nesw-resize", r !== i && (o.type = "nwse-resize");
        break;
      }
    }
    o.rotation = s, this.editor.setCursor(o);
  }
}
T(jX, "id", "resizing");
const ZN = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function B7(n, t) {
  t = t % wr;
  const e = Math.round(t / (cr / 4)), r = ZN.indexOf(n);
  return ZN[(r + e) % ZN.length];
}
const H7 = Math.PI / 180;
class NX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "snapshot", {});
    T(this, "info", {});
    T(this, "markId", "");
    T(this, "onEnter", (e) => {
      this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.markId = "rotate start", this.editor.mark(this.markId);
      const r = vY({ editor: this.editor });
      if (!r) return this.parent.transition("idle", this.info);
      this.snapshot = r;
      const i = this._getRotationFromPointerPosition({
        snapToNearestDegree: !1
      });
      eR({
        editor: this.editor,
        delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !1 }),
        snapshot: this.snapshot,
        stage: "start"
      }), this.editor.setCursor({
        type: nw[this.info.handle],
        rotation: i + this.snapshot.initialSelectionRotation
      });
    });
    T(this, "onExit", () => {
      this.editor.setCursor({ type: "default", rotation: 0 }), this.parent.setCurrentToolIdMask(void 0), this.snapshot = {};
    });
    T(this, "onPointerMove", () => {
      this.update();
    });
    T(this, "onKeyDown", () => {
      this.update();
    });
    T(this, "onKeyUp", () => {
      this.update();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    // ---
    T(this, "update", () => {
      const e = this._getRotationFromPointerPosition({
        snapToNearestDegree: !1
      });
      eR({
        editor: this.editor,
        delta: e,
        snapshot: this.snapshot,
        stage: "update"
      }), this.editor.setCursor({
        type: nw[this.info.handle],
        rotation: e + this.snapshot.initialSelectionRotation
      });
    });
    T(this, "cancel", () => {
      this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("idle", this.info);
    });
    T(this, "complete", () => {
      eR({
        editor: this.editor,
        delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !0 }),
        snapshot: this.snapshot,
        stage: "end"
      }), ei(
        this.editor,
        this.snapshot.shapeSnapshots.map((e) => e.shape.id)
      ), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("idle", this.info);
    });
  }
  _getRotationFromPointerPosition({ snapToNearestDegree: e }) {
    const r = this.editor.getSelectionRotation(), i = this.editor.getSelectionRotatedPageBounds(), {
      inputs: { shiftKey: s, currentPagePoint: o }
    } = this.editor, { initialCursorAngle: l, initialSelectionRotation: u } = this.snapshot;
    if (!i) return u;
    const f = i.center.clone().rotWith(i.point, r).angle(o) - l;
    let m = u + f;
    if (s)
      m = EM(m, 24);
    else if (e && (m = Math.round(m / H7) * H7, this.editor.getInstanceState().isCoarsePointer)) {
      const v = EM(m, 4), S = ZI(m, v);
      Math.abs(S) < Cye(5) && (m = v);
    }
    return m - u;
  }
}
T(NX, "id", "rotating");
class FX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "hits", /* @__PURE__ */ new Set());
    T(this, "size", 0);
    T(this, "scribbleId", "id");
    T(this, "initialSelectedShapeIds", /* @__PURE__ */ new Set());
    T(this, "newlySelectedShapeIds", /* @__PURE__ */ new Set());
    T(this, "onEnter", () => {
      this.initialSelectedShapeIds = new Set(
        this.editor.inputs.shiftKey ? this.editor.getSelectedShapeIds() : []
      ), this.newlySelectedShapeIds = /* @__PURE__ */ new Set(), this.size = 0, this.hits.clear();
      const e = this.editor.scribbles.addScribble({
        color: "selection-stroke",
        opacity: 0.32,
        size: 12
      });
      this.scribbleId = e.id, this.updateScribbleSelection(!0), this.editor.updateInstanceState({ brush: null });
    });
    T(this, "onExit", () => {
      this.editor.scribbles.stop(this.scribbleId);
    });
    T(this, "onPointerMove", () => {
      this.updateScribbleSelection(!0);
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onKeyDown", () => {
      this.updateScribbleSelection(!1);
    });
    T(this, "onKeyUp", () => {
      this.editor.inputs.altKey ? this.updateScribbleSelection(!1) : this.parent.transition("brushing");
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "pushPointToScribble", () => {
      const { x: e, y: r } = this.editor.inputs.currentPagePoint;
      this.editor.scribbles.addPoint(this.scribbleId, e, r);
    });
  }
  updateScribbleSelection(e) {
    const { editor: r } = this, i = this.editor.getCurrentPageShapes(), {
      inputs: { shiftKey: s, originPagePoint: o, previousPagePoint: l, currentPagePoint: u }
    } = this.editor, { newlySelectedShapeIds: d, initialSelectedShapeIds: f } = this;
    e && this.pushPointToScribble();
    const m = i;
    let v, S, w, E;
    const A = 0;
    for (let M = 0, j = m.length; M < j; M++) {
      if (v = m[M], r.isShapeOfType(v, "group") || d.has(v.id) || r.isShapeOrAncestorLocked(v) || (S = r.getShapeGeometry(v), r.isShapeOfType(v, "frame") && S.bounds.containsPoint(r.getPointInShapeSpace(v, o))))
        continue;
      const $ = r.getShapePageTransform(v);
      if (!S || !$) continue;
      const U = $.clone().invert();
      w = U.applyToPoint(l), E = U.applyToPoint(u);
      const { bounds: F } = S;
      if (!(F.minX - A > Math.max(w.x, E.x) || F.minY - A > Math.max(w.y, E.y) || F.maxX + A < Math.min(w.x, E.x) || F.maxY + A < Math.min(w.y, E.y)) && S.hitTestLineSegment(w, E, A)) {
        const B = this.editor.getOutermostSelectableShape(v), G = this.editor.getShapeMask(B.id);
        if (G && x5(
          l,
          u,
          G
        ) !== null && !yc(u, G))
          continue;
        d.add(B.id);
      }
    }
    const P = r.getSelectedShapeIds(), R = new Set(
      s ? [...d, ...f] : [...d]
    );
    (P.length !== R.size || P.some((M) => !R.has(M))) && this.editor.setSelectedShapes(Array.from(R));
  }
  complete() {
    this.updateScribbleSelection(!0), this.parent.transition("idle");
  }
  cancel() {
    this.editor.setSelectedShapes([...this.initialSelectedShapeIds]), this.parent.transition("idle");
  }
}
T(FX, "id", "scribble_brushing");
const a1e = 20, l1e = 100;
class c1e {
  constructor(t) {
    T(this, "prevDroppingShapeId", null);
    T(this, "droppingNodeTimer", null);
    T(this, "first", !0);
    T(this, "dispose", () => {
      this.clear();
    });
    this.editor = t, t.disposables.add(this.dispose);
  }
  updateDroppingNode(t, e) {
    var r;
    this.first && (this.editor.setHintingShapes(
      t.map((i) => this.editor.findShapeAncestor(i, (s) => s.type !== "group")).filter((i) => i)
    ), this.prevDroppingShapeId = ((r = this.editor.getDroppingOverShape(this.editor.inputs.originPagePoint, t)) == null ? void 0 : r.id) ?? null, this.first = !1), this.droppingNodeTimer === null ? this.setDragTimer(t, a1e, e) : this.editor.inputs.pointerVelocity.len() > 0.5 && (clearTimeout(this.droppingNodeTimer), this.setDragTimer(t, l1e, e));
  }
  setDragTimer(t, e, r) {
    this.droppingNodeTimer = this.editor.timers.setTimeout(() => {
      this.editor.run(() => {
        this.handleDrag(this.editor.inputs.currentPagePoint, t, r);
      }), this.droppingNodeTimer = null;
    }, e);
  }
  handleDrag(t, e, r) {
    var u, d, f, m, v;
    e = xn(e.map((S) => this.editor.getShape(S.id)));
    const i = ((u = this.editor.getDroppingOverShape(t, e)) == null ? void 0 : u.id) ?? null;
    if (i === this.prevDroppingShapeId) {
      this.hintParents(e);
      return;
    }
    const { prevDroppingShapeId: s } = this, o = s && this.editor.getShape(s), l = i && this.editor.getShape(i);
    o && ((f = (d = this.editor.getShapeUtil(o)).onDragShapesOut) == null || f.call(d, o, e)), l && ((v = (m = this.editor.getShapeUtil(l)).onDragShapesOver) == null || v.call(m, l, e)), this.hintParents(e), r == null || r(), this.prevDroppingShapeId = i;
  }
  hintParents(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t) {
      const s = this.editor.findShapeAncestor(i, (o) => o.type !== "group");
      s && (e.has(s.id) || e.set(s.id, []), e.get(s.id).push(i.id));
    }
    const r = [];
    for (const [i, s] of e) {
      const o = this.editor.getShape(i);
      o && VY(this.editor, o).length < s.length && r.push(o.id);
    }
    this.editor.setHintingShapes(r);
  }
  dropShapes(t) {
    var r, i;
    const { prevDroppingShapeId: e } = this;
    if (this.handleDrag(this.editor.inputs.currentPagePoint, t), e) {
      const s = this.editor.getShape(e);
      if (!s) return;
      (i = (r = this.editor.getShapeUtil(s)).onDropShapesOver) == null || i.call(r, s, t);
    }
  }
  clear() {
    this.prevDroppingShapeId = null, this.droppingNodeTimer !== null && clearTimeout(this.droppingNodeTimer), this.droppingNodeTimer = null, this.editor.setHintingShapes([]), this.first = !0;
  }
}
class $X extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "selectionSnapshot", {});
    T(this, "snapshot", {});
    T(this, "markId", "");
    T(this, "isCloning", !1);
    T(this, "isCreating", !1);
    T(this, "onCreate", () => {
    });
    T(this, "dragAndDropManager", new c1e(this.editor));
    T(this, "onEnter", (e) => {
      var s;
      const { isCreating: r = !1, onCreate: i = () => {
      } } = e;
      if (!((s = this.editor.getSelectedShapeIds()) != null && s.length)) {
        this.parent.transition("idle");
        return;
      }
      if (this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.isCreating = r, this.onCreate = i, r ? this.markId = `creating:${this.editor.getOnlySelectedShape().id}` : (this.markId = "translating", this.editor.mark(this.markId)), this.isCloning = !1, this.info = e, this.editor.setCursor({ type: "move", rotation: 0 }), this.selectionSnapshot = V7(this.editor), !this.isCreating && this.editor.inputs.altKey) {
        this.startCloning();
        return;
      }
      this.snapshot = this.selectionSnapshot, this.handleStart(), this.updateShapes();
    });
    T(this, "onExit", () => {
      this.parent.setCurrentToolIdMask(void 0), this.selectionSnapshot = {}, this.snapshot = {}, this.editor.snaps.clearIndicators(), this.editor.setCursor({ type: "default", rotation: 0 }), this.dragAndDropManager.clear();
    });
    T(this, "onTick", ({ elapsed: e }) => {
      const { editor: r } = this;
      this.dragAndDropManager.updateDroppingNode(
        this.snapshot.movingShapes,
        this.updateParentTransforms
      ), r.edgeScrollManager.updateEdgeScrolling(e);
    });
    T(this, "onPointerMove", () => {
      this.updateShapes();
    });
    T(this, "onKeyDown", () => {
      if (this.editor.inputs.altKey && !this.isCloning) {
        this.startCloning();
        return;
      }
      this.updateShapes();
    });
    T(this, "onKeyUp", () => {
      if (!this.editor.inputs.altKey && this.isCloning) {
        this.stopCloning();
        return;
      }
      this.updateShapes();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onComplete", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
    T(this, "updateParentTransforms", () => {
      const {
        editor: e,
        snapshot: { shapeSnapshots: r }
      } = this;
      r.forEach((i) => {
        const s = e.getShape(i.shape.id);
        if (!s) return null;
        const o = El(s.parentId) ? null : At.Inverse(e.getShapePageTransform(s.parentId));
        i.parentTransform = o;
      });
    });
  }
  startCloning() {
    this.isCreating || (this.isCloning = !0, this.reset(), this.markId = "translating", this.editor.mark(this.markId), this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds())), this.snapshot = V7(this.editor), this.handleStart(), this.updateShapes());
  }
  stopCloning() {
    this.isCloning = !1, this.snapshot = this.selectionSnapshot, this.reset(), this.markId = "translating", this.editor.mark(this.markId), this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    var e;
    this.updateShapes(), this.dragAndDropManager.dropShapes(this.snapshot.movingShapes), ei(
      this.editor,
      this.snapshot.movingShapes.map((r) => r.id)
    ), this.handleEnd(), this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd) : this.isCreating ? (e = this.onCreate) == null || e.call(this, this.editor.getOnlySelectedShape()) : this.parent.transition("idle");
  }
  cancel() {
    this.reset(), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd) : this.parent.transition("idle", this.info);
  }
  handleStart() {
    const { movingShapes: e } = this.snapshot, r = [];
    e.forEach((i) => {
      var l;
      const s = this.editor.getShapeUtil(i), o = (l = s.onTranslateStart) == null ? void 0 : l.call(s, i);
      o && r.push(o);
    }), r.length > 0 && this.editor.updateShapes(r), this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes: e } = this.snapshot;
    if (this.isCloning && e.length > 0) {
      const i = O.Average(
        e.map((o) => this.editor.getShapePageTransform(o.id).point())
      ), s = O.Sub(i, this.selectionSnapshot.averagePagePoint);
      O.IsNaN(s) || this.editor.updateInstanceState({
        duplicateProps: {
          shapeIds: e.map((o) => o.id),
          offset: { x: s.x, y: s.y }
        }
      });
    }
    const r = [];
    e.forEach((i) => {
      var u;
      const s = this.editor.getShape(i.id), o = this.editor.getShapeUtil(i), l = (u = o.onTranslateEnd) == null ? void 0 : u.call(o, i, s);
      l && r.push(l);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  updateShapes() {
    const { snapshot: e } = this;
    this.dragAndDropManager.updateDroppingNode(e.movingShapes, this.updateParentTransforms), u1e({
      editor: this.editor,
      snapshot: e
    });
    const { movingShapes: r } = e, i = [];
    r.forEach((s) => {
      var d;
      const o = this.editor.getShape(s.id), l = this.editor.getShapeUtil(s), u = (d = l.onTranslate) == null ? void 0 : d.call(l, s, o);
      u && i.push(u);
    }), i.length > 0 && this.editor.updateShapes(i);
  }
}
T($X, "id", "translating");
function V7(n) {
  var m;
  const t = [], e = [], r = n.getSelectedShapeIds(), i = xn(
    r.map((v) => {
      const S = n.getShape(v);
      if (!S) return null;
      t.push(S);
      const w = n.getShapePageTransform(v), E = w.point(), A = w.rotation();
      e.push(E);
      const P = yp.isId(S.parentId) ? null : At.Inverse(n.getShapePageTransform(S.parentId));
      return {
        shape: S,
        pagePoint: E,
        pageRotation: A,
        parentTransform: P
      };
    })
  ), s = n.getOnlySelectedShape();
  let o = [];
  if (s)
    o = n.snaps.shapeBounds.getSnapPoints(s.id);
  else {
    const v = n.getSelectionPageBounds();
    v && (o = v.cornersAndCenter.map((S, w) => ({
      id: "selection:" + w,
      x: S.x,
      y: S.y
    })));
  }
  let l, u;
  const { originPagePoint: d } = n.inputs, f = i.filter(
    (v) => n.isShapeOfType(v.shape, "note") && n.isPointInShape(v.shape, d)
  );
  if (f.length !== 0) if (f.length === 1)
    u = f[0];
  else {
    const v = n.getCurrentPageShapesSorted();
    u = (m = f.map((S) => ({
      snapshot: S,
      index: v.findIndex((w) => w.id === S.shape.id)
    })).sort((S, w) => w.index - S.index)[0]) == null ? void 0 : m.snapshot;
  }
  return u && (l = YY(
    n,
    u.pageRotation,
    u.shape.props.scale,
    u.shape.props.growY ?? 0
  )), {
    averagePagePoint: O.Average(e),
    movingShapes: t,
    shapeSnapshots: i,
    initialPageBounds: n.getSelectionPageBounds(),
    initialSnapPoints: o,
    noteAdjacentPositions: l,
    noteSnapshot: u
  };
}
function u1e({
  editor: n,
  snapshot: t
}) {
  const { inputs: e } = n, {
    noteSnapshot: r,
    noteAdjacentPositions: i,
    initialPageBounds: s,
    initialSnapPoints: o,
    shapeSnapshots: l,
    averagePagePoint: u
  } = t, d = n.getInstanceState().isGridMode, f = n.getDocumentSettings().gridSize, m = O.Sub(e.currentPagePoint, e.originPagePoint), v = n.inputs.shiftKey ? Math.abs(m.x) < Math.abs(m.y) ? "x" : "y" : null;
  if (v === "x" ? m.x = 0 : v === "y" && (m.y = 0), n.snaps.clearIndicators(), (n.user.getIsSnapMode() ? !e.ctrlKey : e.ctrlKey) && n.inputs.pointerVelocity.len() < 0.5) {
    const { nudge: A } = n.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: m,
      initialSelectionPageBounds: s,
      lockedAxis: v,
      initialSelectionSnapPoints: o
    });
    m.add(A);
  } else if (r && i) {
    const { scale: A } = r.shape.props, P = r.pagePoint.clone().add(m).add(U2.clone().mul(A).rot(r.pageRotation));
    let R = GY / n.getZoomLevel(), M = new O(0, 0);
    for (const j of i) {
      const $ = O.Sub(P, j), U = $.len();
      U < R && (R = U, M = $);
    }
    m.sub(M);
  }
  const w = O.Add(u, m);
  d && !e.ctrlKey && w.snapToGrid(f);
  const E = O.Sub(w, u);
  n.updateShapes(
    xn(
      l.map(({ shape: A, pagePoint: P, parentTransform: R }) => {
        const M = O.Add(P, E), j = R ? At.applyToPoint(R, M) : M;
        return {
          id: A.id,
          type: A.type,
          x: j.x,
          y: j.y
        };
      })
    )
  );
}
class o1 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "reactor");
    // We want to clean up the duplicate props when the selection changes
    T(this, "cleanUpDuplicateProps", () => {
      const e = this.editor.getSelectedShapeIds(), r = this.editor.getInstanceState();
      if (!r.duplicateProps) return;
      const i = new Set(r.duplicateProps.shapeIds);
      e.length === i.size && e.every((s) => i.has(s)) || this.editor.updateInstanceState({
        duplicateProps: null
      });
    });
    T(this, "onEnter", () => {
      this.reactor = bS("clean duplicate props", () => {
        try {
          this.cleanUpDuplicateProps();
        } catch (e) {
          typeof process < "u" && process.env.NODE_ENV === "test" || console.error(e);
        }
      });
    });
    T(this, "onExit", () => {
      var e;
      (e = this.reactor) == null || e.call(this), this.editor.getCurrentPageState().editingShapeId && this.editor.setEditingShape(null);
    });
  }
}
T(o1, "id", "select"), T(o1, "initial", "idle"), T(o1, "isLockable", !1), T(o1, "children", () => [
  ER,
  B5,
  r1e,
  RX,
  LX,
  $X,
  xX,
  FX,
  H5,
  OX,
  wX,
  kX,
  jX,
  NX,
  DX,
  IX,
  MX,
  PX
]);
class zX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e;
    });
    T(this, "onPointerDown", () => {
      this.parent.transition("pointing", this.info);
    });
  }
}
T(zX, "id", "idle");
class UX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e;
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onPointerMove", () => {
      this.editor.inputs.isDragging && this.parent.transition("zoom_brushing", this.info);
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
  }
  complete() {
    const { currentScreenPoint: e } = this.editor.inputs;
    this.editor.inputs.altKey ? this.editor.zoomOut(e, { animation: { duration: 220 } }) : this.editor.zoomIn(e, { animation: { duration: 220 } }), this.parent.transition("idle", this.info);
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
T(UX, "id", "pointing");
class BX extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "zoomBrush", new vt());
    T(this, "onEnter", (e) => {
      this.info = e, this.update();
    });
    T(this, "onExit", () => {
      this.editor.updateInstanceState({ zoomBrush: null });
    });
    T(this, "onPointerMove", () => {
      this.update();
    });
    T(this, "onPointerUp", () => {
      this.complete();
    });
    T(this, "onCancel", () => {
      this.cancel();
    });
  }
  update() {
    const {
      inputs: { originPagePoint: e, currentPagePoint: r }
    } = this.editor;
    this.zoomBrush.setTo(vt.FromPoints([e, r])), this.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() });
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
  complete() {
    const { zoomBrush: e } = this, r = 8 / this.editor.getZoomLevel();
    if (e.width < r && e.height < r) {
      const i = this.editor.inputs.currentScreenPoint;
      this.editor.inputs.altKey ? this.editor.zoomOut(i, { animation: { duration: 220 } }) : this.editor.zoomIn(i, { animation: { duration: 220 } });
    } else {
      const i = this.editor.inputs.altKey ? this.editor.getZoomLevel() / 2 : void 0;
      this.editor.zoomToBounds(e, { targetZoom: i, animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
}
T(BX, "id", "zoom_brushing");
class a1 extends Tt {
  constructor() {
    super(...arguments);
    T(this, "info", {});
    T(this, "onEnter", (e) => {
      this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.updateCursor();
    });
    T(this, "onExit", () => {
      this.parent.setCurrentToolIdMask(void 0), this.editor.updateInstanceState({ zoomBrush: null, cursor: { type: "default", rotation: 0 } }), this.parent.setCurrentToolIdMask(void 0);
    });
    T(this, "onKeyDown", () => {
      this.updateCursor();
    });
    T(this, "onKeyUp", (e) => {
      this.updateCursor(), e.code === "KeyZ" && this.complete();
    });
    T(this, "onInterrupt", () => {
      this.complete();
    });
  }
  complete() {
    this.info.onInteractionEnd && this.info.onInteractionEnd !== "select" ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("select");
  }
  updateCursor() {
    this.editor.inputs.altKey ? this.editor.setCursor({ type: "zoom-out", rotation: 0 }) : this.editor.setCursor({ type: "zoom-in", rotation: 0 });
  }
}
T(a1, "id", "zoom"), T(a1, "initial", "idle"), T(a1, "children", () => [zX, BX, UX]), T(a1, "isLockable", !1);
const d1e = [r1, i1, s1, a1, o1];
function Et(n, t, { checkForDefaultPrevented: e = !0 } = {}) {
  return function(i) {
    if (n == null || n(i), e === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function h1e(n, t) {
  typeof n == "function" ? n(t) : n != null && (n.current = t);
}
function G2(...n) {
  return (t) => n.forEach((e) => h1e(e, t));
}
function si(...n) {
  return D.useCallback(G2(...n), n);
}
function f1e(n, t) {
  const e = D.createContext(t);
  function r(s) {
    const { children: o, ...l } = s, u = D.useMemo(() => l, Object.values(l));
    return /* @__PURE__ */ y.jsx(e.Provider, { value: u, children: o });
  }
  function i(s) {
    const o = D.useContext(e);
    if (o) return o;
    if (t !== void 0) return t;
    throw new Error(`\`${s}\` must be used within \`${n}\``);
  }
  return r.displayName = n + "Provider", [r, i];
}
function jh(n, t = []) {
  let e = [];
  function r(s, o) {
    const l = D.createContext(o), u = e.length;
    e = [...e, o];
    function d(m) {
      const { scope: v, children: S, ...w } = m, E = (v == null ? void 0 : v[n][u]) || l, A = D.useMemo(() => w, Object.values(w));
      return /* @__PURE__ */ y.jsx(E.Provider, { value: A, children: S });
    }
    function f(m, v) {
      const S = (v == null ? void 0 : v[n][u]) || l, w = D.useContext(S);
      if (w) return w;
      if (o !== void 0) return o;
      throw new Error(`\`${m}\` must be used within \`${s}\``);
    }
    return d.displayName = s + "Provider", [d, f];
  }
  const i = () => {
    const s = e.map((o) => D.createContext(o));
    return function(l) {
      const u = (l == null ? void 0 : l[n]) || s;
      return D.useMemo(
        () => ({ [`__scope${n}`]: { ...l, [n]: u } }),
        [l, u]
      );
    };
  };
  return i.scopeName = n, [r, p1e(i, ...t)];
}
function p1e(...n) {
  const t = n[0];
  if (n.length === 1) return t;
  const e = () => {
    const r = n.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const o = r.reduce((l, { useScope: u, scopeName: d }) => {
        const m = u(s)[`__scope${d}`];
        return { ...l, ...m };
      }, {});
      return D.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return e.scopeName = t.scopeName, e;
}
var wm = globalThis != null && globalThis.document ? D.useLayoutEffect : () => {
}, g1e = Yae.useId || (() => {
}), m1e = 0;
function hp(n) {
  const [t, e] = D.useState(g1e());
  return wm(() => {
    n || e((r) => r ?? String(m1e++));
  }, [n]), n || (t ? `radix-${t}` : "");
}
function jo(n) {
  const t = D.useRef(n);
  return D.useEffect(() => {
    t.current = n;
  }), D.useMemo(() => (...e) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...e);
  }, []);
}
function Dm({
  prop: n,
  defaultProp: t,
  onChange: e = () => {
  }
}) {
  const [r, i] = v1e({ defaultProp: t, onChange: e }), s = n !== void 0, o = s ? n : r, l = jo(e), u = D.useCallback(
    (d) => {
      if (s) {
        const m = typeof d == "function" ? d(n) : d;
        m !== n && l(m);
      } else
        i(d);
    },
    [s, n, i, l]
  );
  return [o, u];
}
function v1e({
  defaultProp: n,
  onChange: t
}) {
  const e = D.useState(n), [r] = e, i = D.useRef(r), s = jo(t);
  return D.useEffect(() => {
    i.current !== r && (s(r), i.current = r);
  }, [r, i, s]), e;
}
var sS = D.forwardRef((n, t) => {
  const { children: e, ...r } = n, i = D.Children.toArray(e), s = i.find(S1e);
  if (s) {
    const o = s.props.children, l = i.map((u) => u === s ? D.Children.count(o) > 1 ? D.Children.only(null) : D.isValidElement(o) ? o.props.children : null : u);
    return /* @__PURE__ */ y.jsx(N3, { ...r, ref: t, children: D.isValidElement(o) ? D.cloneElement(o, void 0, l) : null });
  }
  return /* @__PURE__ */ y.jsx(N3, { ...r, ref: t, children: e });
});
sS.displayName = "Slot";
var N3 = D.forwardRef((n, t) => {
  const { children: e, ...r } = n;
  if (D.isValidElement(e)) {
    const i = x1e(e);
    return D.cloneElement(e, {
      ...b1e(r, e.props),
      // @ts-ignore
      ref: t ? G2(t, i) : i
    });
  }
  return D.Children.count(e) > 1 ? D.Children.only(null) : null;
});
N3.displayName = "SlotClone";
var y1e = ({ children: n }) => /* @__PURE__ */ y.jsx(y.Fragment, { children: n });
function S1e(n) {
  return D.isValidElement(n) && n.type === y1e;
}
function b1e(n, t) {
  const e = { ...t };
  for (const r in t) {
    const i = n[r], s = t[r];
    /^on[A-Z]/.test(r) ? i && s ? e[r] = (...l) => {
      s(...l), i(...l);
    } : i && (e[r] = i) : r === "style" ? e[r] = { ...i, ...s } : r === "className" && (e[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...n, ...e };
}
function x1e(n) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get, e = t && "isReactWarning" in t && t.isReactWarning;
  return e ? n.ref : (t = (i = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : i.get, e = t && "isReactWarning" in t && t.isReactWarning, e ? n.props.ref : n.props.ref || n.ref);
}
var w1e = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], sr = w1e.reduce((n, t) => {
  const e = D.forwardRef((r, i) => {
    const { asChild: s, ...o } = r, l = s ? sS : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ y.jsx(l, { ...o, ref: i });
  });
  return e.displayName = `Primitive.${t}`, { ...n, [t]: e };
}, {});
function V5(n, t) {
  n && xS.flushSync(() => n.dispatchEvent(t));
}
function C1e(n, t = globalThis == null ? void 0 : globalThis.document) {
  const e = jo(n);
  D.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && e(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [e, t]);
}
var E1e = "DismissableLayer", F3 = "dismissableLayer.update", _1e = "dismissableLayer.pointerDownOutside", T1e = "dismissableLayer.focusOutside", W7, HX = D.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), YT = D.forwardRef(
  (n, t) => {
    const {
      disableOutsidePointerEvents: e = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: o,
      onDismiss: l,
      ...u
    } = n, d = D.useContext(HX), [f, m] = D.useState(null), v = (f == null ? void 0 : f.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, S] = D.useState({}), w = si(t, (F) => m(F)), E = Array.from(d.layers), [A] = [...d.layersWithOutsidePointerEventsDisabled].slice(-1), P = E.indexOf(A), R = f ? E.indexOf(f) : -1, M = d.layersWithOutsidePointerEventsDisabled.size > 0, j = R >= P, $ = A1e((F) => {
      const B = F.target, G = [...d.branches].some((X) => X.contains(B));
      !j || G || (i == null || i(F), o == null || o(F), F.defaultPrevented || l == null || l());
    }, v), U = k1e((F) => {
      const B = F.target;
      [...d.branches].some((X) => X.contains(B)) || (s == null || s(F), o == null || o(F), F.defaultPrevented || l == null || l());
    }, v);
    return C1e((F) => {
      R === d.layers.size - 1 && (r == null || r(F), !F.defaultPrevented && l && (F.preventDefault(), l()));
    }, v), D.useEffect(() => {
      if (f)
        return e && (d.layersWithOutsidePointerEventsDisabled.size === 0 && (W7 = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), d.layersWithOutsidePointerEventsDisabled.add(f)), d.layers.add(f), G7(), () => {
          e && d.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = W7);
        };
    }, [f, v, e, d]), D.useEffect(() => () => {
      f && (d.layers.delete(f), d.layersWithOutsidePointerEventsDisabled.delete(f), G7());
    }, [f, d]), D.useEffect(() => {
      const F = () => S({});
      return document.addEventListener(F3, F), () => document.removeEventListener(F3, F);
    }, []), /* @__PURE__ */ y.jsx(
      sr.div,
      {
        ...u,
        ref: w,
        style: {
          pointerEvents: M ? j ? "auto" : "none" : void 0,
          ...n.style
        },
        onFocusCapture: Et(n.onFocusCapture, U.onFocusCapture),
        onBlurCapture: Et(n.onBlurCapture, U.onBlurCapture),
        onPointerDownCapture: Et(
          n.onPointerDownCapture,
          $.onPointerDownCapture
        )
      }
    );
  }
);
YT.displayName = E1e;
var P1e = "DismissableLayerBranch", VX = D.forwardRef((n, t) => {
  const e = D.useContext(HX), r = D.useRef(null), i = si(t, r);
  return D.useEffect(() => {
    const s = r.current;
    if (s)
      return e.branches.add(s), () => {
        e.branches.delete(s);
      };
  }, [e.branches]), /* @__PURE__ */ y.jsx(sr.div, { ...n, ref: i });
});
VX.displayName = P1e;
function A1e(n, t = globalThis == null ? void 0 : globalThis.document) {
  const e = jo(n), r = D.useRef(!1), i = D.useRef(() => {
  });
  return D.useEffect(() => {
    const s = (l) => {
      if (l.target && !r.current) {
        let u = function() {
          WX(
            _1e,
            e,
            d,
            { discrete: !0 }
          );
        };
        const d = { originalEvent: l };
        l.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = u, t.addEventListener("click", i.current, { once: !0 })) : u();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", s), t.removeEventListener("click", i.current);
    };
  }, [t, e]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function k1e(n, t = globalThis == null ? void 0 : globalThis.document) {
  const e = jo(n), r = D.useRef(!1);
  return D.useEffect(() => {
    const i = (s) => {
      s.target && !r.current && WX(T1e, e, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, e]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function G7() {
  const n = new CustomEvent(F3);
  document.dispatchEvent(n);
}
function WX(n, t, e, { discrete: r }) {
  const i = e.originalEvent.target, s = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: e });
  t && i.addEventListener(n, t, { once: !0 }), r ? V5(i, s) : i.dispatchEvent(s);
}
var I1e = YT, R1e = VX, QN = "focusScope.autoFocusOnMount", JN = "focusScope.autoFocusOnUnmount", K7 = { bubbles: !1, cancelable: !0 }, M1e = "FocusScope", K2 = D.forwardRef((n, t) => {
  const {
    loop: e = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...o
  } = n, [l, u] = D.useState(null), d = jo(i), f = jo(s), m = D.useRef(null), v = si(t, (E) => u(E)), S = D.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  D.useEffect(() => {
    if (r) {
      let E = function(M) {
        if (S.paused || !l) return;
        const j = M.target;
        l.contains(j) ? m.current = j : Fg(m.current, { select: !0 });
      }, A = function(M) {
        if (S.paused || !l) return;
        const j = M.relatedTarget;
        j !== null && (l.contains(j) || Fg(m.current, { select: !0 }));
      }, P = function(M) {
        if (document.activeElement === document.body)
          for (const $ of M)
            $.removedNodes.length > 0 && Fg(l);
      };
      document.addEventListener("focusin", E), document.addEventListener("focusout", A);
      const R = new MutationObserver(P);
      return l && R.observe(l, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", E), document.removeEventListener("focusout", A), R.disconnect();
      };
    }
  }, [r, l, S.paused]), D.useEffect(() => {
    if (l) {
      X7.add(S);
      const E = document.activeElement;
      if (!l.contains(E)) {
        const P = new CustomEvent(QN, K7);
        l.addEventListener(QN, d), l.dispatchEvent(P), P.defaultPrevented || (D1e(F1e(GX(l)), { select: !0 }), document.activeElement === E && Fg(l));
      }
      return () => {
        l.removeEventListener(QN, d), setTimeout(() => {
          const P = new CustomEvent(JN, K7);
          l.addEventListener(JN, f), l.dispatchEvent(P), P.defaultPrevented || Fg(E ?? document.body, { select: !0 }), l.removeEventListener(JN, f), X7.remove(S);
        }, 0);
      };
    }
  }, [l, d, f, S]);
  const w = D.useCallback(
    (E) => {
      if (!e && !r || S.paused) return;
      const A = E.key === "Tab" && !E.altKey && !E.ctrlKey && !E.metaKey, P = document.activeElement;
      if (A && P) {
        const R = E.currentTarget, [M, j] = O1e(R);
        M && j ? !E.shiftKey && P === j ? (E.preventDefault(), e && Fg(M, { select: !0 })) : E.shiftKey && P === M && (E.preventDefault(), e && Fg(j, { select: !0 })) : P === R && E.preventDefault();
      }
    },
    [e, r, S.paused]
  );
  return /* @__PURE__ */ y.jsx(sr.div, { tabIndex: -1, ...o, ref: v, onKeyDown: w });
});
K2.displayName = M1e;
function D1e(n, { select: t = !1 } = {}) {
  const e = document.activeElement;
  for (const r of n)
    if (Fg(r, { select: t }), document.activeElement !== e) return;
}
function O1e(n) {
  const t = GX(n), e = Y7(t, n), r = Y7(t.reverse(), n);
  return [e, r];
}
function GX(n) {
  const t = [], e = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); ) t.push(e.currentNode);
  return t;
}
function Y7(n, t) {
  for (const e of n)
    if (!L1e(e, { upTo: t })) return e;
}
function L1e(n, { upTo: t }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n; ) {
    if (t !== void 0 && n === t) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function j1e(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function Fg(n, { select: t = !1 } = {}) {
  if (n && n.focus) {
    const e = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== e && j1e(n) && t && n.select();
  }
}
var X7 = N1e();
function N1e() {
  let n = [];
  return {
    add(t) {
      const e = n[0];
      t !== e && (e == null || e.pause()), n = q7(n, t), n.unshift(t);
    },
    remove(t) {
      var e;
      n = q7(n, t), (e = n[0]) == null || e.resume();
    }
  };
}
function q7(n, t) {
  const e = [...n], r = e.indexOf(t);
  return r !== -1 && e.splice(r, 1), e;
}
function F1e(n) {
  return n.filter((t) => t.tagName !== "A");
}
var $1e = "Portal", XT = D.forwardRef((n, t) => {
  var l;
  const { container: e, ...r } = n, [i, s] = D.useState(!1);
  wm(() => s(!0), []);
  const o = e || i && ((l = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : l.body);
  return o ? qbe.createPortal(/* @__PURE__ */ y.jsx(sr.div, { ...r, ref: t }), o) : null;
});
XT.displayName = $1e;
function z1e(n, t) {
  return D.useReducer((e, r) => t[e][r] ?? e, n);
}
var fd = (n) => {
  const { present: t, children: e } = n, r = U1e(t), i = typeof e == "function" ? e({ present: r.isPresent }) : D.Children.only(e), s = si(r.ref, B1e(i));
  return typeof e == "function" || r.isPresent ? D.cloneElement(i, { ref: s }) : null;
};
fd.displayName = "Presence";
function U1e(n) {
  const [t, e] = D.useState(), r = D.useRef({}), i = D.useRef(n), s = D.useRef("none"), o = n ? "mounted" : "unmounted", [l, u] = z1e(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return D.useEffect(() => {
    const d = PI(r.current);
    s.current = l === "mounted" ? d : "none";
  }, [l]), wm(() => {
    const d = r.current, f = i.current;
    if (f !== n) {
      const v = s.current, S = PI(d);
      n ? u("MOUNT") : S === "none" || (d == null ? void 0 : d.display) === "none" ? u("UNMOUNT") : u(f && v !== S ? "ANIMATION_OUT" : "UNMOUNT"), i.current = n;
    }
  }, [n, u]), wm(() => {
    if (t) {
      const d = (m) => {
        const S = PI(r.current).includes(m.animationName);
        m.target === t && S && xS.flushSync(() => u("ANIMATION_END"));
      }, f = (m) => {
        m.target === t && (s.current = PI(r.current));
      };
      return t.addEventListener("animationstart", f), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
        t.removeEventListener("animationstart", f), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d);
      };
    } else
      u("ANIMATION_END");
  }, [t, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(l),
    ref: D.useCallback((d) => {
      d && (r.current = getComputedStyle(d)), e(d);
    }, [])
  };
}
function PI(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
function B1e(n) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get, e = t && "isReactWarning" in t && t.isReactWarning;
  return e ? n.ref : (t = (i = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : i.get, e = t && "isReactWarning" in t && t.isReactWarning, e ? n.props.ref : n.props.ref || n.ref);
}
var eF = 0;
function W5() {
  D.useEffect(() => {
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", n[0] ?? Z7()), document.body.insertAdjacentElement("beforeend", n[1] ?? Z7()), eF++, () => {
      eF === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), eF--;
    };
  }, []);
}
function Z7() {
  const n = document.createElement("span");
  return n.setAttribute("data-radix-focus-guard", ""), n.tabIndex = 0, n.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", n;
}
var gh = function() {
  return gh = Object.assign || function(t) {
    for (var e, r = 1, i = arguments.length; r < i; r++) {
      e = arguments[r];
      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, gh.apply(this, arguments);
};
function KX(n, t) {
  var e = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && t.indexOf(r) < 0 && (e[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (e[r[i]] = n[r[i]]);
  return e;
}
function H1e(n, t, e) {
  if (e || arguments.length === 2) for (var r = 0, i = t.length, s; r < i; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return n.concat(s || Array.prototype.slice.call(t));
}
var _R = "right-scroll-bar-position", TR = "width-before-scroll-bar", V1e = "with-scroll-bars-hidden", W1e = "--removed-body-scroll-bar-size";
function tF(n, t) {
  return typeof n == "function" ? n(t) : n && (n.current = t), n;
}
function G1e(n, t) {
  var e = D.useState(function() {
    return {
      // value
      value: n,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return e.value;
        },
        set current(r) {
          var i = e.value;
          i !== r && (e.value = r, e.callback(r, i));
        }
      }
    };
  })[0];
  return e.callback = t, e.facade;
}
var K1e = typeof window < "u" ? D.useLayoutEffect : D.useEffect, Q7 = /* @__PURE__ */ new WeakMap();
function Y1e(n, t) {
  var e = G1e(null, function(r) {
    return n.forEach(function(i) {
      return tF(i, r);
    });
  });
  return K1e(function() {
    var r = Q7.get(e);
    if (r) {
      var i = new Set(r), s = new Set(n), o = e.current;
      i.forEach(function(l) {
        s.has(l) || tF(l, null);
      }), s.forEach(function(l) {
        i.has(l) || tF(l, o);
      });
    }
    Q7.set(e, n);
  }, [n]), e;
}
function X1e(n) {
  return n;
}
function q1e(n, t) {
  t === void 0 && (t = X1e);
  var e = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return e.length ? e[e.length - 1] : n;
    },
    useMedium: function(s) {
      var o = t(s, r);
      return e.push(o), function() {
        e = e.filter(function(l) {
          return l !== o;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; e.length; ) {
        var o = e;
        e = [], o.forEach(s);
      }
      e = {
        push: function(l) {
          return s(l);
        },
        filter: function() {
          return e;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var o = [];
      if (e.length) {
        var l = e;
        e = [], l.forEach(s), o = e;
      }
      var u = function() {
        var f = o;
        o = [], f.forEach(s);
      }, d = function() {
        return Promise.resolve().then(u);
      };
      d(), e = {
        push: function(f) {
          o.push(f), d();
        },
        filter: function(f) {
          return o = o.filter(f), e;
        }
      };
    }
  };
  return i;
}
function Z1e(n) {
  n === void 0 && (n = {});
  var t = q1e(null);
  return t.options = gh({ async: !0, ssr: !1 }, n), t;
}
var YX = function(n) {
  var t = n.sideCar, e = KX(n, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return D.createElement(r, gh({}, e));
};
YX.isSideCarExport = !0;
function Q1e(n, t) {
  return n.useMedium(t), YX;
}
var XX = Z1e(), nF = function() {
}, Y2 = D.forwardRef(function(n, t) {
  var e = D.useRef(null), r = D.useState({
    onScrollCapture: nF,
    onWheelCapture: nF,
    onTouchMoveCapture: nF
  }), i = r[0], s = r[1], o = n.forwardProps, l = n.children, u = n.className, d = n.removeScrollBar, f = n.enabled, m = n.shards, v = n.sideCar, S = n.noIsolation, w = n.inert, E = n.allowPinchZoom, A = n.as, P = A === void 0 ? "div" : A, R = n.gapMode, M = KX(n, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), j = v, $ = Y1e([e, t]), U = gh(gh({}, M), i);
  return D.createElement(
    D.Fragment,
    null,
    f && D.createElement(j, { sideCar: XX, removeScrollBar: d, shards: m, noIsolation: S, inert: w, setCallbacks: s, allowPinchZoom: !!E, lockRef: e, gapMode: R }),
    o ? D.cloneElement(D.Children.only(l), gh(gh({}, U), { ref: $ })) : D.createElement(P, gh({}, U, { className: u, ref: $ }), l)
  );
});
Y2.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Y2.classNames = {
  fullWidth: TR,
  zeroRight: _R
};
var J1e = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function e_e() {
  if (!document)
    return null;
  var n = document.createElement("style");
  n.type = "text/css";
  var t = J1e();
  return t && n.setAttribute("nonce", t), n;
}
function t_e(n, t) {
  n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(document.createTextNode(t));
}
function n_e(n) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(n);
}
var r_e = function() {
  var n = 0, t = null;
  return {
    add: function(e) {
      n == 0 && (t = e_e()) && (t_e(t, e), n_e(t)), n++;
    },
    remove: function() {
      n--, !n && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, i_e = function() {
  var n = r_e();
  return function(t, e) {
    D.useEffect(function() {
      return n.add(t), function() {
        n.remove();
      };
    }, [t && e]);
  };
}, qX = function() {
  var n = i_e(), t = function(e) {
    var r = e.styles, i = e.dynamic;
    return n(r, i), null;
  };
  return t;
}, s_e = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, rF = function(n) {
  return parseInt(n || "", 10) || 0;
}, o_e = function(n) {
  var t = window.getComputedStyle(document.body), e = t[n === "padding" ? "paddingLeft" : "marginLeft"], r = t[n === "padding" ? "paddingTop" : "marginTop"], i = t[n === "padding" ? "paddingRight" : "marginRight"];
  return [rF(e), rF(r), rF(i)];
}, a_e = function(n) {
  if (n === void 0 && (n = "margin"), typeof window > "u")
    return s_e;
  var t = o_e(n), e = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - e + t[2] - t[0])
  };
}, l_e = qX(), Y0 = "data-scroll-locked", c_e = function(n, t, e, r) {
  var i = n.left, s = n.top, o = n.right, l = n.gap;
  return e === void 0 && (e = "margin"), `
  .`.concat(V1e, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(l, "px ").concat(r, `;
  }
  body[`).concat(Y0, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    e === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(l, "px ").concat(r, `;
    `),
    e === "padding" && "padding-right: ".concat(l, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(_R, ` {
    right: `).concat(l, "px ").concat(r, `;
  }
  
  .`).concat(TR, ` {
    margin-right: `).concat(l, "px ").concat(r, `;
  }
  
  .`).concat(_R, " .").concat(_R, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(TR, " .").concat(TR, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Y0, `] {
    `).concat(W1e, ": ").concat(l, `px;
  }
`);
}, J7 = function() {
  var n = parseInt(document.body.getAttribute(Y0) || "0", 10);
  return isFinite(n) ? n : 0;
}, u_e = function() {
  D.useEffect(function() {
    return document.body.setAttribute(Y0, (J7() + 1).toString()), function() {
      var n = J7() - 1;
      n <= 0 ? document.body.removeAttribute(Y0) : document.body.setAttribute(Y0, n.toString());
    };
  }, []);
}, d_e = function(n) {
  var t = n.noRelative, e = n.noImportant, r = n.gapMode, i = r === void 0 ? "margin" : r;
  u_e();
  var s = D.useMemo(function() {
    return a_e(i);
  }, [i]);
  return D.createElement(l_e, { styles: c_e(s, !t, i, e ? "" : "!important") });
}, $3 = !1;
if (typeof window < "u")
  try {
    var AI = Object.defineProperty({}, "passive", {
      get: function() {
        return $3 = !0, !0;
      }
    });
    window.addEventListener("test", AI, AI), window.removeEventListener("test", AI, AI);
  } catch {
    $3 = !1;
  }
var b0 = $3 ? { passive: !1 } : !1, h_e = function(n) {
  return n.tagName === "TEXTAREA";
}, ZX = function(n, t) {
  var e = window.getComputedStyle(n);
  return (
    // not-not-scrollable
    e[t] !== "hidden" && // contains scroll inside self
    !(e.overflowY === e.overflowX && !h_e(n) && e[t] === "visible")
  );
}, f_e = function(n) {
  return ZX(n, "overflowY");
}, p_e = function(n) {
  return ZX(n, "overflowX");
}, eV = function(n, t) {
  var e = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = QX(n, r);
    if (i) {
      var s = JX(n, r), o = s[1], l = s[2];
      if (o > l)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== e.body);
  return !1;
}, g_e = function(n) {
  var t = n.scrollTop, e = n.scrollHeight, r = n.clientHeight;
  return [
    t,
    e,
    r
  ];
}, m_e = function(n) {
  var t = n.scrollLeft, e = n.scrollWidth, r = n.clientWidth;
  return [
    t,
    e,
    r
  ];
}, QX = function(n, t) {
  return n === "v" ? f_e(t) : p_e(t);
}, JX = function(n, t) {
  return n === "v" ? g_e(t) : m_e(t);
}, v_e = function(n, t) {
  return n === "h" && t === "rtl" ? -1 : 1;
}, y_e = function(n, t, e, r, i) {
  var s = v_e(n, window.getComputedStyle(t).direction), o = s * r, l = e.target, u = t.contains(l), d = !1, f = o > 0, m = 0, v = 0;
  do {
    var S = JX(n, l), w = S[0], E = S[1], A = S[2], P = E - A - s * w;
    (w || P) && QX(n, l) && (m += P, v += w), l instanceof ShadowRoot ? l = l.host : l = l.parentNode;
  } while (
    // portaled content
    !u && l !== document.body || // self content
    u && (t.contains(l) || t === l)
  );
  return (f && (Math.abs(m) < 1 || !i) || !f && (Math.abs(v) < 1 || !i)) && (d = !0), d;
}, kI = function(n) {
  return "changedTouches" in n ? [n.changedTouches[0].clientX, n.changedTouches[0].clientY] : [0, 0];
}, tV = function(n) {
  return [n.deltaX, n.deltaY];
}, nV = function(n) {
  return n && "current" in n ? n.current : n;
}, S_e = function(n, t) {
  return n[0] === t[0] && n[1] === t[1];
}, b_e = function(n) {
  return `
  .block-interactivity-`.concat(n, ` {pointer-events: none;}
  .allow-interactivity-`).concat(n, ` {pointer-events: all;}
`);
}, x_e = 0, x0 = [];
function w_e(n) {
  var t = D.useRef([]), e = D.useRef([0, 0]), r = D.useRef(), i = D.useState(x_e++)[0], s = D.useState(qX)[0], o = D.useRef(n);
  D.useEffect(function() {
    o.current = n;
  }, [n]), D.useEffect(function() {
    if (n.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var E = H1e([n.lockRef.current], (n.shards || []).map(nV), !0).filter(Boolean);
      return E.forEach(function(A) {
        return A.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), E.forEach(function(A) {
          return A.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [n.inert, n.lockRef.current, n.shards]);
  var l = D.useCallback(function(E, A) {
    if ("touches" in E && E.touches.length === 2)
      return !o.current.allowPinchZoom;
    var P = kI(E), R = e.current, M = "deltaX" in E ? E.deltaX : R[0] - P[0], j = "deltaY" in E ? E.deltaY : R[1] - P[1], $, U = E.target, F = Math.abs(M) > Math.abs(j) ? "h" : "v";
    if ("touches" in E && F === "h" && U.type === "range")
      return !1;
    var B = eV(F, U);
    if (!B)
      return !0;
    if (B ? $ = F : ($ = F === "v" ? "h" : "v", B = eV(F, U)), !B)
      return !1;
    if (!r.current && "changedTouches" in E && (M || j) && (r.current = $), !$)
      return !0;
    var G = r.current || $;
    return y_e(G, A, E, G === "h" ? M : j, !0);
  }, []), u = D.useCallback(function(E) {
    var A = E;
    if (!(!x0.length || x0[x0.length - 1] !== s)) {
      var P = "deltaY" in A ? tV(A) : kI(A), R = t.current.filter(function($) {
        return $.name === A.type && ($.target === A.target || A.target === $.shadowParent) && S_e($.delta, P);
      })[0];
      if (R && R.should) {
        A.cancelable && A.preventDefault();
        return;
      }
      if (!R) {
        var M = (o.current.shards || []).map(nV).filter(Boolean).filter(function($) {
          return $.contains(A.target);
        }), j = M.length > 0 ? l(A, M[0]) : !o.current.noIsolation;
        j && A.cancelable && A.preventDefault();
      }
    }
  }, []), d = D.useCallback(function(E, A, P, R) {
    var M = { name: E, delta: A, target: P, should: R, shadowParent: C_e(P) };
    t.current.push(M), setTimeout(function() {
      t.current = t.current.filter(function(j) {
        return j !== M;
      });
    }, 1);
  }, []), f = D.useCallback(function(E) {
    e.current = kI(E), r.current = void 0;
  }, []), m = D.useCallback(function(E) {
    d(E.type, tV(E), E.target, l(E, n.lockRef.current));
  }, []), v = D.useCallback(function(E) {
    d(E.type, kI(E), E.target, l(E, n.lockRef.current));
  }, []);
  D.useEffect(function() {
    return x0.push(s), n.setCallbacks({
      onScrollCapture: m,
      onWheelCapture: m,
      onTouchMoveCapture: v
    }), document.addEventListener("wheel", u, b0), document.addEventListener("touchmove", u, b0), document.addEventListener("touchstart", f, b0), function() {
      x0 = x0.filter(function(E) {
        return E !== s;
      }), document.removeEventListener("wheel", u, b0), document.removeEventListener("touchmove", u, b0), document.removeEventListener("touchstart", f, b0);
    };
  }, []);
  var S = n.removeScrollBar, w = n.inert;
  return D.createElement(
    D.Fragment,
    null,
    w ? D.createElement(s, { styles: b_e(i) }) : null,
    S ? D.createElement(d_e, { gapMode: n.gapMode }) : null
  );
}
function C_e(n) {
  for (var t = null; n !== null; )
    n instanceof ShadowRoot && (t = n.host, n = n.host), n = n.parentNode;
  return t;
}
const E_e = Q1e(XX, w_e);
var X2 = D.forwardRef(function(n, t) {
  return D.createElement(Y2, gh({}, n, { ref: t, sideCar: E_e }));
});
X2.classNames = Y2.classNames;
var __e = function(n) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(n) ? n[0] : n;
  return t.ownerDocument.body;
}, w0 = /* @__PURE__ */ new WeakMap(), II = /* @__PURE__ */ new WeakMap(), RI = {}, iF = 0, eq = function(n) {
  return n && (n.host || eq(n.parentNode));
}, T_e = function(n, t) {
  return t.map(function(e) {
    if (n.contains(e))
      return e;
    var r = eq(e);
    return r && n.contains(r) ? r : (console.error("aria-hidden", e, "in not contained inside", n, ". Doing nothing"), null);
  }).filter(function(e) {
    return !!e;
  });
}, P_e = function(n, t, e, r) {
  var i = T_e(t, Array.isArray(n) ? n : [n]);
  RI[e] || (RI[e] = /* @__PURE__ */ new WeakMap());
  var s = RI[e], o = [], l = /* @__PURE__ */ new Set(), u = new Set(i), d = function(m) {
    !m || l.has(m) || (l.add(m), d(m.parentNode));
  };
  i.forEach(d);
  var f = function(m) {
    !m || u.has(m) || Array.prototype.forEach.call(m.children, function(v) {
      if (l.has(v))
        f(v);
      else
        try {
          var S = v.getAttribute(r), w = S !== null && S !== "false", E = (w0.get(v) || 0) + 1, A = (s.get(v) || 0) + 1;
          w0.set(v, E), s.set(v, A), o.push(v), E === 1 && w && II.set(v, !0), A === 1 && v.setAttribute(e, "true"), w || v.setAttribute(r, "true");
        } catch (P) {
          console.error("aria-hidden: cannot operate on ", v, P);
        }
    });
  };
  return f(t), l.clear(), iF++, function() {
    o.forEach(function(m) {
      var v = w0.get(m) - 1, S = s.get(m) - 1;
      w0.set(m, v), s.set(m, S), v || (II.has(m) || m.removeAttribute(r), II.delete(m)), S || m.removeAttribute(e);
    }), iF--, iF || (w0 = /* @__PURE__ */ new WeakMap(), w0 = /* @__PURE__ */ new WeakMap(), II = /* @__PURE__ */ new WeakMap(), RI = {});
  };
}, G5 = function(n, t, e) {
  e === void 0 && (e = "data-aria-hidden");
  var r = Array.from(Array.isArray(n) ? n : [n]), i = __e(n);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), P_e(r, i, e, "aria-hidden")) : function() {
    return null;
  };
}, K5 = "Dialog", [tq, MNe] = jh(K5), [A_e, pd] = tq(K5), nq = (n) => {
  const {
    __scopeDialog: t,
    children: e,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: o = !0
  } = n, l = D.useRef(null), u = D.useRef(null), [d = !1, f] = Dm({
    prop: r,
    defaultProp: i,
    onChange: s
  });
  return /* @__PURE__ */ y.jsx(
    A_e,
    {
      scope: t,
      triggerRef: l,
      contentRef: u,
      contentId: hp(),
      titleId: hp(),
      descriptionId: hp(),
      open: d,
      onOpenChange: f,
      onOpenToggle: D.useCallback(() => f((m) => !m), [f]),
      modal: o,
      children: e
    }
  );
};
nq.displayName = K5;
var rq = "DialogTrigger", k_e = D.forwardRef(
  (n, t) => {
    const { __scopeDialog: e, ...r } = n, i = pd(rq, e), s = si(t, i.triggerRef);
    return /* @__PURE__ */ y.jsx(
      sr.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": q5(i.open),
        ...r,
        ref: s,
        onClick: Et(n.onClick, i.onOpenToggle)
      }
    );
  }
);
k_e.displayName = rq;
var Y5 = "DialogPortal", [I_e, iq] = tq(Y5, {
  forceMount: void 0
}), sq = (n) => {
  const { __scopeDialog: t, forceMount: e, children: r, container: i } = n, s = pd(Y5, t);
  return /* @__PURE__ */ y.jsx(I_e, { scope: t, forceMount: e, children: D.Children.map(r, (o) => /* @__PURE__ */ y.jsx(fd, { present: e || s.open, children: /* @__PURE__ */ y.jsx(XT, { asChild: !0, container: i, children: o }) })) });
};
sq.displayName = Y5;
var NM = "DialogOverlay", oq = D.forwardRef(
  (n, t) => {
    const e = iq(NM, n.__scopeDialog), { forceMount: r = e.forceMount, ...i } = n, s = pd(NM, n.__scopeDialog);
    return s.modal ? /* @__PURE__ */ y.jsx(fd, { present: r || s.open, children: /* @__PURE__ */ y.jsx(R_e, { ...i, ref: t }) }) : null;
  }
);
oq.displayName = NM;
var R_e = D.forwardRef(
  (n, t) => {
    const { __scopeDialog: e, ...r } = n, i = pd(NM, e);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ y.jsx(X2, { as: sS, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ y.jsx(
        sr.div,
        {
          "data-state": q5(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), oS = "DialogContent", aq = D.forwardRef(
  (n, t) => {
    const e = iq(oS, n.__scopeDialog), { forceMount: r = e.forceMount, ...i } = n, s = pd(oS, n.__scopeDialog);
    return /* @__PURE__ */ y.jsx(fd, { present: r || s.open, children: s.modal ? /* @__PURE__ */ y.jsx(M_e, { ...i, ref: t }) : /* @__PURE__ */ y.jsx(D_e, { ...i, ref: t }) });
  }
);
aq.displayName = oS;
var M_e = D.forwardRef(
  (n, t) => {
    const e = pd(oS, n.__scopeDialog), r = D.useRef(null), i = si(t, e.contentRef, r);
    return D.useEffect(() => {
      const s = r.current;
      if (s) return G5(s);
    }, []), /* @__PURE__ */ y.jsx(
      lq,
      {
        ...n,
        ref: i,
        trapFocus: e.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Et(n.onCloseAutoFocus, (s) => {
          var o;
          s.preventDefault(), (o = e.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Et(n.onPointerDownOutside, (s) => {
          const o = s.detail.originalEvent, l = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || l) && s.preventDefault();
        }),
        onFocusOutside: Et(
          n.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), D_e = D.forwardRef(
  (n, t) => {
    const e = pd(oS, n.__scopeDialog), r = D.useRef(!1), i = D.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      lq,
      {
        ...n,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var o, l;
          (o = n.onCloseAutoFocus) == null || o.call(n, s), s.defaultPrevented || (r.current || (l = e.triggerRef.current) == null || l.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var u, d;
          (u = n.onInteractOutside) == null || u.call(n, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = s.target;
          ((d = e.triggerRef.current) == null ? void 0 : d.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), lq = D.forwardRef(
  (n, t) => {
    const { __scopeDialog: e, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...o } = n, l = pd(oS, e), u = D.useRef(null), d = si(t, u);
    return W5(), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        K2,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ y.jsx(
            YT,
            {
              role: "dialog",
              id: l.contentId,
              "aria-describedby": l.descriptionId,
              "aria-labelledby": l.titleId,
              "data-state": q5(l.open),
              ...o,
              ref: d,
              onDismiss: () => l.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
        /* @__PURE__ */ y.jsx(L_e, { titleId: l.titleId }),
        /* @__PURE__ */ y.jsx(N_e, { contentRef: u, descriptionId: l.descriptionId })
      ] })
    ] });
  }
), X5 = "DialogTitle", cq = D.forwardRef(
  (n, t) => {
    const { __scopeDialog: e, ...r } = n, i = pd(X5, e);
    return /* @__PURE__ */ y.jsx(sr.h2, { id: i.titleId, ...r, ref: t });
  }
);
cq.displayName = X5;
var uq = "DialogDescription", O_e = D.forwardRef(
  (n, t) => {
    const { __scopeDialog: e, ...r } = n, i = pd(uq, e);
    return /* @__PURE__ */ y.jsx(sr.p, { id: i.descriptionId, ...r, ref: t });
  }
);
O_e.displayName = uq;
var dq = "DialogClose", hq = D.forwardRef(
  (n, t) => {
    const { __scopeDialog: e, ...r } = n, i = pd(dq, e);
    return /* @__PURE__ */ y.jsx(
      sr.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Et(n.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
hq.displayName = dq;
function q5(n) {
  return n ? "open" : "closed";
}
var fq = "DialogTitleWarning", [DNe, pq] = f1e(fq, {
  contentName: oS,
  titleName: X5,
  docsSlug: "dialog"
}), L_e = ({ titleId: n }) => {
  const t = pq(fq), e = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return D.useEffect(() => {
    n && (document.getElementById(n) || console.error(e));
  }, [e, n]), null;
}, j_e = "DialogDescriptionWarning", N_e = ({ contentRef: n, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${pq(j_e).contentName}}.`;
  return D.useEffect(() => {
    var s;
    const i = (s = n.current) == null ? void 0 : s.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, n, t]), null;
}, F_e = nq, $_e = sq, z_e = oq, U_e = aq;
const gq = () => {
}, mq = D.createContext(null);
function B_e({ onEvent: n, children: t }) {
  return /* @__PURE__ */ y.jsx(mq.Provider, { value: n ?? gq, children: t });
}
function Fo() {
  return D.useContext(mq) ?? gq;
}
const vq = D.createContext(null);
function H_e({ children: n }) {
  const t = we(), e = Fo(), [r, i] = D.useState([]), s = D.useCallback(
    (d) => {
      const f = d.id ?? Ii();
      return i((m) => [...m.filter((v) => v.id !== d.id), { ...d, id: f }]), e("open-menu", { source: "dialog", id: f }), t.addOpenMenu(f), f;
    },
    [t, e]
  ), o = D.useCallback(
    (d, f) => (i(
      (m) => m.map((v) => v.id === d ? {
        ...v,
        ...f
      } : v)
    ), e("open-menu", { source: "dialog", id: d }), t.addOpenMenu(d), d),
    [t, e]
  ), l = D.useCallback(
    (d) => (i(
      (f) => f.filter((m) => {
        var v;
        return m.id === d ? ((v = m.onClose) == null || v.call(m), !1) : !0;
      })
    ), e("close-menu", { source: "dialog", id: d }), t.deleteOpenMenu(d), d),
    [t, e]
  ), u = D.useCallback(() => {
    i((d) => (d.forEach((f) => {
      var m;
      (m = f.onClose) == null || m.call(f), e("close-menu", { source: "dialog", id: f.id }), t.deleteOpenMenu(f.id);
    }), []));
  }, [t, e]);
  return /* @__PURE__ */ y.jsx(
    vq.Provider,
    {
      value: { dialogs: r, addDialog: s, removeDialog: l, clearDialogs: u, updateDialog: o },
      children: n
    }
  );
}
function wS() {
  const n = D.useContext(vq);
  if (!n)
    throw new Error("useDialogs must be used within a DialogsProvider");
  return n;
}
const V_e = ({ id: n, component: t, onClose: e }) => {
  const { removeDialog: r } = wS(), i = io(), s = D.useCallback(
    (o) => {
      if (!o) {
        if (e)
          try {
            e();
          } catch (l) {
            console.warn(l);
          }
        r(n);
      }
    },
    [n, e, r]
  );
  return /* @__PURE__ */ y.jsx(F_e, { onOpenChange: s, defaultOpen: !0, children: /* @__PURE__ */ y.jsx($_e, { container: i, children: /* @__PURE__ */ y.jsx(
    z_e,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (o) => {
        o.target === o.currentTarget && s(!1);
      },
      children: /* @__PURE__ */ y.jsx(U_e, { dir: "ltr", className: "tlui-dialog__content", children: /* @__PURE__ */ y.jsx(t, { onClose: () => s(!1) }) })
    }
  ) }) });
};
function W_e() {
  const { dialogs: n } = wS();
  return n.map((t) => /* @__PURE__ */ y.jsx(V_e, { ...t }, t.id));
}
const G_e = Gn.memo(W_e);
function K_e() {
  const n = we(), t = De("follow", () => n.getInstanceState().followingUserId, [
    n
  ]);
  return t ? /* @__PURE__ */ y.jsx(Y_e, { userId: t }) : null;
}
function Y_e({ userId: n }) {
  const t = D2(n);
  return t ? /* @__PURE__ */ y.jsx("div", { className: "tlui-following-indicator", style: { borderColor: t.color } }) : null;
}
function q2(n) {
  const t = n + "CollectionProvider", [e, r] = jh(t), [i, s] = e(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (S) => {
    const { scope: w, children: E } = S, A = Gn.useRef(null), P = Gn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ y.jsx(i, { scope: w, itemMap: P, collectionRef: A, children: E });
  };
  o.displayName = t;
  const l = n + "CollectionSlot", u = Gn.forwardRef(
    (S, w) => {
      const { scope: E, children: A } = S, P = s(l, E), R = si(w, P.collectionRef);
      return /* @__PURE__ */ y.jsx(sS, { ref: R, children: A });
    }
  );
  u.displayName = l;
  const d = n + "CollectionItemSlot", f = "data-radix-collection-item", m = Gn.forwardRef(
    (S, w) => {
      const { scope: E, children: A, ...P } = S, R = Gn.useRef(null), M = si(w, R), j = s(d, E);
      return Gn.useEffect(() => (j.itemMap.set(R, { ref: R, ...P }), () => void j.itemMap.delete(R))), /* @__PURE__ */ y.jsx(sS, { [f]: "", ref: M, children: A });
    }
  );
  m.displayName = d;
  function v(S) {
    const w = s(n + "CollectionConsumer", S);
    return Gn.useCallback(() => {
      const A = w.collectionRef.current;
      if (!A) return [];
      const P = Array.from(A.querySelectorAll(`[${f}]`));
      return Array.from(w.itemMap.values()).sort(
        (j, $) => P.indexOf(j.ref.current) - P.indexOf($.ref.current)
      );
    }, [w.collectionRef, w.itemMap]);
  }
  return [
    { Provider: o, Slot: u, ItemSlot: m },
    v,
    r
  ];
}
var X_e = "VisuallyHidden", Z5 = D.forwardRef(
  (n, t) => /* @__PURE__ */ y.jsx(
    sr.span,
    {
      ...n,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...n.style
      }
    }
  )
);
Z5.displayName = X_e;
var Q5 = "ToastProvider", [J5, q_e, Z_e] = q2("Toast"), [yq, ONe] = jh("Toast", [Z_e]), [Q_e, Z2] = yq(Q5), Sq = (n) => {
  const {
    __scopeToast: t,
    label: e = "Notification",
    duration: r = 5e3,
    swipeDirection: i = "right",
    swipeThreshold: s = 50,
    children: o
  } = n, [l, u] = D.useState(null), [d, f] = D.useState(0), m = D.useRef(!1), v = D.useRef(!1);
  return e.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${Q5}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ y.jsx(J5.Provider, { scope: t, children: /* @__PURE__ */ y.jsx(
    Q_e,
    {
      scope: t,
      label: e,
      duration: r,
      swipeDirection: i,
      swipeThreshold: s,
      toastCount: d,
      viewport: l,
      onViewportChange: u,
      onToastAdd: D.useCallback(() => f((S) => S + 1), []),
      onToastRemove: D.useCallback(() => f((S) => S - 1), []),
      isFocusedToastEscapeKeyDownRef: m,
      isClosePausedRef: v,
      children: o
    }
  ) });
};
Sq.displayName = Q5;
var bq = "ToastViewport", J_e = ["F8"], z3 = "toast.viewportPause", U3 = "toast.viewportResume", xq = D.forwardRef(
  (n, t) => {
    const {
      __scopeToast: e,
      hotkey: r = J_e,
      label: i = "Notifications ({hotkey})",
      ...s
    } = n, o = Z2(bq, e), l = q_e(e), u = D.useRef(null), d = D.useRef(null), f = D.useRef(null), m = D.useRef(null), v = si(t, m, o.onViewportChange), S = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), w = o.toastCount > 0;
    D.useEffect(() => {
      const A = (P) => {
        var M;
        r.every((j) => P[j] || P.code === j) && ((M = m.current) == null || M.focus());
      };
      return document.addEventListener("keydown", A), () => document.removeEventListener("keydown", A);
    }, [r]), D.useEffect(() => {
      const A = u.current, P = m.current;
      if (w && A && P) {
        const R = () => {
          if (!o.isClosePausedRef.current) {
            const U = new CustomEvent(z3);
            P.dispatchEvent(U), o.isClosePausedRef.current = !0;
          }
        }, M = () => {
          if (o.isClosePausedRef.current) {
            const U = new CustomEvent(U3);
            P.dispatchEvent(U), o.isClosePausedRef.current = !1;
          }
        }, j = (U) => {
          !A.contains(U.relatedTarget) && M();
        }, $ = () => {
          A.contains(document.activeElement) || M();
        };
        return A.addEventListener("focusin", R), A.addEventListener("focusout", j), A.addEventListener("pointermove", R), A.addEventListener("pointerleave", $), window.addEventListener("blur", R), window.addEventListener("focus", M), () => {
          A.removeEventListener("focusin", R), A.removeEventListener("focusout", j), A.removeEventListener("pointermove", R), A.removeEventListener("pointerleave", $), window.removeEventListener("blur", R), window.removeEventListener("focus", M);
        };
      }
    }, [w, o.isClosePausedRef]);
    const E = D.useCallback(
      ({ tabbingDirection: A }) => {
        const R = l().map((M) => {
          const j = M.ref.current, $ = [j, ...hTe(j)];
          return A === "forwards" ? $ : $.reverse();
        });
        return (A === "forwards" ? R.reverse() : R).flat();
      },
      [l]
    );
    return D.useEffect(() => {
      const A = m.current;
      if (A) {
        const P = (R) => {
          var $, U, F;
          const M = R.altKey || R.ctrlKey || R.metaKey;
          if (R.key === "Tab" && !M) {
            const B = document.activeElement, G = R.shiftKey;
            if (R.target === A && G) {
              ($ = d.current) == null || $.focus();
              return;
            }
            const ne = E({ tabbingDirection: G ? "backwards" : "forwards" }), K = ne.findIndex((Z) => Z === B);
            sF(ne.slice(K + 1)) ? R.preventDefault() : G ? (U = d.current) == null || U.focus() : (F = f.current) == null || F.focus();
          }
        };
        return A.addEventListener("keydown", P), () => A.removeEventListener("keydown", P);
      }
    }, [l, E]), /* @__PURE__ */ y.jsxs(
      R1e,
      {
        ref: u,
        role: "region",
        "aria-label": i.replace("{hotkey}", S),
        tabIndex: -1,
        style: { pointerEvents: w ? void 0 : "none" },
        children: [
          w && /* @__PURE__ */ y.jsx(
            B3,
            {
              ref: d,
              onFocusFromOutsideViewport: () => {
                const A = E({
                  tabbingDirection: "forwards"
                });
                sF(A);
              }
            }
          ),
          /* @__PURE__ */ y.jsx(J5.Slot, { scope: e, children: /* @__PURE__ */ y.jsx(sr.ol, { tabIndex: -1, ...s, ref: v }) }),
          w && /* @__PURE__ */ y.jsx(
            B3,
            {
              ref: f,
              onFocusFromOutsideViewport: () => {
                const A = E({
                  tabbingDirection: "backwards"
                });
                sF(A);
              }
            }
          )
        ]
      }
    );
  }
);
xq.displayName = bq;
var wq = "ToastFocusProxy", B3 = D.forwardRef(
  (n, t) => {
    const { __scopeToast: e, onFocusFromOutsideViewport: r, ...i } = n, s = Z2(wq, e);
    return /* @__PURE__ */ y.jsx(
      Z5,
      {
        "aria-hidden": !0,
        tabIndex: 0,
        ...i,
        ref: t,
        style: { position: "fixed" },
        onFocus: (o) => {
          var d;
          const l = o.relatedTarget;
          !((d = s.viewport) != null && d.contains(l)) && r();
        }
      }
    );
  }
);
B3.displayName = wq;
var Q2 = "Toast", eTe = "toast.swipeStart", tTe = "toast.swipeMove", nTe = "toast.swipeCancel", rTe = "toast.swipeEnd", Cq = D.forwardRef(
  (n, t) => {
    const { forceMount: e, open: r, defaultOpen: i, onOpenChange: s, ...o } = n, [l = !0, u] = Dm({
      prop: r,
      defaultProp: i,
      onChange: s
    });
    return /* @__PURE__ */ y.jsx(fd, { present: e || l, children: /* @__PURE__ */ y.jsx(
      oTe,
      {
        open: l,
        ...o,
        ref: t,
        onClose: () => u(!1),
        onPause: jo(n.onPause),
        onResume: jo(n.onResume),
        onSwipeStart: Et(n.onSwipeStart, (d) => {
          d.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: Et(n.onSwipeMove, (d) => {
          const { x: f, y: m } = d.detail.delta;
          d.currentTarget.setAttribute("data-swipe", "move"), d.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${f}px`), d.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${m}px`);
        }),
        onSwipeCancel: Et(n.onSwipeCancel, (d) => {
          d.currentTarget.setAttribute("data-swipe", "cancel"), d.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), d.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), d.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), d.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: Et(n.onSwipeEnd, (d) => {
          const { x: f, y: m } = d.detail.delta;
          d.currentTarget.setAttribute("data-swipe", "end"), d.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), d.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), d.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${f}px`), d.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${m}px`), u(!1);
        })
      }
    ) });
  }
);
Cq.displayName = Q2;
var [iTe, sTe] = yq(Q2, {
  onClose() {
  }
}), oTe = D.forwardRef(
  (n, t) => {
    const {
      __scopeToast: e,
      type: r = "foreground",
      duration: i,
      open: s,
      onClose: o,
      onEscapeKeyDown: l,
      onPause: u,
      onResume: d,
      onSwipeStart: f,
      onSwipeMove: m,
      onSwipeCancel: v,
      onSwipeEnd: S,
      ...w
    } = n, E = Z2(Q2, e), [A, P] = D.useState(null), R = si(t, (Z) => P(Z)), M = D.useRef(null), j = D.useRef(null), $ = i || E.duration, U = D.useRef(0), F = D.useRef($), B = D.useRef(0), { onToastAdd: G, onToastRemove: X } = E, te = jo(() => {
      var oe;
      (A == null ? void 0 : A.contains(document.activeElement)) && ((oe = E.viewport) == null || oe.focus()), o();
    }), ne = D.useCallback(
      (Z) => {
        !Z || Z === 1 / 0 || (window.clearTimeout(B.current), U.current = (/* @__PURE__ */ new Date()).getTime(), B.current = window.setTimeout(te, Z));
      },
      [te]
    );
    D.useEffect(() => {
      const Z = E.viewport;
      if (Z) {
        const oe = () => {
          ne(F.current), d == null || d();
        }, fe = () => {
          const ie = (/* @__PURE__ */ new Date()).getTime() - U.current;
          F.current = F.current - ie, window.clearTimeout(B.current), u == null || u();
        };
        return Z.addEventListener(z3, fe), Z.addEventListener(U3, oe), () => {
          Z.removeEventListener(z3, fe), Z.removeEventListener(U3, oe);
        };
      }
    }, [E.viewport, $, u, d, ne]), D.useEffect(() => {
      s && !E.isClosePausedRef.current && ne($);
    }, [s, $, E.isClosePausedRef, ne]), D.useEffect(() => (G(), () => X()), [G, X]);
    const K = D.useMemo(() => A ? Iq(A) : null, [A]);
    return E.viewport ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      K && /* @__PURE__ */ y.jsx(
        aTe,
        {
          __scopeToast: e,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          "aria-atomic": !0,
          children: K
        }
      ),
      /* @__PURE__ */ y.jsx(iTe, { scope: e, onClose: te, children: xS.createPortal(
        /* @__PURE__ */ y.jsx(J5.ItemSlot, { scope: e, children: /* @__PURE__ */ y.jsx(
          I1e,
          {
            asChild: !0,
            onEscapeKeyDown: Et(l, () => {
              E.isFocusedToastEscapeKeyDownRef.current || te(), E.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ y.jsx(
              sr.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": !0,
                tabIndex: 0,
                "data-state": s ? "open" : "closed",
                "data-swipe-direction": E.swipeDirection,
                ...w,
                ref: R,
                style: { userSelect: "none", touchAction: "none", ...n.style },
                onKeyDown: Et(n.onKeyDown, (Z) => {
                  Z.key === "Escape" && (l == null || l(Z.nativeEvent), Z.nativeEvent.defaultPrevented || (E.isFocusedToastEscapeKeyDownRef.current = !0, te()));
                }),
                onPointerDown: Et(n.onPointerDown, (Z) => {
                  Z.button === 0 && (M.current = { x: Z.clientX, y: Z.clientY });
                }),
                onPointerMove: Et(n.onPointerMove, (Z) => {
                  if (!M.current) return;
                  const oe = Z.clientX - M.current.x, fe = Z.clientY - M.current.y, ie = !!j.current, ue = ["left", "right"].includes(E.swipeDirection), Se = ["left", "up"].includes(E.swipeDirection) ? Math.min : Math.max, ke = ue ? Se(0, oe) : 0, ce = ue ? 0 : Se(0, fe), ye = Z.pointerType === "touch" ? 10 : 2, Fe = { x: ke, y: ce }, Xe = { originalEvent: Z, delta: Fe };
                  ie ? (j.current = Fe, MI(tTe, m, Xe, {
                    discrete: !1
                  })) : rV(Fe, E.swipeDirection, ye) ? (j.current = Fe, MI(eTe, f, Xe, {
                    discrete: !1
                  }), Z.target.setPointerCapture(Z.pointerId)) : (Math.abs(oe) > ye || Math.abs(fe) > ye) && (M.current = null);
                }),
                onPointerUp: Et(n.onPointerUp, (Z) => {
                  const oe = j.current, fe = Z.target;
                  if (fe.hasPointerCapture(Z.pointerId) && fe.releasePointerCapture(Z.pointerId), j.current = null, M.current = null, oe) {
                    const ie = Z.currentTarget, ue = { originalEvent: Z, delta: oe };
                    rV(oe, E.swipeDirection, E.swipeThreshold) ? MI(rTe, S, ue, {
                      discrete: !0
                    }) : MI(
                      nTe,
                      v,
                      ue,
                      {
                        discrete: !0
                      }
                    ), ie.addEventListener("click", (Se) => Se.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        E.viewport
      ) })
    ] }) : null;
  }
), aTe = (n) => {
  const { __scopeToast: t, children: e, ...r } = n, i = Z2(Q2, t), [s, o] = D.useState(!1), [l, u] = D.useState(!1);
  return uTe(() => o(!0)), D.useEffect(() => {
    const d = window.setTimeout(() => u(!0), 1e3);
    return () => window.clearTimeout(d);
  }, []), l ? null : /* @__PURE__ */ y.jsx(XT, { asChild: !0, children: /* @__PURE__ */ y.jsx(Z5, { ...r, children: s && /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    i.label,
    " ",
    e
  ] }) }) });
}, lTe = "ToastTitle", Eq = D.forwardRef(
  (n, t) => {
    const { __scopeToast: e, ...r } = n;
    return /* @__PURE__ */ y.jsx(sr.div, { ...r, ref: t });
  }
);
Eq.displayName = lTe;
var cTe = "ToastDescription", _q = D.forwardRef(
  (n, t) => {
    const { __scopeToast: e, ...r } = n;
    return /* @__PURE__ */ y.jsx(sr.div, { ...r, ref: t });
  }
);
_q.displayName = cTe;
var Tq = "ToastAction", Pq = D.forwardRef(
  (n, t) => {
    const { altText: e, ...r } = n;
    return e.trim() ? /* @__PURE__ */ y.jsx(kq, { altText: e, asChild: !0, children: /* @__PURE__ */ y.jsx(eU, { ...r, ref: t }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${Tq}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
Pq.displayName = Tq;
var Aq = "ToastClose", eU = D.forwardRef(
  (n, t) => {
    const { __scopeToast: e, ...r } = n, i = sTe(Aq, e);
    return /* @__PURE__ */ y.jsx(kq, { asChild: !0, children: /* @__PURE__ */ y.jsx(
      sr.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Et(n.onClick, i.onClose)
      }
    ) });
  }
);
eU.displayName = Aq;
var kq = D.forwardRef((n, t) => {
  const { __scopeToast: e, altText: r, ...i } = n;
  return /* @__PURE__ */ y.jsx(
    sr.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...i,
      ref: t
    }
  );
});
function Iq(n) {
  const t = [];
  return Array.from(n.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), dTe(r)) {
      const i = r.ariaHidden || r.hidden || r.style.display === "none", s = r.dataset.radixToastAnnounceExclude === "";
      if (!i)
        if (s) {
          const o = r.dataset.radixToastAnnounceAlt;
          o && t.push(o);
        } else
          t.push(...Iq(r));
    }
  }), t;
}
function MI(n, t, e, { discrete: r }) {
  const i = e.originalEvent.currentTarget, s = new CustomEvent(n, { bubbles: !0, cancelable: !0, detail: e });
  t && i.addEventListener(n, t, { once: !0 }), r ? V5(i, s) : i.dispatchEvent(s);
}
var rV = (n, t, e = 0) => {
  const r = Math.abs(n.x), i = Math.abs(n.y), s = r > i;
  return t === "left" || t === "right" ? s && r > e : !s && i > e;
};
function uTe(n = () => {
}) {
  const t = jo(n);
  wm(() => {
    let e = 0, r = 0;
    return e = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
      window.cancelAnimationFrame(e), window.cancelAnimationFrame(r);
    };
  }, [t]);
}
function dTe(n) {
  return n.nodeType === n.ELEMENT_NODE;
}
function hTe(n) {
  const t = [], e = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); ) t.push(e.currentNode);
  return t;
}
function sF(n) {
  const t = document.activeElement;
  return n.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));
}
var fTe = Cq, pTe = Eq, gTe = _q, mTe = Pq, iV = eU;
const Rq = D.createContext(null);
function vTe({ children: n }) {
  const [t, e] = D.useState([]), r = D.useCallback((o) => {
    const l = o.id ?? Ii();
    return e((u) => [...u.filter((d) => d.id !== o.id), { ...o, id: l }]), l;
  }, []), i = D.useCallback((o) => (e((l) => l.filter((u) => u.id !== o)), o), []), s = D.useCallback(() => {
    e(() => []);
  }, []);
  return /* @__PURE__ */ y.jsx(Sq, { children: /* @__PURE__ */ y.jsx(Rq.Provider, { value: { toasts: t, addToast: r, removeToast: i, clearToasts: s }, children: n }) });
}
function gd() {
  const n = D.useContext(Rq);
  if (!n)
    throw new Error("useToasts must be used within a ToastsProvider");
  return n;
}
const Wt = D.forwardRef(
  function({ children: t, disabled: e, type: r, ...i }, s) {
    return /* @__PURE__ */ y.jsx(
      "button",
      {
        ref: s,
        type: "button",
        draggable: !1,
        disabled: e,
        ...i,
        className: Vt("tlui-button", `tlui-button__${r}`, i.className),
        children: t
      }
    );
  }
);
function Zi({ children: n }) {
  return /* @__PURE__ */ y.jsx("span", { className: "tlui-button__label", children: n });
}
const Ih = D.memo(function({
  small: t,
  invertIcon: e,
  icon: r,
  color: i,
  className: s,
  ...o
}) {
  const l = U5(), u = l.icons[r] ?? l.icons["question-mark-circle"], d = D.useRef(null);
  return D.useLayoutEffect(() => {
    u || console.error(`Icon not found: ${r}. Add it to the assetUrls.icons object.`), d != null && d.current && (d.current.style.webkitMask = `url(${u}) center 100% / 100% no-repeat`);
  }, [d, u, r]), r === "none" ? /* @__PURE__ */ y.jsx(
    "div",
    {
      className: Vt(
        "tlui-icon tlui-icon__placeholder",
        { "tlui-icon__small": t },
        s
      )
    }
  ) : /* @__PURE__ */ y.jsx(
    "div",
    {
      ...o,
      ref: d,
      className: Vt("tlui-icon", { "tlui-icon__small": t }, s),
      style: {
        color: i,
        mask: `url(${u}) center 100% / 100% no-repeat`,
        transform: e ? "scale(-1, 1)" : void 0
      }
    }
  );
}), yTe = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function STe({ toast: n }) {
  const { removeToast: t } = gd(), e = Dn(), r = (o) => {
    o || t(n.id);
  }, i = n.actions && n.actions.length > 0, s = n.icon || n.severity && yTe[n.severity];
  return /* @__PURE__ */ y.jsxs(
    fTe,
    {
      onOpenChange: r,
      className: "tlui-toast__container",
      duration: n.keepOpen ? 1 / 0 : 5e3,
      "data-severity": n.severity,
      children: [
        s && /* @__PURE__ */ y.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ y.jsx(Ih, { icon: s }) }),
        /* @__PURE__ */ y.jsxs("div", { className: "tlui-toast__main", children: [
          /* @__PURE__ */ y.jsxs("div", { className: "tlui-toast__content", children: [
            n.title && /* @__PURE__ */ y.jsx(pTe, { className: "tlui-toast__title", children: n.title }),
            n.description && /* @__PURE__ */ y.jsx(gTe, { className: "tlui-toast__description", children: n.description })
          ] }),
          n.actions && /* @__PURE__ */ y.jsxs("div", { className: "tlui-toast__actions", children: [
            n.actions.map((o, l) => /* @__PURE__ */ y.jsx(mTe, { altText: o.label, asChild: !0, onClick: o.onClick, children: /* @__PURE__ */ y.jsx(Wt, { type: o.type, children: /* @__PURE__ */ y.jsx(Zi, { children: o.label }) }) }, l)),
            /* @__PURE__ */ y.jsx(iV, { asChild: !0, children: /* @__PURE__ */ y.jsx(
              Wt,
              {
                type: "normal",
                className: "tlui-toast__close",
                style: { marginLeft: "auto" },
                children: /* @__PURE__ */ y.jsx(Zi, { children: n.closeLabel ?? e("toast.close") })
              }
            ) })
          ] })
        ] }),
        !i && /* @__PURE__ */ y.jsx(iV, { asChild: !0, children: /* @__PURE__ */ y.jsx(Wt, { type: "normal", className: "tlui-toast__close", children: /* @__PURE__ */ y.jsx(Zi, { children: n.closeLabel ?? e("toast.close") }) }) })
      ]
    }
  );
}
function bTe() {
  const { toasts: n } = gd();
  return n.map((t) => /* @__PURE__ */ y.jsx(STe, { toast: t }, t.id));
}
const xTe = D.memo(bTe);
function wTe() {
  const n = we(), { toasts: t } = gd(), [e, r] = D.useState(!1);
  return D.useEffect(() => {
    let i = -1;
    return t.length ? r(!0) : i = n.timers.setTimeout(() => {
      r(!1);
    }, 1e3), () => {
      clearTimeout(i);
    };
  }, [t.length, r, n]), e ? /* @__PURE__ */ y.jsx(xq, { className: "tlui-toast__viewport" }) : null;
}
function Rn({ icon: n, small: t, invertIcon: e }) {
  return /* @__PURE__ */ y.jsx(Ih, { className: "tlui-button__icon", icon: n, small: t, invertIcon: e });
}
const oF = [0, 390, 428, 468, 580, 640, 840, 1023];
var Ui = /* @__PURE__ */ ((n) => (n[n.ZERO = 0] = "ZERO", n[n.MOBILE_XXS = 1] = "MOBILE_XXS", n[n.MOBILE_XS = 2] = "MOBILE_XS", n[n.MOBILE_SM = 3] = "MOBILE_SM", n[n.MOBILE = 4] = "MOBILE", n[n.TABLET_SM = 5] = "TABLET_SM", n[n.TABLET = 6] = "TABLET", n[n.DESKTOP = 7] = "DESKTOP", n))(Ui || {});
let H3 = {
  fonts: {
    draw: `${hm()}/fonts/Shantell_Sans-Tldrawish.woff2`,
    serif: `${hm()}/fonts/IBMPlexSerif-Medium.woff2`,
    sansSerif: `${hm()}/fonts/IBMPlexSans-Medium.woff2`,
    monospace: `${hm()}/fonts/IBMPlexMono-Medium.woff2`
  }
};
function Mq(n) {
  return D.useMemo(() => n ? {
    fonts: { ...H3.fonts, ...n == null ? void 0 : n.fonts }
  } : H3, [n]);
}
const CTe = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bring-forward",
  "bring-to-front",
  "broken",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "color",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "leading",
  "link",
  "lock",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
let jE = {
  ...H3,
  icons: Object.fromEntries(
    CTe.map((n) => [n, `${hm()}/icons/icon/${n}.svg`])
  ),
  translations: Object.fromEntries(
    B1.map((n) => [
      n.locale,
      `${hm()}/translations/${n.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    $T.map((n) => [
      n.type,
      `${hm()}/embed-icons/${n.type}.png`
    ])
  )
};
function ETe(n) {
  return n ? {
    fonts: Object.assign({ ...jE.fonts }, { ...n == null ? void 0 : n.fonts }),
    icons: Object.assign({ ...jE.icons }, { ...n == null ? void 0 : n.icons }),
    embedIcons: Object.assign({ ...jE.embedIcons }, { ...n == null ? void 0 : n.embedIcons }),
    translations: Object.assign(
      { ...jE.translations },
      { ...n == null ? void 0 : n.translations }
    )
  } : jE;
}
function J2({ className: n, children: t }) {
  return /* @__PURE__ */ y.jsx("div", { className: Vt("tlui-dialog__header", n), children: t });
}
function eD({ className: n, children: t }) {
  return /* @__PURE__ */ y.jsx(cq, { dir: "ltr", className: Vt("tlui-dialog__header__title", n), children: t });
}
function tD() {
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ y.jsx(hq, { "data-testid": "dialog.close", dir: "ltr", asChild: !0, children: /* @__PURE__ */ y.jsx(
    Wt,
    {
      type: "icon",
      "aria-label": "Close",
      onTouchEnd: (n) => n.target.click(),
      children: /* @__PURE__ */ y.jsx(Rn, { small: !0, icon: "cross-2" })
    }
  ) }) });
}
function V1({ className: n, children: t, style: e }) {
  return /* @__PURE__ */ y.jsx("div", { className: Vt("tlui-dialog__body", n), style: e, children: t });
}
function tU({ className: n, children: t }) {
  return /* @__PURE__ */ y.jsx("div", { className: Vt("tlui-dialog__footer", n), children: t });
}
const nD = D.forwardRef(
  function({
    className: t,
    label: e,
    icon: r,
    iconLeft: i,
    autoSelect: s = !1,
    autoFocus: o = !1,
    defaultValue: l,
    placeholder: u,
    onComplete: d,
    onValueChange: f,
    onCancel: m,
    onFocus: v,
    onBlur: S,
    shouldManuallyMaintainScrollPositionWhenFocused: w = !1,
    children: E,
    value: A
  }, P) {
    const R = we(), M = D.useRef(null);
    D.useImperativeHandle(P, () => M.current);
    const j = Dn(), $ = D.useRef(l ?? ""), U = D.useRef(l ?? ""), [F, B] = D.useState(!1), G = D.useCallback(
      (K) => {
        B(!0);
        const Z = K.currentTarget;
        U.current = Z.value, R.timers.requestAnimationFrame(() => {
          s && Z.select();
        }), v == null || v();
      },
      [s, v, R.timers]
    ), X = D.useCallback(
      (K) => {
        const Z = K.currentTarget.value;
        U.current = Z, f == null || f(Z);
      },
      [f]
    ), te = D.useCallback(
      (K) => {
        switch (K.key) {
          case "Enter": {
            K.currentTarget.blur(), to(K), d == null || d(K.currentTarget.value);
            break;
          }
          case "Escape": {
            K.currentTarget.value = $.current, K.currentTarget.blur(), to(K), m == null || m(K.currentTarget.value);
            break;
          }
        }
      },
      [d, m]
    ), ne = D.useCallback(
      (K) => {
        B(!1);
        const Z = K.currentTarget.value;
        S == null || S(Z);
      },
      [S]
    );
    return D.useEffect(() => {
      if (!R.environment.isIos) return;
      const K = window.visualViewport;
      if (F && w && K) {
        const Z = () => {
          var oe;
          (oe = M.current) == null || oe.scrollIntoView({ block: "center" });
        };
        return K.addEventListener("resize", Z), K.addEventListener("scroll", Z), R.timers.requestAnimationFrame(() => {
          var oe;
          (oe = M.current) == null || oe.scrollIntoView({ block: "center" });
        }), () => {
          K.removeEventListener("resize", Z), K.removeEventListener("scroll", Z);
        };
      }
    }, [R, F, w]), /* @__PURE__ */ y.jsxs("div", { draggable: !1, className: "tlui-input__wrapper", children: [
      E,
      e && /* @__PURE__ */ y.jsx("label", { children: j(e) }),
      i && /* @__PURE__ */ y.jsx(Ih, { icon: i, className: "tlui-icon-left", small: !0 }),
      /* @__PURE__ */ y.jsx(
        "input",
        {
          ref: M,
          className: Vt("tlui-input", t),
          type: "text",
          defaultValue: l,
          onKeyUp: te,
          onChange: X,
          onFocus: G,
          onBlur: ne,
          autoFocus: o,
          placeholder: u,
          value: A
        }
      ),
      r && /* @__PURE__ */ y.jsx(Ih, { icon: r, small: !!e })
    ] });
  }
), Dq = ro(function({ onClose: t }) {
  const e = we(), r = Dn(), i = U5(), [s, o] = D.useState(null), [l, u] = D.useState(""), [d, f] = D.useState(null), [m, v] = D.useState(!1), S = D.useRef(-1);
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(J2, { children: [
      /* @__PURE__ */ y.jsx(eD, { children: s ? `${r("embed-dialog.title")} — ${s.title}` : r("embed-dialog.title") }),
      /* @__PURE__ */ y.jsx(tD, {})
    ] }),
    s ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsxs(V1, { className: "tlui-embed-dialog__enter", children: [
        /* @__PURE__ */ y.jsx(
          nD,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "http://example.com",
            autoFocus: !0,
            onValueChange: (w) => {
              u(w);
              const E = pm(w);
              f(
                E && E.definition.type === s.type ? E : null
              ), v(!1), clearTimeout(S.current), S.current = e.timers.setTimeout(
                () => v(!E),
                320
              );
            }
          }
        ),
        l === "" ? /* @__PURE__ */ y.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ y.jsx("span", { children: r("embed-dialog.instruction") }),
          " ",
          s.instructionLink && /* @__PURE__ */ y.jsxs(
            "a",
            {
              target: "_blank",
              rel: "noopener noreferrer",
              href: s.instructionLink,
              className: "tlui-embed-dialog__instruction__link",
              children: [
                "Learn more.",
                /* @__PURE__ */ y.jsx(Ih, { icon: "external-link", small: !0 })
              ]
            }
          )
        ] }) : /* @__PURE__ */ y.jsx("div", { className: "tlui-embed-dialog__warning", children: m ? r("embed-dialog.invalid-url") : " " })
      ] }),
      /* @__PURE__ */ y.jsxs(tU, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "normal",
            onClick: () => {
              o(null), f(null), u("");
            },
            children: /* @__PURE__ */ y.jsx(Zi, { children: r("embed-dialog.back") })
          }
        ),
        /* @__PURE__ */ y.jsx("div", { className: "tlui-embed__spacer" }),
        /* @__PURE__ */ y.jsx(Wt, { type: "normal", onClick: t, children: /* @__PURE__ */ y.jsx(Zi, { children: r("embed-dialog.cancel") }) }),
        /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "primary",
            disabled: !d,
            onClick: () => {
              d && (e.putExternalContent({
                type: "embed",
                url: l,
                point: e.getViewportPageBounds().center,
                embed: d.definition
              }), t());
            },
            children: /* @__PURE__ */ y.jsx(Zi, { children: r("embed-dialog.create") })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ y.jsx(y.Fragment, { children: /* @__PURE__ */ y.jsx(V1, { className: "tlui-embed-dialog__list", children: $T.map((w) => /* @__PURE__ */ y.jsxs(Wt, { type: "menu", onClick: () => o(w), children: [
      /* @__PURE__ */ y.jsx(Zi, { children: w.title }),
      /* @__PURE__ */ y.jsx(
        "div",
        {
          className: "tlui-embed-dialog__item__image",
          style: { backgroundImage: `url(${i.embedIcons[w.type]})` }
        }
      )
    ] }, w.type)) }) })
  ] });
});
function Oq() {
  const n = we(), t = D.useRef();
  return D.useEffect(() => {
    const e = window.document.createElement("input");
    e.type = "file", e.accept = Ime, e.multiple = !0, t.current = e;
    async function r(i) {
      const s = i.target.files;
      !s || s.length === 0 || (n.mark("insert media"), await n.putExternalContent({
        type: "files",
        files: Array.from(s),
        point: n.getViewportPageBounds().center,
        ignoreParent: !1
      }), e.value = "");
    }
    return e.addEventListener("change", r), () => {
      t.current = void 0, e.removeEventListener("change", r);
    };
  }, [n]), D.useCallback(() => {
    var e;
    (e = t.current) == null || e.click();
  }, [t]);
}
const Lq = D.createContext(null);
function _Te({ overrides: n, children: t }) {
  const e = we(), r = Fo(), { addDialog: i } = wS(), s = Oq(), o = D.useMemo(() => {
    const l = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: !0,
        onSelect(d) {
          e.setCurrentTool("select"), r("select-tool", { source: d, id: "select" });
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: !0,
        onSelect(d) {
          e.setCurrentTool("hand"), r("select-tool", { source: d, id: "hand" });
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(d) {
          e.setCurrentTool("eraser"), r("select-tool", { source: d, id: "eraser" });
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(d) {
          e.setCurrentTool("draw"), r("select-tool", { source: d, id: "draw" });
        }
      },
      ...[...od.values].map((d) => ({
        id: d,
        label: `tool.${d}`,
        meta: {
          geo: d
        },
        kbd: d === "rectangle" ? "r" : d === "ellipse" ? "o" : void 0,
        icon: "geo-" + d,
        onSelect(f) {
          e.run(() => {
            e.setStyleForNextShapes(od, d), e.setCurrentTool("geo"), r("select-tool", { source: f, id: `geo-${d}` });
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(d) {
          e.setCurrentTool("arrow"), r("select-tool", { source: d, id: "arrow" });
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(d) {
          e.setCurrentTool("line"), r("select-tool", { source: d, id: "line" });
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(d) {
          e.setCurrentTool("frame"), r("select-tool", { source: d, id: "frame" });
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(d) {
          e.setCurrentTool("text"), r("select-tool", { source: d, id: "text" });
        }
      },
      {
        id: "asset",
        label: "tool.asset",
        icon: "tool-media",
        kbd: "$u",
        onSelect(d) {
          s(), r("select-tool", { source: d, id: "media" });
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(d) {
          e.setCurrentTool("note"), r("select-tool", { source: d, id: "note" });
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: !0,
        icon: "tool-laser",
        kbd: "k",
        onSelect(d) {
          e.setCurrentTool("laser"), r("select-tool", { source: d, id: "laser" });
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(d) {
          i({ component: Dq }), r("select-tool", { source: d, id: "embed" });
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "!d",
        onSelect(d) {
          e.setCurrentTool("highlight"), r("select-tool", { source: d, id: "highlight" });
        }
      }
    ];
    l.push();
    const u = Object.fromEntries(l.map((d) => [d.id, d]));
    return n ? n(e, u, { insertMedia: s }) : u;
  }, [n, e, r, s, i]);
  return /* @__PURE__ */ y.jsx(Lq.Provider, { value: o, children: t });
}
function rD() {
  const n = D.useContext(Lq);
  if (!n)
    throw new Error("useTools must be used within a ToolProvider");
  return n;
}
const jq = Gn.createContext(null);
function TTe({ forceMobile: n = !1, children: t }) {
  const e = we(), r = De(
    "breakpoint",
    () => {
      const { width: i } = e.getViewportScreenBounds(), s = n ? Ui.MOBILE_SM : oF.length - 1;
      for (let o = 0; o < s; o++)
        if (i > oF[o] && i <= oF[o + 1])
          return o;
      return s;
    },
    [e]
  );
  return /* @__PURE__ */ y.jsx(jq.Provider, { value: r, children: t });
}
function Ya() {
  const n = D.useContext(jq);
  if (n === null)
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  return n;
}
function PTe() {
  const { addToast: n, removeToast: t, clearToasts: e } = gd(), { addDialog: r, clearDialogs: i, removeDialog: s, updateDialog: o } = wS(), u = Ya() < Ui.TABLET_SM, d = Dn();
  return D.useMemo(
    () => ({
      addToast: n,
      removeToast: t,
      clearToasts: e,
      addDialog: r,
      clearDialogs: i,
      removeDialog: s,
      updateDialog: o,
      msg: d,
      isMobile: u
    }),
    [
      r,
      n,
      i,
      e,
      d,
      s,
      t,
      o,
      u
    ]
  );
}
function ATe(n, t) {
  const e = {};
  for (const r of n)
    if (r.translations)
      for (const [i, s] of Fl(r.translations)) {
        let o = e[i];
        o || (o = e[i] = {}), Object.assign(o, s);
      }
  return {
    actions: (r, i) => {
      for (const s of n)
        s.actions && (i = s.actions(r, i, t));
      return i;
    },
    tools: (r, i, s) => {
      for (const o of n)
        o.tools && (i = o.tools(r, i, { ...t, ...s }));
      return i;
    },
    translations: e
  };
}
function Nq(n) {
  return D.useMemo(() => n, n);
}
function kTe(n) {
  const t = Nq(
    n == null ? [] : Array.isArray(n) ? n : [n]
  );
  return D.useMemo(() => {
    const e = {};
    for (const r of t)
      if (r.translations)
        for (const [i, s] of Fl(r.translations)) {
          let o = e[i];
          o || (o = e[i] = {}), Object.assign(o, s);
        }
    return e;
  }, [t]);
}
function ITe(n) {
  const t = PTe(), e = Nq(
    n == null ? [] : Array.isArray(n) ? n : [n]
  );
  return D.useMemo(
    () => ATe(e, t),
    [e, t]
  );
}
function RTe(n, t) {
  const e = xn(
    t.map((i) => n.getShape(i)).filter((i) => i && n.isShapeOfType(i, "frame"))
  );
  if (!e.length) return;
  const r = [];
  n.run(() => {
    e.map((i) => {
      const s = n.getSortedChildIdsForParent(i.id);
      s.length && (n.reparentShapes(s, i.parentId, i.index), r.push(...s));
    }), n.setSelectedShapes(r), n.deleteShapes(t);
  });
}
const MTe = 50;
function DTe(n, t, e = {}) {
  const r = n.getShape(t);
  if (!r) return;
  const i = n.getSortedChildIdsForParent(r.id), s = xn(i.map((S) => n.getShape(S)));
  if (!s.length) return;
  const o = vt.FromPoints(
    s.flatMap((S) => {
      const w = n.getShapeGeometry(S.id);
      return n.getShapeLocalTransform(S).applyToPoints(w.vertices);
    })
  ), { padding: l = MTe } = e, u = o.w + 2 * l, d = o.h + 2 * l, f = l - o.minX, m = l - o.minY;
  if (f === 0 && m === 0 && r.props.w === u && r.props.h === d) return;
  const v = new O(f, m).rot(r.rotation);
  n.run(() => {
    const S = i.map((w) => {
      const E = n.getShape(w);
      return {
        id: E.id,
        type: E.type,
        x: E.x + f,
        y: E.y + m
      };
    });
    S.push({
      id: r.id,
      type: r.type,
      x: r.x - v.x,
      y: r.y - v.y,
      props: {
        w: u,
        h: d
      }
    }), n.updateShapes(S);
  });
}
function sV(n) {
  return bc.isValid(n) ? { isValid: !0, hasProtocol: !0 } : bc.isValid("https://" + n) ? { isValid: !0, hasProtocol: !1 } : { isValid: !1, hasProtocol: !1 };
}
const OTe = ro(function({ onClose: t }) {
  const r = we().getOnlySelectedShape();
  return r && "url" in r.props && typeof r.props.url == "string" ? /* @__PURE__ */ y.jsx(LTe, { onClose: t, selectedShape: r }) : null;
}), LTe = ro(function({
  onClose: t,
  selectedShape: e
}) {
  const r = we(), i = Dn(), s = D.useRef(null);
  D.useEffect(() => {
    r.timers.requestAnimationFrame(() => {
      var w;
      return (w = s.current) == null ? void 0 : w.focus();
    });
  }, [r]);
  const o = D.useRef(e.props.url), [l, u] = D.useState(() => {
    const w = sV(e.props.url), E = w.isValid === !0 ? w.hasProtocol ? e.props.url : "https://" + e.props.url : "https://";
    return {
      actual: E,
      safe: E,
      valid: !0
    };
  }), d = D.useCallback((w) => {
    const E = w.replace(/https?:\/\/(https?:\/\/)/, (R, M) => M), A = sV(E), P = A.isValid === !0 ? A.hasProtocol ? E : "https://" + E : "https://";
    u({
      actual: E,
      safe: P,
      valid: A.isValid
    });
  }, []), f = D.useCallback(() => {
    const w = r.getOnlySelectedShape();
    w && (r.updateShapes([
      { id: w.id, type: w.type, props: { url: "" } }
    ]), t());
  }, [r, t]), m = D.useCallback(() => {
    const w = r.getOnlySelectedShape();
    w && (w && "url" in w.props && w.props.url !== l.safe && r.updateShapes([
      {
        id: w.id,
        type: w.type,
        props: { url: l.safe }
      }
    ]), t());
  }, [r, t, l]), v = D.useCallback(() => {
    t();
  }, [t]);
  if (!e)
    return t(), null;
  const S = o.current && !l.valid;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(J2, { children: [
      /* @__PURE__ */ y.jsx(eD, { children: i("edit-link-dialog.title") }),
      /* @__PURE__ */ y.jsx(tD, {})
    ] }),
    /* @__PURE__ */ y.jsx(V1, { children: /* @__PURE__ */ y.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ y.jsx(
        nD,
        {
          ref: s,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: !0,
          value: l.actual,
          onValueChange: d,
          onComplete: m,
          onCancel: v
        }
      ),
      /* @__PURE__ */ y.jsx("div", { children: l.valid ? i("edit-link-dialog.detail") : i("edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ y.jsxs(tU, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ y.jsx(Wt, { type: "normal", onClick: v, onTouchEnd: v, children: /* @__PURE__ */ y.jsx(Zi, { children: i("edit-link-dialog.cancel") }) }),
      S ? /* @__PURE__ */ y.jsx(Wt, { type: "danger", onTouchEnd: f, onClick: f, children: /* @__PURE__ */ y.jsx(Zi, { children: i("edit-link-dialog.clear") }) }) : /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "primary",
          disabled: !l.valid,
          onTouchEnd: m,
          onClick: m,
          children: /* @__PURE__ */ y.jsx(Zi, { children: i("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
});
var nU = { exports: {} };
nU.exports;
(function(n) {
  var t = function() {
    var e = String.fromCharCode, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", s = {};
    function o(u, d) {
      if (!s[u]) {
        s[u] = {};
        for (var f = 0; f < u.length; f++)
          s[u][u.charAt(f)] = f;
      }
      return s[u][d];
    }
    var l = {
      compressToBase64: function(u) {
        if (u == null) return "";
        var d = l._compress(u, 6, function(f) {
          return r.charAt(f);
        });
        switch (d.length % 4) {
          default:
          case 0:
            return d;
          case 1:
            return d + "===";
          case 2:
            return d + "==";
          case 3:
            return d + "=";
        }
      },
      decompressFromBase64: function(u) {
        return u == null ? "" : u == "" ? null : l._decompress(u.length, 32, function(d) {
          return o(r, u.charAt(d));
        });
      },
      compressToUTF16: function(u) {
        return u == null ? "" : l._compress(u, 15, function(d) {
          return e(d + 32);
        }) + " ";
      },
      decompressFromUTF16: function(u) {
        return u == null ? "" : u == "" ? null : l._decompress(u.length, 16384, function(d) {
          return u.charCodeAt(d) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(u) {
        for (var d = l.compress(u), f = new Uint8Array(d.length * 2), m = 0, v = d.length; m < v; m++) {
          var S = d.charCodeAt(m);
          f[m * 2] = S >>> 8, f[m * 2 + 1] = S % 256;
        }
        return f;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(u) {
        if (u == null)
          return l.decompress(u);
        for (var d = new Array(u.length / 2), f = 0, m = d.length; f < m; f++)
          d[f] = u[f * 2] * 256 + u[f * 2 + 1];
        var v = [];
        return d.forEach(function(S) {
          v.push(e(S));
        }), l.decompress(v.join(""));
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(u) {
        return u == null ? "" : l._compress(u, 6, function(d) {
          return i.charAt(d);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(u) {
        return u == null ? "" : u == "" ? null : (u = u.replace(/ /g, "+"), l._decompress(u.length, 32, function(d) {
          return o(i, u.charAt(d));
        }));
      },
      compress: function(u) {
        return l._compress(u, 16, function(d) {
          return e(d);
        });
      },
      _compress: function(u, d, f) {
        if (u == null) return "";
        var m, v, S = {}, w = {}, E = "", A = "", P = "", R = 2, M = 3, j = 2, $ = [], U = 0, F = 0, B;
        for (B = 0; B < u.length; B += 1)
          if (E = u.charAt(B), Object.prototype.hasOwnProperty.call(S, E) || (S[E] = M++, w[E] = !0), A = P + E, Object.prototype.hasOwnProperty.call(S, A))
            P = A;
          else {
            if (Object.prototype.hasOwnProperty.call(w, P)) {
              if (P.charCodeAt(0) < 256) {
                for (m = 0; m < j; m++)
                  U = U << 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++;
                for (v = P.charCodeAt(0), m = 0; m < 8; m++)
                  U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
              } else {
                for (v = 1, m = 0; m < j; m++)
                  U = U << 1 | v, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = 0;
                for (v = P.charCodeAt(0), m = 0; m < 16; m++)
                  U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
              }
              R--, R == 0 && (R = Math.pow(2, j), j++), delete w[P];
            } else
              for (v = S[P], m = 0; m < j; m++)
                U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
            R--, R == 0 && (R = Math.pow(2, j), j++), S[A] = M++, P = String(E);
          }
        if (P !== "") {
          if (Object.prototype.hasOwnProperty.call(w, P)) {
            if (P.charCodeAt(0) < 256) {
              for (m = 0; m < j; m++)
                U = U << 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++;
              for (v = P.charCodeAt(0), m = 0; m < 8; m++)
                U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
            } else {
              for (v = 1, m = 0; m < j; m++)
                U = U << 1 | v, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = 0;
              for (v = P.charCodeAt(0), m = 0; m < 16; m++)
                U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
            }
            R--, R == 0 && (R = Math.pow(2, j), j++), delete w[P];
          } else
            for (v = S[P], m = 0; m < j; m++)
              U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
          R--, R == 0 && (R = Math.pow(2, j), j++);
        }
        for (v = 2, m = 0; m < j; m++)
          U = U << 1 | v & 1, F == d - 1 ? (F = 0, $.push(f(U)), U = 0) : F++, v = v >> 1;
        for (; ; )
          if (U = U << 1, F == d - 1) {
            $.push(f(U));
            break;
          } else F++;
        return $.join("");
      },
      decompress: function(u) {
        return u == null ? "" : u == "" ? null : l._decompress(u.length, 32768, function(d) {
          return u.charCodeAt(d);
        });
      },
      _decompress: function(u, d, f) {
        var m = [], v = 4, S = 4, w = 3, E = "", A = [], P, R, M, j, $, U, F, B = { val: f(0), position: d, index: 1 };
        for (P = 0; P < 3; P += 1)
          m[P] = P;
        for (M = 0, $ = Math.pow(2, 2), U = 1; U != $; )
          j = B.val & B.position, B.position >>= 1, B.position == 0 && (B.position = d, B.val = f(B.index++)), M |= (j > 0 ? 1 : 0) * U, U <<= 1;
        switch (M) {
          case 0:
            for (M = 0, $ = Math.pow(2, 8), U = 1; U != $; )
              j = B.val & B.position, B.position >>= 1, B.position == 0 && (B.position = d, B.val = f(B.index++)), M |= (j > 0 ? 1 : 0) * U, U <<= 1;
            F = e(M);
            break;
          case 1:
            for (M = 0, $ = Math.pow(2, 16), U = 1; U != $; )
              j = B.val & B.position, B.position >>= 1, B.position == 0 && (B.position = d, B.val = f(B.index++)), M |= (j > 0 ? 1 : 0) * U, U <<= 1;
            F = e(M);
            break;
          case 2:
            return "";
        }
        for (m[3] = F, R = F, A.push(F); ; ) {
          if (B.index > u)
            return "";
          for (M = 0, $ = Math.pow(2, w), U = 1; U != $; )
            j = B.val & B.position, B.position >>= 1, B.position == 0 && (B.position = d, B.val = f(B.index++)), M |= (j > 0 ? 1 : 0) * U, U <<= 1;
          switch (F = M) {
            case 0:
              for (M = 0, $ = Math.pow(2, 8), U = 1; U != $; )
                j = B.val & B.position, B.position >>= 1, B.position == 0 && (B.position = d, B.val = f(B.index++)), M |= (j > 0 ? 1 : 0) * U, U <<= 1;
              m[S++] = e(M), F = S - 1, v--;
              break;
            case 1:
              for (M = 0, $ = Math.pow(2, 16), U = 1; U != $; )
                j = B.val & B.position, B.position >>= 1, B.position == 0 && (B.position = d, B.val = f(B.index++)), M |= (j > 0 ? 1 : 0) * U, U <<= 1;
              m[S++] = e(M), F = S - 1, v--;
              break;
            case 2:
              return A.join("");
          }
          if (v == 0 && (v = Math.pow(2, w), w++), m[F])
            E = m[F];
          else if (F === S)
            E = R + R.charAt(0);
          else
            return null;
          A.push(E), m[S++] = R + E.charAt(0), v--, R = E, v == 0 && (v = Math.pow(2, w), w++);
        }
      }
    };
    return l;
  }();
  n != null ? n.exports = t : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return t;
  });
})(nU);
var jTe = nU.exports;
const Fq = /* @__PURE__ */ Ep(jTe);
async function NTe(n, t, e) {
  var P, R, M;
  const { elements: r, files: i } = t, s = {
    shapes: [],
    bindings: [],
    rootShapeIds: [],
    assets: [],
    schema: n.store.schema.serialize()
  }, o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), u = n.getCurrentPageId(), d = /* @__PURE__ */ new Map(), f = [], m = /* @__PURE__ */ new Set();
  r.forEach((j) => {
    if (d.set(j.id, Ar()), j.boundElements !== null)
      for (const $ of j.boundElements)
        $.type === "text" && m.add($.id);
  });
  let v = CG;
  for (const j of r) {
    if (m.has(j.id))
      continue;
    const $ = d.get(j.id), U = {
      id: $,
      typeName: "shape",
      parentId: u,
      index: v,
      x: j.x,
      y: j.y,
      rotation: 0,
      isLocked: j.locked,
      opacity: FTe(j.opacity),
      meta: {}
    };
    switch (j.angle !== 0 && l.set($, j.angle), j.groupIds && j.groupIds.length > 0 ? o.has(j.groupIds[0]) ? (P = o.get(j.groupIds[0])) == null || P.push($) : o.set(j.groupIds[0], [$]) : f.push($), j.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let F = "", B = "middle";
        if (j.boundElements !== null) {
          for (const X of j.boundElements)
            if (X.type === "text") {
              const te = r.find((ne) => ne.id === X.id);
              te && (F = te.text, B = VTe[te.textAlign]);
            }
        }
        const G = j.backgroundColor === "transparent" ? j.strokeColor : j.backgroundColor;
        s.shapes.push({
          ...U,
          type: "geo",
          props: {
            geo: j.type,
            url: j.link ?? "",
            w: j.width,
            h: j.height,
            size: DI[j.strokeWidth] ?? "draw",
            color: NE[G] ?? "black",
            text: F,
            align: B,
            dash: OI(j),
            fill: KTe(j)
          }
        });
        break;
      }
      case "freedraw": {
        s.shapes.push({
          ...U,
          type: "draw",
          props: {
            dash: OI(j),
            size: DI[j.strokeWidth],
            color: NE[j.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: j.points.map(([F, B, G = 0.5]) => ({
                  x: F,
                  y: B,
                  z: G
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        if (j.points.slice().length < 2)
          break;
        const B = z1(j.points.length);
        s.shapes.push({
          ...U,
          type: "line",
          props: {
            dash: OI(j),
            size: DI[j.strokeWidth],
            color: NE[j.strokeColor] ?? "black",
            spline: j.roundness ? "cubic" : "line",
            points: {
              ...Object.fromEntries(
                j.points.map(([G, X], te) => {
                  const ne = B[te];
                  return [ne, { id: ne, index: ne, x: G, y: X }];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let F = "";
        if (j.boundElements !== null) {
          for (const ne of j.boundElements)
            if (ne.type === "text") {
              const K = r.find((Z) => Z.id === ne.id);
              K && (F = K.text);
            }
        }
        const B = j.points[0], G = j.points[j.points.length - 1], X = d.get((R = j.startBinding) == null ? void 0 : R.elementId), te = d.get((M = j.endBinding) == null ? void 0 : M.elementId);
        s.shapes.push({
          ...U,
          type: "arrow",
          props: {
            text: F,
            bend: GTe(j, B, G),
            dash: OI(j),
            size: DI[j.strokeWidth] ?? "m",
            color: NE[j.strokeColor] ?? "black",
            start: { x: B[0], y: B[1] },
            end: { x: G[0], y: G[1] },
            arrowheadEnd: oV[j.endArrowhead] ?? "none",
            arrowheadStart: oV[j.startArrowhead] ?? "none"
          }
        }), X && s.bindings.push({
          id: qy(),
          typeName: "binding",
          type: "arrow",
          fromId: $,
          toId: X,
          props: {
            terminal: "start",
            normalizedAnchor: { x: 0.5, y: 0.5 },
            isPrecise: !1,
            isExact: !1
          },
          meta: {}
        }), te && s.bindings.push({
          id: qy(),
          typeName: "binding",
          type: "arrow",
          fromId: $,
          toId: te,
          props: {
            terminal: "end",
            normalizedAnchor: { x: 0.5, y: 0.5 },
            isPrecise: !1,
            isExact: !1
          },
          meta: {}
        });
        break;
      }
      case "text": {
        const { size: F, scale: B } = zTe(j.fontSize);
        s.shapes.push({
          ...U,
          type: "text",
          props: {
            size: F,
            scale: B,
            font: UTe[j.fontFamily] ?? "draw",
            color: NE[j.strokeColor] ?? "black",
            text: j.text,
            textAlign: WTe[j.textAlign]
          }
        });
        break;
      }
      case "image": {
        const F = i[j.fileId];
        if (!F) break;
        const B = Zv.createId();
        s.assets.push({
          id: B,
          typeName: "asset",
          type: "image",
          props: {
            w: j.width,
            h: j.height,
            fileSize: F.size,
            name: j.id ?? "Untitled",
            isAnimated: !1,
            mimeType: F.mimeType,
            src: F.dataURL
          },
          meta: {}
        }), s.shapes.push({
          ...U,
          type: "image",
          props: {
            w: j.width,
            h: j.height,
            assetId: B
          }
        });
      }
    }
    v = id(v);
  }
  const S = e ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : void 0);
  n.mark("paste"), n.putContentOntoCurrentPage(s, {
    point: S,
    select: !1,
    preserveIds: !0
  });
  for (const j of o.values())
    if (j.length > 1) {
      n.groupShapes(j);
      const $ = n.getShape(j[0]);
      $ != null && $.parentId && kl($.parentId) && f.push($.parentId);
    }
  for (const [j, $] of l)
    n.select(j), n.rotateShapesBy([j], $);
  const w = xn(f.map((j) => n.getShape(j))), E = vt.Common(w.map((j) => n.getShapePageBounds(j))), A = n.getViewportPageBounds().center;
  n.updateShapes(
    w.map((j) => {
      const $ = {
        x: (j.x ?? 0) - (E.x + E.w / 2),
        y: (j.y ?? 0) - (E.y + E.h / 2)
      };
      return {
        id: j.id,
        type: j.type,
        x: A.x + $.x,
        y: A.y + $.y
      };
    })
  ), n.setSelectedShapes(f);
}
const FTe = (n) => {
  const t = n / 100;
  return t < 0.2 ? 0.1 : t < 0.4 ? 0.25 : t < 0.6 ? 0.5 : t < 0.8 ? 0.75 : 1;
}, DI = {
  1: "s",
  2: "m",
  3: "l",
  4: "xl"
}, $Te = {
  16: "s",
  20: "m",
  28: "l",
  36: "xl"
};
function zTe(n) {
  const t = $Te[n];
  return t ? { size: t, scale: 1 } : n < 16 ? { size: "s", scale: n / 16 } : n > 36 ? { size: "xl", scale: n / 36 } : { size: "m", scale: 1 };
}
const UTe = {
  1: "draw",
  2: "sans",
  3: "mono"
}, NE = {
  "#ffffff": "grey",
  // Strokes
  "#000000": "black",
  "#343a40": "black",
  "#495057": "grey",
  "#c92a2a": "red",
  "#a61e4d": "light-red",
  "#862e9c": "violet",
  "#5f3dc4": "light-violet",
  "#364fc7": "blue",
  "#1864ab": "light-blue",
  "#0b7285": "light-green",
  "#087f5b": "light-green",
  "#2b8a3e": "green",
  "#5c940d": "light-green",
  "#e67700": "yellow",
  "#d9480f": "orange",
  // Backgrounds
  "#ced4da": "grey",
  "#868e96": "grey",
  "#fa5252": "light-red",
  "#e64980": "red",
  "#be4bdb": "light-violet",
  "#7950f2": "violet",
  "#4c6ef5": "blue",
  "#228be6": "light-blue",
  "#15aabf": "light-green",
  "#12b886": "green",
  "#40c057": "green",
  "#82c91e": "light-green",
  "#fab005": "yellow",
  "#fd7e14": "orange",
  "#212529": "grey"
}, BTe = {
  solid: "draw",
  dashed: "dashed",
  dotted: "dotted"
}, HTe = {
  "cross-hatch": "pattern",
  hachure: "pattern",
  solid: "solid"
}, VTe = {
  left: "start",
  center: "middle",
  right: "end"
}, WTe = {
  left: "start",
  center: "middle",
  right: "end"
}, oV = {
  arrow: "arrow",
  dot: "dot",
  triangle: "triangle",
  bar: "pipe"
};
function GTe(n, t, e) {
  let r = 0;
  if (n.points.length > 2) {
    const i = new O(t[0], t[1]), s = new O(e[0], e[1]), o = new O(n.points[1][0], n.points[1][1]), l = O.Sub(s, i), u = O.Per(l), d = O.Med(s, i), f = O.Sub(d, u), m = O.Add(d, u), v = O.NearestPointOnLineSegment(f, m, o, !1);
    r = O.Dist(v, d), O.Clockwise(v, s, d) && (r *= -1);
  }
  return r;
}
const OI = (n) => {
  let t = BTe[n.strokeStyle] ?? "draw";
  return t === "draw" && n.roughness === 0 && (t = "solid"), t;
}, KTe = (n) => n.backgroundColor === "transparent" ? "none" : HTe[n.fillStyle] ?? "solid";
async function YTe(n, t, e, r) {
  const s = (await Promise.all(t.map(async (o) => await (await Th(o)).blob()))).map((o) => new File([o], "tldrawFile", { type: o.type }));
  n.mark("paste"), await n.putExternalContent({
    type: "files",
    files: s,
    point: e,
    ignoreParent: !1,
    sources: r
  }), t.forEach((o) => URL.revokeObjectURL(o));
}
function XTe(n, t, e) {
  const r = n.getSelectionPageBounds();
  n.mark("paste"), n.putContentOntoCurrentPage(t, {
    point: e,
    select: !0
  });
  const i = n.getSelectionPageBounds();
  r && i && (r != null && r.collides(i)) && (n.updateInstanceState({ isChangingStyle: !0 }), n.timers.setTimeout(() => {
    n.updateInstanceState({ isChangingStyle: !1 });
  }, 150));
}
async function V3(n, t, e, r) {
  return n.mark("paste"), await n.putExternalContent({
    type: "url",
    point: e,
    url: t,
    sources: r
  });
}
function qTe(n) {
  const t = document.implementation.createHTMLDocument("");
  return t.documentElement.innerHTML = n.trim(), t.body.textContent || t.body.innerText || "";
}
const ZTe = (n) => {
  try {
    const t = new URL(n);
    return t.protocol === "http:" || t.protocol === "https:";
  } catch {
    return !1;
  }
}, QTe = (n) => {
  const t = n.split(/[\n\s]/);
  for (const e of t)
    try {
      const r = new URL(e);
      if (!(r.protocol === "http:" || r.protocol === "https:"))
        return;
    } catch {
      return;
    }
  return zK(t);
}, JTe = (n) => /^<svg/.test(n), ePe = ["input", "select", "textarea"];
function aF(n) {
  const { activeElement: t } = document;
  return n.getIsMenuOpen() || t && (t.getAttribute("contenteditable") || ePe.indexOf(t.tagName.toLowerCase()) > -1);
}
const tPe = (n) => n.types.find((t) => t.match(/^image\//)), lF = (n, t, e, r) => {
  const i = QTe(t);
  if (i)
    for (const s of i)
      V3(n, s, e);
  else ZTe(t) ? V3(n, t, e) : JTe(t) ? (n.mark("paste"), n.putExternalContent({
    type: "svg-text",
    text: t,
    point: e,
    sources: r
  })) : (n.mark("paste"), n.putExternalContent({
    type: "text",
    text: t,
    point: e,
    sources: r
  }));
}, nPe = async (n, t, e) => {
  if (n.getEditingShapeId() !== null) return;
  if (!t)
    throw Error("No clipboard data");
  const r = [];
  for (const i of Object.values(t.items))
    switch (i.kind) {
      case "file": {
        r.push({
          type: "file",
          source: new Promise((s) => s(i.getAsFile()))
        });
        break;
      }
      case "string": {
        i.type === "text/html" ? r.push({
          type: "html",
          source: new Promise((s) => i.getAsString(s))
        }) : i.type === "text/plain" ? r.push({
          type: "text",
          source: new Promise((s) => i.getAsString(s))
        }) : r.push({ type: i.type, source: new Promise((s) => i.getAsString(s)) });
        break;
      }
    }
  zq(n, r, e);
}, $q = async (n, t, e) => {
  const r = [];
  for (const i of t) {
    if (tPe(i))
      for (const s of i.types)
        s.match(/^image\//) && r.push({ type: "blob", source: i.getType(s) });
    i.types.includes("text/html") && r.push({
      type: "html",
      source: (async () => {
        const s = await i.getType("text/html");
        return await Xy.blobToText(s);
      })()
    }), i.types.includes("text/uri-list") && r.push({
      type: "url",
      source: (async () => {
        const s = await i.getType("text/uri-list");
        return await Xy.blobToText(s);
      })()
    }), i.types.includes("text/plain") && r.push({
      type: "text",
      source: (async () => {
        const s = await i.getType("text/plain");
        return await Xy.blobToText(s);
      })()
    });
  }
  return await zq(n, r, e);
};
async function zq(n, t, e) {
  const r = t.filter(
    (s) => (s.type === "file" || s.type === "blob") && s.source !== null
  );
  if (r.length) {
    const o = (await Promise.all(r.map((l) => l.source))).filter(Boolean).map(
      (l) => URL.createObjectURL(l)
    );
    return await YTe(n, o, e);
  }
  const i = await Promise.all(
    t.filter((s) => s.type !== "file").map(
      (s) => new Promise((o) => {
        const l = s;
        if (l.type === "file") {
          o({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        l.source.then((u) => {
          var f;
          const d = (f = u.match(/<div data-tldraw[^>]*>(.*)<\/div>/)) == null ? void 0 : f[1];
          if (d)
            try {
              const m = Fq.decompressFromBase64(d);
              if (m === null) {
                o({
                  type: "error",
                  data: m,
                  reason: "found tldraw data comment but could not parse base64"
                });
                return;
              } else {
                const v = JSON.parse(m);
                if (v.type !== "application/tldraw" && o({
                  type: "error",
                  data: v,
                  reason: `found tldraw data comment but JSON was of a different type: ${v.type}`
                }), typeof v.data == "string") {
                  o({
                    type: "error",
                    data: v,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                o({ type: "tldraw", data: v.data });
                return;
              }
            } catch {
              o({
                type: "error",
                data: d,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          else {
            if (l.type === "html") {
              o({ type: "text", data: u, subtype: "html" });
              return;
            }
            if (l.type === "url") {
              o({ type: "text", data: u, subtype: "url" });
              return;
            }
            try {
              const m = JSON.parse(u);
              if (m.type === "excalidraw/clipboard") {
                o({ type: "excalidraw", data: m });
                return;
              } else {
                o({ type: "text", data: u, subtype: "json" });
                return;
              }
            } catch {
              o({ type: "text", data: u, subtype: "text" });
              return;
            }
          }
          o({ type: "error", data: u, reason: "unhandled case" });
        });
      })
    )
  );
  for (const s of i)
    if (s.type === "tldraw") {
      XTe(n, s.data, e);
      return;
    }
  for (const s of i)
    if (s.type === "excalidraw") {
      NTe(n, s.data, e);
      return;
    }
  for (const s of i)
    if (s.type === "text" && s.subtype === "html") {
      const l = new DOMParser().parseFromString(s.data, "text/html").querySelector("body");
      if (l && Array.from(l.children).filter((d) => d.nodeType === 1).length === 1 && l.firstElementChild && l.firstElementChild.tagName === "A" && l.firstElementChild.hasAttribute("href") && l.firstElementChild.getAttribute("href") !== "") {
        const d = l.firstElementChild.getAttribute("href");
        lF(n, d, e, i);
        return;
      }
      if (!i.some((d) => d.type === "text" && d.subtype !== "html") && s.data.trim()) {
        lF(n, qTe(s.data), e, i);
        return;
      }
    }
  for (const s of i)
    if (s.type === "text" && s.subtype === "url") {
      V3(n, s.data, e, i);
      return;
    }
  for (const s of i)
    if (s.type === "text" && s.subtype === "text" && s.data.trim()) {
      lF(n, s.data, e, i);
      return;
    }
}
const FM = async (n) => {
  var r;
  const t = await n.resolveAssetsInContent(
    n.getContentFromCurrentPage(n.getSelectedShapeIds())
  );
  if (!t) {
    navigator && navigator.clipboard && navigator.clipboard.writeText("");
    return;
  }
  const e = Fq.compressToBase64(
    JSON.stringify({
      type: "application/tldraw",
      kind: "content",
      data: t
    })
  );
  if (!(typeof navigator > "u")) {
    const i = t.shapes.map((s) => n.isShapeOfType(s, "text") || n.isShapeOfType(s, "geo") || n.isShapeOfType(s, "arrow") ? s.props.text : n.isShapeOfType(s, "bookmark") || n.isShapeOfType(s, "embed") ? s.props.url : null).filter(Ume);
    if ((r = navigator.clipboard) != null && r.write) {
      const s = new Blob([`<div data-tldraw>${e}</div>`], {
        type: "text/html"
      });
      let o = i.join(" ");
      o === "" && (o = " "), navigator.clipboard.write([
        new ClipboardItem({
          "text/html": s,
          // What is this second blob used for?
          "text/plain": new Blob([o], { type: "text/plain" })
        })
      ]);
    } else navigator.clipboard.writeText && navigator.clipboard.writeText(`<div data-tldraw>${e}</div>`);
  }
};
function rPe() {
  const n = we(), t = Fo(), e = D.useCallback(
    async function(o) {
      n.getSelectedShapeIds().length !== 0 && (await FM(n), t("copy", { source: o }));
    },
    [n, t]
  ), r = D.useCallback(
    async function(o) {
      n.getSelectedShapeIds().length !== 0 && (await FM(n), n.deleteShapes(n.getSelectedShapeIds()), t("cut", { source: o }));
    },
    [n, t]
  ), i = D.useCallback(
    async function(o, l, u) {
      n.getEditingShapeId() === null && (Array.isArray(o) && o[0] instanceof ClipboardItem ? ($q(n, o, u), t("paste", { source: "menu" })) : navigator.clipboard.read().then((d) => {
        i(d, l, u);
      }));
    },
    [n, t]
  );
  return {
    copy: e,
    cut: r,
    paste: i
  };
}
function iPe() {
  const n = we(), t = Fo(), e = De("editor.isFocused", () => n.getInstanceState().isFocused, [
    n
  ]);
  D.useEffect(() => {
    if (!e) return;
    const r = async (u) => {
      n.getSelectedShapeIds().length === 0 || n.getEditingShapeId() !== null || aF(n) || (qn(u), await FM(n), t("copy", { source: "kbd" }));
    };
    async function i(u) {
      n.getSelectedShapeIds().length === 0 || n.getEditingShapeId() !== null || aF(n) || (qn(u), await FM(n), n.deleteShapes(n.getSelectedShapeIds()), t("cut", { source: "kbd" }));
    }
    let s = !1;
    const o = (u) => {
      u.button === 1 && (s = !0, n.timers.requestAnimationFrame(() => {
        s = !1;
      }));
    }, l = (u) => {
      if (s) {
        to(u);
        return;
      }
      if (n.getEditingShapeId() !== null || aF(n)) return;
      let d, f = !1;
      n.inputs.shiftKey && (f = !0), n.user.getIsPasteAtCursorMode() && (f = !f), f && (d = n.inputs.currentPagePoint), u.clipboardData && !n.inputs.shiftKey ? nPe(n, u.clipboardData, d) : navigator.clipboard.read().then((m) => {
        Array.isArray(m) && m[0] instanceof ClipboardItem && $q(n, m, d);
      }), qn(u), t("paste", { source: "kbd" });
    };
    return document.addEventListener("copy", r), document.addEventListener("cut", i), document.addEventListener("paste", l), document.addEventListener("pointerup", o), () => {
      document.removeEventListener("copy", r), document.removeEventListener("cut", i), document.removeEventListener("paste", l), document.removeEventListener("pointerup", o);
    };
  }, [n, t, e]);
}
async function Uq(n, t, e) {
  const { type: r, quality: i, scale: s, width: o, height: l } = e;
  let [u, d] = await Vwe(
    o * s,
    l * s
  );
  u = Math.floor(u), d = Math.floor(d);
  const f = u / o, m = URL.createObjectURL(new Blob([t], { type: "image/svg+xml" })), v = await new Promise((w) => {
    const E = Xx();
    E.crossOrigin = "anonymous", E.onload = async () => {
      n.environment.isSafari && await new Promise((R) => n.timers.setTimeout(R, 250));
      const A = document.createElement("canvas"), P = A.getContext("2d");
      A.width = u, A.height = d, P.imageSmoothingEnabled = !0, P.imageSmoothingQuality = "high", P.drawImage(E, 0, 0, u, d), URL.revokeObjectURL(m), w(A);
    }, E.onerror = () => {
      w(null);
    }, E.src = m;
  });
  if (!v) return null;
  const S = await new Promise(
    (w) => v.toBlob(
      (E) => {
        (!E || qi.throwToBlob.get()) && w(null), w(E);
      },
      "image/" + r,
      i
    )
  );
  if (!S) return null;
  if (r === "png") {
    const w = new DataView(await S.arrayBuffer());
    return ph.setPhysChunk(w, f, {
      type: "image/" + r
    });
  } else
    return S;
}
async function Bq(n, t, e) {
  const r = await n.getSvgString(t != null && t.length ? t : [...n.getCurrentPageShapeIds()], {
    scale: 1,
    background: n.getInstanceState().exportBackground,
    ...e
  });
  if (!r)
    throw new Error("Could not construct SVG.");
  return r;
}
async function W3(n, t, e, r = {}) {
  var i;
  switch (e) {
    case "svg":
      return (i = await Bq(n, t, r)) == null ? void 0 : i.svg;
    case "json": {
      const s = await n.resolveAssetsInContent(n.getContentFromCurrentPage(t));
      return JSON.stringify(s);
    }
    default:
      ma(e);
  }
}
async function Hq({
  editor: n,
  ids: t,
  format: e,
  opts: r = {}
}) {
  switch (e) {
    case "svg":
      return new Blob([await W3(n, t, "svg", r)], { type: "text/plain" });
    case "json":
      return new Blob([await W3(n, t, "json", r)], { type: "text/plain" });
    case "jpeg":
    case "png":
    case "webp": {
      const i = await Bq(n, t, r);
      if (!i) throw new Error("Could not construct image.");
      const s = await Uq(n, i.svg, {
        type: e,
        quality: 1,
        scale: 2,
        width: i.width,
        height: i.height
      });
      if (!s)
        throw new Error("Could not construct image.");
      return s;
    }
    default:
      ma(e);
  }
}
const sPe = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  json: "text/plain",
  svg: "text/plain"
};
function oPe(n, t, e, r = {}) {
  return {
    blobPromise: Hq({ editor: n, ids: t, format: e, opts: r }),
    mimeType: sPe[e]
  };
}
function aPe(n, t, e = "svg", r = {}) {
  if (!window.navigator.clipboard) return Promise.reject(new Error("Copy not supported"));
  if (window.navigator.clipboard.write) {
    const { blobPromise: i, mimeType: s } = oPe(n, t, e, r);
    return window.navigator.clipboard.write([new ClipboardItem({ [s]: i })]).catch((o) => (console.error(o), i.then((l) => window.navigator.clipboard.write([new ClipboardItem({ [s]: l })]))));
  }
  switch (e) {
    case "json":
    case "svg":
      return lPe(async () => W3(n, t, e, r));
    case "jpeg":
    case "png":
      throw new Error("Copy not supported");
    default:
      ma(e);
  }
}
async function lPe(n) {
  var t, e;
  await ((e = (t = navigator.clipboard) == null ? void 0 : t.writeText) == null ? void 0 : e.call(t, await n()));
}
function cPe() {
  const n = we(), { addToast: t } = gd(), e = Dn();
  return D.useCallback(
    (r, i = "svg") => {
      aPe(n, r, i).catch(() => {
        t({
          id: "copy-fail",
          severity: "warning",
          title: e("toast.error.copy-fail.title"),
          description: e("toast.error.copy-fail.desc")
        });
      });
    },
    [n, t, e]
  );
}
async function uPe(n, t, e = "png", r, i = {}) {
  if (!r && (r = `shapes at ${aV()}`, t.length === 1)) {
    const l = n.getShape(t[0]);
    n.isShapeOfType(l, "frame") ? r = l.props.name ?? "frame" : r = `${l.id.replace(/:/, "_")} at ${aV()}`;
  }
  r += `.${e}`;
  const s = await Hq({ editor: n, ids: t, format: e, opts: i }), o = new File([s], r, { type: s.type });
  dPe(o);
}
function aV() {
  const n = /* @__PURE__ */ new Date(), t = String(n.getFullYear()).slice(2), e = String(n.getMonth() + 1).padStart(2, "0"), r = String(n.getDate()).padStart(2, "0"), i = String(n.getHours()).padStart(2, "0"), s = String(n.getMinutes()).padStart(2, "0"), o = String(n.getSeconds()).padStart(2, "0");
  return `${t}-${e}-${r} ${i}.${s}.${o}`;
}
function dPe(n) {
  const t = document.createElement("a"), e = URL.createObjectURL(n);
  t.href = e, t.download = n.name, t.click(), URL.revokeObjectURL(e);
}
function hPe() {
  const n = we(), { addToast: t } = gd(), e = Dn();
  return D.useCallback(
    (r, i = "png", s) => {
      uPe(n, r, i, s, {
        scale: 1,
        background: n.getInstanceState().exportBackground
      }).catch((o) => {
        console.error(o.message), t({
          id: "export-fail",
          title: e("toast.error.export-fail.title"),
          description: e("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [n, t, e]
  );
}
async function fPe(n, t, e) {
  const r = xn(
    t.map((l) => {
      const u = n.getShape(l);
      if (!(!u || n.getShapeUtil(u.type).toSvg === void 0))
        return u;
    })
  );
  if (r.length === 0) return;
  if (r.length === 1) {
    const l = r[0];
    if (!l || n.isShapeOfType(l, "image")) return;
  }
  const i = [];
  if (e !== void 0) {
    const l = r.map((u) => ({
      shape: u,
      bounds: n.getShapeMaskedPageBounds(u).clone().expandBy(e)
    }));
    for (let u = 0; u < l.length; u++) {
      const d = l[u];
      if (u === 0) {
        i[0] = {
          shapes: [d.shape],
          bounds: d.bounds
        };
        continue;
      }
      let f = !1;
      for (const m of i)
        if (m.bounds.includes(d.bounds)) {
          m.shapes.push(d.shape), m.bounds.expand(d.bounds), f = !0;
          break;
        }
      f || i.push({
        shapes: [d.shape],
        bounds: d.bounds
      });
    }
  } else {
    const l = vt.Common(r.map((u) => n.getShapeMaskedPageBounds(u)));
    i.push({
      shapes: r,
      bounds: l
    });
  }
  const s = n.options.flattenImageBoundsPadding;
  for (const l of i) {
    e !== void 0 && l.bounds.expandBy(-e);
    const u = await n.getSvgString(l.shapes, {
      padding: s
    });
    if (!(u != null && u.svg)) continue;
    const d = new Blob([u.svg], { type: "image/svg+xml" }), f = await n.getAssetForExternalContent({
      type: "file",
      file: new File([d], "asset.svg", { type: "image/svg+xml" })
    });
    f && (l.asset = f);
  }
  const o = [];
  return bh(() => {
    for (const l of i) {
      const { asset: u, bounds: d, shapes: f } = l;
      if (!u) continue;
      const m = n.findCommonAncestor(f) ?? n.getCurrentPageId();
      if (!m) continue;
      let v = "a1";
      for (const P of f)
        if (P.parentId === m) {
          P.index > v && (v = P.index);
          break;
        }
      let S, w, E;
      if (kl(m)) {
        const P = n.getShape(m);
        if (!P) continue;
        const R = n.getPointInShapeSpace(P, {
          x: d.x,
          y: d.y
        });
        E = n.getShapePageTransform(m).rotation(), R.sub(new O(s, s).rot(-E)), S = R.x, w = R.y;
      } else
        S = d.x - s, w = d.y - s, E = 0;
      n.deleteShapes(f), n.createAssets([{ ...u, id: u.id }]);
      const A = Ar();
      n.createShape({
        id: A,
        type: "image",
        index: v,
        parentId: m,
        x: S,
        y: w,
        rotation: -E,
        props: {
          assetId: u.id,
          w: d.w + s * 2,
          h: d.h + s * 2
        }
      }), o.push(A);
    }
  }), o;
}
function iD() {
  return we().store.props.collaboration !== void 0;
}
function pPe() {
  const n = we();
  return De(
    "sync status",
    () => {
      var t;
      return (t = n.store.props.collaboration) != null && t.status ? n.store.props.collaboration.status.get() : null;
    },
    [n]
  );
}
function gPe() {
  const n = we(), t = D.useRef(null), e = D.useRef(null);
  return D.useCallback(
    async function() {
      const i = document.createElement("div"), s = document.createElement("style"), o = (P, R) => {
        P && (P.innerHTML = ""), R && document.head.contains(R) && document.head.removeChild(R), P && document.body.contains(P) && document.body.removeChild(P);
      };
      o(t.current, e.current), t.current = i, e.current = s;
      const l = `tl-print-surface-${Ii()}`;
      i.className = l, s.innerHTML = `
			.${l} {
				display: none;
			}

			.${l} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${l} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${l}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${l}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${l}__item__header {
					display: none;
				}

				.${l}__item__footer {
					display: none;
					text-align: right;
				}

				.${l}__item__footer__hide {
					display: none;
				}

				
			}

		`;
      const u = () => {
        document.head.appendChild(s), document.body.appendChild(i);
      }, d = () => {
        n.once("tick", () => {
          o(i, s);
        });
      };
      window.addEventListener("beforeprint", u), window.addEventListener("afterprint", d);
      function f(P, R, M) {
        try {
          i.innerHTML += `<div class="${l}__item">
        <div class="${l}__item__header">
          ${P.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${l}__item__main">
          ${M}
        </div>
        <div class="${l}__item__footer ${l}__item__footer__${R ? "" : "hide"}">
          ${R ?? ""}
        </div>
      </div>`;
        } catch (j) {
          console.error(j);
        }
      }
      function m() {
        n.environment.isChromeForIos ? (u(), window.print()) : n.environment.isSafari ? (u(), document.execCommand("print", !1)) : window.print();
      }
      const v = n.getSelectedShapeIds(), S = n.getCurrentPageId(), w = n.getPages(), A = {
        scale: 1,
        background: !1,
        darkMode: !1,
        preserveAspectRatio: "xMidYMid meet"
      };
      if (n.getSelectedShapeIds().length > 0) {
        const P = await n.getSvgString(v, A);
        if (P) {
          const R = w.find((M) => M.id === S);
          f(`tldraw — ${R == null ? void 0 : R.name}`, null, P.svg), m();
        }
      } else {
        const P = n.getCurrentPage(), R = await n.getSvgString(
          n.getSortedChildIdsForParent(P.id),
          A
        );
        R && (f(`tldraw — ${P.name}`, null, R.svg), m());
      }
      window.removeEventListener("beforeprint", u), window.removeEventListener("afterprint", d);
    },
    [n]
  );
}
const Vq = D.createContext(null);
function mPe(n) {
  return Object.fromEntries(n.map((t) => [t.id, t]));
}
function C0(n, t) {
  if (n.getSelectedShapes().length === 0)
    return n.getDocumentSettings().name || t;
}
function vPe({ overrides: n, children: t }) {
  const e = we(), r = iD(), { addDialog: i, clearDialogs: s } = wS(), { clearToasts: o, addToast: l } = gd(), u = Dn(), d = Oq(), f = gPe(), { cut: m, copy: v, paste: S } = rPe(), w = cPe(), E = hPe(), A = u("document.default-name"), P = Fo(), R = D.useMemo(() => {
    function M() {
      return e.isIn("select") || (e.complete(), e.setCurrentTool("select")), !1;
    }
    function j() {
      return e.isIn("select") && e.getSelectedShapeIds().length > 0;
    }
    const $ = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(F) {
          j() && (M() || (P("edit-link", { source: F }), e.mark("edit-link"), i({ component: OTe })));
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "$i",
        onSelect(F) {
          P("insert-embed", { source: F }), i({ component: Dq });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "$u",
        onSelect(F) {
          P("insert-media", { source: F }), d();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "$z",
        onSelect(F) {
          P("undo", { source: F }), e.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "$!z",
        onSelect(F) {
          P("redo", { source: F }), e.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          "context-menu": "action.export-as-svg.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("export-as", { format: "svg", source: F }), E(B, "svg", C0(e, A)));
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          "context-menu": "action.export-as-png.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("export-as", { format: "png", source: F }), E(B, "png", C0(e, A)));
        }
      },
      {
        id: "export-as-json",
        label: {
          default: "action.export-as-json",
          menu: "action.export-as-json.short",
          "context-menu": "action.export-as-json.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("export-as", { format: "json", source: F }), E(B, "json", C0(e, A)));
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          "context-menu": "action.export-all-as-svg.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("export-all-as", { format: "svg", source: F }), E(
            Array.from(e.getCurrentPageShapeIds()),
            "svg",
            C0(e, A)
          ));
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          "context-menu": "action.export-all-as-png.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          const B = Array.from(e.getCurrentPageShapeIds().values());
          B.length !== 0 && (P("export-all-as", { format: "png", source: F }), E(B, "png", C0(e, A)));
        }
      },
      {
        id: "export-all-as-json",
        label: {
          default: "action.export-all-as-json",
          menu: "action.export-all-as-json.short",
          "context-menu": "action.export-all-as-json.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          const B = Array.from(e.getCurrentPageShapeIds().values());
          B.length !== 0 && (P("export-all-as", { format: "json", source: F }), E(B, "json", C0(e, A)));
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          "context-menu": "action.copy-as-svg.short"
        },
        kbd: "$!c",
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("copy-as", { format: "svg", source: F }), w(B, "svg"));
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          "context-menu": "action.copy-as-png.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("copy-as", { format: "png", source: F }), w(B, "png"));
        }
      },
      {
        id: "copy-as-json",
        label: {
          default: "action.copy-as-json",
          menu: "action.copy-as-json.short",
          "context-menu": "action.copy-as-json.short"
        },
        readonlyOk: !0,
        onSelect(F) {
          let B = e.getSelectedShapeIds();
          B.length === 0 && (B = Array.from(e.getCurrentPageShapeIds().values())), B.length !== 0 && (P("copy-as", { format: "json", source: F }), w(B, "json"));
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(F) {
          if (!j() || M()) return;
          P("toggle-auto-size", { source: F }), e.mark("toggling auto size");
          const B = e.getSelectedShapes().filter(
            (G) => e.isShapeOfType(G, "text") && G.props.autoSize === !1
          );
          e.updateShapes(
            B.map((G) => ({
              id: G.id,
              type: G.type,
              props: {
                ...G.props,
                w: 8,
                autoSize: !0
              }
            }))
          ), ei(
            e,
            B.map((G) => G.id)
          );
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: !0,
        onSelect(F) {
          P("open-embed-link", { source: F });
          const B = e.getSelectedShapeIds(), G = "No embed shapes selected";
          if (B.length !== 1) {
            console.error(G);
            return;
          }
          const X = e.getShape(B[0]);
          if (!X || !e.isShapeOfType(X, "embed")) {
            console.error(G);
            return;
          }
          lwe(X.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: !0,
        kbd: "z",
        onSelect(F) {
          var B, G;
          if (((B = e.root.getCurrent()) == null ? void 0 : B.id) !== "zoom" && (P("zoom-tool", { source: F }), !(e.inputs.shiftKey || e.inputs.ctrlKey))) {
            const X = e.root.getCurrent();
            X && ((G = X.getCurrent()) == null ? void 0 : G.id) === "idle" && e.setCurrentTool("zoom", { onInteractionEnd: X.id, maskAs: "zoom" });
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        onSelect(F) {
          j() && (M() || e.run(() => {
            P("convert-to-bookmark", { source: F });
            const B = e.getSelectedShapes(), G = [], X = [];
            for (const te of B) {
              if (!te || !e.isShapeOfType(te, "embed") || !te.props.url)
                continue;
              const ne = new O(te.x, te.y);
              ne.rot(-te.rotation), ne.add(new O(te.props.w / 2 - 300 / 2, te.props.h / 2 - 320 / 2)), ne.rot(te.rotation);
              const K = {
                id: Ar(),
                type: "bookmark",
                rotation: te.rotation,
                x: ne.x,
                y: ne.y,
                opacity: 1,
                props: {
                  url: te.props.url
                }
              };
              G.push(K), X.push(te.id);
            }
            e.mark("convert shapes to bookmark"), e.deleteShapes(X), e.createShapes(G);
          }));
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(F) {
          j() && (M() || (P("convert-to-embed", { source: F }), e.run(() => {
            const B = e.getSelectedShapeIds(), G = xn(B.map((ne) => e.getShape(ne))), X = [], te = [];
            for (const ne of G) {
              if (!e.isShapeOfType(ne, "bookmark")) continue;
              const { url: K } = ne.props, Z = pm(ne.props.url);
              if (!Z || !Z.definition) continue;
              const { width: oe, height: fe } = Z.definition, ie = new O(ne.x, ne.y);
              ie.rot(-ne.rotation), ie.add(new O(ne.props.w / 2 - oe / 2, ne.props.h / 2 - fe / 2)), ie.rot(ne.rotation);
              const ue = {
                id: Ar(),
                type: "embed",
                x: ie.x,
                y: ie.y,
                rotation: ne.rotation,
                props: {
                  url: K,
                  w: oe,
                  h: fe
                }
              };
              X.push(ue), te.push(ne.id);
            }
            e.mark("convert shapes to embed"), e.deleteShapes(te), e.createShapes(X);
          })));
        }
      },
      {
        id: "duplicate",
        kbd: "$d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(F) {
          if (!j() || M()) return;
          P("duplicate-shapes", { source: F });
          const B = e.getInstanceState();
          let G, X;
          if (B.duplicateProps)
            G = B.duplicateProps.shapeIds, X = B.duplicateProps.offset;
          else {
            G = e.getSelectedShapeIds();
            const te = vt.Common(xn(G.map((ne) => e.getShapePageBounds(ne))));
            X = e.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: e.options.adjacentShapeMargin,
              y: e.options.adjacentShapeMargin
            } : {
              x: te.width + e.options.adjacentShapeMargin,
              y: 0
            };
          }
          e.mark("duplicate shapes"), e.duplicateShapes(G, X), B.duplicateProps && e.updateInstanceState({
            duplicateProps: {
              ...B.duplicateProps,
              shapeIds: e.getSelectedShapeIds()
            }
          });
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "$!g",
        icon: "ungroup",
        onSelect(F) {
          j() && (M() || (P("ungroup-shapes", { source: F }), e.mark("ungroup"), e.ungroupShapes(e.getSelectedShapeIds())));
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "$g",
        icon: "group",
        onSelect(F) {
          if (!j() || M()) return;
          P("group-shapes", { source: F });
          const B = e.getOnlySelectedShape();
          B && e.isShapeOfType(B, "group") ? (e.mark("ungroup"), e.ungroupShapes(e.getSelectedShapeIds())) : (e.mark("group"), e.groupShapes(e.getSelectedShapeIds()));
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "$!f",
        onSelect(F) {
          if (!j()) return;
          P("remove-frame", { source: F });
          const B = e.getSelectedShapes();
          B.length > 0 && B.every((G) => e.isShapeOfType(G, "frame")) && (e.mark("remove-frame"), RTe(
            e,
            B.map((G) => G.id)
          ));
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(F) {
          if (!j()) return;
          P("fit-frame-to-content", { source: F });
          const B = e.getOnlySelectedShape();
          B && e.isShapeOfType(B, "frame") && (e.mark("fit-frame-to-content"), DTe(e, B.id));
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "?A",
        icon: "align-left",
        onSelect(F) {
          if (!j() || M()) return;
          P("align-shapes", { operation: "left", source: F }), e.mark("align left");
          const B = e.getSelectedShapeIds();
          e.alignShapes(B, "left"), ei(e, B);
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          "context-menu": "action.align-center-horizontal.short"
        },
        kbd: "?H",
        icon: "align-center-horizontal",
        onSelect(F) {
          if (!j() || M()) return;
          P("align-shapes", { operation: "center-horizontal", source: F }), e.mark("align center horizontal");
          const B = e.getSelectedShapeIds();
          e.alignShapes(B, "center-horizontal"), ei(e, B);
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "?D",
        icon: "align-right",
        onSelect(F) {
          if (!j() || M()) return;
          P("align-shapes", { operation: "right", source: F }), e.mark("align right");
          const B = e.getSelectedShapeIds();
          e.alignShapes(B, "right"), ei(e, B);
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          "context-menu": "action.align-center-vertical.short"
        },
        kbd: "?V",
        icon: "align-center-vertical",
        onSelect(F) {
          if (!j() || M()) return;
          P("align-shapes", { operation: "center-vertical", source: F }), e.mark("align center vertical");
          const B = e.getSelectedShapeIds();
          e.alignShapes(B, "center-vertical"), ei(e, B);
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "?W",
        onSelect(F) {
          if (!j() || M()) return;
          P("align-shapes", { operation: "top", source: F }), e.mark("align top");
          const B = e.getSelectedShapeIds();
          e.alignShapes(B, "top"), ei(e, B);
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "?S",
        onSelect(F) {
          if (!j() || M()) return;
          P("align-shapes", { operation: "bottom", source: F }), e.mark("align bottom");
          const B = e.getSelectedShapeIds();
          e.alignShapes(B, "bottom"), ei(e, B);
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          "context-menu": "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "?!h",
        onSelect(F) {
          if (!j() || M()) return;
          P("distribute-shapes", { operation: "horizontal", source: F }), e.mark("distribute horizontal");
          const B = e.getSelectedShapeIds();
          e.distributeShapes(B, "horizontal"), ei(e, B);
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          "context-menu": "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "?!V",
        onSelect(F) {
          if (!j() || M()) return;
          P("distribute-shapes", { operation: "vertical", source: F }), e.mark("distribute vertical");
          const B = e.getSelectedShapeIds();
          e.distributeShapes(B, "vertical"), ei(e, B);
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          "context-menu": "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(F) {
          if (!j() || M()) return;
          P("stretch-shapes", { operation: "horizontal", source: F }), e.mark("stretch horizontal");
          const B = e.getSelectedShapeIds();
          e.stretchShapes(B, "horizontal"), ei(e, B);
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          "context-menu": "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(F) {
          if (!j() || M()) return;
          P("stretch-shapes", { operation: "vertical", source: F }), e.mark("stretch vertical");
          const B = e.getSelectedShapeIds();
          e.stretchShapes(B, "vertical"), ei(e, B);
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          "context-menu": "action.flip-horizontal.short"
        },
        kbd: "!h",
        onSelect(F) {
          if (!j() || M()) return;
          P("flip-shapes", { operation: "horizontal", source: F }), e.mark("flip horizontal");
          const B = e.getSelectedShapeIds();
          e.flipShapes(B, "horizontal"), ei(e, B);
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", "context-menu": "action.flip-vertical.short" },
        kbd: "!v",
        onSelect(F) {
          if (!j() || M()) return;
          P("flip-shapes", { operation: "vertical", source: F }), e.mark("flip vertical");
          const B = e.getSelectedShapeIds();
          e.flipShapes(B, "vertical"), ei(e, B);
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(F) {
          if (!j() || M()) return;
          P("pack-shapes", { source: F }), e.mark("pack");
          const B = e.getSelectedShapeIds();
          e.packShapes(B, e.options.adjacentShapeMargin), ei(e, B);
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          "context-menu": "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(F) {
          if (!j() || M()) return;
          P("stack-shapes", { operation: "vertical", source: F }), e.mark("stack-vertical");
          const B = e.getSelectedShapeIds();
          e.stackShapes(B, "vertical", 16), ei(e, B);
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          "context-menu": "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(F) {
          if (!j() || M()) return;
          P("stack-shapes", { operation: "horizontal", source: F }), e.mark("stack-horizontal");
          const B = e.getSelectedShapeIds();
          e.stackShapes(B, "horizontal", 16), ei(e, B);
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(F) {
          j() && (M() || (P("reorder-shapes", { operation: "toFront", source: F }), e.mark("bring to front"), e.bringToFront(e.getSelectedShapeIds())));
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "?]",
        onSelect(F) {
          j() && (M() || (P("reorder-shapes", { operation: "forward", source: F }), e.mark("bring forward"), e.bringForward(e.getSelectedShapeIds())));
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "?[",
        onSelect(F) {
          j() && (M() || (P("reorder-shapes", { operation: "backward", source: F }), e.mark("send backward"), e.sendBackward(e.getSelectedShapeIds())));
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(F) {
          j() && (M() || (P("reorder-shapes", { operation: "toBack", source: F }), e.mark("send to back"), e.sendToBack(e.getSelectedShapeIds())));
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "$x",
        onSelect(F) {
          j() && (M() || (e.mark("cut"), m(F)));
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "$c",
        readonlyOk: !0,
        onSelect(F) {
          j() && (M() || v(F));
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "$v",
        onSelect(F) {
          var B;
          (B = navigator.clipboard) == null || B.read().then((G) => {
            S(
              G,
              F,
              F === "context-menu" ? e.inputs.currentPagePoint : void 0
            );
          }).catch(() => {
            l({
              title: u("action.paste-error-title"),
              description: u("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "$a",
        readonlyOk: !0,
        onSelect(F) {
          e.run(() => {
            M() || (P("select-all-shapes", { source: F }), e.mark("select all kbd"), e.selectAll());
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: !0,
        onSelect(F) {
          j() && (M() || (P("select-none-shapes", { source: F }), e.mark("select none"), e.selectNone()));
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫,del,backspace",
        icon: "trash",
        onSelect(F) {
          j() && (M() || (P("delete-shapes", { source: F }), e.mark("delete"), e.deleteShapes(e.getSelectedShapeIds())));
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        onSelect(F) {
          if (!j() || M()) return;
          P("rotate-cw", { source: F }), e.mark("rotate-cw");
          const B = e.getSelectionRotation() % (ri / 2), G = vm(B, 0) || vm(B, ri / 2), X = e.getSelectedShapeIds();
          e.rotateShapesBy(X, ri / 2 - (G ? 0 : B)), ei(e, X);
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        onSelect(F) {
          if (!j() || M()) return;
          P("rotate-ccw", { source: F }), e.mark("rotate-ccw");
          const B = e.getSelectionRotation() % (ri / 2), G = vm(B, 0), X = e.getSelectedShapeIds();
          e.rotateShapesBy(X, G ? -(ri / 2) : -B), ei(e, X);
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "$=,=",
        readonlyOk: !0,
        onSelect(F) {
          P("zoom-in", { source: F }), e.zoomIn(void 0, {
            animation: { duration: e.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "$-,-",
        readonlyOk: !0,
        onSelect(F) {
          P("zoom-out", { source: F }), e.zoomOut(void 0, {
            animation: { duration: e.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "!0",
        readonlyOk: !0,
        onSelect(F) {
          P("reset-zoom", { source: F }), e.resetZoom(void 0, {
            animation: { duration: e.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "!1",
        readonlyOk: !0,
        onSelect(F) {
          P("zoom-to-fit", { source: F }), e.zoomToFit({ animation: { duration: e.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "!2",
        readonlyOk: !0,
        onSelect(F) {
          j() && (M() || (P("zoom-to-selection", { source: F }), e.zoomToSelection({ animation: { duration: e.options.animationMediumMs } })));
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(F) {
          P("toggle-snap-mode", { source: F }), e.user.updateUserPreferences({ isSnapMode: !e.user.getIsSnapMode() });
        },
        checkbox: !0
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "$/",
        readonlyOk: !0,
        onSelect(F) {
          const B = e.user.getIsDarkMode() ? "light" : "dark";
          P("color-scheme", { source: F, value: B }), e.user.updateUserPreferences({
            colorScheme: B
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: !0,
        onSelect(F) {
          P("toggle-wrap-mode", { source: F }), e.user.updateUserPreferences({
            isWrapMode: !e.user.getIsWrapMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: !1,
        onSelect(F) {
          P("toggle-dynamic-size-mode", { source: F }), e.user.updateUserPreferences({
            isDynamicSizeMode: !e.user.getIsDynamicResizeMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: !1,
        onSelect(F) {
          P("toggle-paste-at-cursor", { source: F }), e.user.updateUserPreferences({
            isPasteAtCursorMode: !e.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: !0,
        onSelect(F) {
          P("toggle-reduce-motion", { source: F }), e.user.updateUserPreferences({
            animationSpeed: e.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: !0,
        onSelect(F) {
          P("toggle-edge-scrolling", { source: F }), e.user.updateUserPreferences({
            edgeScrollSpeed: e.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          "context-menu": "action.toggle-transparent.context-menu"
        },
        readonlyOk: !0,
        onSelect(F) {
          P("toggle-transparent", { source: F }), e.updateInstanceState({
            exportBackground: !e.getInstanceState().exportBackground
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(F) {
          P("toggle-tool-lock", { source: F }), e.updateInstanceState({ isToolLocked: !e.getInstanceState().isToolLocked });
        },
        checkbox: !0
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(F) {
          P("unlock-all", { source: F });
          const B = [];
          for (const G of e.getCurrentPageShapes())
            G.isLocked && B.push({ id: G.id, type: G.type, isLocked: !1 });
          B.length > 0 && e.updateShapes(B);
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: !0,
        kbd: "$.",
        checkbox: !0,
        onSelect(F) {
          e.timers.requestAnimationFrame(() => {
            e.run(() => {
              P("toggle-focus-mode", { source: F }), s(), o(), e.updateInstanceState({ isFocusMode: !e.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: !0,
        kbd: "$'",
        onSelect(F) {
          P("toggle-grid-mode", { source: F }), e.updateInstanceState({ isGridMode: !e.getInstanceState().isGridMode });
        },
        checkbox: !0
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: !0,
        onSelect(F) {
          P("toggle-debug-mode", { source: F }), e.updateInstanceState({
            isDebugMode: !e.getInstanceState().isDebugMode
          });
        },
        checkbox: !0
      },
      {
        id: "print",
        label: "action.print",
        kbd: "$p",
        readonlyOk: !0,
        onSelect(F) {
          P("print", { source: F }), f();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(F) {
          P("exit-pen-mode", { source: F }), e.updateInstanceState({ isPenMode: !1 });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(F) {
          P("stop-following", { source: F }), e.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: !0,
        onSelect(F) {
          P("zoom-to-content", { source: F });
          const B = e.getSelectionPageBounds() ?? e.getCurrentPageBounds();
          B && e.zoomToBounds(B, {
            targetZoom: Math.min(1, e.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "!l",
        onSelect(F) {
          e.mark("locking"), P("toggle-lock", { source: F }), e.toggleLock(e.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(F) {
          const B = yp.createId(), G = e.getSelectedShapeIds();
          e.run(() => {
            e.mark("move_shapes_to_page"), e.createPage({ name: u("page-menu.new-page-initial-name"), id: B }), e.moveShapesToPage(G, B);
          }), P("move-to-new-page", { source: F });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "?t",
        onSelect(F) {
          const B = xc;
          e.run(() => {
            e.mark("change-color"), e.isIn("select") && e.setStyleForSelectedShapes(B, "white"), e.setStyleForNextShapes(B, "white");
          }), P("set-style", { source: F, id: B.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "?f",
        onSelect(F) {
          const B = tS;
          e.run(() => {
            e.mark("change-fill"), e.isIn("select") && e.setStyleForSelectedShapes(B, "fill"), e.setStyleForNextShapes(B, "fill");
          }), P("set-style", { source: F, id: B.id, value: "fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "!f",
        onSelect: async (F) => {
          const B = e.getSelectedShapeIds();
          if (B.length === 0) return;
          e.mark("flattening to image"), P("flatten-to-image", { source: F });
          const G = await fPe(
            e,
            B,
            e.options.flattenImageBoundsExpand
          );
          G != null && G.length && e.setSelectedShapes(G);
        }
      }
    ];
    r && $.push({
      id: "open-cursor-chat",
      label: "action.open-cursor-chat",
      readonlyOk: !0,
      kbd: "/",
      onSelect(F) {
        P("open-cursor-chat", { source: F }), !e.getInstanceState().isCoarsePointer && e.timers.requestAnimationFrame(() => {
          e.updateInstanceState({ isChatting: !0 });
        });
      }
    });
    const U = mPe($);
    return n ? n(e, U, void 0) : U;
  }, [
    e,
    P,
    n,
    i,
    l,
    d,
    E,
    w,
    m,
    v,
    S,
    s,
    o,
    f,
    u,
    A,
    r
  ]);
  return /* @__PURE__ */ y.jsx(Vq.Provider, { value: R, children: t });
}
function Dt() {
  const n = D.useContext(Vq);
  if (!n)
    throw new Error("useTools must be used within a ToolProvider");
  return n;
}
function W1(n, t) {
  return n ? typeof n == "string" ? n : t ? n[t] ?? n.default : void 0 : void 0;
}
const yPe = ["top", "right", "bottom", "left"], Sh = Math.min, fc = Math.max, $M = Math.round, LI = Math.floor, Cm = (n) => ({
  x: n,
  y: n
}), SPe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, bPe = {
  start: "end",
  end: "start"
};
function G3(n, t, e) {
  return fc(n, Sh(t, e));
}
function bp(n, t) {
  return typeof n == "function" ? n(t) : n;
}
function xp(n) {
  return n.split("-")[0];
}
function mw(n) {
  return n.split("-")[1];
}
function rU(n) {
  return n === "x" ? "y" : "x";
}
function iU(n) {
  return n === "y" ? "height" : "width";
}
function Em(n) {
  return ["top", "bottom"].includes(xp(n)) ? "y" : "x";
}
function sU(n) {
  return rU(Em(n));
}
function xPe(n, t, e) {
  e === void 0 && (e = !1);
  const r = mw(n), i = sU(n), s = iU(i);
  let o = i === "x" ? r === (e ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = zM(o)), [o, zM(o)];
}
function wPe(n) {
  const t = zM(n);
  return [K3(n), t, K3(t)];
}
function K3(n) {
  return n.replace(/start|end/g, (t) => bPe[t]);
}
function CPe(n, t, e) {
  const r = ["left", "right"], i = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? s : o;
    default:
      return [];
  }
}
function EPe(n, t, e, r) {
  const i = mw(n);
  let s = CPe(xp(n), e === "start", r);
  return i && (s = s.map((o) => o + "-" + i), t && (s = s.concat(s.map(K3)))), s;
}
function zM(n) {
  return n.replace(/left|right|bottom|top/g, (t) => SPe[t]);
}
function _Pe(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function Wq(n) {
  return typeof n != "number" ? _Pe(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function UM(n) {
  const {
    x: t,
    y: e,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: e,
    left: t,
    right: t + r,
    bottom: e + i,
    x: t,
    y: e
  };
}
function lV(n, t, e) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = Em(t), o = sU(t), l = iU(o), u = xp(t), d = s === "y", f = r.x + r.width / 2 - i.width / 2, m = r.y + r.height / 2 - i.height / 2, v = r[l] / 2 - i[l] / 2;
  let S;
  switch (u) {
    case "top":
      S = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      S = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      S = {
        x: r.x + r.width,
        y: m
      };
      break;
    case "left":
      S = {
        x: r.x - i.width,
        y: m
      };
      break;
    default:
      S = {
        x: r.x,
        y: r.y
      };
  }
  switch (mw(t)) {
    case "start":
      S[o] -= v * (e && d ? -1 : 1);
      break;
    case "end":
      S[o] += v * (e && d ? -1 : 1);
      break;
  }
  return S;
}
const TPe = async (n, t, e) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = e, l = s.filter(Boolean), u = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let d = await o.getElementRects({
    reference: n,
    floating: t,
    strategy: i
  }), {
    x: f,
    y: m
  } = lV(d, r, u), v = r, S = {}, w = 0;
  for (let E = 0; E < l.length; E++) {
    const {
      name: A,
      fn: P
    } = l[E], {
      x: R,
      y: M,
      data: j,
      reset: $
    } = await P({
      x: f,
      y: m,
      initialPlacement: r,
      placement: v,
      strategy: i,
      middlewareData: S,
      rects: d,
      platform: o,
      elements: {
        reference: n,
        floating: t
      }
    });
    f = R ?? f, m = M ?? m, S = {
      ...S,
      [A]: {
        ...S[A],
        ...j
      }
    }, $ && w <= 50 && (w++, typeof $ == "object" && ($.placement && (v = $.placement), $.rects && (d = $.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: t,
      strategy: i
    }) : $.rects), {
      x: f,
      y: m
    } = lV(d, v, u)), E = -1);
  }
  return {
    x: f,
    y: m,
    placement: v,
    strategy: i,
    middlewareData: S
  };
};
async function G1(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: l,
    strategy: u
  } = n, {
    boundary: d = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: m = "floating",
    altBoundary: v = !1,
    padding: S = 0
  } = bp(t, n), w = Wq(S), A = l[v ? m === "floating" ? "reference" : "floating" : m], P = UM(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(A))) == null || e ? A : A.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: d,
    rootBoundary: f,
    strategy: u
  })), R = m === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, M = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), j = await (s.isElement == null ? void 0 : s.isElement(M)) ? await (s.getScale == null ? void 0 : s.getScale(M)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, $ = UM(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: R,
    offsetParent: M,
    strategy: u
  }) : R);
  return {
    top: (P.top - $.top + w.top) / j.y,
    bottom: ($.bottom - P.bottom + w.bottom) / j.y,
    left: (P.left - $.left + w.left) / j.x,
    right: ($.right - P.right + w.right) / j.x
  };
}
const PPe = (n) => ({
  name: "arrow",
  options: n,
  async fn(t) {
    const {
      x: e,
      y: r,
      placement: i,
      rects: s,
      platform: o,
      elements: l,
      middlewareData: u
    } = t, {
      element: d,
      padding: f = 0
    } = bp(n, t) || {};
    if (d == null)
      return {};
    const m = Wq(f), v = {
      x: e,
      y: r
    }, S = sU(i), w = iU(S), E = await o.getDimensions(d), A = S === "y", P = A ? "top" : "left", R = A ? "bottom" : "right", M = A ? "clientHeight" : "clientWidth", j = s.reference[w] + s.reference[S] - v[S] - s.floating[w], $ = v[S] - s.reference[S], U = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(d));
    let F = U ? U[M] : 0;
    (!F || !await (o.isElement == null ? void 0 : o.isElement(U))) && (F = l.floating[M] || s.floating[w]);
    const B = j / 2 - $ / 2, G = F / 2 - E[w] / 2 - 1, X = Sh(m[P], G), te = Sh(m[R], G), ne = X, K = F - E[w] - te, Z = F / 2 - E[w] / 2 + B, oe = G3(ne, Z, K), fe = !u.arrow && mw(i) != null && Z !== oe && s.reference[w] / 2 - (Z < ne ? X : te) - E[w] / 2 < 0, ie = fe ? Z < ne ? Z - ne : Z - K : 0;
    return {
      [S]: v[S] + ie,
      data: {
        [S]: oe,
        centerOffset: Z - oe - ie,
        ...fe && {
          alignmentOffset: ie
        }
      },
      reset: fe
    };
  }
}), APe = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: l,
        platform: u,
        elements: d
      } = t, {
        mainAxis: f = !0,
        crossAxis: m = !0,
        fallbackPlacements: v,
        fallbackStrategy: S = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: E = !0,
        ...A
      } = bp(n, t);
      if ((e = s.arrow) != null && e.alignmentOffset)
        return {};
      const P = xp(i), R = Em(l), M = xp(l) === l, j = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), $ = v || (M || !E ? [zM(l)] : wPe(l)), U = w !== "none";
      !v && U && $.push(...EPe(l, E, w, j));
      const F = [l, ...$], B = await G1(t, A), G = [];
      let X = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (f && G.push(B[P]), m) {
        const Z = xPe(i, o, j);
        G.push(B[Z[0]], B[Z[1]]);
      }
      if (X = [...X, {
        placement: i,
        overflows: G
      }], !G.every((Z) => Z <= 0)) {
        var te, ne;
        const Z = (((te = s.flip) == null ? void 0 : te.index) || 0) + 1, oe = F[Z];
        if (oe)
          return {
            data: {
              index: Z,
              overflows: X
            },
            reset: {
              placement: oe
            }
          };
        let fe = (ne = X.filter((ie) => ie.overflows[0] <= 0).sort((ie, ue) => ie.overflows[1] - ue.overflows[1])[0]) == null ? void 0 : ne.placement;
        if (!fe)
          switch (S) {
            case "bestFit": {
              var K;
              const ie = (K = X.filter((ue) => {
                if (U) {
                  const Se = Em(ue.placement);
                  return Se === R || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Se === "y";
                }
                return !0;
              }).map((ue) => [ue.placement, ue.overflows.filter((Se) => Se > 0).reduce((Se, ke) => Se + ke, 0)]).sort((ue, Se) => ue[1] - Se[1])[0]) == null ? void 0 : K[0];
              ie && (fe = ie);
              break;
            }
            case "initialPlacement":
              fe = l;
              break;
          }
        if (i !== fe)
          return {
            reset: {
              placement: fe
            }
          };
      }
      return {};
    }
  };
};
function cV(n, t) {
  return {
    top: n.top - t.height,
    right: n.right - t.width,
    bottom: n.bottom - t.height,
    left: n.left - t.width
  };
}
function uV(n) {
  return yPe.some((t) => n[t] >= 0);
}
const kPe = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(t) {
      const {
        rects: e
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = bp(n, t);
      switch (r) {
        case "referenceHidden": {
          const s = await G1(t, {
            ...i,
            elementContext: "reference"
          }), o = cV(s, e.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: uV(o)
            }
          };
        }
        case "escaped": {
          const s = await G1(t, {
            ...i,
            altBoundary: !0
          }), o = cV(s, e.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: uV(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function IPe(n, t) {
  const {
    placement: e,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = xp(e), l = mw(e), u = Em(e) === "y", d = ["left", "top"].includes(o) ? -1 : 1, f = s && u ? -1 : 1, m = bp(t, n);
  let {
    mainAxis: v,
    crossAxis: S,
    alignmentAxis: w
  } = typeof m == "number" ? {
    mainAxis: m,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...m
  };
  return l && typeof w == "number" && (S = l === "end" ? w * -1 : w), u ? {
    x: S * f,
    y: v * d
  } : {
    x: v * d,
    y: S * f
  };
}
const RPe = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      var e, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: l
      } = t, u = await IPe(t, n);
      return o === ((e = l.offset) == null ? void 0 : e.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: i + u.x,
        y: s + u.y,
        data: {
          ...u,
          placement: o
        }
      };
    }
  };
}, MPe = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: r,
        placement: i
      } = t, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (A) => {
            let {
              x: P,
              y: R
            } = A;
            return {
              x: P,
              y: R
            };
          }
        },
        ...u
      } = bp(n, t), d = {
        x: e,
        y: r
      }, f = await G1(t, u), m = Em(xp(i)), v = rU(m);
      let S = d[v], w = d[m];
      if (s) {
        const A = v === "y" ? "top" : "left", P = v === "y" ? "bottom" : "right", R = S + f[A], M = S - f[P];
        S = G3(R, S, M);
      }
      if (o) {
        const A = m === "y" ? "top" : "left", P = m === "y" ? "bottom" : "right", R = w + f[A], M = w - f[P];
        w = G3(R, w, M);
      }
      const E = l.fn({
        ...t,
        [v]: S,
        [m]: w
      });
      return {
        ...E,
        data: {
          x: E.x - e,
          y: E.y - r
        }
      };
    }
  };
}, DPe = function(n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(t) {
      const {
        x: e,
        y: r,
        placement: i,
        rects: s,
        middlewareData: o
      } = t, {
        offset: l = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = bp(n, t), f = {
        x: e,
        y: r
      }, m = Em(i), v = rU(m);
      let S = f[v], w = f[m];
      const E = bp(l, t), A = typeof E == "number" ? {
        mainAxis: E,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...E
      };
      if (u) {
        const M = v === "y" ? "height" : "width", j = s.reference[v] - s.floating[M] + A.mainAxis, $ = s.reference[v] + s.reference[M] - A.mainAxis;
        S < j ? S = j : S > $ && (S = $);
      }
      if (d) {
        var P, R;
        const M = v === "y" ? "width" : "height", j = ["top", "left"].includes(xp(i)), $ = s.reference[m] - s.floating[M] + (j && ((P = o.offset) == null ? void 0 : P[m]) || 0) + (j ? 0 : A.crossAxis), U = s.reference[m] + s.reference[M] + (j ? 0 : ((R = o.offset) == null ? void 0 : R[m]) || 0) - (j ? A.crossAxis : 0);
        w < $ ? w = $ : w > U && (w = U);
      }
      return {
        [v]: S,
        [m]: w
      };
    }
  };
}, OPe = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(t) {
      const {
        placement: e,
        rects: r,
        platform: i,
        elements: s
      } = t, {
        apply: o = () => {
        },
        ...l
      } = bp(n, t), u = await G1(t, l), d = xp(e), f = mw(e), m = Em(e) === "y", {
        width: v,
        height: S
      } = r.floating;
      let w, E;
      d === "top" || d === "bottom" ? (w = d, E = f === (await (i.isRTL == null ? void 0 : i.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (E = d, w = f === "end" ? "top" : "bottom");
      const A = S - u.top - u.bottom, P = v - u.left - u.right, R = Sh(S - u[w], A), M = Sh(v - u[E], P), j = !t.middlewareData.shift;
      let $ = R, U = M;
      if (m ? U = f || j ? Sh(M, P) : P : $ = f || j ? Sh(R, A) : A, j && !f) {
        const B = fc(u.left, 0), G = fc(u.right, 0), X = fc(u.top, 0), te = fc(u.bottom, 0);
        m ? U = v - 2 * (B !== 0 || G !== 0 ? B + G : fc(u.left, u.right)) : $ = S - 2 * (X !== 0 || te !== 0 ? X + te : fc(u.top, u.bottom));
      }
      await o({
        ...t,
        availableWidth: U,
        availableHeight: $
      });
      const F = await i.getDimensions(s.floating);
      return v !== F.width || S !== F.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function vw(n) {
  return Gq(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Sc(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function kp(n) {
  var t;
  return (t = (Gq(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
function Gq(n) {
  return n instanceof Node || n instanceof Sc(n).Node;
}
function cd(n) {
  return n instanceof Element || n instanceof Sc(n).Element;
}
function Rh(n) {
  return n instanceof HTMLElement || n instanceof Sc(n).HTMLElement;
}
function dV(n) {
  return typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Sc(n).ShadowRoot;
}
function qT(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: r,
    display: i
  } = ud(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + e) && !["inline", "contents"].includes(i);
}
function LPe(n) {
  return ["table", "td", "th"].includes(vw(n));
}
function sD(n) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return n.matches(t);
    } catch {
      return !1;
    }
  });
}
function oU(n) {
  const t = aU(), e = cd(n) ? ud(n) : n;
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (e.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (e.contain || "").includes(r));
}
function jPe(n) {
  let t = _m(n);
  for (; Rh(t) && !rw(t); ) {
    if (oU(t))
      return t;
    if (sD(t))
      return null;
    t = _m(t);
  }
  return null;
}
function aU() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function rw(n) {
  return ["html", "body", "#document"].includes(vw(n));
}
function ud(n) {
  return Sc(n).getComputedStyle(n);
}
function oD(n) {
  return cd(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function _m(n) {
  if (vw(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    dV(n) && n.host || // Fallback.
    kp(n)
  );
  return dV(t) ? t.host : t;
}
function Kq(n) {
  const t = _m(n);
  return rw(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : Rh(t) && qT(t) ? t : Kq(t);
}
function K1(n, t, e) {
  var r;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const i = Kq(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = Sc(i);
  if (s) {
    const l = Y3(o);
    return t.concat(o, o.visualViewport || [], qT(i) ? i : [], l && e ? K1(l) : []);
  }
  return t.concat(i, K1(i, [], e));
}
function Y3(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function Yq(n) {
  const t = ud(n);
  let e = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Rh(n), s = i ? n.offsetWidth : e, o = i ? n.offsetHeight : r, l = $M(e) !== s || $M(r) !== o;
  return l && (e = s, r = o), {
    width: e,
    height: r,
    $: l
  };
}
function lU(n) {
  return cd(n) ? n : n.contextElement;
}
function X0(n) {
  const t = lU(n);
  if (!Rh(t))
    return Cm(1);
  const e = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = Yq(t);
  let o = (s ? $M(e.width) : e.width) / r, l = (s ? $M(e.height) : e.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const NPe = /* @__PURE__ */ Cm(0);
function Xq(n) {
  const t = Sc(n);
  return !aU() || !t.visualViewport ? NPe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function FPe(n, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Sc(n) ? !1 : t;
}
function aS(n, t, e, r) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const i = n.getBoundingClientRect(), s = lU(n);
  let o = Cm(1);
  t && (r ? cd(r) && (o = X0(r)) : o = X0(n));
  const l = FPe(s, e, r) ? Xq(s) : Cm(0);
  let u = (i.left + l.x) / o.x, d = (i.top + l.y) / o.y, f = i.width / o.x, m = i.height / o.y;
  if (s) {
    const v = Sc(s), S = r && cd(r) ? Sc(r) : r;
    let w = v, E = Y3(w);
    for (; E && r && S !== w; ) {
      const A = X0(E), P = E.getBoundingClientRect(), R = ud(E), M = P.left + (E.clientLeft + parseFloat(R.paddingLeft)) * A.x, j = P.top + (E.clientTop + parseFloat(R.paddingTop)) * A.y;
      u *= A.x, d *= A.y, f *= A.x, m *= A.y, u += M, d += j, w = Sc(E), E = Y3(w);
    }
  }
  return UM({
    width: f,
    height: m,
    x: u,
    y: d
  });
}
function $Pe(n) {
  let {
    elements: t,
    rect: e,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", o = kp(r), l = t ? sD(t.floating) : !1;
  if (r === o || l && s)
    return e;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = Cm(1);
  const f = Cm(0), m = Rh(r);
  if ((m || !m && !s) && ((vw(r) !== "body" || qT(o)) && (u = oD(r)), Rh(r))) {
    const v = aS(r);
    d = X0(r), f.x = v.x + r.clientLeft, f.y = v.y + r.clientTop;
  }
  return {
    width: e.width * d.x,
    height: e.height * d.y,
    x: e.x * d.x - u.scrollLeft * d.x + f.x,
    y: e.y * d.y - u.scrollTop * d.y + f.y
  };
}
function zPe(n) {
  return Array.from(n.getClientRects());
}
function qq(n) {
  return aS(kp(n)).left + oD(n).scrollLeft;
}
function UPe(n) {
  const t = kp(n), e = oD(n), r = n.ownerDocument.body, i = fc(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = fc(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -e.scrollLeft + qq(n);
  const l = -e.scrollTop;
  return ud(r).direction === "rtl" && (o += fc(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
function BPe(n, t) {
  const e = Sc(n), r = kp(n), i = e.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, l = 0, u = 0;
  if (i) {
    s = i.width, o = i.height;
    const d = aU();
    (!d || d && t === "fixed") && (l = i.offsetLeft, u = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: l,
    y: u
  };
}
function HPe(n, t) {
  const e = aS(n, !0, t === "fixed"), r = e.top + n.clientTop, i = e.left + n.clientLeft, s = Rh(n) ? X0(n) : Cm(1), o = n.clientWidth * s.x, l = n.clientHeight * s.y, u = i * s.x, d = r * s.y;
  return {
    width: o,
    height: l,
    x: u,
    y: d
  };
}
function hV(n, t, e) {
  let r;
  if (t === "viewport")
    r = BPe(n, e);
  else if (t === "document")
    r = UPe(kp(n));
  else if (cd(t))
    r = HPe(t, e);
  else {
    const i = Xq(n);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return UM(r);
}
function Zq(n, t) {
  const e = _m(n);
  return e === t || !cd(e) || rw(e) ? !1 : ud(e).position === "fixed" || Zq(e, t);
}
function VPe(n, t) {
  const e = t.get(n);
  if (e)
    return e;
  let r = K1(n, [], !1).filter((l) => cd(l) && vw(l) !== "body"), i = null;
  const s = ud(n).position === "fixed";
  let o = s ? _m(n) : n;
  for (; cd(o) && !rw(o); ) {
    const l = ud(o), u = oU(o);
    !u && l.position === "fixed" && (i = null), (s ? !u && !i : !u && l.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || qT(o) && !u && Zq(n, o)) ? r = r.filter((f) => f !== o) : i = l, o = _m(o);
  }
  return t.set(n, r), r;
}
function WPe(n) {
  let {
    element: t,
    boundary: e,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...e === "clippingAncestors" ? sD(t) ? [] : VPe(t, this._c) : [].concat(e), r], l = o[0], u = o.reduce((d, f) => {
    const m = hV(t, f, i);
    return d.top = fc(m.top, d.top), d.right = Sh(m.right, d.right), d.bottom = Sh(m.bottom, d.bottom), d.left = fc(m.left, d.left), d;
  }, hV(t, l, i));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function GPe(n) {
  const {
    width: t,
    height: e
  } = Yq(n);
  return {
    width: t,
    height: e
  };
}
function KPe(n, t, e) {
  const r = Rh(t), i = kp(t), s = e === "fixed", o = aS(n, !0, s, t);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = Cm(0);
  if (r || !r && !s)
    if ((vw(t) !== "body" || qT(i)) && (l = oD(t)), r) {
      const m = aS(t, !0, s, t);
      u.x = m.x + t.clientLeft, u.y = m.y + t.clientTop;
    } else i && (u.x = qq(i));
  const d = o.left + l.scrollLeft - u.x, f = o.top + l.scrollTop - u.y;
  return {
    x: d,
    y: f,
    width: o.width,
    height: o.height
  };
}
function cF(n) {
  return ud(n).position === "static";
}
function fV(n, t) {
  return !Rh(n) || ud(n).position === "fixed" ? null : t ? t(n) : n.offsetParent;
}
function Qq(n, t) {
  const e = Sc(n);
  if (sD(n))
    return e;
  if (!Rh(n)) {
    let i = _m(n);
    for (; i && !rw(i); ) {
      if (cd(i) && !cF(i))
        return i;
      i = _m(i);
    }
    return e;
  }
  let r = fV(n, t);
  for (; r && LPe(r) && cF(r); )
    r = fV(r, t);
  return r && rw(r) && cF(r) && !oU(r) ? e : r || jPe(n) || e;
}
const YPe = async function(n) {
  const t = this.getOffsetParent || Qq, e = this.getDimensions, r = await e(n.floating);
  return {
    reference: KPe(n.reference, await t(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function XPe(n) {
  return ud(n).direction === "rtl";
}
const qPe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: $Pe,
  getDocumentElement: kp,
  getClippingRect: WPe,
  getOffsetParent: Qq,
  getElementRects: YPe,
  getClientRects: zPe,
  getDimensions: GPe,
  getScale: X0,
  isElement: cd,
  isRTL: XPe
};
function ZPe(n, t) {
  let e = null, r;
  const i = kp(n);
  function s() {
    var l;
    clearTimeout(r), (l = e) == null || l.disconnect(), e = null;
  }
  function o(l, u) {
    l === void 0 && (l = !1), u === void 0 && (u = 1), s();
    const {
      left: d,
      top: f,
      width: m,
      height: v
    } = n.getBoundingClientRect();
    if (l || t(), !m || !v)
      return;
    const S = LI(f), w = LI(i.clientWidth - (d + m)), E = LI(i.clientHeight - (f + v)), A = LI(d), R = {
      rootMargin: -S + "px " + -w + "px " + -E + "px " + -A + "px",
      threshold: fc(0, Sh(1, u)) || 1
    };
    let M = !0;
    function j($) {
      const U = $[0].intersectionRatio;
      if (U !== u) {
        if (!M)
          return o();
        U ? o(!1, U) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      M = !1;
    }
    try {
      e = new IntersectionObserver(j, {
        ...R,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(j, R);
    }
    e.observe(n);
  }
  return o(!0), s;
}
function QPe(n, t, e, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = r, d = lU(n), f = i || s ? [...d ? K1(d) : [], ...K1(t)] : [];
  f.forEach((P) => {
    i && P.addEventListener("scroll", e, {
      passive: !0
    }), s && P.addEventListener("resize", e);
  });
  const m = d && l ? ZPe(d, e) : null;
  let v = -1, S = null;
  o && (S = new ResizeObserver((P) => {
    let [R] = P;
    R && R.target === d && S && (S.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      var M;
      (M = S) == null || M.observe(t);
    })), e();
  }), d && !u && S.observe(d), S.observe(t));
  let w, E = u ? aS(n) : null;
  u && A();
  function A() {
    const P = aS(n);
    E && (P.x !== E.x || P.y !== E.y || P.width !== E.width || P.height !== E.height) && e(), E = P, w = requestAnimationFrame(A);
  }
  return e(), () => {
    var P;
    f.forEach((R) => {
      i && R.removeEventListener("scroll", e), s && R.removeEventListener("resize", e);
    }), m == null || m(), (P = S) == null || P.disconnect(), S = null, u && cancelAnimationFrame(w);
  };
}
const JPe = RPe, eAe = MPe, tAe = APe, nAe = OPe, rAe = kPe, pV = PPe, iAe = DPe, sAe = (n, t, e) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: qPe,
    ...e
  }, s = {
    ...i.platform,
    _c: r
  };
  return TPe(n, t, {
    ...i,
    platform: s
  });
};
var PR = typeof document < "u" ? D.useLayoutEffect : D.useEffect;
function BM(n, t) {
  if (n === t)
    return !0;
  if (typeof n != typeof t)
    return !1;
  if (typeof n == "function" && n.toString() === t.toString())
    return !0;
  let e, r, i;
  if (n && t && typeof n == "object") {
    if (Array.isArray(n)) {
      if (e = n.length, e !== t.length) return !1;
      for (r = e; r-- !== 0; )
        if (!BM(n[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(n), e = i.length, e !== Object.keys(t).length)
      return !1;
    for (r = e; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = e; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && n.$$typeof) && !BM(n[s], t[s]))
        return !1;
    }
    return !0;
  }
  return n !== n && t !== t;
}
function Jq(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function gV(n, t) {
  const e = Jq(n);
  return Math.round(t * e) / e;
}
function mV(n) {
  const t = D.useRef(n);
  return PR(() => {
    t.current = n;
  }), t;
}
function oAe(n) {
  n === void 0 && (n = {});
  const {
    placement: t = "bottom",
    strategy: e = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: s,
      floating: o
    } = {},
    transform: l = !0,
    whileElementsMounted: u,
    open: d
  } = n, [f, m] = D.useState({
    x: 0,
    y: 0,
    strategy: e,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [v, S] = D.useState(r);
  BM(v, r) || S(r);
  const [w, E] = D.useState(null), [A, P] = D.useState(null), R = D.useCallback((ie) => {
    ie !== U.current && (U.current = ie, E(ie));
  }, []), M = D.useCallback((ie) => {
    ie !== F.current && (F.current = ie, P(ie));
  }, []), j = s || w, $ = o || A, U = D.useRef(null), F = D.useRef(null), B = D.useRef(f), G = u != null, X = mV(u), te = mV(i), ne = D.useCallback(() => {
    if (!U.current || !F.current)
      return;
    const ie = {
      placement: t,
      strategy: e,
      middleware: v
    };
    te.current && (ie.platform = te.current), sAe(U.current, F.current, ie).then((ue) => {
      const Se = {
        ...ue,
        isPositioned: !0
      };
      K.current && !BM(B.current, Se) && (B.current = Se, xS.flushSync(() => {
        m(Se);
      }));
    });
  }, [v, t, e, te]);
  PR(() => {
    d === !1 && B.current.isPositioned && (B.current.isPositioned = !1, m((ie) => ({
      ...ie,
      isPositioned: !1
    })));
  }, [d]);
  const K = D.useRef(!1);
  PR(() => (K.current = !0, () => {
    K.current = !1;
  }), []), PR(() => {
    if (j && (U.current = j), $ && (F.current = $), j && $) {
      if (X.current)
        return X.current(j, $, ne);
      ne();
    }
  }, [j, $, ne, X, G]);
  const Z = D.useMemo(() => ({
    reference: U,
    floating: F,
    setReference: R,
    setFloating: M
  }), [R, M]), oe = D.useMemo(() => ({
    reference: j,
    floating: $
  }), [j, $]), fe = D.useMemo(() => {
    const ie = {
      position: e,
      left: 0,
      top: 0
    };
    if (!oe.floating)
      return ie;
    const ue = gV(oe.floating, f.x), Se = gV(oe.floating, f.y);
    return l ? {
      ...ie,
      transform: "translate(" + ue + "px, " + Se + "px)",
      ...Jq(oe.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: e,
      left: ue,
      top: Se
    };
  }, [e, l, oe.floating, f.x, f.y]);
  return D.useMemo(() => ({
    ...f,
    update: ne,
    refs: Z,
    elements: oe,
    floatingStyles: fe
  }), [f, ne, Z, oe, fe]);
}
const aAe = (n) => {
  function t(e) {
    return {}.hasOwnProperty.call(e, "current");
  }
  return {
    name: "arrow",
    options: n,
    fn(e) {
      const {
        element: r,
        padding: i
      } = typeof n == "function" ? n(e) : n;
      return r && t(r) ? r.current != null ? pV({
        element: r.current,
        padding: i
      }).fn(e) : {} : r ? pV({
        element: r,
        padding: i
      }).fn(e) : {};
    }
  };
}, lAe = (n, t) => ({
  ...JPe(n),
  options: [n, t]
}), cAe = (n, t) => ({
  ...eAe(n),
  options: [n, t]
}), uAe = (n, t) => ({
  ...iAe(n),
  options: [n, t]
}), dAe = (n, t) => ({
  ...tAe(n),
  options: [n, t]
}), hAe = (n, t) => ({
  ...nAe(n),
  options: [n, t]
}), fAe = (n, t) => ({
  ...rAe(n),
  options: [n, t]
}), pAe = (n, t) => ({
  ...aAe(n),
  options: [n, t]
});
var gAe = "Arrow", eZ = D.forwardRef((n, t) => {
  const { children: e, width: r = 10, height: i = 5, ...s } = n;
  return /* @__PURE__ */ y.jsx(
    sr.svg,
    {
      ...s,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: n.asChild ? e : /* @__PURE__ */ y.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
eZ.displayName = gAe;
var mAe = eZ;
function tZ(n) {
  const [t, e] = D.useState(void 0);
  return wm(() => {
    if (n) {
      e({ width: n.offsetWidth, height: n.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let o, l;
        if ("borderBoxSize" in s) {
          const u = s.borderBoxSize, d = Array.isArray(u) ? u[0] : u;
          o = d.inlineSize, l = d.blockSize;
        } else
          o = n.offsetWidth, l = n.offsetHeight;
        e({ width: o, height: l });
      });
      return r.observe(n, { box: "border-box" }), () => r.unobserve(n);
    } else
      e(void 0);
  }, [n]), t;
}
var cU = "Popper", [nZ, aD] = jh(cU), [vAe, rZ] = nZ(cU), iZ = (n) => {
  const { __scopePopper: t, children: e } = n, [r, i] = D.useState(null);
  return /* @__PURE__ */ y.jsx(vAe, { scope: t, anchor: r, onAnchorChange: i, children: e });
};
iZ.displayName = cU;
var sZ = "PopperAnchor", oZ = D.forwardRef(
  (n, t) => {
    const { __scopePopper: e, virtualRef: r, ...i } = n, s = rZ(sZ, e), o = D.useRef(null), l = si(t, o);
    return D.useEffect(() => {
      s.onAnchorChange((r == null ? void 0 : r.current) || o.current);
    }), r ? null : /* @__PURE__ */ y.jsx(sr.div, { ...i, ref: l });
  }
);
oZ.displayName = sZ;
var uU = "PopperContent", [yAe, SAe] = nZ(uU), aZ = D.forwardRef(
  (n, t) => {
    var Ze, tt, et, at, Yt, Un;
    const {
      __scopePopper: e,
      side: r = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: o = 0,
      arrowPadding: l = 0,
      avoidCollisions: u = !0,
      collisionBoundary: d = [],
      collisionPadding: f = 0,
      sticky: m = "partial",
      hideWhenDetached: v = !1,
      updatePositionStrategy: S = "optimized",
      onPlaced: w,
      ...E
    } = n, A = rZ(uU, e), [P, R] = D.useState(null), M = si(t, (pt) => R(pt)), [j, $] = D.useState(null), U = tZ(j), F = (U == null ? void 0 : U.width) ?? 0, B = (U == null ? void 0 : U.height) ?? 0, G = r + (s !== "center" ? "-" + s : ""), X = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, te = Array.isArray(d) ? d : [d], ne = te.length > 0, K = {
      padding: X,
      boundary: te.filter(xAe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: ne
    }, { refs: Z, floatingStyles: oe, placement: fe, isPositioned: ie, middlewareData: ue } = oAe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: G,
      whileElementsMounted: (...pt) => QPe(...pt, {
        animationFrame: S === "always"
      }),
      elements: {
        reference: A.anchor
      },
      middleware: [
        lAe({ mainAxis: i + B, alignmentAxis: o }),
        u && cAe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: m === "partial" ? uAe() : void 0,
          ...K
        }),
        u && dAe({ ...K }),
        hAe({
          ...K,
          apply: ({ elements: pt, rects: Ut, availableWidth: jt, availableHeight: $t }) => {
            const { width: yn, height: hi } = Ut.reference, Nr = pt.floating.style;
            Nr.setProperty("--radix-popper-available-width", `${jt}px`), Nr.setProperty("--radix-popper-available-height", `${$t}px`), Nr.setProperty("--radix-popper-anchor-width", `${yn}px`), Nr.setProperty("--radix-popper-anchor-height", `${hi}px`);
          }
        }),
        j && pAe({ element: j, padding: l }),
        wAe({ arrowWidth: F, arrowHeight: B }),
        v && fAe({ strategy: "referenceHidden", ...K })
      ]
    }), [Se, ke] = uZ(fe), ce = jo(w);
    wm(() => {
      ie && (ce == null || ce());
    }, [ie, ce]);
    const ye = (Ze = ue.arrow) == null ? void 0 : Ze.x, Fe = (tt = ue.arrow) == null ? void 0 : tt.y, Xe = ((et = ue.arrow) == null ? void 0 : et.centerOffset) !== 0, [je, nt] = D.useState();
    return wm(() => {
      P && nt(window.getComputedStyle(P).zIndex);
    }, [P]), /* @__PURE__ */ y.jsx(
      "div",
      {
        ref: Z.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...oe,
          transform: ie ? oe.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: je,
          "--radix-popper-transform-origin": [
            (at = ue.transformOrigin) == null ? void 0 : at.x,
            (Yt = ue.transformOrigin) == null ? void 0 : Yt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((Un = ue.hide) == null ? void 0 : Un.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: n.dir,
        children: /* @__PURE__ */ y.jsx(
          yAe,
          {
            scope: e,
            placedSide: Se,
            onArrowChange: $,
            arrowX: ye,
            arrowY: Fe,
            shouldHideArrow: Xe,
            children: /* @__PURE__ */ y.jsx(
              sr.div,
              {
                "data-side": Se,
                "data-align": ke,
                ...E,
                ref: M,
                style: {
                  ...E.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: ie ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
aZ.displayName = uU;
var lZ = "PopperArrow", bAe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, cZ = D.forwardRef(function(t, e) {
  const { __scopePopper: r, ...i } = t, s = SAe(lZ, r), o = bAe[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ y.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ y.jsx(
          mAe,
          {
            ...i,
            ref: e,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
cZ.displayName = lZ;
function xAe(n) {
  return n !== null;
}
var wAe = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(t) {
    var A, P, R;
    const { placement: e, rects: r, middlewareData: i } = t, o = ((A = i.arrow) == null ? void 0 : A.centerOffset) !== 0, l = o ? 0 : n.arrowWidth, u = o ? 0 : n.arrowHeight, [d, f] = uZ(e), m = { start: "0%", center: "50%", end: "100%" }[f], v = (((P = i.arrow) == null ? void 0 : P.x) ?? 0) + l / 2, S = (((R = i.arrow) == null ? void 0 : R.y) ?? 0) + u / 2;
    let w = "", E = "";
    return d === "bottom" ? (w = o ? m : `${v}px`, E = `${-u}px`) : d === "top" ? (w = o ? m : `${v}px`, E = `${r.floating.height + u}px`) : d === "right" ? (w = `${-u}px`, E = o ? m : `${S}px`) : d === "left" && (w = `${r.floating.width + u}px`, E = o ? m : `${S}px`), { data: { x: w, y: E } };
  }
});
function uZ(n) {
  const [t, e = "center"] = n.split("-");
  return [t, e];
}
var dU = iZ, hU = oZ, dZ = aZ, hZ = cZ, fU = "Popover", [fZ, LNe] = jh(fU, [
  aD
]), ZT = aD(), [CAe, Om] = fZ(fU), pZ = (n) => {
  const {
    __scopePopover: t,
    children: e,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: o = !1
  } = n, l = ZT(t), u = D.useRef(null), [d, f] = D.useState(!1), [m = !1, v] = Dm({
    prop: r,
    defaultProp: i,
    onChange: s
  });
  return /* @__PURE__ */ y.jsx(dU, { ...l, children: /* @__PURE__ */ y.jsx(
    CAe,
    {
      scope: t,
      contentId: hp(),
      triggerRef: u,
      open: m,
      onOpenChange: v,
      onOpenToggle: D.useCallback(() => v((S) => !S), [v]),
      hasCustomAnchor: d,
      onCustomAnchorAdd: D.useCallback(() => f(!0), []),
      onCustomAnchorRemove: D.useCallback(() => f(!1), []),
      modal: o,
      children: e
    }
  ) });
};
pZ.displayName = fU;
var gZ = "PopoverAnchor", EAe = D.forwardRef(
  (n, t) => {
    const { __scopePopover: e, ...r } = n, i = Om(gZ, e), s = ZT(e), { onCustomAnchorAdd: o, onCustomAnchorRemove: l } = i;
    return D.useEffect(() => (o(), () => l()), [o, l]), /* @__PURE__ */ y.jsx(hU, { ...s, ...r, ref: t });
  }
);
EAe.displayName = gZ;
var mZ = "PopoverTrigger", vZ = D.forwardRef(
  (n, t) => {
    const { __scopePopover: e, ...r } = n, i = Om(mZ, e), s = ZT(e), o = si(t, i.triggerRef), l = /* @__PURE__ */ y.jsx(
      sr.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": wZ(i.open),
        ...r,
        ref: o,
        onClick: Et(n.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? l : /* @__PURE__ */ y.jsx(hU, { asChild: !0, ...s, children: l });
  }
);
vZ.displayName = mZ;
var pU = "PopoverPortal", [_Ae, TAe] = fZ(pU, {
  forceMount: void 0
}), yZ = (n) => {
  const { __scopePopover: t, forceMount: e, children: r, container: i } = n, s = Om(pU, t);
  return /* @__PURE__ */ y.jsx(_Ae, { scope: t, forceMount: e, children: /* @__PURE__ */ y.jsx(fd, { present: e || s.open, children: /* @__PURE__ */ y.jsx(XT, { asChild: !0, container: i, children: r }) }) });
};
yZ.displayName = pU;
var iw = "PopoverContent", SZ = D.forwardRef(
  (n, t) => {
    const e = TAe(iw, n.__scopePopover), { forceMount: r = e.forceMount, ...i } = n, s = Om(iw, n.__scopePopover);
    return /* @__PURE__ */ y.jsx(fd, { present: r || s.open, children: s.modal ? /* @__PURE__ */ y.jsx(PAe, { ...i, ref: t }) : /* @__PURE__ */ y.jsx(AAe, { ...i, ref: t }) });
  }
);
SZ.displayName = iw;
var PAe = D.forwardRef(
  (n, t) => {
    const e = Om(iw, n.__scopePopover), r = D.useRef(null), i = si(t, r), s = D.useRef(!1);
    return D.useEffect(() => {
      const o = r.current;
      if (o) return G5(o);
    }, []), /* @__PURE__ */ y.jsx(X2, { as: sS, allowPinchZoom: !0, children: /* @__PURE__ */ y.jsx(
      bZ,
      {
        ...n,
        ref: i,
        trapFocus: e.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Et(n.onCloseAutoFocus, (o) => {
          var l;
          o.preventDefault(), s.current || (l = e.triggerRef.current) == null || l.focus();
        }),
        onPointerDownOutside: Et(
          n.onPointerDownOutside,
          (o) => {
            const l = o.detail.originalEvent, u = l.button === 0 && l.ctrlKey === !0, d = l.button === 2 || u;
            s.current = d;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Et(
          n.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), AAe = D.forwardRef(
  (n, t) => {
    const e = Om(iw, n.__scopePopover), r = D.useRef(!1), i = D.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      bZ,
      {
        ...n,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var o, l;
          (o = n.onCloseAutoFocus) == null || o.call(n, s), s.defaultPrevented || (r.current || (l = e.triggerRef.current) == null || l.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var u, d;
          (u = n.onInteractOutside) == null || u.call(n, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = s.target;
          ((d = e.triggerRef.current) == null ? void 0 : d.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), bZ = D.forwardRef(
  (n, t) => {
    const {
      __scopePopover: e,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: o,
      onEscapeKeyDown: l,
      onPointerDownOutside: u,
      onFocusOutside: d,
      onInteractOutside: f,
      ...m
    } = n, v = Om(iw, e), S = ZT(e);
    return W5(), /* @__PURE__ */ y.jsx(
      K2,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ y.jsx(
          YT,
          {
            asChild: !0,
            disableOutsidePointerEvents: o,
            onInteractOutside: f,
            onEscapeKeyDown: l,
            onPointerDownOutside: u,
            onFocusOutside: d,
            onDismiss: () => v.onOpenChange(!1),
            children: /* @__PURE__ */ y.jsx(
              dZ,
              {
                "data-state": wZ(v.open),
                role: "dialog",
                id: v.contentId,
                ...S,
                ...m,
                ref: t,
                style: {
                  ...m.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), xZ = "PopoverClose", kAe = D.forwardRef(
  (n, t) => {
    const { __scopePopover: e, ...r } = n, i = Om(xZ, e);
    return /* @__PURE__ */ y.jsx(
      sr.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Et(n.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
kAe.displayName = xZ;
var IAe = "PopoverArrow", RAe = D.forwardRef(
  (n, t) => {
    const { __scopePopover: e, ...r } = n, i = ZT(e);
    return /* @__PURE__ */ y.jsx(hZ, { ...i, ...r, ref: t });
  }
);
RAe.displayName = IAe;
function wZ(n) {
  return n ? "open" : "closed";
}
var gU = pZ, mU = vZ, vU = yZ, yU = SZ;
function Ip(n, t) {
  const e = we(), r = D.useRef(!1), i = Fo(), s = D.useCallback(
    (l) => {
      r.current = l, e.run(() => {
        l ? (e.complete(), e.addOpenMenu(n)) : e.updateInstanceState({
          openMenus: e.getOpenMenus().filter((u) => !u.startsWith(n))
        }), t == null || t(l);
      });
    },
    [e, n, t]
  ), o = De("is menu open", () => e.getOpenMenus().includes(n), [e, n]);
  return D.useEffect(() => (r.current && (i("open-menu", { source: "unknown", id: n }), e.addOpenMenu(n)), () => {
    r.current && (e.deleteOpenMenu(n), e.getOpenMenus().forEach((l) => {
      l.startsWith(n) && (i("close-menu", { source: "unknown", id: n }), e.deleteOpenMenu(l));
    }), r.current = !1);
  }), [e, n, i]), [o, s];
}
function SU({ id: n, children: t, onOpenChange: e, open: r }) {
  const [i, s] = Ip(n, e);
  return /* @__PURE__ */ y.jsx(
    gU,
    {
      onOpenChange: s,
      open: r || i,
      children: /* @__PURE__ */ y.jsx("div", { className: "tlui-popover", children: t })
    }
  );
}
function bU({ children: n }) {
  return /* @__PURE__ */ y.jsx(mU, { asChild: !0, dir: "ltr", children: n });
}
function xU({
  side: n,
  children: t,
  align: e = "center",
  sideOffset: r = 8,
  alignOffset: i = 0
}) {
  const s = io();
  return /* @__PURE__ */ y.jsx(vU, { container: s, children: /* @__PURE__ */ y.jsx(
    yU,
    {
      className: "tlui-popover__content",
      side: n,
      sideOffset: r,
      align: e,
      alignOffset: i,
      dir: "ltr",
      children: t
    }
  ) });
}
const CZ = D.createContext(null);
function lD() {
  const n = D.useContext(CZ);
  if (!n)
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  return n;
}
function lu({
  type: n,
  sourceId: t,
  children: e
}) {
  return /* @__PURE__ */ y.jsx(CZ.Provider, { value: { type: n, sourceId: t }, children: e });
}
function MAe(n) {
  return n.getSelectedShapeIds().map((r) => n.getShape(r)).filter((r) => {
    if (!r) return !1;
    if (n.isShapeOfType(r, "arrow")) {
      const i = Ml(n, r);
      if (i.start || i.end) return !1;
    }
    return !0;
  });
}
const EZ = () => {
  const n = we();
  return De("threeStackableItems", () => MAe(n).length > 2, [n]);
}, Rp = () => {
  const n = we();
  return De("isInSelectState", () => n.isIn("select"), [n]);
}, _Z = () => {
  const n = we();
  return De(
    "allow group",
    () => {
      const t = n.getSelectedShapes();
      if (t.length < 2) return !1;
      for (const e of t)
        if (n.isShapeOfType(e, "arrow")) {
          const r = Ml(n, e);
          if (r.start && !t.some((i) => i.id === r.start.toId) || r.end && !t.some((i) => i.id === r.end.toId))
            return !1;
        }
      return !0;
    },
    [n]
  );
}, TZ = () => {
  const n = we();
  return De(
    "allowUngroup",
    () => n.getSelectedShapeIds().some((t) => {
      var e;
      return ((e = n.getShape(t)) == null ? void 0 : e.type) === "group";
    }),
    [n]
  );
}, DAe = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read;
function PZ(n, t) {
  const e = we();
  return De(
    "selectedShapes",
    () => e.getSelectedShapes().length >= n,
    [e, n, t]
  );
}
function Xa(n, t) {
  const e = we();
  return De(
    "selectedShapes",
    () => {
      const r = e.getSelectedShapes().filter((i) => !e.isShapeOrAncestorLocked(i)).length;
      return n === void 0 ? r : r >= n;
    },
    [e]
  );
}
function OAe() {
  const n = we();
  return De(
    "showAutoSizeToggle",
    () => {
      const t = n.getSelectedShapes();
      return t.length === 1 && n.isShapeOfType(t[0], "text") && t[0].props.autoSize === !1;
    },
    [n]
  );
}
function AZ() {
  const n = we();
  return De(
    "hasLinkShapeSelected",
    () => {
      const t = n.getOnlySelectedShape();
      return !!(t && t.type !== "embed" && "url" in t.props && !t.isLocked);
    },
    [n]
  );
}
function LAe() {
  const n = we();
  return De(
    "onlyFlippableShape",
    () => {
      const t = n.getOnlySelectedShape();
      return t && (n.isShapeOfType(t, "group") || n.isShapeOfType(t, "image") || n.isShapeOfType(t, "arrow") || n.isShapeOfType(t, "line") || n.isShapeOfType(t, "draw"));
    },
    [n]
  );
}
function kZ() {
  const n = we();
  return De("useCanRedo", () => n.getCanRedo(), [n]);
}
function IZ() {
  const n = we();
  return De("useCanUndo", () => n.getCanUndo(), [n]);
}
var jAe = D.createContext(void 0);
function wU(n) {
  const t = D.useContext(jAe);
  return n || t || "ltr";
}
var uF = "rovingFocusGroup.onEntryFocus", NAe = { bubbles: !1, cancelable: !0 }, cD = "RovingFocusGroup", [X3, RZ, FAe] = q2(cD), [$Ae, MZ] = jh(
  cD,
  [FAe]
), [zAe, UAe] = $Ae(cD), DZ = D.forwardRef(
  (n, t) => /* @__PURE__ */ y.jsx(X3.Provider, { scope: n.__scopeRovingFocusGroup, children: /* @__PURE__ */ y.jsx(X3.Slot, { scope: n.__scopeRovingFocusGroup, children: /* @__PURE__ */ y.jsx(BAe, { ...n, ref: t }) }) })
);
DZ.displayName = cD;
var BAe = D.forwardRef((n, t) => {
  const {
    __scopeRovingFocusGroup: e,
    orientation: r,
    loop: i = !1,
    dir: s,
    currentTabStopId: o,
    defaultCurrentTabStopId: l,
    onCurrentTabStopIdChange: u,
    onEntryFocus: d,
    preventScrollOnEntryFocus: f = !1,
    ...m
  } = n, v = D.useRef(null), S = si(t, v), w = wU(s), [E = null, A] = Dm({
    prop: o,
    defaultProp: l,
    onChange: u
  }), [P, R] = D.useState(!1), M = jo(d), j = RZ(e), $ = D.useRef(!1), [U, F] = D.useState(0);
  return D.useEffect(() => {
    const B = v.current;
    if (B)
      return B.addEventListener(uF, M), () => B.removeEventListener(uF, M);
  }, [M]), /* @__PURE__ */ y.jsx(
    zAe,
    {
      scope: e,
      orientation: r,
      dir: w,
      loop: i,
      currentTabStopId: E,
      onItemFocus: D.useCallback(
        (B) => A(B),
        [A]
      ),
      onItemShiftTab: D.useCallback(() => R(!0), []),
      onFocusableItemAdd: D.useCallback(
        () => F((B) => B + 1),
        []
      ),
      onFocusableItemRemove: D.useCallback(
        () => F((B) => B - 1),
        []
      ),
      children: /* @__PURE__ */ y.jsx(
        sr.div,
        {
          tabIndex: P || U === 0 ? -1 : 0,
          "data-orientation": r,
          ...m,
          ref: S,
          style: { outline: "none", ...n.style },
          onMouseDown: Et(n.onMouseDown, () => {
            $.current = !0;
          }),
          onFocus: Et(n.onFocus, (B) => {
            const G = !$.current;
            if (B.target === B.currentTarget && G && !P) {
              const X = new CustomEvent(uF, NAe);
              if (B.currentTarget.dispatchEvent(X), !X.defaultPrevented) {
                const te = j().filter((fe) => fe.focusable), ne = te.find((fe) => fe.active), K = te.find((fe) => fe.id === E), oe = [ne, K, ...te].filter(
                  Boolean
                ).map((fe) => fe.ref.current);
                jZ(oe, f);
              }
            }
            $.current = !1;
          }),
          onBlur: Et(n.onBlur, () => R(!1))
        }
      )
    }
  );
}), OZ = "RovingFocusGroupItem", LZ = D.forwardRef(
  (n, t) => {
    const {
      __scopeRovingFocusGroup: e,
      focusable: r = !0,
      active: i = !1,
      tabStopId: s,
      ...o
    } = n, l = hp(), u = s || l, d = UAe(OZ, e), f = d.currentTabStopId === u, m = RZ(e), { onFocusableItemAdd: v, onFocusableItemRemove: S } = d;
    return D.useEffect(() => {
      if (r)
        return v(), () => S();
    }, [r, v, S]), /* @__PURE__ */ y.jsx(
      X3.ItemSlot,
      {
        scope: e,
        id: u,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ y.jsx(
          sr.span,
          {
            tabIndex: f ? 0 : -1,
            "data-orientation": d.orientation,
            ...o,
            ref: t,
            onMouseDown: Et(n.onMouseDown, (w) => {
              r ? d.onItemFocus(u) : w.preventDefault();
            }),
            onFocus: Et(n.onFocus, () => d.onItemFocus(u)),
            onKeyDown: Et(n.onKeyDown, (w) => {
              if (w.key === "Tab" && w.shiftKey) {
                d.onItemShiftTab();
                return;
              }
              if (w.target !== w.currentTarget) return;
              const E = WAe(w, d.orientation, d.dir);
              if (E !== void 0) {
                if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
                w.preventDefault();
                let P = m().filter((R) => R.focusable).map((R) => R.ref.current);
                if (E === "last") P.reverse();
                else if (E === "prev" || E === "next") {
                  E === "prev" && P.reverse();
                  const R = P.indexOf(w.currentTarget);
                  P = d.loop ? GAe(P, R + 1) : P.slice(R + 1);
                }
                setTimeout(() => jZ(P));
              }
            })
          }
        )
      }
    );
  }
);
LZ.displayName = OZ;
var HAe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function VAe(n, t) {
  return t !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
}
function WAe(n, t, e) {
  const r = VAe(n.key, e);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return HAe[r];
}
function jZ(n, t = !1) {
  const e = document.activeElement;
  for (const r of n)
    if (r === e || (r.focus({ preventScroll: t }), document.activeElement !== e)) return;
}
function GAe(n, t) {
  return n.map((e, r) => n[(t + r) % n.length]);
}
var KAe = DZ, YAe = LZ, q3 = ["Enter", " "], XAe = ["ArrowDown", "PageUp", "Home"], NZ = ["ArrowUp", "PageDown", "End"], qAe = [...XAe, ...NZ], ZAe = {
  ltr: [...q3, "ArrowRight"],
  rtl: [...q3, "ArrowLeft"]
}, QAe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, QT = "Menu", [Y1, JAe, eke] = q2(QT), [CS, uD] = jh(QT, [
  eke,
  aD,
  MZ
]), JT = aD(), FZ = MZ(), [$Z, Lm] = CS(QT), [tke, eP] = CS(QT), zZ = (n) => {
  const { __scopeMenu: t, open: e = !1, children: r, dir: i, onOpenChange: s, modal: o = !0 } = n, l = JT(t), [u, d] = D.useState(null), f = D.useRef(!1), m = jo(s), v = wU(i);
  return D.useEffect(() => {
    const S = () => {
      f.current = !0, document.addEventListener("pointerdown", w, { capture: !0, once: !0 }), document.addEventListener("pointermove", w, { capture: !0, once: !0 });
    }, w = () => f.current = !1;
    return document.addEventListener("keydown", S, { capture: !0 }), () => {
      document.removeEventListener("keydown", S, { capture: !0 }), document.removeEventListener("pointerdown", w, { capture: !0 }), document.removeEventListener("pointermove", w, { capture: !0 });
    };
  }, []), /* @__PURE__ */ y.jsx(dU, { ...l, children: /* @__PURE__ */ y.jsx(
    $Z,
    {
      scope: t,
      open: e,
      onOpenChange: m,
      content: u,
      onContentChange: d,
      children: /* @__PURE__ */ y.jsx(
        tke,
        {
          scope: t,
          onClose: D.useCallback(() => m(!1), [m]),
          isUsingKeyboardRef: f,
          dir: v,
          modal: o,
          children: r
        }
      )
    }
  ) });
};
zZ.displayName = QT;
var nke = "MenuAnchor", CU = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, ...r } = n, i = JT(e);
    return /* @__PURE__ */ y.jsx(hU, { ...i, ...r, ref: t });
  }
);
CU.displayName = nke;
var EU = "MenuPortal", [rke, UZ] = CS(EU, {
  forceMount: void 0
}), BZ = (n) => {
  const { __scopeMenu: t, forceMount: e, children: r, container: i } = n, s = Lm(EU, t);
  return /* @__PURE__ */ y.jsx(rke, { scope: t, forceMount: e, children: /* @__PURE__ */ y.jsx(fd, { present: e || s.open, children: /* @__PURE__ */ y.jsx(XT, { asChild: !0, container: i, children: r }) }) });
};
BZ.displayName = EU;
var au = "MenuContent", [ike, _U] = CS(au), HZ = D.forwardRef(
  (n, t) => {
    const e = UZ(au, n.__scopeMenu), { forceMount: r = e.forceMount, ...i } = n, s = Lm(au, n.__scopeMenu), o = eP(au, n.__scopeMenu);
    return /* @__PURE__ */ y.jsx(Y1.Provider, { scope: n.__scopeMenu, children: /* @__PURE__ */ y.jsx(fd, { present: r || s.open, children: /* @__PURE__ */ y.jsx(Y1.Slot, { scope: n.__scopeMenu, children: o.modal ? /* @__PURE__ */ y.jsx(ske, { ...i, ref: t }) : /* @__PURE__ */ y.jsx(oke, { ...i, ref: t }) }) }) });
  }
), ske = D.forwardRef(
  (n, t) => {
    const e = Lm(au, n.__scopeMenu), r = D.useRef(null), i = si(t, r);
    return D.useEffect(() => {
      const s = r.current;
      if (s) return G5(s);
    }, []), /* @__PURE__ */ y.jsx(
      TU,
      {
        ...n,
        ref: i,
        trapFocus: e.open,
        disableOutsidePointerEvents: e.open,
        disableOutsideScroll: !0,
        onFocusOutside: Et(
          n.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => e.onOpenChange(!1)
      }
    );
  }
), oke = D.forwardRef((n, t) => {
  const e = Lm(au, n.__scopeMenu);
  return /* @__PURE__ */ y.jsx(
    TU,
    {
      ...n,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => e.onOpenChange(!1)
    }
  );
}), TU = D.forwardRef(
  (n, t) => {
    const {
      __scopeMenu: e,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: s,
      onCloseAutoFocus: o,
      disableOutsidePointerEvents: l,
      onEntryFocus: u,
      onEscapeKeyDown: d,
      onPointerDownOutside: f,
      onFocusOutside: m,
      onInteractOutside: v,
      onDismiss: S,
      disableOutsideScroll: w,
      ...E
    } = n, A = Lm(au, e), P = eP(au, e), R = JT(e), M = FZ(e), j = JAe(e), [$, U] = D.useState(null), F = D.useRef(null), B = si(t, F, A.onContentChange), G = D.useRef(0), X = D.useRef(""), te = D.useRef(0), ne = D.useRef(null), K = D.useRef("right"), Z = D.useRef(0), oe = w ? X2 : D.Fragment, fe = w ? { as: sS, allowPinchZoom: !0 } : void 0, ie = (Se) => {
      var Ze, tt;
      const ke = X.current + Se, ce = j().filter((et) => !et.disabled), ye = document.activeElement, Fe = (Ze = ce.find((et) => et.ref.current === ye)) == null ? void 0 : Ze.textValue, Xe = ce.map((et) => et.textValue), je = yke(Xe, ke, Fe), nt = (tt = ce.find((et) => et.textValue === je)) == null ? void 0 : tt.ref.current;
      (function et(at) {
        X.current = at, window.clearTimeout(G.current), at !== "" && (G.current = window.setTimeout(() => et(""), 1e3));
      })(ke), nt && setTimeout(() => nt.focus());
    };
    D.useEffect(() => () => window.clearTimeout(G.current), []), W5();
    const ue = D.useCallback((Se) => {
      var ce, ye;
      return K.current === ((ce = ne.current) == null ? void 0 : ce.side) && bke(Se, (ye = ne.current) == null ? void 0 : ye.area);
    }, []);
    return /* @__PURE__ */ y.jsx(
      ike,
      {
        scope: e,
        searchRef: X,
        onItemEnter: D.useCallback(
          (Se) => {
            ue(Se) && Se.preventDefault();
          },
          [ue]
        ),
        onItemLeave: D.useCallback(
          (Se) => {
            var ke;
            ue(Se) || ((ke = F.current) == null || ke.focus(), U(null));
          },
          [ue]
        ),
        onTriggerLeave: D.useCallback(
          (Se) => {
            ue(Se) && Se.preventDefault();
          },
          [ue]
        ),
        pointerGraceTimerRef: te,
        onPointerGraceIntentChange: D.useCallback((Se) => {
          ne.current = Se;
        }, []),
        children: /* @__PURE__ */ y.jsx(oe, { ...fe, children: /* @__PURE__ */ y.jsx(
          K2,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: Et(s, (Se) => {
              var ke;
              Se.preventDefault(), (ke = F.current) == null || ke.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: o,
            children: /* @__PURE__ */ y.jsx(
              YT,
              {
                asChild: !0,
                disableOutsidePointerEvents: l,
                onEscapeKeyDown: d,
                onPointerDownOutside: f,
                onFocusOutside: m,
                onInteractOutside: v,
                onDismiss: S,
                children: /* @__PURE__ */ y.jsx(
                  KAe,
                  {
                    asChild: !0,
                    ...M,
                    dir: P.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: $,
                    onCurrentTabStopIdChange: U,
                    onEntryFocus: Et(u, (Se) => {
                      P.isUsingKeyboardRef.current || Se.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ y.jsx(
                      dZ,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": oQ(A.open),
                        "data-radix-menu-content": "",
                        dir: P.dir,
                        ...R,
                        ...E,
                        ref: B,
                        style: { outline: "none", ...E.style },
                        onKeyDown: Et(E.onKeyDown, (Se) => {
                          const ce = Se.target.closest("[data-radix-menu-content]") === Se.currentTarget, ye = Se.ctrlKey || Se.altKey || Se.metaKey, Fe = Se.key.length === 1;
                          ce && (Se.key === "Tab" && Se.preventDefault(), !ye && Fe && ie(Se.key));
                          const Xe = F.current;
                          if (Se.target !== Xe || !qAe.includes(Se.key)) return;
                          Se.preventDefault();
                          const nt = j().filter((Ze) => !Ze.disabled).map((Ze) => Ze.ref.current);
                          NZ.includes(Se.key) && nt.reverse(), mke(nt);
                        }),
                        onBlur: Et(n.onBlur, (Se) => {
                          Se.currentTarget.contains(Se.target) || (window.clearTimeout(G.current), X.current = "");
                        }),
                        onPointerMove: Et(
                          n.onPointerMove,
                          X1((Se) => {
                            const ke = Se.target, ce = Z.current !== Se.clientX;
                            if (Se.currentTarget.contains(ke) && ce) {
                              const ye = Se.clientX > Z.current ? "right" : "left";
                              K.current = ye, Z.current = Se.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
HZ.displayName = au;
var ake = "MenuGroup", PU = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, ...r } = n;
    return /* @__PURE__ */ y.jsx(sr.div, { role: "group", ...r, ref: t });
  }
);
PU.displayName = ake;
var lke = "MenuLabel", VZ = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, ...r } = n;
    return /* @__PURE__ */ y.jsx(sr.div, { ...r, ref: t });
  }
);
VZ.displayName = lke;
var HM = "MenuItem", vV = "menu.itemSelect", dD = D.forwardRef(
  (n, t) => {
    const { disabled: e = !1, onSelect: r, ...i } = n, s = D.useRef(null), o = eP(HM, n.__scopeMenu), l = _U(HM, n.__scopeMenu), u = si(t, s), d = D.useRef(!1), f = () => {
      const m = s.current;
      if (!e && m) {
        const v = new CustomEvent(vV, { bubbles: !0, cancelable: !0 });
        m.addEventListener(vV, (S) => r == null ? void 0 : r(S), { once: !0 }), V5(m, v), v.defaultPrevented ? d.current = !1 : o.onClose();
      }
    };
    return /* @__PURE__ */ y.jsx(
      WZ,
      {
        ...i,
        ref: u,
        disabled: e,
        onClick: Et(n.onClick, f),
        onPointerDown: (m) => {
          var v;
          (v = n.onPointerDown) == null || v.call(n, m), d.current = !0;
        },
        onPointerUp: Et(n.onPointerUp, (m) => {
          var v;
          d.current || (v = m.currentTarget) == null || v.click();
        }),
        onKeyDown: Et(n.onKeyDown, (m) => {
          const v = l.searchRef.current !== "";
          e || v && m.key === " " || q3.includes(m.key) && (m.currentTarget.click(), m.preventDefault());
        })
      }
    );
  }
);
dD.displayName = HM;
var WZ = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, disabled: r = !1, textValue: i, ...s } = n, o = _U(HM, e), l = FZ(e), u = D.useRef(null), d = si(t, u), [f, m] = D.useState(!1), [v, S] = D.useState("");
    return D.useEffect(() => {
      const w = u.current;
      w && S((w.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ y.jsx(
      Y1.ItemSlot,
      {
        scope: e,
        disabled: r,
        textValue: i ?? v,
        children: /* @__PURE__ */ y.jsx(YAe, { asChild: !0, ...l, focusable: !r, children: /* @__PURE__ */ y.jsx(
          sr.div,
          {
            role: "menuitem",
            "data-highlighted": f ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...s,
            ref: d,
            onPointerMove: Et(
              n.onPointerMove,
              X1((w) => {
                r ? o.onItemLeave(w) : (o.onItemEnter(w), w.defaultPrevented || w.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Et(
              n.onPointerLeave,
              X1((w) => o.onItemLeave(w))
            ),
            onFocus: Et(n.onFocus, () => m(!0)),
            onBlur: Et(n.onBlur, () => m(!1))
          }
        ) })
      }
    );
  }
), cke = "MenuCheckboxItem", GZ = D.forwardRef(
  (n, t) => {
    const { checked: e = !1, onCheckedChange: r, ...i } = n;
    return /* @__PURE__ */ y.jsx(ZZ, { scope: n.__scopeMenu, checked: e, children: /* @__PURE__ */ y.jsx(
      dD,
      {
        role: "menuitemcheckbox",
        "aria-checked": VM(e) ? "mixed" : e,
        ...i,
        ref: t,
        "data-state": IU(e),
        onSelect: Et(
          i.onSelect,
          () => r == null ? void 0 : r(VM(e) ? !0 : !e),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
GZ.displayName = cke;
var KZ = "MenuRadioGroup", [uke, dke] = CS(
  KZ,
  { value: void 0, onValueChange: () => {
  } }
), YZ = D.forwardRef(
  (n, t) => {
    const { value: e, onValueChange: r, ...i } = n, s = jo(r);
    return /* @__PURE__ */ y.jsx(uke, { scope: n.__scopeMenu, value: e, onValueChange: s, children: /* @__PURE__ */ y.jsx(PU, { ...i, ref: t }) });
  }
);
YZ.displayName = KZ;
var XZ = "MenuRadioItem", qZ = D.forwardRef(
  (n, t) => {
    const { value: e, ...r } = n, i = dke(XZ, n.__scopeMenu), s = e === i.value;
    return /* @__PURE__ */ y.jsx(ZZ, { scope: n.__scopeMenu, checked: s, children: /* @__PURE__ */ y.jsx(
      dD,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...r,
        ref: t,
        "data-state": IU(s),
        onSelect: Et(
          r.onSelect,
          () => {
            var o;
            return (o = i.onValueChange) == null ? void 0 : o.call(i, e);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
qZ.displayName = XZ;
var AU = "MenuItemIndicator", [ZZ, hke] = CS(
  AU,
  { checked: !1 }
), QZ = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, forceMount: r, ...i } = n, s = hke(AU, e);
    return /* @__PURE__ */ y.jsx(
      fd,
      {
        present: r || VM(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ y.jsx(
          sr.span,
          {
            ...i,
            ref: t,
            "data-state": IU(s.checked)
          }
        )
      }
    );
  }
);
QZ.displayName = AU;
var fke = "MenuSeparator", JZ = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, ...r } = n;
    return /* @__PURE__ */ y.jsx(
      sr.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
JZ.displayName = fke;
var pke = "MenuArrow", eQ = D.forwardRef(
  (n, t) => {
    const { __scopeMenu: e, ...r } = n, i = JT(e);
    return /* @__PURE__ */ y.jsx(hZ, { ...i, ...r, ref: t });
  }
);
eQ.displayName = pke;
var kU = "MenuSub", [gke, tQ] = CS(kU), nQ = (n) => {
  const { __scopeMenu: t, children: e, open: r = !1, onOpenChange: i } = n, s = Lm(kU, t), o = JT(t), [l, u] = D.useState(null), [d, f] = D.useState(null), m = jo(i);
  return D.useEffect(() => (s.open === !1 && m(!1), () => m(!1)), [s.open, m]), /* @__PURE__ */ y.jsx(dU, { ...o, children: /* @__PURE__ */ y.jsx(
    $Z,
    {
      scope: t,
      open: r,
      onOpenChange: m,
      content: d,
      onContentChange: f,
      children: /* @__PURE__ */ y.jsx(
        gke,
        {
          scope: t,
          contentId: hp(),
          triggerId: hp(),
          trigger: l,
          onTriggerChange: u,
          children: e
        }
      )
    }
  ) });
};
nQ.displayName = kU;
var l1 = "MenuSubTrigger", rQ = D.forwardRef(
  (n, t) => {
    const e = Lm(l1, n.__scopeMenu), r = eP(l1, n.__scopeMenu), i = tQ(l1, n.__scopeMenu), s = _U(l1, n.__scopeMenu), o = D.useRef(null), { pointerGraceTimerRef: l, onPointerGraceIntentChange: u } = s, d = { __scopeMenu: n.__scopeMenu }, f = D.useCallback(() => {
      o.current && window.clearTimeout(o.current), o.current = null;
    }, []);
    return D.useEffect(() => f, [f]), D.useEffect(() => {
      const m = l.current;
      return () => {
        window.clearTimeout(m), u(null);
      };
    }, [l, u]), /* @__PURE__ */ y.jsx(CU, { asChild: !0, ...d, children: /* @__PURE__ */ y.jsx(
      WZ,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": e.open,
        "aria-controls": i.contentId,
        "data-state": oQ(e.open),
        ...n,
        ref: G2(t, i.onTriggerChange),
        onClick: (m) => {
          var v;
          (v = n.onClick) == null || v.call(n, m), !(n.disabled || m.defaultPrevented) && (m.currentTarget.focus(), e.open || e.onOpenChange(!0));
        },
        onPointerMove: Et(
          n.onPointerMove,
          X1((m) => {
            s.onItemEnter(m), !m.defaultPrevented && !n.disabled && !e.open && !o.current && (s.onPointerGraceIntentChange(null), o.current = window.setTimeout(() => {
              e.onOpenChange(!0), f();
            }, 100));
          })
        ),
        onPointerLeave: Et(
          n.onPointerLeave,
          X1((m) => {
            var S, w;
            f();
            const v = (S = e.content) == null ? void 0 : S.getBoundingClientRect();
            if (v) {
              const E = (w = e.content) == null ? void 0 : w.dataset.side, A = E === "right", P = A ? -5 : 5, R = v[A ? "left" : "right"], M = v[A ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: m.clientX + P, y: m.clientY },
                  { x: R, y: v.top },
                  { x: M, y: v.top },
                  { x: M, y: v.bottom },
                  { x: R, y: v.bottom }
                ],
                side: E
              }), window.clearTimeout(l.current), l.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(m), m.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Et(n.onKeyDown, (m) => {
          var S;
          const v = s.searchRef.current !== "";
          n.disabled || v && m.key === " " || ZAe[r.dir].includes(m.key) && (e.onOpenChange(!0), (S = e.content) == null || S.focus(), m.preventDefault());
        })
      }
    ) });
  }
);
rQ.displayName = l1;
var iQ = "MenuSubContent", sQ = D.forwardRef(
  (n, t) => {
    const e = UZ(au, n.__scopeMenu), { forceMount: r = e.forceMount, ...i } = n, s = Lm(au, n.__scopeMenu), o = eP(au, n.__scopeMenu), l = tQ(iQ, n.__scopeMenu), u = D.useRef(null), d = si(t, u);
    return /* @__PURE__ */ y.jsx(Y1.Provider, { scope: n.__scopeMenu, children: /* @__PURE__ */ y.jsx(fd, { present: r || s.open, children: /* @__PURE__ */ y.jsx(Y1.Slot, { scope: n.__scopeMenu, children: /* @__PURE__ */ y.jsx(
      TU,
      {
        id: l.contentId,
        "aria-labelledby": l.triggerId,
        ...i,
        ref: d,
        align: "start",
        side: o.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (f) => {
          var m;
          o.isUsingKeyboardRef.current && ((m = u.current) == null || m.focus()), f.preventDefault();
        },
        onCloseAutoFocus: (f) => f.preventDefault(),
        onFocusOutside: Et(n.onFocusOutside, (f) => {
          f.target !== l.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: Et(n.onEscapeKeyDown, (f) => {
          o.onClose(), f.preventDefault();
        }),
        onKeyDown: Et(n.onKeyDown, (f) => {
          var S;
          const m = f.currentTarget.contains(f.target), v = QAe[o.dir].includes(f.key);
          m && v && (s.onOpenChange(!1), (S = l.trigger) == null || S.focus(), f.preventDefault());
        })
      }
    ) }) }) });
  }
);
sQ.displayName = iQ;
function oQ(n) {
  return n ? "open" : "closed";
}
function VM(n) {
  return n === "indeterminate";
}
function IU(n) {
  return VM(n) ? "indeterminate" : n ? "checked" : "unchecked";
}
function mke(n) {
  const t = document.activeElement;
  for (const e of n)
    if (e === t || (e.focus(), document.activeElement !== t)) return;
}
function vke(n, t) {
  return n.map((e, r) => n[(t + r) % n.length]);
}
function yke(n, t, e) {
  const i = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, s = e ? n.indexOf(e) : -1;
  let o = vke(n, Math.max(s, 0));
  i.length === 1 && (o = o.filter((d) => d !== e));
  const u = o.find(
    (d) => d.toLowerCase().startsWith(i.toLowerCase())
  );
  return u !== e ? u : void 0;
}
function Ske(n, t) {
  const { x: e, y: r } = n;
  let i = !1;
  for (let s = 0, o = t.length - 1; s < t.length; o = s++) {
    const l = t[s].x, u = t[s].y, d = t[o].x, f = t[o].y;
    u > r != f > r && e < (d - l) * (r - u) / (f - u) + l && (i = !i);
  }
  return i;
}
function bke(n, t) {
  if (!t) return !1;
  const e = { x: n.clientX, y: n.clientY };
  return Ske(e, t);
}
function X1(n) {
  return (t) => t.pointerType === "mouse" ? n(t) : void 0;
}
var aQ = zZ, lQ = CU, cQ = BZ, uQ = HZ, dQ = PU, hQ = VZ, fQ = dD, pQ = GZ, gQ = YZ, mQ = qZ, vQ = QZ, yQ = JZ, SQ = eQ, bQ = nQ, xQ = rQ, wQ = sQ, RU = "ContextMenu", [xke, jNe] = jh(RU, [
  uD
]), Sa = uD(), [wke, CQ] = xke(RU), EQ = (n) => {
  const { __scopeContextMenu: t, children: e, onOpenChange: r, dir: i, modal: s = !0 } = n, [o, l] = D.useState(!1), u = Sa(t), d = jo(r), f = D.useCallback(
    (m) => {
      l(m), d(m);
    },
    [d]
  );
  return /* @__PURE__ */ y.jsx(
    wke,
    {
      scope: t,
      open: o,
      onOpenChange: f,
      modal: s,
      children: /* @__PURE__ */ y.jsx(
        aQ,
        {
          ...u,
          dir: i,
          open: o,
          onOpenChange: f,
          modal: s,
          children: e
        }
      )
    }
  );
};
EQ.displayName = RU;
var _Q = "ContextMenuTrigger", TQ = D.forwardRef(
  (n, t) => {
    const { __scopeContextMenu: e, disabled: r = !1, ...i } = n, s = CQ(_Q, e), o = Sa(e), l = D.useRef({ x: 0, y: 0 }), u = D.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...l.current })
    }), d = D.useRef(0), f = D.useCallback(
      () => window.clearTimeout(d.current),
      []
    ), m = (v) => {
      l.current = { x: v.clientX, y: v.clientY }, s.onOpenChange(!0);
    };
    return D.useEffect(() => f, [f]), D.useEffect(() => void (r && f()), [r, f]), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(lQ, { ...o, virtualRef: u }),
      /* @__PURE__ */ y.jsx(
        sr.span,
        {
          "data-state": s.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          ...i,
          ref: t,
          style: { WebkitTouchCallout: "none", ...n.style },
          onContextMenu: r ? n.onContextMenu : Et(n.onContextMenu, (v) => {
            f(), m(v), v.preventDefault();
          }),
          onPointerDown: r ? n.onPointerDown : Et(
            n.onPointerDown,
            jI((v) => {
              f(), d.current = window.setTimeout(() => m(v), 700);
            })
          ),
          onPointerMove: r ? n.onPointerMove : Et(n.onPointerMove, jI(f)),
          onPointerCancel: r ? n.onPointerCancel : Et(n.onPointerCancel, jI(f)),
          onPointerUp: r ? n.onPointerUp : Et(n.onPointerUp, jI(f))
        }
      )
    ] });
  }
);
TQ.displayName = _Q;
var Cke = "ContextMenuPortal", MU = (n) => {
  const { __scopeContextMenu: t, ...e } = n, r = Sa(t);
  return /* @__PURE__ */ y.jsx(cQ, { ...r, ...e });
};
MU.displayName = Cke;
var PQ = "ContextMenuContent", AQ = D.forwardRef(
  (n, t) => {
    const { __scopeContextMenu: e, ...r } = n, i = CQ(PQ, e), s = Sa(e), o = D.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      uQ,
      {
        ...s,
        ...r,
        ref: t,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (l) => {
          var u;
          (u = n.onCloseAutoFocus) == null || u.call(n, l), !l.defaultPrevented && o.current && l.preventDefault(), o.current = !1;
        },
        onInteractOutside: (l) => {
          var u;
          (u = n.onInteractOutside) == null || u.call(n, l), !l.defaultPrevented && !i.modal && (o.current = !0);
        },
        style: {
          ...n.style,
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
AQ.displayName = PQ;
var Eke = "ContextMenuGroup", kQ = D.forwardRef(
  (n, t) => {
    const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
    return /* @__PURE__ */ y.jsx(dQ, { ...i, ...r, ref: t });
  }
);
kQ.displayName = Eke;
var _ke = "ContextMenuLabel", Tke = D.forwardRef(
  (n, t) => {
    const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
    return /* @__PURE__ */ y.jsx(hQ, { ...i, ...r, ref: t });
  }
);
Tke.displayName = _ke;
var Pke = "ContextMenuItem", IQ = D.forwardRef(
  (n, t) => {
    const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
    return /* @__PURE__ */ y.jsx(fQ, { ...i, ...r, ref: t });
  }
);
IQ.displayName = Pke;
var Ake = "ContextMenuCheckboxItem", RQ = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(pQ, { ...i, ...r, ref: t });
});
RQ.displayName = Ake;
var kke = "ContextMenuRadioGroup", Ike = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(gQ, { ...i, ...r, ref: t });
});
Ike.displayName = kke;
var Rke = "ContextMenuRadioItem", Mke = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(mQ, { ...i, ...r, ref: t });
});
Mke.displayName = Rke;
var Dke = "ContextMenuItemIndicator", Oke = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(vQ, { ...i, ...r, ref: t });
});
Oke.displayName = Dke;
var Lke = "ContextMenuSeparator", jke = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(yQ, { ...i, ...r, ref: t });
});
jke.displayName = Lke;
var Nke = "ContextMenuArrow", Fke = D.forwardRef(
  (n, t) => {
    const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
    return /* @__PURE__ */ y.jsx(SQ, { ...i, ...r, ref: t });
  }
);
Fke.displayName = Nke;
var $ke = "ContextMenuSub", MQ = (n) => {
  const { __scopeContextMenu: t, children: e, onOpenChange: r, open: i, defaultOpen: s } = n, o = Sa(t), [l, u] = Dm({
    prop: i,
    defaultProp: s,
    onChange: r
  });
  return /* @__PURE__ */ y.jsx(bQ, { ...o, open: l, onOpenChange: u, children: e });
};
MQ.displayName = $ke;
var zke = "ContextMenuSubTrigger", DQ = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(xQ, { ...i, ...r, ref: t });
});
DQ.displayName = zke;
var Uke = "ContextMenuSubContent", OQ = D.forwardRef((n, t) => {
  const { __scopeContextMenu: e, ...r } = n, i = Sa(e);
  return /* @__PURE__ */ y.jsx(
    wQ,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...n.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
OQ.displayName = Uke;
function jI(n) {
  return (t) => t.pointerType !== "mouse" ? n(t) : void 0;
}
var Bke = EQ, Hke = TQ, Vke = MU, Wke = AQ, Gke = RQ;
const LQ = typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().indexOf("mac") > -1, Kke = LQ ? "⌘" : "Ctrl", Yke = LQ ? "⌥" : "Alt";
function jQ(n) {
  return n.split(",")[0].split("").map((t) => {
    const e = t.replace(/\$/g, Kke).replace(/\?/g, Yke).replace(/!/g, "⇧");
    return e[0].toUpperCase() + e.slice(1);
  });
}
function Z3(n) {
  return "— " + jQ(n).join(" ");
}
function Xke(n) {
  return /* @__PURE__ */ y.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", ...n, children: /* @__PURE__ */ y.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ y.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ y.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ y.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
var DU = "DropdownMenu", [qke, NNe] = jh(
  DU,
  [uD]
), ba = uD(), [Zke, NQ] = qke(DU), FQ = (n) => {
  const {
    __scopeDropdownMenu: t,
    children: e,
    dir: r,
    open: i,
    defaultOpen: s,
    onOpenChange: o,
    modal: l = !0
  } = n, u = ba(t), d = D.useRef(null), [f = !1, m] = Dm({
    prop: i,
    defaultProp: s,
    onChange: o
  });
  return /* @__PURE__ */ y.jsx(
    Zke,
    {
      scope: t,
      triggerId: hp(),
      triggerRef: d,
      contentId: hp(),
      open: f,
      onOpenChange: m,
      onOpenToggle: D.useCallback(() => m((v) => !v), [m]),
      modal: l,
      children: /* @__PURE__ */ y.jsx(aQ, { ...u, open: f, onOpenChange: m, dir: r, modal: l, children: e })
    }
  );
};
FQ.displayName = DU;
var $Q = "DropdownMenuTrigger", zQ = D.forwardRef(
  (n, t) => {
    const { __scopeDropdownMenu: e, disabled: r = !1, ...i } = n, s = NQ($Q, e), o = ba(e);
    return /* @__PURE__ */ y.jsx(lQ, { asChild: !0, ...o, children: /* @__PURE__ */ y.jsx(
      sr.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: G2(t, s.triggerRef),
        onPointerDown: Et(n.onPointerDown, (l) => {
          !r && l.button === 0 && l.ctrlKey === !1 && (s.onOpenToggle(), s.open || l.preventDefault());
        }),
        onKeyDown: Et(n.onKeyDown, (l) => {
          r || (["Enter", " "].includes(l.key) && s.onOpenToggle(), l.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(l.key) && l.preventDefault());
        })
      }
    ) });
  }
);
zQ.displayName = $Q;
var Qke = "DropdownMenuPortal", UQ = (n) => {
  const { __scopeDropdownMenu: t, ...e } = n, r = ba(t);
  return /* @__PURE__ */ y.jsx(cQ, { ...r, ...e });
};
UQ.displayName = Qke;
var BQ = "DropdownMenuContent", HQ = D.forwardRef(
  (n, t) => {
    const { __scopeDropdownMenu: e, ...r } = n, i = NQ(BQ, e), s = ba(e), o = D.useRef(!1);
    return /* @__PURE__ */ y.jsx(
      uQ,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...s,
        ...r,
        ref: t,
        onCloseAutoFocus: Et(n.onCloseAutoFocus, (l) => {
          var u;
          o.current || (u = i.triggerRef.current) == null || u.focus(), o.current = !1, l.preventDefault();
        }),
        onInteractOutside: Et(n.onInteractOutside, (l) => {
          const u = l.detail.originalEvent, d = u.button === 0 && u.ctrlKey === !0, f = u.button === 2 || d;
          (!i.modal || f) && (o.current = !0);
        }),
        style: {
          ...n.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
HQ.displayName = BQ;
var Jke = "DropdownMenuGroup", VQ = D.forwardRef(
  (n, t) => {
    const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
    return /* @__PURE__ */ y.jsx(dQ, { ...i, ...r, ref: t });
  }
);
VQ.displayName = Jke;
var eIe = "DropdownMenuLabel", tIe = D.forwardRef(
  (n, t) => {
    const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
    return /* @__PURE__ */ y.jsx(hQ, { ...i, ...r, ref: t });
  }
);
tIe.displayName = eIe;
var nIe = "DropdownMenuItem", WQ = D.forwardRef(
  (n, t) => {
    const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
    return /* @__PURE__ */ y.jsx(fQ, { ...i, ...r, ref: t });
  }
);
WQ.displayName = nIe;
var rIe = "DropdownMenuCheckboxItem", GQ = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(pQ, { ...i, ...r, ref: t });
});
GQ.displayName = rIe;
var iIe = "DropdownMenuRadioGroup", sIe = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(gQ, { ...i, ...r, ref: t });
});
sIe.displayName = iIe;
var oIe = "DropdownMenuRadioItem", aIe = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(mQ, { ...i, ...r, ref: t });
});
aIe.displayName = oIe;
var lIe = "DropdownMenuItemIndicator", cIe = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(vQ, { ...i, ...r, ref: t });
});
cIe.displayName = lIe;
var uIe = "DropdownMenuSeparator", dIe = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(yQ, { ...i, ...r, ref: t });
});
dIe.displayName = uIe;
var hIe = "DropdownMenuArrow", fIe = D.forwardRef(
  (n, t) => {
    const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
    return /* @__PURE__ */ y.jsx(SQ, { ...i, ...r, ref: t });
  }
);
fIe.displayName = hIe;
var pIe = (n) => {
  const { __scopeDropdownMenu: t, children: e, open: r, onOpenChange: i, defaultOpen: s } = n, o = ba(t), [l = !1, u] = Dm({
    prop: r,
    defaultProp: s,
    onChange: i
  });
  return /* @__PURE__ */ y.jsx(bQ, { ...o, open: l, onOpenChange: u, children: e });
}, gIe = "DropdownMenuSubTrigger", KQ = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(xQ, { ...i, ...r, ref: t });
});
KQ.displayName = gIe;
var mIe = "DropdownMenuSubContent", YQ = D.forwardRef((n, t) => {
  const { __scopeDropdownMenu: e, ...r } = n, i = ba(e);
  return /* @__PURE__ */ y.jsx(
    wQ,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...n.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
YQ.displayName = mIe;
var OU = FQ, LU = zQ, hD = UQ, jU = HQ, vIe = VQ, yIe = WQ, SIe = GQ, bIe = pIe, xIe = KQ, wIe = YQ;
function lS({
  id: n,
  children: t,
  modal: e = !1,
  debugOpen: r = !1
}) {
  const [i, s] = Ip(n);
  return /* @__PURE__ */ y.jsx(
    OU,
    {
      open: r || i,
      dir: "ltr",
      modal: e,
      onOpenChange: s,
      children: t
    }
  );
}
function cS({ children: n, ...t }) {
  return /* @__PURE__ */ y.jsx(
    LU,
    {
      dir: "ltr",
      asChild: !0,
      onTouchEnd: (e) => qn(e),
      ...t,
      children: n
    }
  );
}
function uS({
  side: n = "bottom",
  align: t = "start",
  sideOffset: e = 8,
  alignOffset: r = 8,
  children: i
}) {
  const s = io();
  return /* @__PURE__ */ y.jsx(hD, { container: s, children: /* @__PURE__ */ y.jsx(
    jU,
    {
      className: "tlui-menu",
      side: n,
      sideOffset: e,
      align: t,
      alignOffset: r,
      collisionPadding: 4,
      children: i
    }
  ) });
}
function CIe({ id: n, children: t }) {
  const [e, r] = Ip(n);
  return /* @__PURE__ */ y.jsx(bIe, { open: e, onOpenChange: r, children: t });
}
function EIe({
  id: n,
  label: t,
  title: e,
  disabled: r
}) {
  return /* @__PURE__ */ y.jsx(xIe, { dir: "ltr", asChild: !0, disabled: r, children: /* @__PURE__ */ y.jsxs(
    Wt,
    {
      "data-testid": n,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled: r,
      title: e,
      children: [
        /* @__PURE__ */ y.jsx(Zi, { children: t }),
        /* @__PURE__ */ y.jsx(Rn, { icon: "chevron-right", small: !0 })
      ]
    }
  ) });
}
function _Ie({
  id: n,
  alignOffset: t = -1,
  sideOffset: e = -4,
  size: r = "small",
  children: i
}) {
  const s = io();
  return /* @__PURE__ */ y.jsx(hD, { container: s, children: /* @__PURE__ */ y.jsx(
    wIe,
    {
      "data-testid": n,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset: t,
      sideOffset: e,
      collisionPadding: 4,
      "data-size": r,
      children: i
    }
  ) });
}
function TIe({ children: n }) {
  return /* @__PURE__ */ y.jsx(vIe, { dir: "ltr", className: "tlui-menu__group", children: n });
}
function q1({ noClose: n, children: t }) {
  return /* @__PURE__ */ y.jsx(yIe, { dir: "ltr", asChild: !0, onClick: n ? qn : void 0, children: t });
}
function I1({ children: n, visibleOnMobileLayout: t = !1 }) {
  const e = Ya();
  return !t && e < Ui.MOBILE ? null : /* @__PURE__ */ y.jsx("kbd", { className: "tlui-kbd", children: jQ(n).map((r, i) => /* @__PURE__ */ y.jsx("span", { children: r }, i)) });
}
function Me({
  disabled: n = !1,
  spinner: t = !1,
  readonlyOk: e = !1,
  id: r,
  kbd: i,
  label: s,
  icon: o,
  onSelect: l,
  noClose: u,
  isSelected: d
}) {
  const { type: f, sourceId: m } = lD(), v = Dn(), [S, w] = D.useState(!1);
  if (Ap() && !e) return null;
  const A = W1(s, f), P = i ? Z3(i) : void 0, R = A ? v(A) : void 0, M = R && P ? `${R} ${P}` : R;
  switch (f) {
    case "menu":
      return /* @__PURE__ */ y.jsx(q1, { children: /* @__PURE__ */ y.jsxs(
        Wt,
        {
          type: "menu",
          "data-testid": `${m}.${r}`,
          disabled: n,
          title: M,
          onClick: (j) => {
            u && qn(j), S ? w(!1) : l(m);
          },
          children: [
            /* @__PURE__ */ y.jsx(Zi, { children: R }),
            i && /* @__PURE__ */ y.jsx(I1, { children: i })
          ]
        }
      ) });
    case "context-menu":
      return n ? null : /* @__PURE__ */ y.jsxs(
        IQ,
        {
          dir: "ltr",
          title: M,
          draggable: !1,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${m}.${r}`,
          onSelect: (j) => {
            u && qn(j), S ? w(!1) : l(m);
          },
          children: [
            /* @__PURE__ */ y.jsx("span", { className: "tlui-button__label", draggable: !1, children: R }),
            i && /* @__PURE__ */ y.jsx(I1, { children: i }),
            t && /* @__PURE__ */ y.jsx(Xke, {})
          ]
        }
      );
    case "panel":
      return /* @__PURE__ */ y.jsxs(
        Wt,
        {
          "data-testid": `${m}.${r}`,
          type: "menu",
          title: M,
          disabled: n,
          onClick: () => l(m),
          children: [
            /* @__PURE__ */ y.jsx(Zi, { children: R }),
            o && /* @__PURE__ */ y.jsx(Rn, { icon: o })
          ]
        }
      );
    case "small-icons":
    case "icons":
      return /* @__PURE__ */ y.jsx(
        Wt,
        {
          "data-testid": `${m}.${r}`,
          type: "icon",
          title: M,
          disabled: n,
          onClick: () => l(m),
          children: /* @__PURE__ */ y.jsx(Rn, { icon: o, small: f === "small-icons" })
        }
      );
    case "keyboard-shortcuts":
      return i ? /* @__PURE__ */ y.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${m}.${r}`, children: [
        /* @__PURE__ */ y.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: R }),
        /* @__PURE__ */ y.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ y.jsx(I1, { visibleOnMobileLayout: !0, children: i }) })
      ] }) : (console.warn(
        `Menu item '${s}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
      ), null);
    case "helper-buttons":
      return /* @__PURE__ */ y.jsxs(Wt, { type: "low", onClick: () => l(m), children: [
        /* @__PURE__ */ y.jsx(Rn, { icon: o }),
        /* @__PURE__ */ y.jsx(Zi, { children: R })
      ] });
    case "toolbar":
      return /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "tool",
          "data-testid": `tools.${r}`,
          "aria-label": A,
          "data-value": r,
          onClick: () => l("toolbar"),
          title: M,
          onTouchStart: (j) => {
            qn(j), l("toolbar");
          },
          role: "radio",
          "aria-checked": d ? "true" : "false",
          children: /* @__PURE__ */ y.jsx(Rn, { icon: o })
        }
      );
    case "toolbar-overflow":
      return /* @__PURE__ */ y.jsx(q1, { "aria-label": s, children: /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          className: "tlui-button-grid__button",
          onClick: () => {
            l("toolbar");
          },
          "data-testid": `tools.more.${r}`,
          title: M,
          role: "radio",
          "aria-checked": d ? "true" : "false",
          "data-value": r,
          children: /* @__PURE__ */ y.jsx(Rn, { icon: o })
        }
      ) });
    default:
      throw ma(f);
  }
}
function PIe() {
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(AIe, {}),
    /* @__PURE__ */ y.jsx(kIe, {}),
    /* @__PURE__ */ y.jsx(IIe, {}),
    /* @__PURE__ */ y.jsx(RIe, {}),
    /* @__PURE__ */ y.jsx(MIe, {}),
    /* @__PURE__ */ y.jsx(LIe, {}),
    /* @__PURE__ */ y.jsx(jIe, {}),
    /* @__PURE__ */ y.jsx(NIe, {})
  ] });
}
function AIe() {
  const n = Dt(), t = Xa(2), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["align-left"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["align-center-horizontal"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["align-right"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["stretch-horizontal"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["align-top"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["align-center-vertical"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["align-bottom"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["stretch-vertical"], disabled: !r })
  ] });
}
function kIe() {
  const n = Dt(), t = Xa(3), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["distribute-horizontal"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["distribute-vertical"], disabled: !r })
  ] });
}
function IIe() {
  const n = Dt(), t = EZ(), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["stack-horizontal"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["stack-vertical"], disabled: !r })
  ] });
}
function RIe() {
  const n = Dt(), t = Xa(1), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["send-to-back"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["send-backward"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["bring-forward"], disabled: !r }),
    /* @__PURE__ */ y.jsx(Me, { ...n["bring-to-front"], disabled: !r })
  ] });
}
function MIe() {
  return Ya() < Ui.TABLET_SM ? /* @__PURE__ */ y.jsx(DIe, {}) : /* @__PURE__ */ y.jsx(OIe, {});
}
function DIe() {
  const n = Dt(), t = we(), e = De("zoom is 1", () => t.getZoomLevel() === 1, [t]);
  return /* @__PURE__ */ y.jsx(Me, { ...n["zoom-to-100"], disabled: e });
}
function OIe() {
  const n = Dt(), t = Xa(1), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsx(Me, { ...n["rotate-ccw"], disabled: !r });
}
function LIe() {
  const n = Dt(), t = Xa(1), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsx(Me, { ...n["rotate-cw"], disabled: !r });
}
function jIe() {
  const n = Dt(), t = AZ(), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsx(Me, { ...n["edit-link"], disabled: !r });
}
function NIe() {
  const n = _Z(), t = TZ();
  return n ? /* @__PURE__ */ y.jsx(yV, {}) : t ? /* @__PURE__ */ y.jsx(FIe, {}) : /* @__PURE__ */ y.jsx(yV, {});
}
function yV() {
  const n = Dt(), t = Xa(2), e = Rp(), r = t && e;
  return /* @__PURE__ */ y.jsx(Me, { ...n.group, disabled: !r });
}
function FIe() {
  const n = Dt();
  return /* @__PURE__ */ y.jsx(Me, { ...n.ungroup });
}
const $Ie = D.memo(function({
  children: t
}) {
  const e = Dn(), r = Ya(), i = Ap(), s = we(), o = De(
    "should display quick actions when in readonly",
    () => s.isInAny("hand", "zoom"),
    [s]
  ), l = t ?? /* @__PURE__ */ y.jsx(PIe, {});
  if (!(i && !o))
    return /* @__PURE__ */ y.jsxs(SU, { id: "actions-menu", children: [
      /* @__PURE__ */ y.jsx(bU, { children: /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          "data-testid": "actions-menu.button",
          title: e("actions-menu.title"),
          children: /* @__PURE__ */ y.jsx(Rn, { icon: "dots-vertical", small: !0 })
        }
      ) }),
      /* @__PURE__ */ y.jsx(
        xU,
        {
          side: r >= Ui.TABLET ? "bottom" : "top",
          sideOffset: 6,
          children: /* @__PURE__ */ y.jsx("div", { className: "tlui-actions-menu tlui-buttons__grid", "data-testid": "actions-menu.content", children: /* @__PURE__ */ y.jsx(lu, { type: "icons", sourceId: "actions-menu", children: l }) })
        }
      )
    ] });
});
function Bl({
  id: n,
  kbd: t,
  label: e,
  readonlyOk: r,
  onSelect: i,
  toggle: s = !1,
  disabled: o = !1,
  checked: l = !1
}) {
  const { type: u, sourceId: d } = lD(), f = Ap(), m = Dn();
  if (f && !r) return null;
  const v = W1(e, u), S = v ? m(v) : void 0;
  switch (u) {
    case "menu":
      return /* @__PURE__ */ y.jsxs(
        SIe,
        {
          dir: "ltr",
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: S,
          onSelect: (w) => {
            i == null || i(d), qn(w);
          },
          disabled: o,
          checked: l,
          children: [
            /* @__PURE__ */ y.jsx(
              Ih,
              {
                small: !0,
                icon: s ? l ? "toggle-on" : "toggle-off" : l ? "check" : "none"
              }
            ),
            S && /* @__PURE__ */ y.jsx("span", { className: "tlui-button__label", draggable: !1, children: S }),
            t && /* @__PURE__ */ y.jsx(I1, { children: t })
          ]
        }
      );
    case "context-menu":
      return /* @__PURE__ */ y.jsxs(
        Gke,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          title: S,
          onSelect: (w) => {
            i(d), qn(w);
          },
          disabled: o,
          checked: l,
          children: [
            /* @__PURE__ */ y.jsx(
              Ih,
              {
                small: !0,
                icon: s ? l ? "toggle-on" : "toggle-off" : l ? "check" : "none"
              }
            ),
            S && /* @__PURE__ */ y.jsx("span", { className: "tlui-button__label", draggable: !1, children: S }),
            t && /* @__PURE__ */ y.jsx(I1, { children: t })
          ]
        },
        n
      );
    default:
      return null;
  }
}
function mn({ id: n, label: t, children: e }) {
  const { type: r, sourceId: i } = lD(), s = Dn(), o = W1(t, r), l = o ? s(o) : void 0;
  switch (r) {
    case "panel":
      return /* @__PURE__ */ y.jsx("div", { className: "tlui-menu__group", "data-testid": `${i}-group.${n}`, children: e });
    case "menu":
      return /* @__PURE__ */ y.jsx(TIe, { "data-testid": `${i}-group.${n}`, children: e });
    case "context-menu":
      return /* @__PURE__ */ y.jsx(
        kQ,
        {
          dir: "ltr",
          className: "tlui-menu__group",
          "data-testid": `${i}-group.${n}`,
          children: e
        }
      );
    case "keyboard-shortcuts":
      return /* @__PURE__ */ y.jsxs("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${i}-group.${n}`, children: [
        /* @__PURE__ */ y.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: l }),
        /* @__PURE__ */ y.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children: e })
      ] });
    default:
      return e;
  }
}
function qa({
  id: n,
  disabled: t = !1,
  label: e,
  size: r = "small",
  children: i
}) {
  const { type: s, sourceId: o } = lD(), l = io(), u = Dn(), d = e ? typeof e == "string" ? e : e[s] ?? e.default : void 0, f = d ? u(d) : void 0;
  switch (s) {
    case "menu":
      return /* @__PURE__ */ y.jsxs(CIe, { id: `${o}-sub.${n}`, children: [
        /* @__PURE__ */ y.jsx(
          EIe,
          {
            id: `${o}-sub.${f ? f.toLowerCase() + "-button" : ""}`,
            disabled: t,
            label: f,
            title: f
          }
        ),
        /* @__PURE__ */ y.jsx(
          _Ie,
          {
            id: `${o}-sub.${f ? f.toLowerCase() + "-content" : ""}`,
            size: r,
            children: i
          }
        )
      ] });
    case "context-menu":
      return t ? null : /* @__PURE__ */ y.jsxs(zIe, { id: `${o}-sub.${n}`, children: [
        /* @__PURE__ */ y.jsx(DQ, { dir: "ltr", disabled: t, asChild: !0, children: /* @__PURE__ */ y.jsxs(
          Wt,
          {
            "data-testid": `${o}-sub-trigger.${n}`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              /* @__PURE__ */ y.jsx(Zi, { children: f }),
              /* @__PURE__ */ y.jsx(Rn, { icon: "chevron-right", small: !0 })
            ]
          }
        ) }),
        /* @__PURE__ */ y.jsx(MU, { container: l, children: /* @__PURE__ */ y.jsx(
          OQ,
          {
            "data-testid": `${o}-sub-content.${n}`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": r,
            children: i
          }
        ) })
      ] });
    default:
      return i;
  }
}
function zIe({ id: n, children: t }) {
  const [e, r] = Ip(n);
  return /* @__PURE__ */ y.jsx(MQ, { open: e, onOpenChange: r, children: t });
}
function XQ() {
  const n = Dt();
  return OAe() ? /* @__PURE__ */ y.jsx(Me, { ...n["toggle-auto-size"] }) : null;
}
function qQ() {
  const n = Dt();
  return AZ() ? /* @__PURE__ */ y.jsx(Me, { ...n["edit-link"] }) : null;
}
function UIe() {
  const n = Dt();
  return Xa(1) ? /* @__PURE__ */ y.jsx(Me, { ...n.duplicate }) : null;
}
function ZQ() {
  const n = Dt(), t = we();
  return De(
    "should display flatten option",
    () => {
      if (t.getSelectedShapeIds().length === 0) return !1;
      const i = t.getOnlySelectedShape();
      return !(i && t.isShapeOfType(i, "image"));
    },
    [t]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...n["flatten-to-image"] }) : null;
}
function QQ() {
  const n = Dt();
  return _Z() ? /* @__PURE__ */ y.jsx(Me, { ...n.group }) : null;
}
function JQ() {
  const n = Dt();
  return TZ() ? /* @__PURE__ */ y.jsx(Me, { ...n.ungroup }) : null;
}
function eJ() {
  const n = we(), t = Dt();
  return De(
    "allow unframe",
    () => {
      const r = n.getSelectedShapes();
      return r.length === 0 ? !1 : r.every((i) => n.isShapeOfType(i, "frame"));
    },
    [n]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...t["remove-frame"] }) : null;
}
function tJ() {
  const n = we(), t = Dt();
  return De(
    "allow fit frame to content",
    () => {
      const r = n.getOnlySelectedShape();
      return r ? n.isShapeOfType(r, "frame") && n.getSortedChildIdsForParent(r).length > 0 : !1;
    },
    [n]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...t["fit-frame-to-content"] }) : null;
}
function nJ() {
  const n = we(), t = Dt();
  return De("selected shapes", () => n.getSelectedShapes().length > 0, [
    n
  ]) ? /* @__PURE__ */ y.jsx(Me, { ...t["toggle-lock"] }) : null;
}
function NU() {
  const n = Dt(), t = we(), e = De(
    "isTransparentBg",
    () => !t.getInstanceState().exportBackground,
    [t]
  );
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-transparent"], checked: e, toggle: !0 });
}
function BIe() {
  const n = we(), t = Dt(), e = De("any shapes", () => n.getCurrentPageShapeIds().size > 0, [
    n
  ]);
  return /* @__PURE__ */ y.jsx(Me, { ...t["unlock-all"], disabled: !e });
}
function rJ() {
  const n = we(), t = De("zoomed to 100", () => n.getZoomLevel() === 1, [n]), e = Dt();
  return /* @__PURE__ */ y.jsx(Me, { ...e["zoom-to-100"], noClose: !0, disabled: t });
}
function iJ() {
  const n = we(), t = De("has shapes", () => n.getCurrentPageShapeIds().size > 0, [n]), e = Dt();
  return /* @__PURE__ */ y.jsx(
    Me,
    {
      ...e["zoom-to-fit"],
      disabled: !t,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: !0
    }
  );
}
function sJ() {
  const n = we(), t = De("has shapes", () => n.getSelectedShapeIds().length > 0, [
    n
  ]), e = Dt();
  return /* @__PURE__ */ y.jsx(
    Me,
    {
      ...e["zoom-to-selection"],
      disabled: !t,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: !0
    }
  );
}
function FU() {
  return /* @__PURE__ */ y.jsxs(mn, { id: "clipboard", children: [
    /* @__PURE__ */ y.jsx(VIe, {}),
    /* @__PURE__ */ y.jsx(WIe, {}),
    /* @__PURE__ */ y.jsx(GIe, {}),
    /* @__PURE__ */ y.jsx(UIe, {}),
    /* @__PURE__ */ y.jsx(KIe, {})
  ] });
}
function HIe() {
  var r;
  const n = we(), t = Dt(), e = De(
    "atLeastOneShapeOnPage",
    () => n.getCurrentPageShapeIds().size > 0,
    [n]
  );
  return /* @__PURE__ */ y.jsxs(
    qa,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !e,
      children: [
        /* @__PURE__ */ y.jsxs(mn, { id: "copy-as-group", children: [
          /* @__PURE__ */ y.jsx(Me, { ...t["copy-as-svg"] }),
          !!((r = window.navigator.clipboard) != null && r.write) && /* @__PURE__ */ y.jsx(Me, { ...t["copy-as-png"] }),
          /* @__PURE__ */ y.jsx(Me, { ...t["copy-as-json"] })
        ] }),
        /* @__PURE__ */ y.jsx(mn, { id: "copy-as-bg", children: /* @__PURE__ */ y.jsx(NU, {}) })
      ]
    }
  );
}
function VIe() {
  const n = Dt(), t = Xa(1);
  return /* @__PURE__ */ y.jsx(Me, { ...n.cut, disabled: !t });
}
function WIe() {
  const n = Dt(), t = PZ(1);
  return /* @__PURE__ */ y.jsx(Me, { ...n.copy, disabled: !t });
}
function GIe() {
  const n = Dt(), t = DAe;
  return /* @__PURE__ */ y.jsx(Me, { ...n.paste, disabled: !t });
}
function oJ() {
  const n = we(), t = Dt();
  return De(
    "atLeastOneShapeOnPage",
    () => n.getCurrentPageShapeIds().size > 0,
    [n]
  ) ? /* @__PURE__ */ y.jsxs(mn, { id: "conversions", children: [
    /* @__PURE__ */ y.jsx(HIe, {}),
    /* @__PURE__ */ y.jsxs(qa, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      /* @__PURE__ */ y.jsxs(mn, { id: "export-as-group", children: [
        /* @__PURE__ */ y.jsx(Me, { ...t["export-as-svg"] }),
        /* @__PURE__ */ y.jsx(Me, { ...t["export-as-png"] }),
        /* @__PURE__ */ y.jsx(Me, { ...t["export-as-json"] })
      ] }),
      /* @__PURE__ */ y.jsx(mn, { id: "export-as-bg", children: /* @__PURE__ */ y.jsx(NU, {}) })
    ] })
  ] }) : null;
}
function $U() {
  const n = Dt(), t = we(), e = De(
    "atLeastOneShapeOnPage",
    () => t.getCurrentPageShapeIds().size > 0,
    [t]
  );
  return /* @__PURE__ */ y.jsx(Me, { ...n["select-all"], disabled: !e });
}
function KIe() {
  const n = Dt(), t = Xa(1);
  return /* @__PURE__ */ y.jsx(Me, { ...n.delete, disabled: !t });
}
function YIe() {
  return PZ(1) ? /* @__PURE__ */ y.jsxs(qa, { id: "edit", label: "context-menu.edit", size: "small", children: [
    /* @__PURE__ */ y.jsx(QQ, {}),
    /* @__PURE__ */ y.jsx(JQ, {}),
    /* @__PURE__ */ y.jsx(ZQ, {}),
    /* @__PURE__ */ y.jsx(qQ, {}),
    /* @__PURE__ */ y.jsx(tJ, {}),
    /* @__PURE__ */ y.jsx(eJ, {}),
    /* @__PURE__ */ y.jsx(lJ, {}),
    /* @__PURE__ */ y.jsx(aJ, {}),
    /* @__PURE__ */ y.jsx(XQ, {}),
    /* @__PURE__ */ y.jsx(nJ, {})
  ] }) : null;
}
function XIe() {
  const n = Xa(2), t = LAe(), e = Dt();
  return n || t ? /* @__PURE__ */ y.jsxs(qa, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    n && /* @__PURE__ */ y.jsxs(mn, { id: "align", children: [
      /* @__PURE__ */ y.jsx(Me, { ...e["align-left"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["align-center-horizontal"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["align-right"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["align-top"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["align-center-vertical"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["align-bottom"] })
    ] }),
    /* @__PURE__ */ y.jsx(qIe, {}),
    n && /* @__PURE__ */ y.jsxs(mn, { id: "stretch", children: [
      /* @__PURE__ */ y.jsx(Me, { ...e["stretch-horizontal"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["stretch-vertical"] })
    ] }),
    (n || t) && /* @__PURE__ */ y.jsxs(mn, { id: "flip", children: [
      /* @__PURE__ */ y.jsx(Me, { ...e["flip-horizontal"] }),
      /* @__PURE__ */ y.jsx(Me, { ...e["flip-vertical"] })
    ] }),
    /* @__PURE__ */ y.jsx(ZIe, {})
  ] }) : null;
}
function qIe() {
  const n = Dt();
  return Xa(3) ? /* @__PURE__ */ y.jsxs(mn, { id: "distribute", children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["distribute-horizontal"] }),
    /* @__PURE__ */ y.jsx(Me, { ...n["distribute-vertical"] })
  ] }) : null;
}
function ZIe() {
  const n = Dt(), t = Xa(2), e = EZ();
  return t ? /* @__PURE__ */ y.jsxs(mn, { id: "order", children: [
    /* @__PURE__ */ y.jsx(Me, { ...n.pack }),
    e && /* @__PURE__ */ y.jsx(Me, { ...n["stack-horizontal"] }),
    e && /* @__PURE__ */ y.jsx(Me, { ...n["stack-vertical"] })
  ] }) : null;
}
function QIe() {
  const n = Dt();
  return Xa(1) ? /* @__PURE__ */ y.jsx(qa, { id: "reorder", label: "context-menu.reorder", size: "small", children: /* @__PURE__ */ y.jsxs(mn, { id: "reorder", children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["bring-to-front"] }),
    /* @__PURE__ */ y.jsx(Me, { ...n["bring-forward"] }),
    /* @__PURE__ */ y.jsx(Me, { ...n["send-backward"] }),
    /* @__PURE__ */ y.jsx(Me, { ...n["send-to-back"] })
  ] }) }) : null;
}
function JIe() {
  const n = we(), t = De("pages", () => n.getPages(), [n]), e = De("current page id", () => n.getCurrentPageId(), [n]), { addToast: r } = gd(), i = Dt(), s = Fo();
  return Xa(1) ? /* @__PURE__ */ y.jsxs(qa, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    /* @__PURE__ */ y.jsx(mn, { id: "pages", children: t.map((l) => /* @__PURE__ */ y.jsx(
      Me,
      {
        id: l.id,
        disabled: e === l.id,
        label: l.name,
        onSelect: () => {
          n.mark("move_shapes_to_page"), n.moveShapesToPage(n.getSelectedShapeIds(), l.id);
          const u = n.getPage(l.id);
          u && r({
            title: "Changed Page",
            description: `Moved to ${u.name}.`,
            actions: [
              {
                label: "Go Back",
                type: "primary",
                onClick: () => {
                  n.mark("change-page"), n.setCurrentPage(e);
                }
              }
            ]
          }), s("move-to-page", { source: "context-menu" });
        }
      },
      l.id
    )) }),
    /* @__PURE__ */ y.jsx(mn, { id: "new-page", children: /* @__PURE__ */ y.jsx(Me, { ...i["move-to-new-page"] }) })
  ] }) : null;
}
function aJ() {
  const n = we(), t = Dt();
  return De(
    "oneEmbedSelected",
    () => {
      const r = n.getOnlySelectedShape();
      return r ? !!(n.isShapeOfType(r, "embed") && r.props.url && !n.isShapeOrAncestorLocked(r)) : !1;
    },
    [n]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...t["convert-to-bookmark"] }) : null;
}
function lJ() {
  const n = we(), t = Dt();
  return De(
    "oneEmbeddableBookmarkSelected",
    () => {
      const r = n.getOnlySelectedShape();
      return r ? !!(n.isShapeOfType(r, "bookmark") && r.props.url && pm(r.props.url) && !n.isShapeOrAncestorLocked(r)) : !1;
    },
    [n]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...t["convert-to-embed"] }) : null;
}
function eRe() {
  const n = Dt(), t = we(), e = De("isSnapMode", () => t.user.getIsSnapMode(), [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-snap-mode"], checked: e });
}
function tRe() {
  const n = Dt(), t = we(), e = De("isToolLock", () => t.getInstanceState().isToolLocked, [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-tool-lock"], checked: e });
}
function nRe() {
  const n = Dt(), t = we(), e = De("isGridMode", () => t.getInstanceState().isGridMode, [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-grid"], checked: e });
}
function rRe() {
  const n = Dt(), t = we(), e = De("isWrapMode", () => t.user.getIsWrapMode(), [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-wrap-mode"], checked: e });
}
function iRe() {
  const n = Dt(), t = we(), e = De("isFocusMode", () => t.getInstanceState().isFocusMode, [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-focus-mode"], checked: e });
}
function sRe() {
  const n = Dt(), t = we(), e = De("edgeScrollSpeed", () => t.user.getEdgeScrollSpeed(), [
    t
  ]);
  return /* @__PURE__ */ y.jsx(
    Bl,
    {
      ...n["toggle-edge-scrolling"],
      checked: e === 1
    }
  );
}
function oRe() {
  const n = Dt(), t = we(), e = De("animationSpeed", () => t.user.getAnimationSpeed(), [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-reduce-motion"], checked: e === 0 });
}
function aRe() {
  const n = Dt(), t = we(), e = De("isDebugMode", () => t.getInstanceState().isDebugMode, [t]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-debug-mode"], checked: e });
}
function lRe() {
  const n = Dt(), t = we(), e = De(
    "dynamic resize",
    () => t.user.getIsDynamicResizeMode(),
    [t]
  );
  return /* @__PURE__ */ y.jsx(
    Bl,
    {
      ...n["toggle-dynamic-size-mode"],
      checked: e
    }
  );
}
function cRe() {
  const n = Dt(), t = we(), e = De("paste at cursor", () => t.user.getIsPasteAtCursorMode(), [
    t
  ]);
  return /* @__PURE__ */ y.jsx(Bl, { ...n["toggle-paste-at-cursor"], checked: e });
}
function uRe() {
  const n = we(), t = Dt();
  return De(
    "show cursor chat",
    () => n.getCurrentToolId() === "select" && !n.getInstanceState().isCoarsePointer,
    [n]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...t["open-cursor-chat"] }) : null;
}
function dRe() {
  const n = we(), t = iD();
  return De(
    "isSelectToolActive",
    () => n.getCurrentToolId() === "select",
    [n]
  ) ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    t && /* @__PURE__ */ y.jsx(uRe, {}),
    /* @__PURE__ */ y.jsxs(mn, { id: "modify", children: [
      /* @__PURE__ */ y.jsx(YIe, {}),
      /* @__PURE__ */ y.jsx(XIe, {}),
      /* @__PURE__ */ y.jsx(QIe, {}),
      /* @__PURE__ */ y.jsx(JIe, {})
    ] }),
    /* @__PURE__ */ y.jsx(FU, {}),
    /* @__PURE__ */ y.jsx(oJ, {}),
    /* @__PURE__ */ y.jsx(mn, { id: "select-all", children: /* @__PURE__ */ y.jsx($U, {}) })
  ] }) : null;
}
const cJ = D.memo(function({
  children: t
}) {
  const e = we(), { Canvas: r } = xi(), i = D.useCallback(
    (d) => {
      if (d) {
        if (e.getInstanceState().isCoarsePointer) {
          const f = e.getSelectedShapes(), {
            inputs: { currentPagePoint: m }
          } = e, v = e.getShapesAtPoint(m);
          if (
            // if there are no selected shapes
            !e.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !v.some((S) => f.includes(S))
          ) {
            const S = v.filter((w) => e.isShapeOrAncestorLocked(w));
            S.length && e.select(...S.map((w) => w.id));
          }
        }
      } else {
        const f = e.getOnlySelectedShape();
        f && e.isShapeOrAncestorLocked(f) && e.setSelectedShapes([]);
      }
    },
    [e]
  ), s = io(), [o, l] = Ip("context menu", i), u = t ?? /* @__PURE__ */ y.jsx(dRe, {});
  return /* @__PURE__ */ y.jsxs(Bke, { dir: "ltr", onOpenChange: l, modal: !1, children: [
    /* @__PURE__ */ y.jsx(Hke, { onContextMenu: void 0, dir: "ltr", children: r ? /* @__PURE__ */ y.jsx(r, {}) : null }),
    o && /* @__PURE__ */ y.jsx(Vke, { container: s, children: /* @__PURE__ */ y.jsx(
      Wke,
      {
        className: "tlui-menu scrollable",
        "data-testid": "context-menu",
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: qn,
        children: /* @__PURE__ */ y.jsx(lu, { type: "context-menu", sourceId: "context-menu", children: u })
      }
    ) })
  ] });
}), hRe = 2e3, fRe = 5e3, pRe = ro(function() {
  const t = we(), { isChatting: e, chatMessage: r } = t.getInstanceState(), i = D.useRef(-1), [s, o] = D.useState("");
  return D.useEffect(() => {
    if (!e && r || e) {
      const u = e ? fRe : hRe;
      i.current = t.timers.setTimeout(() => {
        t.updateInstanceState({ chatMessage: "", isChatting: !1 }), o(""), t.focus();
      }, u);
    }
    return () => {
      clearTimeout(i.current);
    };
  }, [t, r, e]), e ? /* @__PURE__ */ y.jsx(mRe, { value: s, setValue: o, chatMessage: r }) : r.trim() ? /* @__PURE__ */ y.jsx(gRe, { chatMessage: r }) : null;
});
function uJ(n) {
  const t = we();
  D.useLayoutEffect(() => {
    var o;
    if (!n.current) return;
    const { x: r, y: i } = t.inputs.currentScreenPoint;
    (o = n.current) == null || o.style.setProperty("transform", `translate(${r}px, ${i}px)`);
    function s(l) {
      var f;
      const { minX: u, minY: d } = t.getViewportScreenBounds();
      (f = n.current) == null || f.style.setProperty(
        "transform",
        `translate(${l.clientX - u}px, ${l.clientY - d}px)`
      );
    }
    return window.addEventListener("pointermove", s), () => {
      window.removeEventListener("pointermove", s);
    };
  }, [n, t]);
}
const gRe = ({ chatMessage: n }) => {
  const t = we(), e = D.useRef(null);
  return uJ(e), /* @__PURE__ */ y.jsx(
    "div",
    {
      ref: e,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: t.user.getColor() },
      children: n
    }
  );
}, mRe = ro(function({
  chatMessage: t,
  value: e,
  setValue: r
}) {
  const i = we(), s = Dn(), o = D.useRef(null), l = t || s("cursor-chat.type-to-chat");
  uJ(o), D.useLayoutEffect(() => {
    const v = o.current;
    if (!v) return;
    const S = i.textMeasure.measureText(e || l, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    v.style.setProperty("width", S.w + "px");
  }, [i, e, l]), D.useLayoutEffect(() => {
    const v = i.timers.requestAnimationFrame(() => {
      var S;
      (S = o.current) == null || S.focus();
    });
    return () => {
      cancelAnimationFrame(v);
    };
  }, [i]);
  const u = D.useCallback(() => {
    i.updateInstanceState({ isChatting: !1 }), i.focus();
  }, [i]), d = D.useCallback(
    (v) => {
      const { value: S } = v.target;
      r(S.slice(0, 64)), i.updateInstanceState({ chatMessage: S });
    },
    [i, r]
  ), f = D.useCallback(
    (v) => {
      const S = o.current;
      if (!S) return;
      const { value: w } = S;
      switch (v.key) {
        case "Enter": {
          if (qn(v), v.stopPropagation(), !w) {
            u();
            return;
          }
          r("");
          break;
        }
        case "Escape": {
          qn(v), v.stopPropagation(), u();
          break;
        }
      }
    },
    [u, r]
  ), m = D.useCallback((v) => {
    v.stopPropagation();
  }, []);
  return /* @__PURE__ */ y.jsx(
    "input",
    {
      ref: o,
      className: "tl-cursor-chat",
      style: { backgroundColor: i.user.getColor() },
      onBlur: u,
      onChange: d,
      onKeyDown: f,
      onPaste: m,
      value: e,
      placeholder: l,
      spellCheck: !1
    }
  );
});
function Q3({ checked: n }) {
  return /* @__PURE__ */ y.jsx(Ih, { icon: n ? "check" : "none", className: "tlui-button__icon", small: !0 });
}
function vRe() {
  const n = we(), { addToast: t } = gd(), { addDialog: e } = wS(), [r, i] = Gn.useState(!1);
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(mn, { id: "items", children: [
      /* @__PURE__ */ y.jsx(
        Me,
        {
          id: "add-toast",
          onSelect: () => {
            t({
              id: Ii(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "success"
              // icon?: string
              // title?: string
              // description?: string
              // actions?: TLUiToastAction[]
            }), t({
              id: Ii(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
              // icon?: string
              // title?: string
              // description?: string
              // actions?: TLUiToastAction[]
            }), t({
              id: Ii(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            }), t({
              id: Ii(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: !0
            });
          },
          label: "Show toast"
        }
      ),
      /* @__PURE__ */ y.jsx(
        Me,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            e({
              component: ({ onClose: s }) => /* @__PURE__ */ y.jsx(
                bRe,
                {
                  displayDontShowAgain: !0,
                  onCancel: () => s(),
                  onContinue: () => s()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      /* @__PURE__ */ y.jsx(
        Me,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => xRe(n, 100)
        }
      ),
      /* @__PURE__ */ y.jsx(
        Me,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            var l;
            const s = n.getSelectedShapes(), o = s.length === 0 ? n.getRenderingShapes() : s;
            window.alert(
              `Shapes ${o.length}, DOM nodes:${(l = document.querySelector(".tl-shapes").querySelectorAll("*")) == null ? void 0 : l.length}`
            );
          }
        }
      ),
      (() => {
        if (r) throw Error("oh no!");
        return null;
      })(),
      /* @__PURE__ */ y.jsx(Me, { id: "throw-error", onSelect: () => i(!0), label: "Throw error" }),
      /* @__PURE__ */ y.jsx(Me, { id: "hard-reset", onSelect: YK, label: "Hard reset" })
    ] }),
    /* @__PURE__ */ y.jsxs(mn, { id: "flags", children: [
      /* @__PURE__ */ y.jsx(yRe, {}),
      /* @__PURE__ */ y.jsx(SRe, {})
    ] })
  ] });
}
function yRe() {
  const n = Object.values(qi);
  return n.length ? /* @__PURE__ */ y.jsx(qa, { id: "debug flags", label: "Debug Flags", children: /* @__PURE__ */ y.jsx(mn, { id: "debug flags", children: n.map((t) => /* @__PURE__ */ y.jsx(dJ, { flag: t }, t.name)) }) }) : null;
}
function SRe() {
  const n = Object.values(t5);
  return n.length ? /* @__PURE__ */ y.jsx(qa, { id: "feature flags", label: "Feature Flags", children: /* @__PURE__ */ y.jsx(mn, { id: "feature flags", children: n.map((t) => /* @__PURE__ */ y.jsx(dJ, { flag: t }, t.name)) }) }) : null;
}
function bRe({
  title: n = "title",
  body: t = "hello hello hello",
  cancel: e = "Cancel",
  confirm: r = "Continue",
  displayDontShowAgain: i = !1,
  onCancel: s,
  onContinue: o
}) {
  const [l, u] = Gn.useState(!1);
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(J2, { children: [
      /* @__PURE__ */ y.jsx(eD, { children: n }),
      /* @__PURE__ */ y.jsx(tD, {})
    ] }),
    /* @__PURE__ */ y.jsx(V1, { style: { maxWidth: 350 }, children: t }),
    /* @__PURE__ */ y.jsxs(tU, { className: "tlui-dialog__footer__actions", children: [
      i && /* @__PURE__ */ y.jsxs(
        Wt,
        {
          type: "normal",
          onClick: () => u(!l),
          style: { marginRight: "auto" },
          children: [
            /* @__PURE__ */ y.jsx(Q3, { checked: l }),
            /* @__PURE__ */ y.jsx(Zi, { children: "Don’t show again" })
          ]
        }
      ),
      /* @__PURE__ */ y.jsx(Wt, { type: "normal", onClick: s, children: /* @__PURE__ */ y.jsx(Zi, { children: e }) }),
      /* @__PURE__ */ y.jsx(Wt, { type: "primary", onClick: async () => o(), children: /* @__PURE__ */ y.jsx(Zi, { children: r }) })
    ] })
  ] });
}
const dJ = ro(function({
  flag: t,
  onChange: e
}) {
  const r = t.get();
  return /* @__PURE__ */ y.jsx(
    Bl,
    {
      id: t.name,
      title: t.name,
      label: t.name.replace(/([a-z0-9])([A-Z])/g, (i) => `${i[0]} ${i[1].toLowerCase()}`).replace(/^[a-z]/, (i) => i.toUpperCase()),
      checked: r,
      onSelect: () => {
        t.set(!r), e == null || e(!r);
      }
    }
  );
});
let SV = 0;
function xRe(n, t) {
  const e = Array(t), r = Math.floor(Math.sqrt(t));
  for (let i = 0; i < t; i++)
    SV++, e[i] = {
      id: Ar("box" + SV),
      type: "geo",
      x: i % r * 132,
      y: Math.floor(i / r) * 132
    };
  n.run(() => {
    n.createShapes(e).setSelectedShapes(e.map((i) => i.id));
  });
}
function wRe({ children: n }) {
  const t = n ?? /* @__PURE__ */ y.jsx(vRe, {});
  return /* @__PURE__ */ y.jsxs(lS, { id: "debug", children: [
    /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsx(Wt, { type: "icon", title: "Debug menu", children: /* @__PURE__ */ y.jsx(Rn, { icon: "dots-horizontal" }) }) }),
    /* @__PURE__ */ y.jsx(uS, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ y.jsx(lu, { type: "menu", sourceId: "debug-panel", children: t }) })
  ] });
}
const CRe = D.memo(function() {
  const { DebugMenu: t } = Nm();
  return /* @__PURE__ */ y.jsxs("div", { className: "tlui-debug-panel", children: [
    /* @__PURE__ */ y.jsx(_Re, {}),
    /* @__PURE__ */ y.jsx(TRe, {}),
    t && /* @__PURE__ */ y.jsx(t, {})
  ] });
});
function ERe(n = !0) {
  const [t, e] = D.useState(0), r = we();
  D.useEffect(() => {
    if (!n) return;
    const i = () => e((s) => s + 1);
    return r.on("tick", i), () => {
      r.off("tick", i);
    };
  }, [r, n]);
}
const _Re = ro(function() {
  ERe();
  const t = we(), e = t.getPath(), r = t.getHoveredShape(), i = t.getOnlySelectedShape(), s = e === "select.idle" || !e.includes("select.") ? r : i, o = s && e.includes("select.") ? ` / ${s.type || ""}${"geo" in s.props ? " / " + s.props.geo : ""} / [${O.ToInt(t.getPointInShapeSpace(s, t.inputs.currentPagePoint))}]` : "", l = e.startsWith("select.") && !e.includes(".idle") ? ` / [${O.ToInt(t.inputs.originPagePoint)}] → [${O.ToInt(
    t.inputs.currentPagePoint
  )}] = ${O.Dist(t.inputs.originPagePoint, t.inputs.currentPagePoint).toFixed(0)}` : "";
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-debug-panel__current-state", children: `${e}${o}${l}` });
});
function TRe() {
  const n = we(), t = De("show_fps", () => qi.showFps.get(), [qi]), e = D.useRef(null);
  return D.useEffect(() => {
    if (!t) return;
    const r = 250;
    let i = 0, s = -1, o = performance.now(), l = 0, u = 0, d = !1;
    function f() {
      if (u++, l = performance.now() - o, l > r) {
        const m = Math.round(
          u * (r / l) * (1e3 / r)
        );
        m > i && (i = m);
        const v = i * 0.75;
        (m < v && !d || m >= v && d) && (d = !d), e.current.innerHTML = `FPS ${m.toString()}`, e.current.className = "tlui-debug-panel__fps" + (d ? " tlui-debug-panel__fps__slow" : ""), l -= r, u = 0, o = performance.now();
      }
      s = n.timers.requestAnimationFrame(f);
    }
    return f(), () => {
      cancelAnimationFrame(s);
    };
  }, [t, n]), t ? /* @__PURE__ */ y.jsx("div", { ref: e }) : null;
}
const PRe = D.memo(function() {
  const t = Ya(), { MainMenu: e, QuickActions: r, ActionsMenu: i, PageMenu: s } = Nm();
  return !e && !s && t < 6 ? null : /* @__PURE__ */ y.jsx("div", { className: "tlui-menu-zone", children: /* @__PURE__ */ y.jsxs("div", { className: "tlui-buttons__horizontal", children: [
    e && /* @__PURE__ */ y.jsx(e, {}),
    s && /* @__PURE__ */ y.jsx(s, {}),
    t < 6 ? null : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      r && /* @__PURE__ */ y.jsx(r, {}),
      i && /* @__PURE__ */ y.jsx(i, {})
    ] })
  ] }) });
});
function ARe() {
  const n = we(), t = Dt(), [e, r] = D.useState(!1), i = D.useRef(!1);
  return mm(
    "toggle showback to content",
    () => {
      const s = i.current, o = n.getCurrentPageShapeIds();
      let l = !1;
      o.size && (l = o.size === n.getCulledShapes().size), s !== l && (r(l), i.current = l);
    },
    [n]
  ), e ? /* @__PURE__ */ y.jsx(
    Me,
    {
      ...t["back-to-content"],
      onSelect: () => {
        t["back-to-content"].onSelect("helper-buttons"), r(!1);
      }
    }
  ) : null;
}
function kRe() {
  const n = we(), t = Dt();
  return De("is pen mode", () => n.getInstanceState().isPenMode, [n]) ? /* @__PURE__ */ y.jsx(Me, { ...t["exit-pen-mode"] }) : null;
}
function IRe() {
  const n = we(), t = Dt();
  return De(
    "is following user",
    () => !!n.getInstanceState().followingUserId,
    [n]
  ) ? /* @__PURE__ */ y.jsx(Me, { ...t["stop-following"] }) : null;
}
function RRe() {
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(kRe, {}),
    /* @__PURE__ */ y.jsx(ARe, {}),
    /* @__PURE__ */ y.jsx(IRe, {})
  ] });
}
function MRe({ children: n }) {
  const t = n ?? /* @__PURE__ */ y.jsx(RRe, {});
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-helper-buttons", children: /* @__PURE__ */ y.jsx(lu, { type: "helper-buttons", sourceId: "helper-buttons", children: t }) });
}
function DRe() {
  const n = Dt(), t = rD(), e = iD();
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(mn, { label: "shortcuts-dialog.tools", id: "tools", children: [
      /* @__PURE__ */ y.jsx(Me, { ...n["toggle-tool-lock"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["insert-media"] }),
      /* @__PURE__ */ y.jsx(Me, { ...t.select }),
      /* @__PURE__ */ y.jsx(Me, { ...t.draw }),
      /* @__PURE__ */ y.jsx(Me, { ...t.eraser }),
      /* @__PURE__ */ y.jsx(Me, { ...t.hand }),
      /* @__PURE__ */ y.jsx(Me, { ...t.rectangle }),
      /* @__PURE__ */ y.jsx(Me, { ...t.ellipse }),
      /* @__PURE__ */ y.jsx(Me, { ...t.arrow }),
      /* @__PURE__ */ y.jsx(Me, { ...t.line }),
      /* @__PURE__ */ y.jsx(Me, { ...t.text }),
      /* @__PURE__ */ y.jsx(Me, { ...t.frame }),
      /* @__PURE__ */ y.jsx(Me, { ...t.note }),
      /* @__PURE__ */ y.jsx(Me, { ...t.laser })
    ] }),
    /* @__PURE__ */ y.jsxs(mn, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      /* @__PURE__ */ y.jsx(Me, { ...n["toggle-dark-mode"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["toggle-focus-mode"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["toggle-grid"] })
    ] }),
    /* @__PURE__ */ y.jsxs(mn, { label: "shortcuts-dialog.edit", id: "edit", children: [
      /* @__PURE__ */ y.jsx(Me, { ...n.undo }),
      /* @__PURE__ */ y.jsx(Me, { ...n.redo }),
      /* @__PURE__ */ y.jsx(Me, { ...n.cut }),
      /* @__PURE__ */ y.jsx(Me, { ...n.copy }),
      /* @__PURE__ */ y.jsx(Me, { ...n.paste }),
      /* @__PURE__ */ y.jsx(Me, { ...n["select-all"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n.delete }),
      /* @__PURE__ */ y.jsx(Me, { ...n.duplicate })
    ] }),
    /* @__PURE__ */ y.jsxs(mn, { label: "shortcuts-dialog.view", id: "view", children: [
      /* @__PURE__ */ y.jsx(Me, { ...n["zoom-in"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["zoom-out"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["zoom-to-100"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["zoom-to-fit"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["zoom-to-selection"] })
    ] }),
    /* @__PURE__ */ y.jsxs(mn, { label: "shortcuts-dialog.transform", id: "transform", children: [
      /* @__PURE__ */ y.jsx(Me, { ...n["bring-to-front"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["bring-forward"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["send-backward"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["send-to-back"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n.group }),
      /* @__PURE__ */ y.jsx(Me, { ...n.ungroup }),
      /* @__PURE__ */ y.jsx(Me, { ...n["flip-horizontal"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["flip-vertical"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["align-top"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["align-center-vertical"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["align-bottom"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["align-left"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["align-center-horizontal"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["align-right"] })
    ] }),
    e && /* @__PURE__ */ y.jsx(mn, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: /* @__PURE__ */ y.jsx(Me, { ...n["open-cursor-chat"] }) })
  ] });
}
const ORe = D.memo(function({
  children: t
}) {
  const e = Dn(), r = Ya(), i = t ?? /* @__PURE__ */ y.jsx(DRe, {});
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(J2, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ y.jsx(eD, { children: e("shortcuts-dialog.title") }),
      /* @__PURE__ */ y.jsx(tD, {})
    ] }),
    /* @__PURE__ */ y.jsx(
      V1,
      {
        className: Vt("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": r <= Ui.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": r <= Ui.TABLET
        }),
        children: /* @__PURE__ */ y.jsx(lu, { type: "keyboard-shortcuts", sourceId: "kbd", children: i })
      }
    ),
    /* @__PURE__ */ y.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
}), LRe = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function jRe() {
  const n = we(), t = Fo(), e = De(
    "colorScheme",
    () => n.user.getUserPreferences().colorScheme ?? n.user.getIsDarkMode() ? "dark" : "light",
    [n]
  );
  return /* @__PURE__ */ y.jsx(qa, { id: "help menu color-scheme", label: "menu.theme", children: /* @__PURE__ */ y.jsx(mn, { id: "languages", children: LRe.map(({ colorScheme: r, label: i }) => /* @__PURE__ */ y.jsx(
    Bl,
    {
      id: `color-scheme-${r}`,
      label: i,
      checked: r === e,
      onSelect: () => {
        n.user.updateUserPreferences({ colorScheme: r }), t("color-scheme", { source: "menu", value: r });
      }
    },
    r
  )) }) });
}
function hJ() {
  const n = we(), t = Fo(), e = De("locale", () => n.user.getLocale(), [n]);
  return /* @__PURE__ */ y.jsx(qa, { id: "help menu language", label: "menu.language", children: /* @__PURE__ */ y.jsx(mn, { id: "languages", children: B1.map(({ locale: r, label: i }) => /* @__PURE__ */ y.jsx(
    Bl,
    {
      id: `language-${r}`,
      title: r,
      label: i,
      checked: r === e,
      onSelect: () => {
        n.user.updateUserPreferences({ locale: r }), t("change-language", { source: "menu", locale: r });
      }
    },
    r
  )) }) });
}
function NRe() {
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(hJ, {}),
    /* @__PURE__ */ y.jsx(fJ, {})
  ] });
}
function fJ() {
  const { KeyboardShortcutsDialog: n } = Nm(), { addDialog: t } = wS();
  return n ? /* @__PURE__ */ y.jsx(
    Me,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: !0,
      onSelect: () => {
        t({ component: n });
      }
    }
  ) : null;
}
function FRe() {
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(zRe, {}),
    /* @__PURE__ */ y.jsx(VRe, {}),
    /* @__PURE__ */ y.jsx($Re, {}),
    /* @__PURE__ */ y.jsx(WRe, {}),
    /* @__PURE__ */ y.jsx(KRe, {}),
    /* @__PURE__ */ y.jsx(GRe, {})
  ] });
}
function $Re() {
  const n = Dt();
  return /* @__PURE__ */ y.jsxs(qa, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    /* @__PURE__ */ y.jsxs(mn, { id: "export-all-as-group", children: [
      /* @__PURE__ */ y.jsx(Me, { ...n["export-all-as-svg"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["export-all-as-png"] }),
      /* @__PURE__ */ y.jsx(Me, { ...n["export-all-as-json"] })
    ] }),
    /* @__PURE__ */ y.jsx(mn, { id: "export-all-as-bg", children: /* @__PURE__ */ y.jsx(NU, {}) })
  ] });
}
function zRe() {
  const n = we(), t = De(
    "isSelectToolActive",
    () => n.getCurrentToolId() === "select",
    [n]
  );
  return /* @__PURE__ */ y.jsxs(qa, { id: "edit", label: "menu.edit", disabled: !t, children: [
    /* @__PURE__ */ y.jsx(HRe, {}),
    /* @__PURE__ */ y.jsx(FU, {}),
    /* @__PURE__ */ y.jsx(oJ, {}),
    /* @__PURE__ */ y.jsx(URe, {}),
    /* @__PURE__ */ y.jsx(BRe, {}),
    /* @__PURE__ */ y.jsx(mn, { id: "select-all", children: /* @__PURE__ */ y.jsx($U, {}) })
  ] });
}
function URe() {
  return /* @__PURE__ */ y.jsxs(mn, { id: "misc", children: [
    /* @__PURE__ */ y.jsx(QQ, {}),
    /* @__PURE__ */ y.jsx(JQ, {}),
    /* @__PURE__ */ y.jsx(qQ, {}),
    /* @__PURE__ */ y.jsx(XQ, {}),
    /* @__PURE__ */ y.jsx(eJ, {}),
    /* @__PURE__ */ y.jsx(tJ, {}),
    /* @__PURE__ */ y.jsx(lJ, {}),
    /* @__PURE__ */ y.jsx(aJ, {}),
    /* @__PURE__ */ y.jsx(ZQ, {})
  ] });
}
function BRe() {
  return /* @__PURE__ */ y.jsxs(mn, { id: "lock", children: [
    /* @__PURE__ */ y.jsx(nJ, {}),
    /* @__PURE__ */ y.jsx(BIe, {})
  ] });
}
function HRe() {
  const n = Dt(), t = IZ(), e = kZ();
  return /* @__PURE__ */ y.jsxs(mn, { id: "undo-redo", children: [
    /* @__PURE__ */ y.jsx(Me, { ...n.undo, disabled: !t }),
    /* @__PURE__ */ y.jsx(Me, { ...n.redo, disabled: !e })
  ] });
}
function VRe() {
  const n = Dt();
  return /* @__PURE__ */ y.jsx(qa, { id: "view", label: "menu.view", children: /* @__PURE__ */ y.jsxs(mn, { id: "view-actions", children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["zoom-in"] }),
    /* @__PURE__ */ y.jsx(Me, { ...n["zoom-out"] }),
    /* @__PURE__ */ y.jsx(rJ, {}),
    /* @__PURE__ */ y.jsx(iJ, {}),
    /* @__PURE__ */ y.jsx(sJ, {})
  ] }) });
}
function WRe() {
  const n = Dt();
  return /* @__PURE__ */ y.jsxs(mn, { id: "extras", children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["insert-embed"] }),
    /* @__PURE__ */ y.jsx(Me, { ...n["insert-media"] })
  ] });
}
function GRe() {
  function n(t) {
    window.open(t, "_blank");
  }
  return /* @__PURE__ */ y.jsx(mn, { id: "help", children: /* @__PURE__ */ y.jsx(qa, { id: "help", label: "menu.help", children: /* @__PURE__ */ y.jsxs(mn, { id: "help-actions", children: [
    /* @__PURE__ */ y.jsx(fJ, {}),
    /* @__PURE__ */ y.jsx(
      Me,
      {
        id: "about",
        label: "help-menu.docs",
        icon: "external-link",
        readonlyOk: !0,
        onSelect: () => {
          n("https://tldraw.dev");
        }
      }
    )
  ] }) }) });
}
function KRe() {
  return /* @__PURE__ */ y.jsx(mn, { id: "preferences", children: /* @__PURE__ */ y.jsxs(qa, { id: "preferences", label: "menu.preferences", children: [
    /* @__PURE__ */ y.jsxs(mn, { id: "preferences-actions", children: [
      /* @__PURE__ */ y.jsx(eRe, {}),
      /* @__PURE__ */ y.jsx(tRe, {}),
      /* @__PURE__ */ y.jsx(nRe, {}),
      /* @__PURE__ */ y.jsx(rRe, {}),
      /* @__PURE__ */ y.jsx(iRe, {}),
      /* @__PURE__ */ y.jsx(sRe, {}),
      /* @__PURE__ */ y.jsx(oRe, {}),
      /* @__PURE__ */ y.jsx(lRe, {}),
      /* @__PURE__ */ y.jsx(cRe, {}),
      /* @__PURE__ */ y.jsx(aRe, {})
    ] }),
    /* @__PURE__ */ y.jsx(mn, { id: "color-scheme", children: /* @__PURE__ */ y.jsx(jRe, {}) }),
    /* @__PURE__ */ y.jsx(mn, { id: "language", children: /* @__PURE__ */ y.jsx(hJ, {}) })
  ] }) });
}
const YRe = D.memo(function({ children: t }) {
  const e = io(), [r, i] = Ip("main menu"), s = Dn(), o = t ?? /* @__PURE__ */ y.jsx(FRe, {});
  return /* @__PURE__ */ y.jsxs(OU, { dir: "ltr", open: r, onOpenChange: i, modal: !1, children: [
    /* @__PURE__ */ y.jsx(LU, { asChild: !0, dir: "ltr", children: /* @__PURE__ */ y.jsx(Wt, { type: "icon", "data-testid": "main-menu.button", title: s("menu.title"), children: /* @__PURE__ */ y.jsx(Rn, { icon: "menu", small: !0 }) }) }),
    /* @__PURE__ */ y.jsx(hD, { container: e, children: /* @__PURE__ */ y.jsx(
      jU,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: /* @__PURE__ */ y.jsx(lu, { type: "menu", sourceId: "main-menu", children: o })
      }
    ) })
  ] });
}), dF = {};
function FE(n) {
  if (dF[n])
    return dF[n];
  const e = document.createElement("canvas").getContext("2d");
  e.fillStyle = n, e.fillRect(0, 0, 1, 1);
  const [r, i, s, o] = e.getImageData(0, 0, 1, 1).data, l = new Float32Array([r / 255, i / 255, s / 255, o / 255]);
  return dF[n] = l, l;
}
const AR = 10, pJ = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * AR + // num triangles in center rect
  12 + 4 * 12
);
function _0(n, {
  center: t,
  radius: e,
  numArcSegments: r = 20,
  startAngle: i = 0,
  endAngle: s = wr,
  offset: o = 0
}) {
  const l = (s - i) / r;
  let u = o;
  for (let d = i; d < s; d += l)
    n[u++] = t.x, n[u++] = t.y, n[u++] = t.x + Math.cos(d) * e, n[u++] = t.y + Math.sin(d) * e, n[u++] = t.x + Math.cos(d + l) * e, n[u++] = t.y + Math.sin(d + l) * e;
  return n;
}
function T0(n, t, e, r, i, s) {
  n[t++] = e, n[t++] = r, n[t++] = e, n[t++] = r + s, n[t++] = e + i, n[t++] = r, n[t++] = e + i, n[t++] = r, n[t++] = e, n[t++] = r + s, n[t++] = e + i, n[t++] = r + s;
}
function XRe(n, t, e) {
  const r = AR;
  e = Math.min(e, Math.min(t.w, t.h) / 2);
  const i = vt.ExpandBy(t, -e);
  if (i.w <= 0 || i.h <= 0)
    return _0(n, { center: t.center, radius: e, numArcSegments: AR * 4 }), AR * 4 * 6;
  let s = 0;
  return T0(n, s, i.minX, i.minY, i.w, i.h), s += 12, T0(n, s, i.minX, t.minY, i.w, e), s += 12, T0(n, s, i.maxX, i.minY, e, i.h), s += 12, T0(n, s, i.minX, i.maxY, i.w, e), s += 12, T0(n, s, t.minX, i.minY, e, i.h), s += 12, _0(n, {
    numArcSegments: r,
    offset: s,
    center: i.point,
    radius: e,
    startAngle: cr,
    endAngle: cr * 1.5
  }), s += r * 6, _0(n, {
    numArcSegments: r,
    offset: s,
    center: O.Add(i.point, new O(i.w, 0)),
    radius: e,
    startAngle: cr * 1.5,
    endAngle: wr
  }), s += r * 6, _0(n, {
    numArcSegments: r,
    offset: s,
    center: O.Add(i.point, i.size),
    radius: e,
    startAngle: 0,
    endAngle: ri
  }), s += r * 6, _0(n, {
    numArcSegments: r,
    offset: s,
    center: O.Add(i.point, new O(0, i.h)),
    radius: e,
    startAngle: ri,
    endAngle: cr
  }), pJ;
}
function qRe(n) {
  if (!n) throw new Error("Canvas element not found");
  const t = n.getContext("webgl2", {
    premultipliedAlpha: !1
  });
  if (!t) throw new Error("Failed to get webgl2 context");
  const e = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`, r = t.createShader(t.VERTEX_SHADER);
  if (!r)
    throw new Error("Failed to create vertex shader");
  if (t.shaderSource(r, e), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS))
    throw new Error("Failed to compile vertex shader");
  const i = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`, s = t.createShader(t.FRAGMENT_SHADER);
  if (!s)
    throw new Error("Failed to create fragment shader");
  if (t.shaderSource(s, i), t.compileShader(s), !t.getShaderParameter(s, t.COMPILE_STATUS))
    throw new Error("Failed to compile fragment shader");
  const o = t.createProgram();
  if (!o)
    throw new Error("Failed to create program");
  if (t.attachShader(o, r), t.attachShader(o, s), t.linkProgram(o), !t.getProgramParameter(o, t.LINK_STATUS))
    throw new Error("Failed to link program");
  t.useProgram(o);
  const l = t.getAttribLocation(
    o,
    "shapeVertexPosition"
  );
  if (l < 0)
    throw new Error("Failed to get shapeVertexPosition attribute location");
  t.enableVertexAttribArray(l);
  const u = t.getUniformLocation(o, "canvasPageBounds"), d = t.getUniformLocation(o, "fillColor");
  if (!t.createBuffer()) throw new Error("Failed to create buffer");
  if (!t.createBuffer()) throw new Error("Failed to create buffer");
  return {
    context: t,
    selectedShapes: NI(t, 1024),
    unselectedShapes: NI(t, 4096),
    viewport: NI(t, pJ),
    collaborators: NI(t, 1024),
    prepareTriangles(v, S) {
      t.bindBuffer(t.ARRAY_BUFFER, v.buffer), t.bufferData(t.ARRAY_BUFFER, v.vertices, t.STATIC_DRAW, 0, S), t.enableVertexAttribArray(l), t.vertexAttribPointer(
        l,
        2,
        t.FLOAT,
        !1,
        0,
        0
      );
    },
    drawTrianglesTransparently(v) {
      t.enable(t.BLEND), t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA), t.drawArrays(t.TRIANGLES, 0, v / 2), t.disable(t.BLEND);
    },
    drawTriangles(v) {
      t.drawArrays(t.TRIANGLES, 0, v / 2);
    },
    setFillColor(v) {
      t.uniform4fv(d, v);
    },
    setCanvasPageBounds(v) {
      t.uniform4fv(u, v);
    }
  };
}
function NI(n, t) {
  const e = n.createBuffer();
  if (!e) throw new Error("Failed to create buffer");
  return { buffer: e, vertices: new Float32Array(t) };
}
function bV(n, t, e) {
  let r = n.vertices.length;
  for (; r < t + e.length; )
    r *= 2;
  if (r != n.vertices.length) {
    const i = new Float32Array(r);
    i.set(n.vertices), n.vertices = i;
  }
  n.vertices.set(e, t);
}
var ZRe = Object.defineProperty, QRe = Object.getOwnPropertyDescriptor, jm = (n, t, e, r) => {
  for (var i = QRe(t, e), s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (i = o(t, e, i) || i);
  return i && ZRe(t, e, i), i;
};
class Mp {
  constructor(t, e, r) {
    T(this, "disposables", []);
    T(this, "close", () => this.disposables.forEach((t) => t()));
    T(this, "gl");
    T(this, "shapeGeometryCache");
    T(this, "colors");
    T(this, "id", Ii());
    T(this, "canvasBoundingClientRect", Qs("canvasBoundingClientRect", new vt()));
    T(this, "originPagePoint", new O());
    T(this, "originPageCenter", new O());
    T(this, "isInViewport", !1);
    T(this, "getMinimapPagePoint", (t, e) => {
      const r = this.getCanvasPageBounds(), i = this.getCanvasScreenBounds();
      let s = t - i.x, o = e - i.y;
      return s *= r.width / i.width, o *= r.height / i.height, s += r.minX, o += r.minY, new O(s, o, 1);
    });
    T(this, "minimapScreenPointToPagePoint", (t, e, r = !1, i = !1) => {
      const { editor: s } = this, o = s.getViewportPageBounds();
      let { x: l, y: u } = this.getMinimapPagePoint(t, e);
      if (i) {
        const d = this.editor.getCurrentPageBounds() ?? new vt(), f = d.minX - o.width / 2, m = d.maxX + o.width / 2, v = d.minY - o.height / 2, S = d.maxY + o.height / 2, w = Math.max(0, f + o.width - l), E = Math.max(0, -(m - o.width - l)), A = Math.max(0, v + o.height - u), P = Math.max(0, -(S - o.height - u));
        l += (w - E) / 2, u += (A - P) / 2, l = Zs(l, f, m), u = Zs(u, v, S);
      }
      if (r) {
        const { originPagePoint: d } = this, f = Math.abs(l - d.x), m = Math.abs(u - d.y);
        f > m ? u = d.y : l = d.x;
      }
      return new O(l, u);
    });
    T(this, "render", () => {
      const t = this.gl.context, e = this.getCanvasSize();
      this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray()), this.elem.width = e.x, this.elem.height = e.y, t.viewport(0, 0, e.x, e.y), t.clearColor(
        this.colors.background[0],
        this.colors.background[1],
        this.colors.background[2],
        1
      ), t.clear(t.COLOR_BUFFER_BIT);
      const r = new Set(this.editor.getSelectedShapeIds()), i = this.colors;
      let s = 0, o = 0;
      const l = this.editor.getCurrentPageShapeIdsSorted();
      for (let u = 0, d = l.length; u < d; u++) {
        const f = l[u], m = this.shapeGeometryCache.get(f);
        if (!m) continue;
        const v = m.length;
        r.has(f) ? (bV(this.gl.selectedShapes, s, m), s += v) : (bV(this.gl.unselectedShapes, o, m), o += v);
      }
      this.drawShapes(this.gl.unselectedShapes, o, i.shapeFill), this.drawShapes(this.gl.selectedShapes, s, i.selectFill), this.drawViewport(), this.drawCollaborators();
    });
    this.editor = t, this.elem = e, this.container = r, this.gl = qRe(e), this.shapeGeometryCache = t.store.createComputedCache("webgl-geometry", (i) => {
      const s = t.getShapeMaskedPageBounds(i.id);
      if (!s) return null;
      const o = new Float32Array(12);
      return T0(o, 0, s.x, s.y, s.w, s.h), o;
    }), this.colors = this._getColors(), this.disposables.push(this._listenForCanvasResize(), bS("minimap render", this.render));
  }
  _getColors() {
    const t = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: FE(t.getPropertyValue("--color-text-3").trim()),
      selectFill: FE(t.getPropertyValue("--color-selected").trim()),
      viewportFill: FE(t.getPropertyValue("--color-muted-1").trim()),
      background: FE(t.getPropertyValue("--color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const t = this.editor.getViewportPageBounds(), e = this.editor.getCurrentPageBounds();
    return e ? vt.Expand(e, t) : t;
  }
  getContentScreenBounds() {
    const t = this.getContentPageBounds(), e = this.editor.pageToScreen(t.point), r = this.editor.pageToScreen(
      new O(t.maxX, t.maxY)
    );
    return new vt(e.x, e.y, r.x - e.x, r.y - e.y);
  }
  _getCanvasBoundingRect() {
    const { x: t, y: e, width: r, height: i } = this.elem.getBoundingClientRect();
    return new vt(t, e, r, i);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const t = new ResizeObserver(() => {
      const e = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(e);
    });
    return t.observe(this.elem), t.observe(this.container), () => t.disconnect();
  }
  getCanvasSize() {
    const t = this.canvasBoundingClientRect.get(), e = this.getDpr();
    return new O(t.width * e, t.height * e);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const t = this.getCanvasScreenBounds(), e = this.getContentPageBounds(), r = t.width / t.height;
    let i = e.width, s = i / r;
    s < e.height && (s = e.height, i = s * r);
    const o = new vt(0, 0, i, s);
    return o.center = e.center, o;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x: t, y: e, w: r, h: i } = this.getCanvasPageBounds();
    return new Float32Array([t, e, r, i]);
  }
  drawShapes(t, e, r) {
    this.gl.prepareTriangles(t, e), this.gl.setFillColor(r), this.gl.drawTriangles(e);
  }
  drawViewport() {
    const t = this.editor.getViewportPageBounds(), e = XRe(this.gl.viewport.vertices, t, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, e), this.gl.setFillColor(this.colors.viewportFill), this.gl.drawTrianglesTransparently(e), this.editor.environment.isSafari && (this.gl.drawTrianglesTransparently(e), this.gl.drawTrianglesTransparently(e), this.gl.drawTrianglesTransparently(e));
  }
  drawCollaborators() {
    const t = this.editor.getCollaboratorsOnCurrentPage();
    if (!t.length) return;
    const e = 20, r = e * 6, i = r * t.length;
    this.gl.collaborators.vertices.length < i && (this.gl.collaborators.vertices = new Float32Array(i));
    const s = this.gl.collaborators.vertices;
    let o = 0;
    const l = this.getZoom();
    for (const { cursor: u } of t)
      _0(s, {
        center: O.From(u),
        radius: 3 * l,
        offset: o,
        numArcSegments: e
      }), o += r;
    this.gl.prepareTriangles(this.gl.collaborators, i), o = 0;
    for (const { color: u } of t)
      this.gl.setFillColor(FE(u)), this.gl.context.drawArrays(this.gl.context.TRIANGLES, o / 2, r / 2), o += r;
  }
}
jm([
  ze
], Mp.prototype, "getDpr");
jm([
  ze
], Mp.prototype, "getContentPageBounds");
jm([
  ze
], Mp.prototype, "getContentScreenBounds");
jm([
  ze
], Mp.prototype, "getCanvasSize");
jm([
  ze
], Mp.prototype, "getCanvasClientPosition");
jm([
  ze
], Mp.prototype, "getCanvasPageBounds");
jm([
  ze
], Mp.prototype, "getZoom");
jm([
  ze
], Mp.prototype, "getCanvasPageBoundsArray");
function JRe() {
  const n = we(), t = io(), e = D.useRef(null), r = D.useRef(!1), i = D.useRef();
  D.useEffect(() => {
    try {
      const f = new Mp(n, e.current, t);
      return i.current = f, i.current.close;
    } catch (f) {
      n.annotateError(f, {
        origin: "minimap",
        willCrashApp: !1
      }), n.timers.setTimeout(() => {
        throw f;
      });
    }
  }, [n, t]);
  const s = D.useCallback(
    (f) => {
      if (!n.getCurrentPageShapeIds().size || !i.current) return;
      const m = i.current.minimapScreenPointToPagePoint(
        f.clientX,
        f.clientY,
        !1,
        !1
      ), v = i.current.minimapScreenPointToPagePoint(
        f.clientX,
        f.clientY,
        !1,
        !0
      );
      i.current.originPagePoint.setTo(v), i.current.originPageCenter.setTo(n.getViewportPageBounds().center), n.centerOnPoint(m, { animation: { duration: n.options.animationMediumMs } });
    },
    [n]
  ), o = D.useCallback(
    (f) => {
      if (!i.current) return;
      const m = f.currentTarget;
      if (UT(m, f), !n.getCurrentPageShapeIds().size) return;
      r.current = !0, i.current.isInViewport = !1;
      const v = i.current.minimapScreenPointToPagePoint(
        f.clientX,
        f.clientY,
        !1,
        !1
      ), S = n.getViewportPageBounds(), w = i.current.getContentPageBounds();
      if (new vt(
        w.x - S.width / 2,
        w.y - S.height / 2,
        w.width + S.width,
        w.height + S.height
      ).containsPoint(v) && !S.containsPoint(v)) {
        i.current.isInViewport = S.containsPoint(v);
        const P = O.Sub(S.center, S.point), R = O.Add(v, P);
        i.current.originPagePoint.setTo(R), i.current.originPageCenter.setTo(v), n.centerOnPoint(v, { animation: { duration: n.options.animationMediumMs } });
      } else {
        const P = i.current.minimapScreenPointToPagePoint(
          f.clientX,
          f.clientY,
          !1,
          !0
        );
        i.current.isInViewport = S.containsPoint(P), i.current.originPagePoint.setTo(P), i.current.originPageCenter.setTo(S.center);
      }
      function A(P) {
        m && BT(m, P), r.current = !1, document.body.removeEventListener("pointerup", A);
      }
      document.body.addEventListener("pointerup", A);
    },
    [n]
  ), l = D.useCallback(
    (f) => {
      if (!i.current) return;
      const m = i.current.minimapScreenPointToPagePoint(
        f.clientX,
        f.clientY,
        f.shiftKey,
        !0
      );
      if (r.current) {
        if (i.current.isInViewport) {
          const E = i.current.originPagePoint.clone().sub(i.current.originPageCenter);
          n.centerOnPoint(O.Sub(m, E));
          return;
        }
        n.centerOnPoint(m);
      }
      const v = i.current.getMinimapPagePoint(f.clientX, f.clientY), S = n.pageToScreen(v), w = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...Ol(f),
        point: S,
        isPen: n.getInstanceState().isPenMode
      };
      n.dispatch(w);
    },
    [n]
  ), u = D.useCallback(
    (f) => {
      const m = jK(f);
      n.dispatch({
        type: "wheel",
        name: "wheel",
        delta: m,
        point: new O(f.clientX, f.clientY),
        shiftKey: f.shiftKey,
        altKey: f.altKey,
        ctrlKey: f.metaKey || f.ctrlKey
      });
    },
    [n]
  ), d = KT();
  return D.useEffect(() => {
    n.timers.setTimeout(() => {
      var f, m;
      (f = i.current) == null || f.updateColors(), (m = i.current) == null || m.render();
    });
  }, [d, n]), /* @__PURE__ */ y.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ y.jsx(
    "canvas",
    {
      role: "img",
      "aria-label": "minimap",
      ref: e,
      className: "tlui-minimap__canvas",
      onDoubleClick: s,
      onPointerMove: l,
      onPointerDown: o,
      onWheel: u
    }
  ) });
}
function eMe(n, t) {
  const [e, r] = Gn.useState(t);
  Gn.useLayoutEffect(() => {
    const s = Qz(n);
    if (s)
      try {
        r(JSON.parse(s));
      } catch {
        console.error(`Could not restore value ${n} from local storage.`);
      }
  }, [n]);
  const i = Gn.useCallback(
    (s) => {
      r((o) => {
        const l = typeof s == "function" ? s(o) : s;
        return Jz(n, JSON.stringify(l)), l;
      });
    },
    [n]
  );
  return [e, i];
}
const tMe = D.memo(function() {
  const t = Dt(), e = Dn(), r = Ya(), [i, s] = eMe("minimap", !0), o = D.useCallback(() => {
    s((d) => !d);
  }, [s]), { ZoomMenu: l, Minimap: u } = Nm();
  return r < Ui.MOBILE ? null : /* @__PURE__ */ y.jsxs("div", { className: "tlui-navigation-panel", children: [
    /* @__PURE__ */ y.jsx("div", { className: "tlui-buttons__horizontal", children: l && r < Ui.TABLET ? /* @__PURE__ */ y.jsx(l, {}) : i ? /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      l && /* @__PURE__ */ y.jsx(l, {}),
      u && /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: e("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-panel__toggle",
          onClick: o,
          children: /* @__PURE__ */ y.jsx(Rn, { icon: i ? "chevrons-ne" : "chevrons-sw" })
        }
      )
    ] }) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${e(W1(t["zoom-out"].label))} ${Z3(t["zoom-out"].kbd)}`,
          onClick: () => t["zoom-out"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ y.jsx(Rn, { icon: "minus" })
        }
      ),
      l && /* @__PURE__ */ y.jsx(l, {}),
      /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${e(W1(t["zoom-in"].label))} ${Z3(t["zoom-in"].kbd)}`,
          onClick: () => t["zoom-in"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ y.jsx(Rn, { icon: "plus" })
        }
      ),
      u && /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: e("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-panel__toggle",
          onClick: o,
          children: /* @__PURE__ */ y.jsx(Rn, { icon: i ? "chevrons-ne" : "chevrons-sw" })
        }
      )
    ] }) }),
    u && r >= Ui.TABLET && !i && /* @__PURE__ */ y.jsx(u, {})
  ] });
}), nMe = function({
  name: t,
  id: e,
  isCurrentPage: r
}) {
  const i = we(), s = Fo(), o = D.useRef(null), l = D.useCallback(() => {
    i.mark("rename page");
  }, [i]), u = D.useCallback(
    (d) => {
      i.renamePage(e, d || "New Page"), s("rename-page", { source: "page-menu" });
    },
    [i, e, s]
  );
  return /* @__PURE__ */ y.jsx(
    nD,
    {
      className: "tlui-page-menu__item__input",
      ref: (d) => o.current = d,
      defaultValue: t,
      onValueChange: u,
      onFocus: l,
      shouldManuallyMaintainScrollPositionWhenFocused: !0,
      autoFocus: r,
      autoSelect: !0
    }
  );
}, J3 = (n, t, e, r, i) => {
  let s;
  const o = n.getPages(), l = e > r ? o[r - 1] : o[r], u = e > r ? o[r] : o[r + 1];
  l && !u ? s = id(l.index) : !l && u ? s = Dme(o[0].index) : s = $1(l.index, u.index), s !== o[e].index && (n.mark("moving page"), n.updatePage({
    id: t,
    index: s
  }), i("move-page", { source: "page-menu" }));
}, xV = ro(function({
  index: t,
  listSize: e,
  item: r,
  onRename: i
}) {
  const s = we(), o = Dn(), l = s.getPages(), u = Fo(), d = D.useCallback(() => {
    s.mark("creating page");
    const S = yp.createId();
    s.duplicatePage(r.id, S), u("duplicate-page", { source: "page-menu" });
  }, [s, r, u]), f = D.useCallback(() => {
    J3(s, r.id, t, t - 1, u);
  }, [s, r, t, u]), m = D.useCallback(() => {
    J3(s, r.id, t, t + 1, u);
  }, [s, r, t, u]), v = D.useCallback(() => {
    s.mark("deleting page"), s.deletePage(r.id), u("delete-page", { source: "page-menu" });
  }, [s, r, u]);
  return /* @__PURE__ */ y.jsxs(lS, { id: `page item submenu ${t}`, children: [
    /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsx(Wt, { type: "icon", title: o("page-menu.submenu.title"), children: /* @__PURE__ */ y.jsx(Rn, { icon: "dots-vertical" }) }) }),
    /* @__PURE__ */ y.jsx(uS, { alignOffset: 0, side: "right", sideOffset: -4, children: /* @__PURE__ */ y.jsxs(lu, { type: "menu", sourceId: "page-menu", children: [
      /* @__PURE__ */ y.jsxs(mn, { id: "modify", children: [
        i && /* @__PURE__ */ y.jsx(Me, { id: "rename", label: "page-menu.submenu.rename", onSelect: i }),
        /* @__PURE__ */ y.jsx(
          Me,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: d,
            disabled: l.length >= s.options.maxPages
          }
        ),
        t > 0 && /* @__PURE__ */ y.jsx(
          Me,
          {
            id: "move-up",
            onSelect: f,
            label: "page-menu.submenu.move-up"
          }
        ),
        t < e - 1 && /* @__PURE__ */ y.jsx(
          Me,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: m
          }
        )
      ] }),
      e > 1 && /* @__PURE__ */ y.jsx(mn, { id: "delete", children: /* @__PURE__ */ y.jsx(Me, { id: "delete", onSelect: v, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
}), rMe = D.memo(function() {
  const t = we(), e = Fo(), r = Dn(), i = Ya(), s = D.useCallback(() => P(!1), []), [o, l] = Ip("page-menu", s), u = 36, d = D.useRef(null), f = De("pages", () => t.getPages(), [t]), m = De("currentPage", () => t.getCurrentPage(), [t]), v = De("currentPageId", () => t.getCurrentPageId(), [t]), S = Ap(), w = De(
    "maxPageCountReached",
    () => t.getPages().length >= t.options.maxPages,
    [t]
  ), E = De(
    "isCoarsePointer",
    () => t.getInstanceState().isCoarsePointer,
    [t]
  ), [A, P] = D.useState(!1), R = D.useCallback(() => {
    S || P((K) => !K);
  }, [S]), M = D.useRef({
    isPointing: !1,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  }), [j, $] = D.useState(
    Object.fromEntries(
      f.map((K, Z) => [K.id, { y: Z * u, offsetY: 0, isSelected: !1 }])
    )
  );
  D.useLayoutEffect(() => {
    $(
      Object.fromEntries(
        f.map((K, Z) => [K.id, { y: Z * u, offsetY: 0, isSelected: !1 }])
      )
    );
  }, [u, f]), D.useEffect(() => {
    o && t.timers.requestAnimationFrame(() => {
      const K = document.querySelector(
        `[data-testid="page-menu-item-${v}"]`
      );
      if (K) {
        const Z = d.current;
        if (!Z) return;
        const oe = K.offsetTop, fe = Z.scrollTop;
        oe < fe && Z.scrollTo({ top: oe });
        const ie = oe + u, ue = Z.scrollTop + Z.offsetHeight;
        ie > ue && Z.scrollTo({ top: ie - Z.offsetHeight });
      }
    });
  }, [u, v, o, t]);
  const U = D.useCallback(
    (K) => {
      const { clientY: Z, currentTarget: oe } = K, {
        dataset: { id: fe, index: ie }
      } = oe;
      if (!fe || !ie) return;
      const ue = M.current;
      UT(K.currentTarget, K), ue.status = "pointing", ue.pointing = { id: fe, index: +ie };
      const ke = j[fe].y;
      ue.startY = Z, ue.startIndex = Math.max(0, Math.min(Math.round(ke / u), f.length - 1));
    },
    [u, f.length, j]
  ), F = D.useCallback(
    (K) => {
      const Z = M.current;
      if (Z.status === "pointing") {
        const { clientY: oe } = K, fe = oe - Z.startY;
        Math.abs(fe) > 5 && (Z.status = "dragging");
      }
      if (Z.status === "dragging") {
        const { clientY: oe } = K, fe = oe - Z.startY, ie = j[Z.pointing.id], { startIndex: ue, pointing: Se } = Z, ke = ie.y + fe, ce = Math.max(0, Math.min(Math.round(ke / u), f.length - 1)), ye = { ...j };
        if (ye[Se.id] = {
          y: ie.y,
          offsetY: fe,
          isSelected: !0
        }, ce !== Z.dragIndex) {
          Z.dragIndex = ce;
          for (let Fe = 0; Fe < f.length; Fe++) {
            const Xe = f[Fe];
            if (Xe.id === Z.pointing.id)
              continue;
            let { y: je } = ye[Xe.id];
            ce === ue ? je = Fe * u : ce < ue ? ce <= Fe && Fe < ue ? je = (Fe + 1) * u : je = Fe * u : ce > ue && (ce >= Fe && Fe > ue ? je = (Fe - 1) * u : je = Fe * u), je !== ye[Xe.id].y && (ye[Xe.id] = { y: je, offsetY: 0, isSelected: !0 });
          }
        }
        $(ye);
      }
    },
    [u, f, j]
  ), B = D.useCallback(
    (K) => {
      const Z = M.current;
      if (Z.status === "dragging") {
        const { id: oe, index: fe } = Z.pointing;
        J3(t, oe, fe, Z.dragIndex, e);
      }
      BT(K.currentTarget, K), Z.status = "idle";
    },
    [t, e]
  ), G = D.useCallback(
    (K) => {
      const Z = M.current;
      K.key === "Escape" && (Z.status === "dragging" && $(
        Object.fromEntries(
          f.map((oe, fe) => [
            oe.id,
            { y: fe * u, offsetY: 0, isSelected: !1 }
          ])
        )
      ), Z.status = "idle");
    },
    [u, f]
  ), X = D.useCallback(() => {
    S || (t.run(() => {
      t.mark("creating page");
      const K = yp.createId();
      t.createPage({ name: r("page-menu.new-page-initial-name"), id: K }), t.setCurrentPage(K), P(!0);
    }), e("new-page", { source: "page-menu" }));
  }, [t, r, S, e]), te = D.useCallback(
    (K) => {
      t.setCurrentPage(K), e("change-page", { source: "page-menu" });
    },
    [t, e]
  ), ne = D.useCallback(
    (K, Z) => {
      t.renamePage(K, Z), e("rename-page", { source: "page-menu" });
    },
    [t, e]
  );
  return /* @__PURE__ */ y.jsxs(SU, { id: "pages", onOpenChange: l, open: o, children: [
    /* @__PURE__ */ y.jsx(bU, { "data-testid": "main.page-menu", children: /* @__PURE__ */ y.jsxs(
      Wt,
      {
        type: "menu",
        title: m.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          /* @__PURE__ */ y.jsx("div", { className: "tlui-page-menu__name", children: m.name }),
          /* @__PURE__ */ y.jsx(Rn, { icon: "chevron-down", small: !0 })
        ]
      }
    ) }),
    /* @__PURE__ */ y.jsx(xU, { side: "bottom", align: "start", sideOffset: 6, children: /* @__PURE__ */ y.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
      /* @__PURE__ */ y.jsxs("div", { className: "tlui-page-menu__header", children: [
        /* @__PURE__ */ y.jsx("div", { className: "tlui-page-menu__header__title", children: r("page-menu.title") }),
        !S && /* @__PURE__ */ y.jsxs("div", { className: "tlui-buttons__horizontal", children: [
          /* @__PURE__ */ y.jsx(
            Wt,
            {
              type: "icon",
              "data-testid": "page-menu.edit",
              title: r(A ? "page-menu.edit-done" : "page-menu.edit-start"),
              onClick: R,
              children: /* @__PURE__ */ y.jsx(Rn, { icon: A ? "check" : "edit" })
            }
          ),
          /* @__PURE__ */ y.jsx(
            Wt,
            {
              type: "icon",
              "data-testid": "page-menu.create",
              title: r(
                w ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
              ),
              disabled: w,
              onClick: X,
              children: /* @__PURE__ */ y.jsx(Rn, { icon: "plus" })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ y.jsx(
        "div",
        {
          "data-testid": "page-menu.list",
          className: "tlui-page-menu__list tlui-menu__group",
          style: { height: u * f.length + 4 },
          ref: d,
          children: f.map((K, Z) => {
            const oe = j[K.id] ?? {
              position: Z * 40,
              offsetY: 0
            };
            return A ? /* @__PURE__ */ y.jsxs(
              "div",
              {
                "data-testid": "page-menu.item",
                className: "tlui-page_menu__item__sortable",
                style: {
                  zIndex: K.id === m.id ? 888 : Z,
                  transform: `translate(0px, ${oe.y + oe.offsetY}px)`
                },
                children: [
                  /* @__PURE__ */ y.jsx(
                    Wt,
                    {
                      type: "icon",
                      tabIndex: -1,
                      className: "tlui-page_menu__item__sortable__handle",
                      onPointerDown: U,
                      onPointerUp: B,
                      onPointerMove: F,
                      onKeyDown: G,
                      "data-id": K.id,
                      "data-index": Z,
                      children: /* @__PURE__ */ y.jsx(Rn, { icon: "drag-handle-dots" })
                    }
                  ),
                  i < Ui.TABLET_SM && E ? (
                    // sigh, this is a workaround for iOS Safari
                    // because the device and the radix popover seem
                    // to be fighting over scroll position. Nothing
                    // else seems to work!
                    /* @__PURE__ */ y.jsxs(Wt, {
                      type: "normal",
                      className: "tlui-page-menu__item__button",
                      onClick: () => {
                        const fe = window.prompt("Rename page", K.name);
                        fe && fe !== K.name && ne(K.id, fe);
                      },
                      onDoubleClick: R,
                      children: [
                        /* @__PURE__ */ y.jsx(Q3, { checked: K.id === m.id }),
                        /* @__PURE__ */ y.jsx(Zi, { children: K.name })
                      ]
                    })
                  ) : /* @__PURE__ */ y.jsx(
                    "div",
                    {
                      className: "tlui-page_menu__item__sortable__title",
                      style: { height: u },
                      children: /* @__PURE__ */ y.jsx(
                        nMe,
                        {
                          id: K.id,
                          name: K.name,
                          isCurrentPage: K.id === m.id
                        }
                      )
                    }
                  ),
                  !S && /* @__PURE__ */ y.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": A, children: /* @__PURE__ */ y.jsx(xV, { index: Z, item: K, listSize: f.length }) })
                ]
              },
              K.id + "_editing"
            ) : /* @__PURE__ */ y.jsxs("div", { "data-testid": "page-menu.item", className: "tlui-page-menu__item", children: [
              /* @__PURE__ */ y.jsxs(
                Wt,
                {
                  type: "normal",
                  className: "tlui-page-menu__item__button",
                  onClick: () => te(K.id),
                  onDoubleClick: R,
                  title: r("page-menu.go-to-page"),
                  children: [
                    /* @__PURE__ */ y.jsx(Q3, { checked: K.id === m.id }),
                    /* @__PURE__ */ y.jsx(Zi, { children: K.name })
                  ]
                }
              ),
              !S && /* @__PURE__ */ y.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ y.jsx(
                xV,
                {
                  index: Z,
                  item: K,
                  listSize: f.length,
                  onRename: () => {
                    if (t.environment.isIos) {
                      const fe = window.prompt("Rename page", K.name);
                      fe && fe !== K.name && ne(K.id, fe);
                    } else
                      P(!0), v !== K.id && te(K.id);
                  }
                }
              ) })
            ] }, K.id);
          })
        }
      )
    ] }) })
  ] });
});
function iMe() {
  const n = Dt(), t = we(), e = IZ(), r = kZ(), i = Xa(1), s = Ap(), o = De(
    "should display quick actions",
    () => t.isInAny("select", "hand", "zoom"),
    [t]
  ), l = Rp(), u = i && l;
  if (!(s && !o))
    return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(Me, { ...n.undo, disabled: !e }),
      /* @__PURE__ */ y.jsx(Me, { ...n.redo, disabled: !r }),
      /* @__PURE__ */ y.jsx(Me, { ...n.delete, disabled: !u }),
      /* @__PURE__ */ y.jsx(Me, { ...n.duplicate, disabled: !u })
    ] });
}
const sMe = D.memo(function({
  children: t
}) {
  const e = t ?? /* @__PURE__ */ y.jsx(iMe, {});
  return /* @__PURE__ */ y.jsx(lu, { type: "small-icons", sourceId: "quick-actions", children: e });
});
function oMe({ userId: n }) {
  const t = D2(n);
  return t ? /* @__PURE__ */ y.jsx(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: t.color
      },
      children: t.userName === "New User" ? "" : t.userName[0] ?? ""
    },
    n
  ) : null;
}
const aMe = ro(function({ userId: t }) {
  const e = we(), r = Dn(), i = Fo(), s = D2(t), o = D.useCallback(() => {
    e.getInstanceState().followingUserId === t ? (e.stopFollowingUser(), i("stop-following", { source: "people-menu" })) : (e.startFollowingUser(t), i("start-following", { source: "people-menu" }));
  }, [e, t, i]), l = (s == null ? void 0 : s.followingUserId) === e.user.getId(), u = e.getInstanceState().followingUserId === t;
  return s ? /* @__PURE__ */ y.jsxs("div", { className: "tlui-people-menu__item tlui-buttons__horizontal", children: [
    /* @__PURE__ */ y.jsxs(
      Wt,
      {
        type: "menu",
        className: "tlui-people-menu__item__button",
        onClick: () => e.zoomToUser(t),
        onDoubleClick: o,
        children: [
          /* @__PURE__ */ y.jsx(Ih, { icon: "color", color: s.color }),
          /* @__PURE__ */ y.jsx("div", { className: "tlui-people-menu__name", children: s.userName ?? "New User" })
        ]
      }
    ),
    /* @__PURE__ */ y.jsx(
      Wt,
      {
        type: "icon",
        className: "tlui-people-menu__item__follow",
        title: r(l ? "people-menu.leading" : u ? "people-menu.following" : "people-menu.follow"),
        onClick: o,
        disabled: l,
        "data-active": u || l,
        children: /* @__PURE__ */ y.jsx(
          Rn,
          {
            icon: l ? "leading" : u ? "following" : "follow"
          }
        )
      }
    )
  ] }) : null;
});
function lMe({ count: n }) {
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-people-menu__more", children: "+" + Math.abs(n) });
}
const cMe = ro(function() {
  const t = we(), e = io(), r = Dn(), i = Fo(), s = D.useRef(!1), [o, l] = D.useState(!1), u = D.useCallback((E) => {
    l(E);
  }, []), d = t.user.getColor(), f = D.useCallback(
    (E) => {
      t.user.updateUserPreferences({ color: E }), i("set-color", { source: "people-menu" });
    },
    [t, i]
  ), {
    handleButtonClick: m,
    handleButtonPointerDown: v,
    handleButtonPointerEnter: S,
    handleButtonPointerUp: w
  } = Gn.useMemo(() => {
    const E = () => {
      s.current = !1, window.removeEventListener("pointerup", E);
    };
    return {
      handleButtonClick: (j) => {
        const { id: $ } = j.currentTarget.dataset;
        $ && d !== $ && f($);
      },
      handleButtonPointerDown: (j) => {
        const { id: $ } = j.currentTarget.dataset;
        $ && (f($), s.current = !0, window.addEventListener("pointerup", E));
      },
      handleButtonPointerEnter: (j) => {
        if (!s.current) return;
        const { id: $ } = j.currentTarget.dataset;
        $ && f($);
      },
      handleButtonPointerUp: (j) => {
        const { id: $ } = j.currentTarget.dataset;
        $ && f($);
      }
    };
  }, [d, f]);
  return /* @__PURE__ */ y.jsxs(gU, { onOpenChange: u, open: o, children: [
    /* @__PURE__ */ y.jsx(mU, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ y.jsx(
      Wt,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: t.user.getColor() },
        title: r("people-menu.change-color"),
        children: /* @__PURE__ */ y.jsx(Rn, { icon: "color" })
      }
    ) }),
    /* @__PURE__ */ y.jsx(vU, { container: e, children: /* @__PURE__ */ y.jsx(
      yU,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: /* @__PURE__ */ y.jsx("div", { className: "tlui-buttons__grid", children: y3.map((E) => /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "icon",
            "data-id": E,
            "data-testid": E,
            "aria-label": E,
            "data-state": d === E ? "hinted" : void 0,
            title: E,
            className: "tlui-button-grid__button",
            style: { color: E },
            onPointerEnter: S,
            onPointerDown: v,
            onPointerUp: w,
            onClick: m,
            children: /* @__PURE__ */ y.jsx(Rn, { icon: "color" })
          },
          E
        )) })
      }
    ) })
  ] });
});
function uMe() {
  const n = we(), t = Fo(), e = De("userName", () => n.user.getName(), []), r = Dn(), i = D.useRef(e), s = D.useRef(e), [o, l] = D.useState(!1), u = D.useCallback(() => {
    l((m) => !m);
  }, []), d = D.useCallback(
    (m) => {
      s.current = m, n.user.updateUserPreferences({ name: m });
    },
    [n]
  ), f = D.useCallback(() => {
    i.current !== s.current && (t("change-user-name", { source: "people-menu" }), i.current = s.current);
  }, [t]);
  return /* @__PURE__ */ y.jsxs("div", { className: "tlui-people-menu__user", children: [
    /* @__PURE__ */ y.jsx(cMe, {}),
    o ? /* @__PURE__ */ y.jsx(
      nD,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: e,
        onValueChange: d,
        onComplete: u,
        onCancel: u,
        onBlur: f,
        shouldManuallyMaintainScrollPositionWhenFocused: !0,
        autoFocus: !0,
        autoSelect: !0
      }
    ) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
      /* @__PURE__ */ y.jsx(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            o || l(!0);
          },
          children: e
        }
      ),
      e === "New User" ? /* @__PURE__ */ y.jsx("div", { className: "tlui-people-menu__user__label", children: r("people-menu.user") }) : null
    ] }),
    /* @__PURE__ */ y.jsx(
      Wt,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: r("people-menu.change-name"),
        onClick: u,
        children: /* @__PURE__ */ y.jsx(Rn, { icon: o ? "check" : "edit" })
      }
    )
  ] });
}
const dMe = ro(function({ children: t }) {
  const e = Dn(), r = io(), i = we(), s = UK(), o = De("user", () => i.user.getColor(), [i]), l = De("user", () => i.user.getName(), [i]), [u, d] = Ip("people menu");
  return /* @__PURE__ */ y.jsxs(gU, { onOpenChange: d, open: u, children: [
    /* @__PURE__ */ y.jsx(mU, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ y.jsxs("button", { className: "tlui-people-menu__avatars-button", title: e("people-menu.title"), children: [
      s.length > 5 && /* @__PURE__ */ y.jsx(lMe, { count: s.length - 5 }),
      /* @__PURE__ */ y.jsxs("div", { className: "tlui-people-menu__avatars", children: [
        s.slice(-5).map((f) => /* @__PURE__ */ y.jsx(oMe, { userId: f }, f)),
        /* @__PURE__ */ y.jsx(
          "div",
          {
            className: "tlui-people-menu__avatar",
            style: {
              backgroundColor: o
            },
            children: l === "New User" ? "" : l[0] ?? ""
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ y.jsx(vU, { container: r, children: /* @__PURE__ */ y.jsx(
      yU,
      {
        dir: "ltr",
        className: "tlui-menu",
        align: "end",
        side: "bottom",
        sideOffset: 2,
        alignOffset: -5,
        children: /* @__PURE__ */ y.jsxs("div", { className: "tlui-people-menu__wrapper", children: [
          /* @__PURE__ */ y.jsx("div", { className: "tlui-people-menu__section", children: /* @__PURE__ */ y.jsx(uMe, {}) }),
          s.length > 0 && /* @__PURE__ */ y.jsx("div", { className: "tlui-people-menu__section", children: s.map((f) => /* @__PURE__ */ y.jsx(aMe, { userId: f }, f + "_presence")) }),
          t
        ] })
      }
    ) })
  ] });
});
function hMe() {
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-share-zone", draggable: !1, children: /* @__PURE__ */ y.jsx(dMe, {}) });
}
const fMe = Object.freeze([
  xc,
  eS,
  tS,
  Ah
]);
function zU(n = fMe) {
  const t = we();
  return De(
    "getRelevantStyles",
    () => {
      var s;
      const e = new w3(t.getSharedStyles()), r = !!((s = t.root.getCurrent()) != null && s.shapeType), i = t.isIn("select") && t.getSelectedShapeIds().length > 0;
      if (e.size === 0 && t.isIn("select") && t.getSelectedShapeIds().length === 0)
        for (const o of n)
          e.applyValue(o, t.getStyleForNextShape(o));
      return r || i || e.size > 0 ? e : null;
    },
    [t]
  );
}
const ou = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
}, Qv = D.memo(function(t) {
  const {
    uiType: e,
    items: r,
    title: i,
    style: s,
    value: o,
    // columns = clamp(items.length, 2, 4),
    onValueChange: l,
    theme: u
  } = t, d = we(), f = Dn(), m = D.useRef(!1), v = D.useRef(null), {
    handleButtonClick: S,
    handleButtonPointerDown: w,
    handleButtonPointerEnter: E,
    handleButtonPointerUp: A
  } = D.useMemo(() => {
    const P = () => {
      m.current = !1, window.removeEventListener("pointerup", P);
      const U = v.current;
      U && ["TEXTAREA", "INPUT"].includes(U.nodeName) && U.focus(), v.current = null;
    };
    return {
      handleButtonClick: (U) => {
        const { id: F } = U.currentTarget.dataset;
        o.type === "shared" && o.value === F || (d.mark("point picker item"), l(s, F));
      },
      handleButtonPointerDown: (U) => {
        const { id: F } = U.currentTarget.dataset;
        d.mark("point picker item"), l(s, F), m.current = !0, v.current = document.activeElement, window.addEventListener("pointerup", P);
      },
      handleButtonPointerEnter: (U) => {
        if (!m.current) return;
        const { id: F } = U.currentTarget.dataset;
        l(s, F);
      },
      handleButtonPointerUp: (U) => {
        const { id: F } = U.currentTarget.dataset;
        o.type === "shared" && o.value === F || l(s, F);
      }
    };
  }, [o, d, l, s]);
  return /* @__PURE__ */ y.jsx("div", { "data-testid": `style.${e}`, className: Vt("tlui-buttons__grid"), children: r.map((P) => /* @__PURE__ */ y.jsx(
    Wt,
    {
      type: "icon",
      "data-id": P.value,
      "data-testid": `style.${e}.${P.value}`,
      "aria-label": P.value,
      "data-state": o.type === "shared" && o.value === P.value ? "hinted" : void 0,
      title: i + " — " + f(`${e}-style.${P.value}`),
      className: Vt("tlui-button-grid__button"),
      style: s === xc ? { color: u[P.value].solid } : void 0,
      onPointerEnter: E,
      onPointerDown: w,
      onPointerUp: A,
      onClick: S,
      children: /* @__PURE__ */ y.jsx(Rn, { icon: P.icon })
    },
    P.value
  )) });
});
function gJ(n, [t, e]) {
  return Math.min(e, Math.max(t, n));
}
function pMe(n) {
  const t = D.useRef({ value: n, previous: n });
  return D.useMemo(() => (t.current.value !== n && (t.current.previous = t.current.value, t.current.value = n), t.current.previous), [n]);
}
var mJ = ["PageUp", "PageDown"], vJ = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], yJ = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, yw = "Slider", [e$, gMe, mMe] = q2(yw), [SJ, FNe] = jh(yw, [
  mMe
]), [vMe, fD] = SJ(yw), bJ = D.forwardRef(
  (n, t) => {
    const {
      name: e,
      min: r = 0,
      max: i = 100,
      step: s = 1,
      orientation: o = "horizontal",
      disabled: l = !1,
      minStepsBetweenThumbs: u = 0,
      defaultValue: d = [r],
      value: f,
      onValueChange: m = () => {
      },
      onValueCommit: v = () => {
      },
      inverted: S = !1,
      ...w
    } = n, E = D.useRef(/* @__PURE__ */ new Set()), A = D.useRef(0), R = o === "horizontal" ? yMe : SMe, [M = [], j] = Dm({
      prop: f,
      defaultProp: d,
      onChange: (X) => {
        var ne;
        (ne = [...E.current][A.current]) == null || ne.focus(), m(X);
      }
    }), $ = D.useRef(M);
    function U(X) {
      const te = EMe(M, X);
      G(X, te);
    }
    function F(X) {
      G(X, A.current);
    }
    function B() {
      const X = $.current[A.current];
      M[A.current] !== X && v(M);
    }
    function G(X, te, { commit: ne } = { commit: !1 }) {
      const K = AMe(s), Z = kMe(Math.round((X - r) / s) * s + r, K), oe = gJ(Z, [r, i]);
      j((fe = []) => {
        const ie = wMe(fe, oe, te);
        if (PMe(ie, u * s)) {
          A.current = ie.indexOf(oe);
          const ue = String(ie) !== String(fe);
          return ue && ne && v(ie), ue ? ie : fe;
        } else
          return fe;
      });
    }
    return /* @__PURE__ */ y.jsx(
      vMe,
      {
        scope: n.__scopeSlider,
        name: e,
        disabled: l,
        min: r,
        max: i,
        valueIndexToChangeRef: A,
        thumbs: E.current,
        values: M,
        orientation: o,
        children: /* @__PURE__ */ y.jsx(e$.Provider, { scope: n.__scopeSlider, children: /* @__PURE__ */ y.jsx(e$.Slot, { scope: n.__scopeSlider, children: /* @__PURE__ */ y.jsx(
          R,
          {
            "aria-disabled": l,
            "data-disabled": l ? "" : void 0,
            ...w,
            ref: t,
            onPointerDown: Et(w.onPointerDown, () => {
              l || ($.current = M);
            }),
            min: r,
            max: i,
            inverted: S,
            onSlideStart: l ? void 0 : U,
            onSlideMove: l ? void 0 : F,
            onSlideEnd: l ? void 0 : B,
            onHomeKeyDown: () => !l && G(r, 0, { commit: !0 }),
            onEndKeyDown: () => !l && G(i, M.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: X, direction: te }) => {
              if (!l) {
                const Z = mJ.includes(X.key) || X.shiftKey && vJ.includes(X.key) ? 10 : 1, oe = A.current, fe = M[oe], ie = s * Z * te;
                G(fe + ie, oe, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
bJ.displayName = yw;
var [xJ, wJ] = SJ(yw, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), yMe = D.forwardRef(
  (n, t) => {
    const {
      min: e,
      max: r,
      dir: i,
      inverted: s,
      onSlideStart: o,
      onSlideMove: l,
      onSlideEnd: u,
      onStepKeyDown: d,
      ...f
    } = n, [m, v] = D.useState(null), S = si(t, (M) => v(M)), w = D.useRef(), E = wU(i), A = E === "ltr", P = A && !s || !A && s;
    function R(M) {
      const j = w.current || m.getBoundingClientRect(), $ = [0, j.width], F = UU($, P ? [e, r] : [r, e]);
      return w.current = j, F(M - j.left);
    }
    return /* @__PURE__ */ y.jsx(
      xJ,
      {
        scope: n.__scopeSlider,
        startEdge: P ? "left" : "right",
        endEdge: P ? "right" : "left",
        direction: P ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ y.jsx(
          CJ,
          {
            dir: E,
            "data-orientation": "horizontal",
            ...f,
            ref: S,
            style: {
              ...f.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (M) => {
              const j = R(M.clientX);
              o == null || o(j);
            },
            onSlideMove: (M) => {
              const j = R(M.clientX);
              l == null || l(j);
            },
            onSlideEnd: () => {
              w.current = void 0, u == null || u();
            },
            onStepKeyDown: (M) => {
              const $ = yJ[P ? "from-left" : "from-right"].includes(M.key);
              d == null || d({ event: M, direction: $ ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), SMe = D.forwardRef(
  (n, t) => {
    const {
      min: e,
      max: r,
      inverted: i,
      onSlideStart: s,
      onSlideMove: o,
      onSlideEnd: l,
      onStepKeyDown: u,
      ...d
    } = n, f = D.useRef(null), m = si(t, f), v = D.useRef(), S = !i;
    function w(E) {
      const A = v.current || f.current.getBoundingClientRect(), P = [0, A.height], M = UU(P, S ? [r, e] : [e, r]);
      return v.current = A, M(E - A.top);
    }
    return /* @__PURE__ */ y.jsx(
      xJ,
      {
        scope: n.__scopeSlider,
        startEdge: S ? "bottom" : "top",
        endEdge: S ? "top" : "bottom",
        size: "height",
        direction: S ? 1 : -1,
        children: /* @__PURE__ */ y.jsx(
          CJ,
          {
            "data-orientation": "vertical",
            ...d,
            ref: m,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (E) => {
              const A = w(E.clientY);
              s == null || s(A);
            },
            onSlideMove: (E) => {
              const A = w(E.clientY);
              o == null || o(A);
            },
            onSlideEnd: () => {
              v.current = void 0, l == null || l();
            },
            onStepKeyDown: (E) => {
              const P = yJ[S ? "from-bottom" : "from-top"].includes(E.key);
              u == null || u({ event: E, direction: P ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), CJ = D.forwardRef(
  (n, t) => {
    const {
      __scopeSlider: e,
      onSlideStart: r,
      onSlideMove: i,
      onSlideEnd: s,
      onHomeKeyDown: o,
      onEndKeyDown: l,
      onStepKeyDown: u,
      ...d
    } = n, f = fD(yw, e);
    return /* @__PURE__ */ y.jsx(
      sr.span,
      {
        ...d,
        ref: t,
        onKeyDown: Et(n.onKeyDown, (m) => {
          m.key === "Home" ? (o(m), m.preventDefault()) : m.key === "End" ? (l(m), m.preventDefault()) : mJ.concat(vJ).includes(m.key) && (u(m), m.preventDefault());
        }),
        onPointerDown: Et(n.onPointerDown, (m) => {
          const v = m.target;
          v.setPointerCapture(m.pointerId), m.preventDefault(), f.thumbs.has(v) ? v.focus() : r(m);
        }),
        onPointerMove: Et(n.onPointerMove, (m) => {
          m.target.hasPointerCapture(m.pointerId) && i(m);
        }),
        onPointerUp: Et(n.onPointerUp, (m) => {
          const v = m.target;
          v.hasPointerCapture(m.pointerId) && (v.releasePointerCapture(m.pointerId), s(m));
        })
      }
    );
  }
), EJ = "SliderTrack", _J = D.forwardRef(
  (n, t) => {
    const { __scopeSlider: e, ...r } = n, i = fD(EJ, e);
    return /* @__PURE__ */ y.jsx(
      sr.span,
      {
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": i.orientation,
        ...r,
        ref: t
      }
    );
  }
);
_J.displayName = EJ;
var t$ = "SliderRange", TJ = D.forwardRef(
  (n, t) => {
    const { __scopeSlider: e, ...r } = n, i = fD(t$, e), s = wJ(t$, e), o = D.useRef(null), l = si(t, o), u = i.values.length, d = i.values.map(
      (v) => AJ(v, i.min, i.max)
    ), f = u > 1 ? Math.min(...d) : 0, m = 100 - Math.max(...d);
    return /* @__PURE__ */ y.jsx(
      sr.span,
      {
        "data-orientation": i.orientation,
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: l,
        style: {
          ...n.style,
          [s.startEdge]: f + "%",
          [s.endEdge]: m + "%"
        }
      }
    );
  }
);
TJ.displayName = t$;
var n$ = "SliderThumb", PJ = D.forwardRef(
  (n, t) => {
    const e = gMe(n.__scopeSlider), [r, i] = D.useState(null), s = si(t, (l) => i(l)), o = D.useMemo(
      () => r ? e().findIndex((l) => l.ref.current === r) : -1,
      [e, r]
    );
    return /* @__PURE__ */ y.jsx(bMe, { ...n, ref: s, index: o });
  }
), bMe = D.forwardRef(
  (n, t) => {
    const { __scopeSlider: e, index: r, name: i, ...s } = n, o = fD(n$, e), l = wJ(n$, e), [u, d] = D.useState(null), f = si(t, (R) => d(R)), m = u ? !!u.closest("form") : !0, v = tZ(u), S = o.values[r], w = S === void 0 ? 0 : AJ(S, o.min, o.max), E = CMe(r, o.values.length), A = v == null ? void 0 : v[l.size], P = A ? _Me(A, w, l.direction) : 0;
    return D.useEffect(() => {
      if (u)
        return o.thumbs.add(u), () => {
          o.thumbs.delete(u);
        };
    }, [u, o.thumbs]), /* @__PURE__ */ y.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [l.startEdge]: `calc(${w}% + ${P}px)`
        },
        children: [
          /* @__PURE__ */ y.jsx(e$.ItemSlot, { scope: n.__scopeSlider, children: /* @__PURE__ */ y.jsx(
            sr.span,
            {
              role: "slider",
              "aria-label": n["aria-label"] || E,
              "aria-valuemin": o.min,
              "aria-valuenow": S,
              "aria-valuemax": o.max,
              "aria-orientation": o.orientation,
              "data-orientation": o.orientation,
              "data-disabled": o.disabled ? "" : void 0,
              tabIndex: o.disabled ? void 0 : 0,
              ...s,
              ref: f,
              style: S === void 0 ? { display: "none" } : n.style,
              onFocus: Et(n.onFocus, () => {
                o.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          m && /* @__PURE__ */ y.jsx(
            xMe,
            {
              name: i ?? (o.name ? o.name + (o.values.length > 1 ? "[]" : "") : void 0),
              value: S
            },
            r
          )
        ]
      }
    );
  }
);
PJ.displayName = n$;
var xMe = (n) => {
  const { value: t, ...e } = n, r = D.useRef(null), i = pMe(t);
  return D.useEffect(() => {
    const s = r.current, o = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(o, "value").set;
    if (i !== t && u) {
      const d = new Event("input", { bubbles: !0 });
      u.call(s, t), s.dispatchEvent(d);
    }
  }, [i, t]), /* @__PURE__ */ y.jsx("input", { style: { display: "none" }, ...e, ref: r, defaultValue: t });
};
function wMe(n = [], t, e) {
  const r = [...n];
  return r[e] = t, r.sort((i, s) => i - s);
}
function AJ(n, t, e) {
  const s = 100 / (e - t) * (n - t);
  return gJ(s, [0, 100]);
}
function CMe(n, t) {
  return t > 2 ? `Value ${n + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][n] : void 0;
}
function EMe(n, t) {
  if (n.length === 1) return 0;
  const e = n.map((i) => Math.abs(i - t)), r = Math.min(...e);
  return e.indexOf(r);
}
function _Me(n, t, e) {
  const r = n / 2, s = UU([0, 50], [0, r]);
  return (r - s(t) * e) * e;
}
function TMe(n) {
  return n.slice(0, -1).map((t, e) => n[e + 1] - t);
}
function PMe(n, t) {
  if (t > 0) {
    const e = TMe(n);
    return Math.min(...e) >= t;
  }
  return !0;
}
function UU(n, t) {
  return (e) => {
    if (n[0] === n[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (n[1] - n[0]);
    return t[0] + r * (e - n[0]);
  };
}
function AMe(n) {
  return (String(n).split(".")[1] || "").length;
}
function kMe(n, t) {
  const e = Math.pow(10, t);
  return Math.round(n * e) / e;
}
var IMe = bJ, RMe = _J, MMe = TJ, DMe = PJ;
const OMe = D.memo(function(t) {
  const { title: e, steps: r, value: i, label: s, onValueChange: o } = t, l = we(), u = Dn(), d = D.useCallback(
    (v) => {
      o(v[0]);
    },
    [o]
  ), f = D.useCallback(() => {
    l.mark("click slider");
  }, [l]), m = D.useCallback(() => {
    i && o(i);
  }, [i, o]);
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ y.jsxs(
    IMe,
    {
      "data-testid": t["data-testid"],
      className: "tlui-slider",
      "area-label": "Opacity",
      dir: "ltr",
      min: 0,
      max: r,
      step: 1,
      value: i ? [i] : void 0,
      onPointerDown: f,
      onValueChange: d,
      onPointerUp: m,
      title: e + " — " + u(s),
      children: [
        /* @__PURE__ */ y.jsx(RMe, { className: "tlui-slider__track", dir: "ltr", children: i !== null && /* @__PURE__ */ y.jsx(MMe, { className: "tlui-slider__range", dir: "ltr" }) }),
        i !== null && /* @__PURE__ */ y.jsx(DMe, { className: "tlui-slider__thumb", dir: "ltr" })
      ]
    }
  ) });
});
function LMe({
  label: n,
  uiTypeA: t,
  uiTypeB: e,
  labelA: r,
  labelB: i,
  itemsA: s,
  itemsB: o,
  styleA: l,
  styleB: u,
  valueA: d,
  valueB: f,
  onValueChange: m
}) {
  const v = Dn(), S = D.useMemo(
    () => {
      var E;
      return ((E = s.find((A) => d.type === "shared" && d.value === A.value)) == null ? void 0 : E.icon) ?? "mixed";
    },
    [s, d]
  ), w = D.useMemo(
    () => {
      var E;
      return ((E = o.find((A) => f.type === "shared" && f.value === A.value)) == null ? void 0 : E.icon) ?? "mixed";
    },
    [o, f]
  );
  return d === void 0 && f === void 0 ? null : /* @__PURE__ */ y.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ y.jsx("div", { title: v(n), className: "tlui-style-panel__double-select-picker-label", children: v(n) }),
    /* @__PURE__ */ y.jsxs("div", { className: "tlui-buttons__horizontal", children: [
      /* @__PURE__ */ y.jsxs(lS, { id: `style panel ${t} A`, children: [
        /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "icon",
            "data-testid": `style.${t}`,
            title: v(r) + " — " + (d === null || d.type === "mixed" ? v("style-panel.mixed") : v(`${t}-style.${d.value}`)),
            children: /* @__PURE__ */ y.jsx(Rn, { icon: S, small: !0, invertIcon: !0 })
          }
        ) }),
        /* @__PURE__ */ y.jsx(uS, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: /* @__PURE__ */ y.jsx("div", { className: "tlui-buttons__grid", children: s.map((E, A) => /* @__PURE__ */ y.jsx(q1, { "data-testid": `style.${t}.${E.value}`, children: /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "icon",
            onClick: () => m(l, E.value),
            title: `${v(r)} — ${v(`${t}-style.${E.value}`)}`,
            children: /* @__PURE__ */ y.jsx(Rn, { icon: E.icon, invertIcon: !0 })
          },
          E.value
        ) }, A)) }) })
      ] }),
      /* @__PURE__ */ y.jsxs(lS, { id: `style panel ${e}`, children: [
        /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "icon",
            "data-testid": `style.${e}`,
            title: v(i) + " — " + (f === null || f.type === "mixed" ? v("style-panel.mixed") : v(`${e}-style.${f.value}`)),
            children: /* @__PURE__ */ y.jsx(Rn, { icon: w, small: !0 })
          }
        ) }),
        /* @__PURE__ */ y.jsx(uS, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: /* @__PURE__ */ y.jsx("div", { className: "tlui-buttons__grid", children: o.map((E) => /* @__PURE__ */ y.jsx(q1, { children: /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "icon",
            title: `${v(i)} — ${v(`${e}-style.${E.value}`)}`,
            "data-testid": `style.${e}.${E.value}`,
            onClick: () => m(u, E.value),
            children: /* @__PURE__ */ y.jsx(Rn, { icon: E.icon })
          }
        ) }, E.value)) }) })
      ] })
    ] })
  ] });
}
const jMe = D.memo(
  LMe
);
function NMe({
  id: n,
  label: t,
  uiType: e,
  style: r,
  items: i,
  type: s,
  value: o,
  onValueChange: l
}) {
  const u = Dn(), d = we(), f = D.useMemo(
    () => {
      var S;
      return (S = i.find((w) => o.type === "shared" && w.value === o.value)) == null ? void 0 : S.icon;
    },
    [i, o]
  ), m = o.type === "mixed" ? u("style-panel.mixed") : u(`${e}-style.${o.value}`), v = t ? u(t) : "";
  return /* @__PURE__ */ y.jsxs(lS, { id: `style panel ${n}`, children: [
    /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsxs(Wt, { type: s, "data-testid": `style.${e}`, title: m, children: [
      /* @__PURE__ */ y.jsx(Zi, { children: v }),
      /* @__PURE__ */ y.jsx(Rn, { icon: f ?? "mixed" })
    ] }) }),
    /* @__PURE__ */ y.jsx(uS, { side: "left", align: "center", alignOffset: 0, children: /* @__PURE__ */ y.jsx("div", { className: "tlui-buttons__grid", children: i.map((S) => /* @__PURE__ */ y.jsx(q1, { children: /* @__PURE__ */ y.jsx(
      Wt,
      {
        type: "icon",
        "data-testid": `style.${e}.${S.value}`,
        title: u(`${e}-style.${S.value}`),
        onClick: () => {
          d.mark("select style dropdown item"), l(r, S.value);
        },
        children: /* @__PURE__ */ y.jsx(Rn, { icon: S.icon })
      }
    ) }, S.value)) }) })
  ] });
}
const BU = D.memo(NMe);
function kJ({ styles: n }) {
  const t = KT();
  if (!n) return null;
  const e = n.get(od), r = n.get(SM), i = n.get(yM), s = n.get(CM), o = n.get(Ph), l = e === void 0, u = r === void 0 && i === void 0, d = s === void 0, f = o === void 0, m = Pp({ isDarkMode: t });
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(FMe, { theme: m, styles: n }),
    !f && /* @__PURE__ */ y.jsx($Me, { theme: m, styles: n }),
    !(l && u && d) && /* @__PURE__ */ y.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      /* @__PURE__ */ y.jsx(zMe, { styles: n }),
      /* @__PURE__ */ y.jsx(BMe, { styles: n }),
      /* @__PURE__ */ y.jsx(UMe, { styles: n })
    ] })
  ] });
}
function tP() {
  const n = we(), t = Fo();
  return Gn.useMemo(
    () => function(r, i) {
      n.run(() => {
        n.isIn("select") && n.setStyleForSelectedShapes(r, i), n.setStyleForNextShapes(r, i), n.updateInstanceState({ isChangingStyle: !0 });
      }), t("set-style", { source: "style-panel", id: r.id, value: i });
    },
    [n, t]
  );
}
function FMe({ styles: n, theme: t }) {
  const e = Dn(), r = we(), i = tP(), s = n.get(xc), o = n.get(tS), l = n.get(eS), u = n.get(Ah), d = o !== void 0 || l !== void 0 || u !== void 0;
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsxs(
      "div",
      {
        tabIndex: -1,
        className: "tlui-style-panel__section__common",
        "aria-label": "style panel styles",
        "data-testid": "style.panel",
        children: [
          s === void 0 ? null : /* @__PURE__ */ y.jsx(
            Qv,
            {
              title: e("style-panel.color"),
              uiType: "color",
              style: xc,
              items: ou.color,
              value: s,
              onValueChange: i,
              theme: t
            }
          ),
          /* @__PURE__ */ y.jsx(HMe, {})
        ]
      }
    ),
    d && /* @__PURE__ */ y.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      o === void 0 ? null : /* @__PURE__ */ y.jsx(
        Qv,
        {
          title: e("style-panel.fill"),
          uiType: "fill",
          style: tS,
          items: ou.fill,
          value: o,
          onValueChange: i,
          theme: t
        }
      ),
      l === void 0 ? null : /* @__PURE__ */ y.jsx(
        Qv,
        {
          title: e("style-panel.dash"),
          uiType: "dash",
          style: eS,
          items: ou.dash,
          value: l,
          onValueChange: i,
          theme: t
        }
      ),
      u === void 0 ? null : /* @__PURE__ */ y.jsx(
        Qv,
        {
          title: e("style-panel.size"),
          uiType: "size",
          style: Ah,
          items: ou.size,
          value: u,
          onValueChange: (f, m) => {
            i(f, m);
            const v = r.getSelectedShapeIds();
            v.length > 0 && ei(r, v);
          },
          theme: t
        }
      )
    ] })
  ] });
}
function $Me({ theme: n, styles: t }) {
  const e = Dn(), r = tP(), i = t.get(Ph), s = t.get(f3), o = t.get(xM), l = t.get(wM);
  return i === void 0 && o === void 0 ? null : /* @__PURE__ */ y.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel text", children: [
    i === void 0 ? null : /* @__PURE__ */ y.jsx(
      Qv,
      {
        title: e("style-panel.font"),
        uiType: "font",
        style: Ph,
        items: ou.font,
        value: i,
        onValueChange: r,
        theme: n
      }
    ),
    s === void 0 ? null : /* @__PURE__ */ y.jsxs("div", { className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ y.jsx(
        Qv,
        {
          title: e("style-panel.align"),
          uiType: "align",
          style: f3,
          items: ou.textAlign,
          value: s,
          onValueChange: r,
          theme: n
        }
      ),
      /* @__PURE__ */ y.jsx("div", { className: "tlui-style-panel__row__extra-button", children: /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          title: e("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: !0,
          children: /* @__PURE__ */ y.jsx(Rn, { icon: "vertical-align-middle" })
        }
      ) })
    ] }),
    o === void 0 ? null : /* @__PURE__ */ y.jsxs("div", { className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ y.jsx(
        Qv,
        {
          title: e("style-panel.align"),
          uiType: "align",
          style: xM,
          items: ou.horizontalAlign,
          value: o,
          onValueChange: r,
          theme: n
        }
      ),
      /* @__PURE__ */ y.jsx("div", { className: "tlui-style-panel__row__extra-button", children: l === void 0 ? /* @__PURE__ */ y.jsx(
        Wt,
        {
          type: "icon",
          title: e("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: !0,
          children: /* @__PURE__ */ y.jsx(Rn, { icon: "vertical-align-middle" })
        }
      ) : /* @__PURE__ */ y.jsx(
        BU,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          style: wM,
          items: ou.verticalAlign,
          value: l,
          onValueChange: r
        }
      ) })
    ] })
  ] });
}
function zMe({ styles: n }) {
  const t = tP(), e = n.get(od);
  return e === void 0 ? null : /* @__PURE__ */ y.jsx(
    BU,
    {
      id: "geo",
      type: "menu",
      label: "style-panel.geo",
      uiType: "geo",
      style: od,
      items: ou.geo,
      value: e,
      onValueChange: t
    }
  );
}
function UMe({ styles: n }) {
  const t = tP(), e = n.get(CM);
  return e === void 0 ? null : /* @__PURE__ */ y.jsx(
    BU,
    {
      id: "spline",
      type: "menu",
      label: "style-panel.spline",
      uiType: "spline",
      style: CM,
      items: ou.spline,
      value: e,
      onValueChange: t
    }
  );
}
function BMe({ styles: n }) {
  const t = tP(), e = n.get(SM), r = n.get(yM);
  return !e || !r ? null : /* @__PURE__ */ y.jsx(
    jMe,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: yM,
      itemsA: ou.arrowheadStart,
      valueA: r,
      uiTypeB: "arrowheadEnd",
      styleB: SM,
      itemsB: ou.arrowheadEnd,
      valueB: e,
      onValueChange: t,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
const $E = [0.1, 0.25, 0.5, 0.75, 1];
function HMe() {
  const n = we(), t = De("opacity", () => n.getSharedOpacity(), [n]), e = Fo(), r = Dn(), i = Gn.useCallback(
    (o) => {
      const l = $E[o];
      n.run(() => {
        n.isIn("select") && n.setOpacityForSelectedShapes(l), n.setOpacityForNextShapes(l), n.updateInstanceState({ isChangingStyle: !0 });
      }), e("set-style", { source: "style-panel", id: "opacity", value: o });
    },
    [n, e]
  );
  if (t === void 0) return null;
  const s = t.type === "mixed" ? -1 : $E.indexOf(
    bme(
      $E,
      (o) => Math.abs(o - t.value)
    )
  );
  return /* @__PURE__ */ y.jsx(
    OMe,
    {
      "data-testid": "style.opacity",
      value: s >= 0 ? s : $E.length - 1,
      label: t.type === "mixed" ? "style-panel.mixed" : `opacity-style.${t.value}`,
      onValueChange: i,
      steps: $E.length - 1,
      title: r("style-panel.opacity")
    }
  );
}
const IJ = D.memo(function({
  isMobile: t,
  children: e
}) {
  const r = we(), i = zU(), s = D.useCallback(() => {
    t || r.updateInstanceState({ isChangingStyle: !1 });
  }, [r, t]), o = e ?? /* @__PURE__ */ y.jsx(kJ, { styles: i });
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      className: Vt("tlui-style-panel", { "tlui-style-panel__wrapper": !t }),
      "data-ismobile": t,
      onPointerLeave: s,
      children: o
    }
  );
});
function VMe() {
  const n = we(), t = Dn(), e = zU(), r = e == null ? void 0 : e.get(xc), i = Pp({ isDarkMode: n.user.getIsDarkMode() }), s = ((r == null ? void 0 : r.type) === "shared" ? i[r.value] : i.black).solid, o = De(
    "disable style panel",
    () => n.isInAny("hand", "zoom", "eraser", "laser"),
    [n]
  ), l = D.useCallback(
    (d) => {
      d || n.updateInstanceState({ isChangingStyle: !1 });
    },
    [n]
  ), { StylePanel: u } = Nm();
  return u ? /* @__PURE__ */ y.jsxs(SU, { id: "mobile style menu", onOpenChange: l, children: [
    /* @__PURE__ */ y.jsx(bU, { children: /* @__PURE__ */ y.jsx(
      Wt,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: o ? "var(--color-muted-1)" : s
        },
        title: t("style-panel.title"),
        disabled: o,
        children: /* @__PURE__ */ y.jsx(
          Rn,
          {
            icon: o ? "blob" : (r == null ? void 0 : r.type) === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    /* @__PURE__ */ y.jsx(xU, { side: "top", align: "end", children: u && /* @__PURE__ */ y.jsx(u, { isMobile: !0 }) })
  ] }) : null;
}
function RJ() {
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(GMe, {}),
    /* @__PURE__ */ y.jsx(KMe, {}),
    /* @__PURE__ */ y.jsx(YMe, {}),
    /* @__PURE__ */ y.jsx(XMe, {}),
    /* @__PURE__ */ y.jsx(qMe, {}),
    /* @__PURE__ */ y.jsx(ZMe, {}),
    /* @__PURE__ */ y.jsx(QMe, {}),
    /* @__PURE__ */ y.jsx(JMe, {}),
    /* @__PURE__ */ y.jsx(e2e, {}),
    /* @__PURE__ */ y.jsx(t2e, {}),
    /* @__PURE__ */ y.jsx(r2e, {}),
    /* @__PURE__ */ y.jsx(n2e, {}),
    /* @__PURE__ */ y.jsx(o2e, {}),
    /* @__PURE__ */ y.jsx(c2e, {}),
    /* @__PURE__ */ y.jsx(i2e, {}),
    /* @__PURE__ */ y.jsx(l2e, {}),
    /* @__PURE__ */ y.jsx(a2e, {}),
    /* @__PURE__ */ y.jsx(s2e, {}),
    /* @__PURE__ */ y.jsx(u2e, {}),
    /* @__PURE__ */ y.jsx(d2e, {}),
    /* @__PURE__ */ y.jsx(h2e, {}),
    /* @__PURE__ */ y.jsx(f2e, {}),
    /* @__PURE__ */ y.jsx(p2e, {}),
    /* @__PURE__ */ y.jsx(g2e, {}),
    /* @__PURE__ */ y.jsx(m2e, {}),
    /* @__PURE__ */ y.jsx(v2e, {}),
    /* @__PURE__ */ y.jsx(S2e, {}),
    /* @__PURE__ */ y.jsx(y2e, {})
  ] });
}
function WMe(n) {
  var r;
  const t = we(), e = (r = n.meta) == null ? void 0 : r.geo;
  return De(
    "is tool selected",
    () => {
      const i = t.getCurrentToolId(), s = t.getSharedStyles().getAsKnownValue(od);
      return e ? i === "geo" && s === e : i === n.id;
    },
    [t, n.id, e]
  );
}
function Gr({ tool: n }) {
  const t = rD(), e = WMe(t[n]);
  return /* @__PURE__ */ y.jsx(Me, { ...t[n], isSelected: e });
}
function GMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "select" });
}
function KMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "hand" });
}
function YMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "draw" });
}
function XMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "eraser" });
}
function qMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "arrow" });
}
function ZMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "text" });
}
function QMe() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "note" });
}
function JMe() {
  const n = rD();
  return /* @__PURE__ */ y.jsx(Me, { ...n.asset });
}
function e2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "rectangle" });
}
function t2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "ellipse" });
}
function n2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "diamond" });
}
function r2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "triangle" });
}
function i2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "rhombus" });
}
function s2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "heart" });
}
function o2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "hexagon" });
}
function a2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "cloud" });
}
function l2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "star" });
}
function c2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "oval" });
}
function u2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "x-box" });
}
function d2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "check-box" });
}
function h2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "arrow-left" });
}
function f2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "arrow-up" });
}
function p2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "arrow-down" });
}
function g2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "arrow-right" });
}
function m2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "line" });
}
function v2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "highlight" });
}
function y2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "frame" });
}
function S2e() {
  return /* @__PURE__ */ y.jsx(Gr, { tool: "laser" });
}
const hF = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function fF(n, t, e, r) {
  n.addEventListener ? n.addEventListener(t, e, r) : n.attachEvent && n.attachEvent("on".concat(t), e);
}
function zE(n, t, e, r) {
  n.removeEventListener ? n.removeEventListener(t, e, r) : n.detachEvent && n.detachEvent("on".concat(t), e);
}
function MJ(n, t) {
  const e = t.slice(0, t.length - 1);
  for (let r = 0; r < e.length; r++) e[r] = n[e[r].toLowerCase()];
  return e;
}
function DJ(n) {
  typeof n != "string" && (n = ""), n = n.replace(/\s/g, "");
  const t = n.split(",");
  let e = t.lastIndexOf("");
  for (; e >= 0; )
    t[e - 1] += ",", t.splice(e, 1), e = t.lastIndexOf("");
  return t;
}
function b2e(n, t) {
  const e = n.length >= t.length ? n : t, r = n.length >= t.length ? t : n;
  let i = !0;
  for (let s = 0; s < e.length; s++)
    r.indexOf(e[s]) === -1 && (i = !1);
  return i;
}
const Z1 = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": hF ? 173 : 189,
  "=": hF ? 61 : 187,
  ";": hF ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, Mh = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, r$ = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, ko = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, Mi = {};
for (let n = 1; n < 20; n++)
  Z1["f".concat(n)] = 111 + n;
let ti = [], R1 = null, OJ = "all";
const Rf = /* @__PURE__ */ new Map(), nP = (n) => Z1[n.toLowerCase()] || Mh[n.toLowerCase()] || n.toUpperCase().charCodeAt(0), x2e = (n) => Object.keys(Z1).find((t) => Z1[t] === n), w2e = (n) => Object.keys(Mh).find((t) => Mh[t] === n);
function LJ(n) {
  OJ = n || "all";
}
function Q1() {
  return OJ || "all";
}
function C2e() {
  return ti.slice(0);
}
function E2e() {
  return ti.map((n) => x2e(n) || w2e(n) || String.fromCharCode(n));
}
function _2e() {
  const n = [];
  return Object.keys(Mi).forEach((t) => {
    Mi[t].forEach((e) => {
      let {
        key: r,
        scope: i,
        mods: s,
        shortcut: o
      } = e;
      n.push({
        scope: i,
        shortcut: o,
        mods: s,
        keys: r.split("+").map((l) => nP(l))
      });
    });
  }), n;
}
function T2e(n) {
  const t = n.target || n.srcElement, {
    tagName: e
  } = t;
  let r = !0;
  const i = e === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(t.type);
  return (t.isContentEditable || (i || e === "TEXTAREA" || e === "SELECT") && !t.readOnly) && (r = !1), r;
}
function P2e(n) {
  return typeof n == "string" && (n = nP(n)), ti.indexOf(n) !== -1;
}
function A2e(n, t) {
  let e, r;
  n || (n = Q1());
  for (const i in Mi)
    if (Object.prototype.hasOwnProperty.call(Mi, i))
      for (e = Mi[i], r = 0; r < e.length; )
        e[r].scope === n ? e.splice(r, 1).forEach((o) => {
          let {
            element: l
          } = o;
          return HU(l);
        }) : r++;
  Q1() === n && LJ(t || "all");
}
function k2e(n) {
  let t = n.keyCode || n.which || n.charCode;
  const e = ti.indexOf(t);
  if (e >= 0 && ti.splice(e, 1), n.key && n.key.toLowerCase() === "meta" && ti.splice(0, ti.length), (t === 93 || t === 224) && (t = 91), t in ko) {
    ko[t] = !1;
    for (const r in Mh) Mh[r] === t && (Ll[r] = !1);
  }
}
function jJ(n) {
  if (typeof n > "u")
    Object.keys(Mi).forEach((i) => {
      Array.isArray(Mi[i]) && Mi[i].forEach((s) => FI(s)), delete Mi[i];
    }), HU(null);
  else if (Array.isArray(n))
    n.forEach((i) => {
      i.key && FI(i);
    });
  else if (typeof n == "object")
    n.key && FI(n);
  else if (typeof n == "string") {
    for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      e[r - 1] = arguments[r];
    let [i, s] = e;
    typeof i == "function" && (s = i, i = ""), FI({
      key: n,
      scope: i,
      method: s,
      splitKey: "+"
    });
  }
}
const FI = (n) => {
  let {
    key: t,
    scope: e,
    method: r,
    splitKey: i = "+"
  } = n;
  DJ(t).forEach((o) => {
    const l = o.split(i), u = l.length, d = l[u - 1], f = d === "*" ? "*" : nP(d);
    if (!Mi[f]) return;
    e || (e = Q1());
    const m = u > 1 ? MJ(Mh, l) : [], v = [];
    Mi[f] = Mi[f].filter((S) => {
      const E = (r ? S.method === r : !0) && S.scope === e && b2e(S.mods, m);
      return E && v.push(S.element), !E;
    }), v.forEach((S) => HU(S));
  });
};
function wV(n, t, e, r) {
  if (t.element !== r)
    return;
  let i;
  if (t.scope === e || t.scope === "all") {
    i = t.mods.length > 0;
    for (const s in ko)
      Object.prototype.hasOwnProperty.call(ko, s) && (!ko[s] && t.mods.indexOf(+s) > -1 || ko[s] && t.mods.indexOf(+s) === -1) && (i = !1);
    (t.mods.length === 0 && !ko[16] && !ko[18] && !ko[17] && !ko[91] || i || t.shortcut === "*") && (t.keys = [], t.keys = t.keys.concat(ti), t.method(n, t) === !1 && (n.preventDefault ? n.preventDefault() : n.returnValue = !1, n.stopPropagation && n.stopPropagation(), n.cancelBubble && (n.cancelBubble = !0)));
  }
}
function CV(n, t) {
  const e = Mi["*"];
  let r = n.keyCode || n.which || n.charCode;
  if (!Ll.filter.call(this, n)) return;
  if ((r === 93 || r === 224) && (r = 91), ti.indexOf(r) === -1 && r !== 229 && ti.push(r), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((l) => {
    const u = r$[l];
    n[l] && ti.indexOf(u) === -1 ? ti.push(u) : !n[l] && ti.indexOf(u) > -1 ? ti.splice(ti.indexOf(u), 1) : l === "metaKey" && n[l] && ti.length === 3 && (n.ctrlKey || n.shiftKey || n.altKey || (ti = ti.slice(ti.indexOf(u))));
  }), r in ko) {
    ko[r] = !0;
    for (const l in Mh)
      Mh[l] === r && (Ll[l] = !0);
    if (!e) return;
  }
  for (const l in ko)
    Object.prototype.hasOwnProperty.call(ko, l) && (ko[l] = n[r$[l]]);
  n.getModifierState && !(n.altKey && !n.ctrlKey) && n.getModifierState("AltGraph") && (ti.indexOf(17) === -1 && ti.push(17), ti.indexOf(18) === -1 && ti.push(18), ko[17] = !0, ko[18] = !0);
  const i = Q1();
  if (e)
    for (let l = 0; l < e.length; l++)
      e[l].scope === i && (n.type === "keydown" && e[l].keydown || n.type === "keyup" && e[l].keyup) && wV(n, e[l], i, t);
  if (!(r in Mi)) return;
  const s = Mi[r], o = s.length;
  for (let l = 0; l < o; l++)
    if ((n.type === "keydown" && s[l].keydown || n.type === "keyup" && s[l].keyup) && s[l].key) {
      const u = s[l], {
        splitKey: d
      } = u, f = u.key.split(d), m = [];
      for (let v = 0; v < f.length; v++)
        m.push(nP(f[v]));
      m.sort().join("") === ti.sort().join("") && wV(n, u, i, t);
    }
}
function Ll(n, t, e) {
  ti = [];
  const r = DJ(n);
  let i = [], s = "all", o = document, l = 0, u = !1, d = !0, f = "+", m = !1, v = !1;
  for (e === void 0 && typeof t == "function" && (e = t), Object.prototype.toString.call(t) === "[object Object]" && (t.scope && (s = t.scope), t.element && (o = t.element), t.keyup && (u = t.keyup), t.keydown !== void 0 && (d = t.keydown), t.capture !== void 0 && (m = t.capture), typeof t.splitKey == "string" && (f = t.splitKey), t.single === !0 && (v = !0)), typeof t == "string" && (s = t), v && jJ(n, s); l < r.length; l++)
    n = r[l].split(f), i = [], n.length > 1 && (i = MJ(Mh, n)), n = n[n.length - 1], n = n === "*" ? "*" : nP(n), n in Mi || (Mi[n] = []), Mi[n].push({
      keyup: u,
      keydown: d,
      scope: s,
      mods: i,
      shortcut: r[l],
      method: e,
      key: r[l],
      splitKey: f,
      element: o
    });
  if (typeof o < "u" && window) {
    if (!Rf.has(o)) {
      const S = function() {
        let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return CV(E, o);
      }, w = function() {
        let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        CV(E, o), k2e(E);
      };
      Rf.set(o, {
        keydownListener: S,
        keyupListenr: w,
        capture: m
      }), fF(o, "keydown", S, m), fF(o, "keyup", w, m);
    }
    if (!R1) {
      const S = () => {
        ti = [];
      };
      R1 = {
        listener: S,
        capture: m
      }, fF(window, "focus", S, m);
    }
  }
}
function I2e(n) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(Mi).forEach((e) => {
    Mi[e].filter((i) => i.scope === t && i.shortcut === n).forEach((i) => {
      i && i.method && i.method();
    });
  });
}
function HU(n) {
  const t = Object.values(Mi).flat();
  if (t.findIndex((r) => {
    let {
      element: i
    } = r;
    return i === n;
  }) < 0) {
    const {
      keydownListener: r,
      keyupListenr: i,
      capture: s
    } = Rf.get(n) || {};
    r && i && (zE(n, "keyup", i, s), zE(n, "keydown", r, s), Rf.delete(n));
  }
  if ((t.length <= 0 || Rf.size <= 0) && (Object.keys(Rf).forEach((i) => {
    const {
      keydownListener: s,
      keyupListenr: o,
      capture: l
    } = Rf.get(i) || {};
    s && o && (zE(i, "keyup", o, l), zE(i, "keydown", s, l), Rf.delete(i));
  }), Rf.clear(), Object.keys(Mi).forEach((i) => delete Mi[i]), R1)) {
    const {
      listener: i,
      capture: s
    } = R1;
    zE(window, "focus", i, s), R1 = null;
  }
}
const pF = {
  getPressedKeyString: E2e,
  setScope: LJ,
  getScope: Q1,
  deleteScope: A2e,
  getPressedKeyCodes: C2e,
  getAllKeyCodes: _2e,
  isPressed: P2e,
  filter: T2e,
  trigger: I2e,
  unbind: jJ,
  keyMap: Z1,
  modifier: Mh,
  modifierMap: r$
};
for (const n in pF)
  Object.prototype.hasOwnProperty.call(pF, n) && (Ll[n] = pF[n]);
if (typeof window < "u") {
  const n = window.hotkeys;
  Ll.noConflict = (t) => (t && window.hotkeys === Ll && (window.hotkeys = n), Ll), window.hotkeys = Ll;
}
const EV = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function R2e() {
  const n = we(), t = Ap(), e = Dt(), r = rD(), i = De("is focused", () => n.getInstanceState().isFocused, [n]);
  D.useEffect(() => {
    if (!i) return;
    const s = new Array(), o = (u, d) => {
      Ll(u, { element: document.body }, d), s.push(() => {
        Ll.unbind(u, d);
      });
    }, l = (u, d) => {
      Ll(u, { element: document.body, keyup: !0, keydown: !1 }, d), s.push(() => {
        Ll.unbind(u, d);
      });
    };
    for (const u of Object.values(e))
      u.kbd && (t && !u.readonlyOk || EV.includes(u.id) || o(_V(u.kbd), (d) => {
        c1(n) || (qn(d), u.onSelect("kbd"));
      }));
    for (const u of Object.values(r))
      !u.kbd || !u.readonlyOk && n.getInstanceState().isReadonly || EV.includes(u.id) || o(_V(u.kbd), (d) => {
        c1(n) || (qn(d), u.onSelect("kbd"));
      });
    return o(",", (u) => {
      if (c1(n) || n.inputs.keys.has("Comma")) return;
      qn(u), n.focus(), n.inputs.keys.add("Comma");
      const { x: d, y: f, z: m } = n.inputs.currentScreenPoint, v = {
        type: "pointer",
        name: "pointer_down",
        point: { x: d, y: f, z: m },
        shiftKey: u.shiftKey,
        altKey: u.altKey,
        ctrlKey: u.metaKey || u.ctrlKey,
        pointerId: 0,
        button: 0,
        isPen: n.getInstanceState().isPenMode,
        target: "canvas"
      };
      n.dispatch(v);
    }), l(",", (u) => {
      if (c1(n) || !n.inputs.keys.has("Comma")) return;
      n.inputs.keys.delete("Comma");
      const { x: d, y: f, z: m } = n.inputs.currentScreenPoint, v = {
        type: "pointer",
        name: "pointer_up",
        point: { x: d, y: f, z: m },
        shiftKey: u.shiftKey,
        altKey: u.altKey,
        ctrlKey: u.metaKey || u.ctrlKey,
        pointerId: 0,
        button: 0,
        isPen: n.getInstanceState().isPenMode,
        target: "canvas"
      };
      n.dispatch(v);
    }), () => {
      s.forEach((u) => u());
    };
  }, [e, r, t, n, i]);
}
function _V(n) {
  return M2e(n).map((t) => {
    let e = "";
    const r = t.split("");
    return r.length === 1 ? e = r[0] : r[0] === "!" ? e = `shift+${r[1]}` : r[0] === "?" ? r.length === 3 && r[1] === "!" ? e = `alt+shift+${r[2]}` : e = `alt+${r[1]}` : r[0] === "$" ? r[1] === "!" ? e = `cmd+shift+${r[2]},ctrl+shift+${r[2]}` : r[1] === "?" ? e = `cmd+⌥+${r[2]},ctrl+alt+${r[2]}` : e = `cmd+${r[1]},ctrl+${r[1]}` : e = t, e;
  }).join(",");
}
function M2e(n) {
  typeof n != "string" && (n = ""), n = n.replace(/\s/g, "");
  const t = n.split(",");
  let e = t.lastIndexOf("");
  for (; e >= 0; )
    t[e - 1] += ",", t.splice(e, 1), e = t.lastIndexOf("");
  return t;
}
function c1(n) {
  return n.getIsMenuOpen() || n.getEditingShapeId() !== null || n.getCrashingError();
}
const D2e = D.createContext(!1);
function O2e({ children: n }) {
  const t = we(), e = HK(), r = Ya(), i = Dn(), s = Math.min(8, 5 + r), [o, l] = D.useState(0), u = D.useRef(null), [d, f] = D.useState(null), m = D.useMemo(() => {
    const S = d ? `:not([data-value="${d}"])` : "";
    return `
			#${e}_main > *:nth-child(n + ${s + (d ? 1 : 2)})${S} {
				display: none;
			}
			#${e}_more > *:nth-child(-n + ${s}) {
				display: none;
			}
        `;
  }, [d, e, s]), v = wY(() => {
    if (!u.current) return;
    const S = Array.from(u.current.children);
    l(S.length), S.findIndex(
      (A) => A.getAttribute("data-value") === d
    ) <= s && f(null);
    const E = Array.from(u.current.children).findIndex(
      (A) => A.getAttribute("aria-checked") === "true"
    );
    E !== -1 && E >= s && f(S[E].getAttribute("data-value"));
  });
  return D.useLayoutEffect(() => {
    v();
  }), D.useLayoutEffect(() => {
    if (!u.current) return;
    const S = new MutationObserver(v);
    return S.observe(u.current, {
      childList: !0,
      subtree: !0,
      attributeFilter: ["data-value", "aria-checked"]
    }), () => {
      S.disconnect();
    };
  }, [v]), D.useEffect(() => {
    const S = [
      ["1", 0],
      ["2", 1],
      ["3", 2],
      ["4", 3],
      ["5", 4],
      ["6", 5],
      ["7", 6],
      ["8", 7],
      ["9", 8],
      ["0", 9]
    ];
    for (const [w, E] of S)
      Ll(w, (A) => {
        var M;
        if (c1(t)) return;
        qn(A);
        const R = Array.from(((M = u.current) == null ? void 0 : M.children) ?? []).filter(
          (j) => !(j instanceof HTMLElement) || j.tagName.toLowerCase() !== "button" ? !1 : !!(j.offsetWidth || j.offsetHeight)
        )[E];
        R && R.click();
      });
    return () => {
      Ll.unbind("1,2,3,4,5,6,7,8,9,0");
    };
  }, [t]), /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx("style", { children: m }),
    /* @__PURE__ */ y.jsxs(
      "div",
      {
        className: Vt("tlui-toolbar__tools", {
          "tlui-toolbar__tools__mobile": r < Ui.TABLET_SM
        }),
        role: "radiogroup",
        children: [
          /* @__PURE__ */ y.jsx("div", { id: `${e}_main`, ref: u, className: "tlui-toolbar__tools__list", children: /* @__PURE__ */ y.jsx(lu, { type: "toolbar", sourceId: "toolbar", children: n }) }),
          o > s + 1 && /* @__PURE__ */ y.jsx(D2e.Provider, { value: !0, children: /* @__PURE__ */ y.jsxs(lS, { id: "toolbar overflow", modal: !1, children: [
            /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsx(
              Wt,
              {
                title: i("tool-panel.more"),
                type: "tool",
                className: "tlui-toolbar__overflow",
                "data-testid": "tools.more-button",
                children: /* @__PURE__ */ y.jsx(Rn, { icon: "chevron-up" })
              }
            ) }),
            /* @__PURE__ */ y.jsx(uS, { side: "top", align: "center", children: /* @__PURE__ */ y.jsx(
              "div",
              {
                className: "tlui-buttons__grid",
                "data-testid": "tools.more-content",
                id: `${e}_more`,
                children: /* @__PURE__ */ y.jsx(lu, { type: "toolbar-overflow", sourceId: "toolbar", children: n })
              }
            ) })
          ] }) })
        ]
      }
    )
  ] });
}
function L2e({ activeToolId: n }) {
  const t = we(), e = Ya(), r = Dn(), i = De("is tool locked", () => t.getInstanceState().isToolLocked, [
    t
  ]), s = De("current tool", () => t.getCurrentTool(), [t]);
  return !n || !s.isLockable ? null : /* @__PURE__ */ y.jsx(
    Wt,
    {
      type: "normal",
      title: r("action.toggle-tool-lock"),
      "data-testid": "tool-lock",
      className: Vt("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": e < Ui.TABLET_SM
      }),
      onClick: () => t.updateInstanceState({ isToolLocked: !i }),
      children: /* @__PURE__ */ y.jsx(Rn, { icon: i ? "lock" : "unlock", small: !0 })
    }
  );
}
const NJ = D.memo(function({ children: t }) {
  const e = we(), r = Ya(), i = Ap(), s = De("current tool id", () => e.getCurrentToolId(), [e]), { ActionsMenu: o, QuickActions: l } = Nm();
  return /* @__PURE__ */ y.jsx("div", { className: "tlui-toolbar", children: /* @__PURE__ */ y.jsxs("div", { className: "tlui-toolbar__inner", children: [
    /* @__PURE__ */ y.jsxs("div", { className: "tlui-toolbar__left", children: [
      !i && /* @__PURE__ */ y.jsxs("div", { className: "tlui-toolbar__extras", children: [
        r < Ui.TABLET && /* @__PURE__ */ y.jsxs("div", { className: "tlui-toolbar__extras__controls tlui-buttons__horizontal", children: [
          l && /* @__PURE__ */ y.jsx(l, {}),
          o && /* @__PURE__ */ y.jsx(o, {})
        ] }),
        /* @__PURE__ */ y.jsx(L2e, { activeToolId: s })
      ] }),
      /* @__PURE__ */ y.jsx(O2e, { children: t ?? /* @__PURE__ */ y.jsx(RJ, {}) })
    ] }),
    r < Ui.TABLET_SM && !i && /* @__PURE__ */ y.jsx("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ y.jsx(VMe, {}) })
  ] }) });
});
function j2e() {
  const n = Dn();
  return /* @__PURE__ */ y.jsxs("div", { className: Vt("tlui-offline-indicator"), children: [
    n("status.offline"),
    /* @__PURE__ */ y.jsx(Ih, { "aria-label": "offline", icon: "status-offline", small: !0 })
  ] });
}
function N2e({
  maxWidth: n = 420,
  ignoreRightWidth: t = 0,
  stylePanelWidth: e = 148,
  marginBetweenZones: r = 12,
  squeezeAmount: i = 52,
  children: s
}) {
  const o = D.useRef(null), l = Ya(), u = D.useCallback(() => {
    const d = o.current;
    if (!d) return;
    const f = d.parentElement.parentElement, m = f.querySelector(".tlui-layout__top__left"), v = f.querySelector(".tlui-layout__top__right"), S = f.offsetWidth, w = m.offsetWidth, E = v.offsetWidth, A = d.offsetWidth - t;
    let P = (S - A) / 2;
    S % 2 !== 0 && (P -= 0.5);
    const R = w + r, M = d.offsetLeft, j = Math.min(
      S - E - w - 2 * r,
      n
    ), $ = Math.max(P, R) - M;
    v.offsetWidth > e && l <= 6 ? d.style.setProperty("max-width", j - i + "px") : d.style.setProperty("max-width", j + "px"), d.style.setProperty("transform", `translate(${$}px, 0px)`);
  }, [l, t, r, n, i, e]);
  return D.useLayoutEffect(() => {
    const d = o.current;
    if (!d) return;
    const f = d.parentElement.parentElement, m = f.querySelector(".tlui-layout__top__left"), v = f.querySelector(".tlui-layout__top__right"), S = new ResizeObserver(u);
    return S.observe(m), S.observe(v), S.observe(f), S.observe(d), u(), () => {
      S.disconnect();
    };
  }, [u]), D.useLayoutEffect(() => {
    u();
  }), /* @__PURE__ */ y.jsx("div", { ref: o, className: "tlui-top-panel__container", children: s });
}
function F2e() {
  const n = pPe() === "offline";
  return /* @__PURE__ */ y.jsx(N2e, { children: n && /* @__PURE__ */ y.jsx(j2e, {}) });
}
function $2e() {
  const n = Dt();
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    /* @__PURE__ */ y.jsx(Me, { ...n["zoom-in"], noClose: !0 }),
    /* @__PURE__ */ y.jsx(Me, { ...n["zoom-out"], noClose: !0 }),
    /* @__PURE__ */ y.jsx(rJ, {}),
    /* @__PURE__ */ y.jsx(iJ, {}),
    /* @__PURE__ */ y.jsx(sJ, {})
  ] });
}
const z2e = D.memo(function({ children: t }) {
  const e = io(), [r, i] = Ip("zoom menu"), s = t ?? /* @__PURE__ */ y.jsx($2e, {});
  return /* @__PURE__ */ y.jsxs(OU, { dir: "ltr", open: r, onOpenChange: i, modal: !1, children: [
    /* @__PURE__ */ y.jsx(LU, { asChild: !0, dir: "ltr", children: /* @__PURE__ */ y.jsx(U2e, {}) }),
    /* @__PURE__ */ y.jsx(hD, { container: e, children: /* @__PURE__ */ y.jsx(
      jU,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: /* @__PURE__ */ y.jsx(lu, { type: "menu", sourceId: "zoom-menu", children: s })
      }
    ) })
  ] });
}), U2e = D.forwardRef(
  function(t, e) {
    const r = we(), i = Ya(), s = De("zoom", () => r.getZoomLevel(), [r]), o = Dn(), l = D.useCallback(() => {
      r.resetZoom(r.getViewportScreenCenter(), {
        animation: { duration: r.options.animationMediumMs }
      });
    }, [r]);
    return /* @__PURE__ */ y.jsx(
      Wt,
      {
        ref: e,
        ...t,
        type: "icon",
        title: `${o("navigation-zone.zoom")}`,
        "data-testid": "minimap.zoom-menu-button",
        className: i < Ui.TABLET_SM ? "tlui-zoom-menu__button" : "tlui-zoom-menu__button__pct",
        onDoubleClick: l,
        icon: i < Ui.MOBILE ? "zoom-in" : void 0,
        children: i < Ui.MOBILE ? null : /* @__PURE__ */ y.jsxs("span", { style: { flexGrow: 0, textAlign: "center" }, children: [
          Math.floor(s * 100),
          "%"
        ] })
      }
    );
  }
), FJ = D.createContext(null);
function B2e({
  overrides: n = {},
  children: t
}) {
  const e = O2(n), r = iD();
  return /* @__PURE__ */ y.jsx(
    FJ.Provider,
    {
      value: D.useMemo(
        () => ({
          ContextMenu: cJ,
          ActionsMenu: $Ie,
          HelpMenu: null,
          ZoomMenu: z2e,
          MainMenu: YRe,
          Minimap: JRe,
          StylePanel: IJ,
          PageMenu: rMe,
          NavigationPanel: tMe,
          Toolbar: NJ,
          KeyboardShortcutsDialog: ORe,
          QuickActions: sMe,
          HelperButtons: MRe,
          DebugPanel: CRe,
          DebugMenu: wRe,
          MenuPanel: PRe,
          SharePanel: r ? hMe : null,
          CursorChatBubble: r ? pRe : null,
          TopPanel: r ? F2e : null,
          ...e
        }),
        [e, r]
      ),
      children: t
    }
  );
}
function Nm() {
  const n = D.useContext(FJ);
  if (!n)
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  return n;
}
function H2e({
  overrides: n,
  components: t,
  assetUrls: e,
  onUiEvent: r,
  forceMobile: i,
  children: s
}) {
  return /* @__PURE__ */ y.jsx(jEe, { assetUrls: ETe(e), children: /* @__PURE__ */ y.jsx($Ee, { overrides: kTe(n), children: /* @__PURE__ */ y.jsx(B_e, { onEvent: r, children: /* @__PURE__ */ y.jsx(vTe, { children: /* @__PURE__ */ y.jsx(H_e, { children: /* @__PURE__ */ y.jsx(TTe, { forceMobile: i, children: /* @__PURE__ */ y.jsx(B2e, { overrides: t, children: /* @__PURE__ */ y.jsx(V2e, { overrides: n, children: s }) }) }) }) }) }) }) });
}
function V2e({
  overrides: n,
  children: t
}) {
  const e = ITe(n);
  return /* @__PURE__ */ y.jsx(vPe, { overrides: e.actions, children: /* @__PURE__ */ y.jsx(_Te, { overrides: e.tools, children: t }) });
}
function W2e() {
  const n = we(), { addToast: t } = gd();
  D.useEffect(() => {
    function e({ name: r, count: i }) {
      t({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${r} (${i}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    return n.addListener("max-shapes", e), () => {
      n.removeListener("max-shapes", e);
    };
  }, [n, t]);
}
const G2e = Gn.memo(function({
  renderDebugMenuItems: t,
  children: e,
  hideUi: r,
  components: i,
  ...s
}) {
  return /* @__PURE__ */ y.jsx(H2e, { ...s, components: i, children: /* @__PURE__ */ y.jsx(K2e, { hideUi: r, renderDebugMenuItems: t, children: e }) });
}), K2e = Gn.memo(function({
  children: t,
  hideUi: e,
  ...r
}) {
  return /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
    t,
    e ? null : /* @__PURE__ */ y.jsx(Y2e, { ...r })
  ] });
}), Y2e = Gn.memo(function() {
  const t = we(), e = Dn(), r = Ya(), i = Ap(), s = De("focus", () => t.getInstanceState().isFocusMode, [t]), o = De("debug", () => t.getInstanceState().isDebugMode, [t]), {
    SharePanel: l,
    TopPanel: u,
    MenuPanel: d,
    StylePanel: f,
    Toolbar: m,
    HelpMenu: v,
    NavigationPanel: S,
    HelperButtons: w,
    DebugPanel: E,
    CursorChatBubble: A
  } = Nm();
  R2e(), iPe(), W2e();
  const { "toggle-focus-mode": P } = Dt();
  return /* @__PURE__ */ y.jsxs(
    "div",
    {
      className: Vt("tlui-layout", {
        "tlui-layout__mobile": r < Ui.TABLET_SM
      }),
      "data-breakpoint": r,
      children: [
        s ? /* @__PURE__ */ y.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ y.jsx(
          Wt,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: e("focus-mode.toggle-focus-mode"),
            onClick: () => P.onSelect("menu"),
            children: /* @__PURE__ */ y.jsx(Rn, { icon: "dot" })
          }
        ) }) : /* @__PURE__ */ y.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ y.jsxs("div", { className: "tlui-layout__top", children: [
            /* @__PURE__ */ y.jsxs("div", { className: "tlui-layout__top__left", children: [
              d && /* @__PURE__ */ y.jsx(d, {}),
              w && /* @__PURE__ */ y.jsx(w, {})
            ] }),
            /* @__PURE__ */ y.jsx("div", { className: "tlui-layout__top__center", children: u && /* @__PURE__ */ y.jsx(u, {}) }),
            /* @__PURE__ */ y.jsxs("div", { className: "tlui-layout__top__right", children: [
              l && /* @__PURE__ */ y.jsx(l, {}),
              f && r >= Ui.TABLET_SM && !i && /* @__PURE__ */ y.jsx(f, {})
            ] })
          ] }),
          /* @__PURE__ */ y.jsxs("div", { className: "tlui-layout__bottom", children: [
            /* @__PURE__ */ y.jsxs("div", { className: "tlui-layout__bottom__main", children: [
              S && /* @__PURE__ */ y.jsx(S, {}),
              m && /* @__PURE__ */ y.jsx(m, {}),
              v && /* @__PURE__ */ y.jsx(v, {})
            ] }),
            o && E && /* @__PURE__ */ y.jsx(E, {})
          ] })
        ] }),
        /* @__PURE__ */ y.jsx(xTe, {}),
        /* @__PURE__ */ y.jsx(G_e, {}),
        /* @__PURE__ */ y.jsx(wTe, {}),
        /* @__PURE__ */ y.jsx(K_e, {}),
        A && /* @__PURE__ */ y.jsx(A, {})
      ]
    }
  );
});
async function X2e(n, t) {
  const {
    url: e,
    style: r = "normal",
    weight: i = "500",
    display: s,
    featureSettings: o,
    stretch: l,
    unicodeRange: u,
    variant: d,
    format: f
  } = t, m = {
    style: r,
    weight: i,
    display: s,
    featureSettings: o,
    stretch: l,
    unicodeRange: u,
    // @ts-expect-error why is this here
    variant: d
  }, v = new FontFace(n, `url(${e})`, m);
  return await v.load(), document.fonts.add(v), v.$$_url = e, v.$$_fontface = `
@font-face {
	font-family: ${v.family};
	font-stretch: ${v.stretch};
	font-weight: ${v.weight};
	font-style: ${v.style};
	src: url("${e}") format("${f}")
}`, v;
}
const $I = (n, t) => {
  const [e, r] = D.useState(
    2
    /* WAITING */
  );
  return D.useEffect(() => {
    let i = !1;
    return r(
      2
      /* WAITING */
    ), X2e(n, t).then(() => {
      i || r(
        0
        /* SUCCESS */
      );
    }).catch((s) => {
      i || (console.error(s), r(
        1
        /* FAILED */
      ));
    }), () => {
      i = !0;
    };
  }, [n, t]), e;
};
function q2e(n) {
  return {
    draw: {
      url: n.fonts.draw,
      format: n.fonts.draw.split(".").pop()
    },
    serif: {
      url: n.fonts.serif,
      format: n.fonts.serif.split(".").pop()
    },
    sansSerif: {
      url: n.fonts.sansSerif,
      format: n.fonts.sansSerif.split(".").pop()
    },
    monospace: {
      url: n.fonts.monospace,
      format: n.fonts.monospace.split(".").pop()
    }
  };
}
function $J(n) {
  const t = D.useMemo(() => q2e(n), [n]), e = [
    $I("tldraw_draw", t.draw),
    $I("tldraw_serif", t.serif),
    $I("tldraw_sans", t.sansSerif),
    $I("tldraw_mono", t.monospace)
  ];
  return {
    // If any of the results have errored, then preloading has failed
    error: e.some(
      (r) => r === 1
      /* FAILED */
    ),
    // If any of the results are waiting, then we're not done yet
    done: !e.some(
      (r) => r === 2
      /* WAITING */
    )
  };
}
function Z2e(n) {
  const {
    children: t,
    maxImageDimension: e,
    maxAssetSize: r,
    acceptedImageMimeTypes: i,
    acceptedVideoMimeTypes: s,
    onMount: o,
    components: l = {},
    shapeUtils: u = [],
    bindingUtils: d = [],
    tools: f = [],
    ...m
  } = n, v = O2(l), S = D.useMemo(
    () => ({
      Scribble: o7,
      ShapeIndicators: Swe,
      CollaboratorScribble: o7,
      SelectionForeground: mwe,
      SelectionBackground: pwe,
      Handles: cwe,
      ...v
    }),
    [v]
  ), w = A1(u), E = D.useMemo(
    () => [...vX, ...w],
    [w]
  ), A = A1(d), P = D.useMemo(
    () => [...NY, ...A],
    [A]
  ), R = A1(f), M = D.useMemo(
    () => [...d1e, ...SCe, ...R],
    [R]
  ), j = Mq(m.assetUrls), { done: $, error: U } = $J(j);
  return U ? /* @__PURE__ */ y.jsx(DY, { children: "Could not load assets. Please refresh the page." }) : $ ? /* @__PURE__ */ y.jsx(
    qxe,
    {
      initialState: "select",
      ...m,
      components: S,
      shapeUtils: E,
      bindingUtils: P,
      tools: M,
      children: /* @__PURE__ */ y.jsxs(G2e, { ...m, components: S, children: [
        /* @__PURE__ */ y.jsx(
          Q2e,
          {
            maxImageDimension: e,
            maxAssetSize: r,
            acceptedImageMimeTypes: i,
            acceptedVideoMimeTypes: s,
            onMount: o
          }
        ),
        t
      ] })
    }
  ) : /* @__PURE__ */ y.jsx(A5, { children: /* @__PURE__ */ y.jsx(v5, {}) });
}
function Q2e({
  maxImageDimension: n = 5e3,
  maxAssetSize: t = 10 * 1024 * 1024,
  // 10mb
  acceptedImageMimeTypes: e = Zz,
  acceptedVideoMimeTypes: r = mG,
  onMount: i
}) {
  const s = we(), o = gd(), l = Dn();
  OY(() => {
    const f = [];
    return f.push(XEe(s)), tCe(
      s,
      {
        maxImageDimension: n,
        maxAssetSize: t,
        acceptedImageMimeTypes: e,
        acceptedVideoMimeTypes: r
      },
      {
        toasts: o,
        msg: l
      }
    ), f.push(s.store.props.onMount(s)), f.push(i == null ? void 0 : i(s)), () => {
      f.forEach((m) => m == null ? void 0 : m());
    };
  });
  const { Canvas: u } = xi(), { ContextMenu: d } = Nm();
  return d ? /* @__PURE__ */ y.jsx(d, {}) : u ? /* @__PURE__ */ y.jsx(u, {}) : null;
}
D.memo(function(t) {
  const [e, r] = D.useState(null), [i, s] = D.useState(null), o = A1(t.shapeUtils ?? []), l = D.useMemo(() => [...vX, ...o], [o]), u = A1(t.bindingUtils ?? []), d = D.useMemo(
    () => [...NY, ...u],
    [u]
  ), f = nwe({ snapshot: t.snapshot, shapeUtils: l }), m = Mq(), { done: v, error: S } = $J(m), {
    pageId: w,
    bounds: E,
    scale: A,
    background: P,
    padding: R,
    darkMode: M,
    preserveAspectRatio: j,
    format: $ = "svg",
    licenseKey: U
  } = t;
  return D.useLayoutEffect(() => {
    if (!i || !f || !v) return;
    let F = !1;
    const B = document.createElement("div");
    i.appendChild(B), i.classList.add("tl-container", "tl-theme__light");
    const G = new mt({
      store: f,
      shapeUtils: l,
      bindingUtils: d,
      tools: [],
      getContainer: () => B,
      licenseKey: U
    });
    w && G.setCurrentPage(w);
    const X = G.getCurrentPageShapeIds();
    async function te() {
      const ne = await G.getSvgString([...X], {
        bounds: E,
        scale: A,
        background: P,
        padding: R,
        darkMode: M,
        preserveAspectRatio: j
      });
      if (ne && !F) {
        if ($ === "svg") {
          if (!F) {
            const K = new Blob([ne.svg], { type: "image/svg+xml" }), Z = URL.createObjectURL(K);
            r(Z);
          }
        } else if ($ === "png") {
          const K = await Uq(G, ne.svg, {
            type: $,
            quality: 1,
            scale: 2,
            width: ne.width,
            height: ne.height
          });
          if (K && !F) {
            const Z = URL.createObjectURL(K);
            r(Z);
          }
        }
      }
      G.dispose();
    }
    return te(), () => {
      F = !0;
    };
  }, [
    $,
    i,
    f,
    l,
    d,
    w,
    E,
    A,
    P,
    R,
    M,
    j,
    v,
    S,
    U
  ]), S ? /* @__PURE__ */ y.jsx(DY, { children: "Could not load assets." }) : v ? /* @__PURE__ */ y.jsx("div", { ref: s, style: { position: "relative", width: "100%", height: "100%" }, children: e && /* @__PURE__ */ y.jsx(
    "img",
    {
      src: e,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) }) : /* @__PURE__ */ y.jsx(A5, { children: /* @__PURE__ */ y.jsx(v5, {}) });
});
D.memo(function({ children: t }) {
  const e = Dn(), r = Ya(), i = t ?? /* @__PURE__ */ y.jsx(NRe, {});
  return r < Ui.MOBILE ? null : /* @__PURE__ */ y.jsx("div", { className: "tlui-help-menu", children: /* @__PURE__ */ y.jsxs(lS, { id: "help menu", children: [
    /* @__PURE__ */ y.jsx(cS, { children: /* @__PURE__ */ y.jsx(Wt, { type: "help", title: e("help-menu.title"), "data-testid": "help-menu.button", children: /* @__PURE__ */ y.jsx(Rn, { icon: "question-mark", small: !0 }) }) }),
    /* @__PURE__ */ y.jsx(uS, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: /* @__PURE__ */ y.jsx(lu, { type: "menu", sourceId: "help-menu", children: i }) })
  ] }) });
});
const J2e = Mn({
  schemaVersion: ya(1),
  storeVersion: qI,
  recordVersions: mM(
    vn,
    Mn({
      version: qI,
      subTypeVersions: mM(vn, qI).optional(),
      subTypeKey: vn.optional()
    })
  )
}), eDe = Mn({
  schemaVersion: ya(2),
  sequences: mM(vn, qI)
});
Mn({
  tldrawFileFormatVersion: lve,
  schema: cve("schemaVersion", {
    1: J2e,
    2: eDe
  }),
  records: Ro(
    Mn({
      id: vn,
      typeName: vn
    }).allowUnknownProperties()
  )
});
const tDe = ({
  width: n = "100%",
  height: t = "100%",
  readOnly: e = !1,
  externalAssetStore: r = null,
  onEditorLoad: i = () => {
  }
}) => {
  const s = D.memo((v) => /* @__PURE__ */ y.jsxs(cJ, { ...v, children: [
    /* @__PURE__ */ y.jsx(FU, {}),
    /* @__PURE__ */ y.jsx(mn, { id: "select-all", children: /* @__PURE__ */ y.jsx($U, {}) })
  ] })), o = D.memo((v) => {
    const S = zU();
    return /* @__PURE__ */ y.jsx(IJ, { ...v, children: /* @__PURE__ */ y.jsx(kJ, { styles: S }) });
  }), l = D.memo(() => /* @__PURE__ */ y.jsx(NJ, { children: /* @__PURE__ */ y.jsx(RJ, {}) })), u = D.useMemo(
    () => ({
      ContextMenu: s,
      ActionsMenu: null,
      HelpMenu: null,
      ZoomMenu: null,
      MainMenu: null,
      Minimap: null,
      StylePanel: o,
      PageMenu: null,
      NavigationPanel: null,
      Toolbar: l,
      KeyboardShortcutsDialog: null,
      QuickActions: null,
      HelperButtons: null,
      DebugPanel: null,
      DebugMenu: null,
      SharePanel: null,
      MenuPanel: null,
      TopPanel: null,
      CursorChatBubble: null
    }),
    [s, o, l]
  ), d = {
    actions(v, S) {
      const w = {
        undo: "$z",
        redo: "$!z",
        cut: "$x",
        copy: "$c",
        paste: "$v",
        "select-all": "$a",
        delete: "⌫,del,backspace",
        duplicate: "$d"
      };
      return Object.fromEntries(Object.entries(S).map(([E, A]) => [E, { ...A, kbd: E in w ? w[E] : "" }]));
    },
    tools(v, S) {
      return Object.fromEntries(Object.entries(S).map(([w, E]) => [w, { ...E, kbd: "" }]));
    }
  }, f = {
    actions(v, S) {
      return Object.fromEntries(Object.entries(S).map(([w, E]) => [w, { ...E, kbd: "" }]));
    },
    tools(v, S) {
      return Object.fromEntries(Object.entries(S).map(([w, E]) => [w, { ...E, kbd: "" }]));
    }
  }, m = D.useMemo(() => {
    if (r)
      return {
        upload(v, S) {
          return r.upload(v.id, v.type, S);
        },
        resolve(v) {
          return r.resolve(v.id, v.type, v.props.src || "");
        }
      };
  }, [r]);
  return /* @__PURE__ */ y.jsx(
    "div",
    {
      style: {
        width: n,
        height: t,
        pointerEvents: e ? "none" : "unset"
      },
      children: /* @__PURE__ */ y.jsx(
        Z2e,
        {
          onMount: i,
          hideUi: e,
          components: u,
          overrides: e ? f : d,
          assets: m
        }
      )
    }
  );
}, nDe = D.memo(tDe), zJ = () => {
  const [n, t] = D.useState(null), [e, r] = D.useState(null), [i, s] = D.useState(0), [o, l] = D.useState({
    width: 0,
    height: 0,
    baseX: 0,
    baseY: 0,
    scale: 1
  }), [u, d] = D.useState(!1), [f, m] = D.useState(!0), v = D.useCallback((M) => {
    s((j) => j === M ? j : (l({
      width: 0,
      height: 0,
      baseX: 0,
      baseY: 0,
      scale: 1
    }), M));
  }, []), S = D.useCallback(({ width: M, height: j, baseX: $, baseY: U, scale: F }) => {
    const B = F, G = Math.max(Math.min(M * (1 - 1 / B), $), 0), X = Math.max(Math.min(j * (1 - 1 / B), U), 0), te = {
      width: M,
      height: j,
      baseX: G,
      baseY: X,
      scale: B
    };
    l((ne) => ne.width !== te.width || ne.height !== te.height || ne.baseX !== te.baseX || ne.baseY !== te.baseY || ne.scale !== te.scale ? te : (console.log("ignore render update"), ne));
  }, []), w = D.useMemo(() => ({
    getDocument: () => n,
    getPage: () => e,
    getPageIndex: () => i,
    setPageIndex: (M) => {
      v(M);
    },
    hasPreviousPage: () => n === null ? !1 : i > 0,
    moveToPreviousPage: () => {
      n !== null && v(Math.max(i - 1, 0));
    },
    hasNextPage: () => n === null ? !1 : i < n.numPages - 1,
    moveToNextPage: () => {
      n !== null && v(Math.min(i + 1, n.numPages - 1));
    },
    getPageCount: () => (n == null ? void 0 : n.numPages) || 0,
    getRenderOptions: () => o,
    setRenderOptions: ({ width: M, height: j, baseX: $, baseY: U, scale: F }) => {
      S({ width: M, height: j, baseX: $, baseY: U, scale: F });
    },
    getRenderSize: () => ({
      width: o.width,
      height: o.height
    }),
    setRenderSize: ({ width: M, height: j }) => {
      S({
        width: M,
        height: j,
        baseX: o.baseX,
        baseY: o.baseY,
        scale: o.scale
      });
    },
    zoom: ({ offsetX: M, offsetY: j, scaleDelta: $ }) => {
      const { width: U, height: F, baseX: B, baseY: G, scale: X } = o, te = Math.max(Math.min(Number((X * (1 + $)).toFixed(2)), 10), 1);
      if (X === te)
        return;
      const ne = Math.max(Math.min(Math.round(B + M / X), Math.floor(U)), 0), K = Math.max(Math.min(Math.round(G + j / X), Math.floor(F)), 0), Z = ne - M / te, oe = K - j / te;
      S({
        width: U,
        height: F,
        baseX: Z,
        baseY: oe,
        scale: te
      });
    },
    isDragModeEnabled: () => u,
    setDragModeEnabled: (M) => {
      d(M);
    },
    drag: ({ deltaX: M, deltaY: j }) => {
      S({
        width: o.width,
        height: o.height,
        baseX: o.baseX + M / o.scale,
        baseY: o.baseY + j / o.scale,
        scale: o.scale
      });
    },
    isItemClickEnabled: () => f,
    setItemClickEnabled: (M) => {
      m(M);
    }
  }), [v, S, n, e, i, o, u, f]), E = D.useCallback(
    (M) => {
      switch (M.key) {
        case "ArrowLeft":
          w.moveToPreviousPage();
          break;
        case "ArrowRight":
          w.moveToNextPage();
          break;
      }
    },
    [w]
  );
  D.useEffect(() => (document.addEventListener("keydown", E), () => document.removeEventListener("keydown", E)), [E]);
  const A = D.useCallback(
    (M) => {
      u && (M.preventDefault(), M.buttons === 1 && (console.log(M.movementX, M.movementY), w.drag({
        deltaX: -M.movementX,
        deltaY: -M.movementY
      })));
    },
    [u, w]
  ), P = D.useCallback(
    (M) => {
      M.preventDefault();
      const j = M.target.getBoundingClientRect(), $ = M.currentTarget.getBoundingClientRect(), U = Math.round(M.offsetX + j.left - $.left), F = Math.round(M.offsetY + j.top - $.top), B = M.deltaX + M.deltaY + M.deltaZ > 0 ? -1 : 1;
      w.zoom({
        offsetX: U,
        offsetY: F,
        scaleDelta: B * 0.2
      });
    },
    [w]
  ), R = D.useCallback(
    ({ pageIndex: M, destination: j }) => {
      console.log(`Target Page Index: ${M}`, j), f && v(M);
    },
    [f, v]
  );
  return {
    pdfViewerController: w,
    onPdfDocumentChange: t,
    onPdfPageChange: r,
    onPdfItemClick: R,
    onPdfMouseMoveEvent: A,
    onPdfWheelEvent: P
  };
};
var M1 = {};
M1.d = (n, t) => {
  for (var e in t)
    M1.o(t, e) && !M1.o(n, e) && Object.defineProperty(n, e, { enumerable: !0, get: t[e] });
};
M1.o = (n, t) => Object.prototype.hasOwnProperty.call(n, t);
var un = globalThis.pdfjsLib = {};
M1.d(un, {
  AbortException: () => (
    /* reexport */
    _S
  ),
  AnnotationEditorLayer: () => (
    /* reexport */
    fz
  ),
  AnnotationEditorParamsType: () => (
    /* reexport */
    gn
  ),
  AnnotationEditorType: () => (
    /* reexport */
    ir
  ),
  AnnotationEditorUIManager: () => (
    /* reexport */
    hS
  ),
  AnnotationLayer: () => (
    /* reexport */
    eLe
  ),
  AnnotationMode: () => (
    /* reexport */
    Hg
  ),
  CMapCompressionType: () => (
    /* reexport */
    s$
  ),
  ColorPicker: () => (
    /* reexport */
    ZM
  ),
  DOMSVGFactory: () => (
    /* reexport */
    GU
  ),
  DrawLayer: () => (
    /* reexport */
    vz
  ),
  FeatureTest: () => (
    /* reexport */
    jl
  ),
  GlobalWorkerOptions: () => (
    /* reexport */
    fp
  ),
  ImageKind: () => (
    /* reexport */
    kR
  ),
  InvalidPDFException: () => (
    /* reexport */
    BJ
  ),
  MissingPDFException: () => (
    /* reexport */
    ES
  ),
  OPS: () => (
    /* reexport */
    Bu
  ),
  Outliner: () => (
    /* reexport */
    Y$
  ),
  PDFDataRangeTransport: () => (
    /* reexport */
    Nee
  ),
  PDFDateString: () => (
    /* reexport */
    XJ
  ),
  PDFWorker: () => (
    /* reexport */
    Z0
  ),
  PasswordResponses: () => (
    /* reexport */
    oDe
  ),
  PermissionFlag: () => (
    /* reexport */
    sDe
  ),
  PixelsPerInch: () => (
    /* reexport */
    Tm
  ),
  RenderingCancelledException: () => (
    /* reexport */
    KU
  ),
  TextLayer: () => (
    /* reexport */
    XM
  ),
  UnexpectedResponseException: () => (
    /* reexport */
    vD
  ),
  Util: () => (
    /* reexport */
    Ft
  ),
  VerbosityLevel: () => (
    /* reexport */
    pD
  ),
  XfaLayer: () => (
    /* reexport */
    $ee
  ),
  build: () => (
    /* reexport */
    OOe
  ),
  createValidAbsoluteUrl: () => (
    /* reexport */
    uDe
  ),
  fetchData: () => (
    /* reexport */
    wD
  ),
  getDocument: () => (
    /* reexport */
    _Oe
  ),
  getFilenameFromUrl: () => (
    /* reexport */
    bDe
  ),
  getPdfFilenameFromUrl: () => (
    /* reexport */
    xDe
  ),
  getXfaPageViewport: () => (
    /* reexport */
    wDe
  ),
  isDataScheme: () => (
    /* reexport */
    YU
  ),
  isPdfFile: () => (
    /* reexport */
    XU
  ),
  noContextMenu: () => (
    /* reexport */
    zl
  ),
  normalizeUnicode: () => (
    /* reexport */
    mDe
  ),
  renderTextLayer: () => (
    /* reexport */
    mOe
  ),
  setLayerDimensions: () => (
    /* reexport */
    dS
  ),
  shadow: () => (
    /* reexport */
    lr
  ),
  updateTextLayer: () => (
    /* reexport */
    vOe
  ),
  version: () => (
    /* reexport */
    DOe
  )
});
const va = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), UJ = [1, 0, 0, 1, 0, 0], i$ = [1e-3, 0, 0, 1e-3, 0, 0], rDe = 1e7, gF = 1.35, Jc = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  OPLIST: 256
}, Hg = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, iDe = "pdfjs_internal_editor_", ir = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, gn = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
}, sDe = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, sa = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, kR = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, Os = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, UE = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, pD = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, s$ = {
  NONE: 0,
  BINARY: 1
}, Bu = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
}, oDe = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let gD = pD.WARNINGS;
function aDe(n) {
  Number.isInteger(n) && (gD = n);
}
function lDe() {
  return gD;
}
function mD(n) {
  gD >= pD.INFOS && console.log(`Info: ${n}`);
}
function In(n) {
  gD >= pD.WARNINGS && console.log(`Warning: ${n}`);
}
function Lr(n) {
  throw new Error(n);
}
function zs(n, t) {
  n || Lr(t);
}
function cDe(n) {
  switch (n == null ? void 0 : n.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function uDe(n, t = null, e = null) {
  if (!n)
    return null;
  try {
    if (e && typeof n == "string") {
      if (e.addDefaultProtocol && n.startsWith("www.")) {
        const i = n.match(/\./g);
        (i == null ? void 0 : i.length) >= 2 && (n = `http://${n}`);
      }
      if (e.tryConvertEncoding)
        try {
          n = gDe(n);
        } catch {
        }
    }
    const r = t ? new URL(n, t) : new URL(n);
    if (cDe(r))
      return r;
  } catch {
  }
  return null;
}
function lr(n, t, e, r = !1) {
  return Object.defineProperty(n, t, {
    value: e,
    enumerable: !r,
    configurable: !0,
    writable: !1
  }), e;
}
const Fm = function() {
  function t(e, r) {
    this.constructor === t && Lr("Cannot initialize BaseException."), this.message = e, this.name = r;
  }
  return t.prototype = new Error(), t.constructor = t, t;
}();
class o$ extends Fm {
  constructor(t, e) {
    super(t, "PasswordException"), this.code = e;
  }
}
class a$ extends Fm {
  constructor(t, e) {
    super(t, "UnknownErrorException"), this.details = e;
  }
}
class BJ extends Fm {
  constructor(t) {
    super(t, "InvalidPDFException");
  }
}
class ES extends Fm {
  constructor(t) {
    super(t, "MissingPDFException");
  }
}
class vD extends Fm {
  constructor(t, e) {
    super(t, "UnexpectedResponseException"), this.status = e;
  }
}
class dDe extends Fm {
  constructor(t) {
    super(t, "FormatError");
  }
}
class _S extends Fm {
  constructor(t) {
    super(t, "AbortException");
  }
}
function HJ(n) {
  (typeof n != "object" || (n == null ? void 0 : n.length) === void 0) && Lr("Invalid argument for bytesToString");
  const t = n.length, e = 8192;
  if (t < e)
    return String.fromCharCode.apply(null, n);
  const r = [];
  for (let i = 0; i < t; i += e) {
    const s = Math.min(i + e, t), o = n.subarray(i, s);
    r.push(String.fromCharCode.apply(null, o));
  }
  return r.join("");
}
function yD(n) {
  typeof n != "string" && Lr("Invalid argument for stringToBytes");
  const t = n.length, e = new Uint8Array(t);
  for (let r = 0; r < t; ++r)
    e[r] = n.charCodeAt(r) & 255;
  return e;
}
function hDe(n) {
  return String.fromCharCode(n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255);
}
function VU(n) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const [e, r] of n)
    t[e] = r;
  return t;
}
function fDe() {
  const n = new Uint8Array(4);
  return n[0] = 1, new Uint32Array(n.buffer, 0, 1)[0] === 1;
}
function pDe() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class jl {
  static get isLittleEndian() {
    return lr(this, "isLittleEndian", fDe());
  }
  static get isEvalSupported() {
    return lr(this, "isEvalSupported", pDe());
  }
  static get isOffscreenCanvasSupported() {
    return lr(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? lr(this, "platform", {
      isMac: navigator.platform.includes("Mac")
    }) : lr(this, "platform", {
      isMac: !1
    });
  }
  static get isCSSRoundSupported() {
    var t, e;
    return lr(this, "isCSSRoundSupported", (e = (t = globalThis.CSS) == null ? void 0 : t.supports) == null ? void 0 : e.call(t, "width: round(1.5px, 1px)"));
  }
}
const mF = Array.from(Array(256).keys(), (n) => n.toString(16).padStart(2, "0"));
var gp, IR, l$;
class Ft {
  static makeHexColor(t, e, r) {
    return `#${mF[t]}${mF[e]}${mF[r]}`;
  }
  static scaleMinMax(t, e) {
    let r;
    t[0] ? (t[0] < 0 && (r = e[0], e[0] = e[2], e[2] = r), e[0] *= t[0], e[2] *= t[0], t[3] < 0 && (r = e[1], e[1] = e[3], e[3] = r), e[1] *= t[3], e[3] *= t[3]) : (r = e[0], e[0] = e[1], e[1] = r, r = e[2], e[2] = e[3], e[3] = r, t[1] < 0 && (r = e[1], e[1] = e[3], e[3] = r), e[1] *= t[1], e[3] *= t[1], t[2] < 0 && (r = e[0], e[0] = e[2], e[2] = r), e[0] *= t[2], e[2] *= t[2]), e[0] += t[4], e[1] += t[5], e[2] += t[4], e[3] += t[5];
  }
  static transform(t, e) {
    return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]];
  }
  static applyTransform(t, e) {
    const r = t[0] * e[0] + t[1] * e[2] + e[4], i = t[0] * e[1] + t[1] * e[3] + e[5];
    return [r, i];
  }
  static applyInverseTransform(t, e) {
    const r = e[0] * e[3] - e[1] * e[2], i = (t[0] * e[3] - t[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / r, s = (-t[0] * e[1] + t[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / r;
    return [i, s];
  }
  static getAxialAlignedBoundingBox(t, e) {
    const r = this.applyTransform(t, e), i = this.applyTransform(t.slice(2, 4), e), s = this.applyTransform([t[0], t[3]], e), o = this.applyTransform([t[2], t[1]], e);
    return [Math.min(r[0], i[0], s[0], o[0]), Math.min(r[1], i[1], s[1], o[1]), Math.max(r[0], i[0], s[0], o[0]), Math.max(r[1], i[1], s[1], o[1])];
  }
  static inverseTransform(t) {
    const e = t[0] * t[3] - t[1] * t[2];
    return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e];
  }
  static singularValueDecompose2dScale(t) {
    const e = [t[0], t[2], t[1], t[3]], r = t[0] * e[0] + t[1] * e[2], i = t[0] * e[1] + t[1] * e[3], s = t[2] * e[0] + t[3] * e[2], o = t[2] * e[1] + t[3] * e[3], l = (r + o) / 2, u = Math.sqrt((r + o) ** 2 - 4 * (r * o - s * i)) / 2, d = l + u || 1, f = l - u || 1;
    return [Math.sqrt(d), Math.sqrt(f)];
  }
  static normalizeRect(t) {
    const e = t.slice(0);
    return t[0] > t[2] && (e[0] = t[2], e[2] = t[0]), t[1] > t[3] && (e[1] = t[3], e[3] = t[1]), e;
  }
  static intersect(t, e) {
    const r = Math.max(Math.min(t[0], t[2]), Math.min(e[0], e[2])), i = Math.min(Math.max(t[0], t[2]), Math.max(e[0], e[2]));
    if (r > i)
      return null;
    const s = Math.max(Math.min(t[1], t[3]), Math.min(e[1], e[3])), o = Math.min(Math.max(t[1], t[3]), Math.max(e[1], e[3]));
    return s > o ? null : [r, s, i, o];
  }
  static bezierBoundingBox(t, e, r, i, s, o, l, u, d) {
    return d ? (d[0] = Math.min(d[0], t, l), d[1] = Math.min(d[1], e, u), d[2] = Math.max(d[2], t, l), d[3] = Math.max(d[3], e, u)) : d = [Math.min(t, l), Math.min(e, u), Math.max(t, l), Math.max(e, u)], Q(this, gp, l$).call(this, t, r, s, l, e, i, o, u, 3 * (-t + 3 * (r - s) + l), 6 * (t - 2 * r + s), 3 * (r - t), d), Q(this, gp, l$).call(this, t, r, s, l, e, i, o, u, 3 * (-e + 3 * (i - o) + u), 6 * (e - 2 * i + o), 3 * (i - e), d), d;
  }
}
gp = new WeakSet(), IR = function(t, e, r, i, s, o, l, u, d, f) {
  if (d <= 0 || d >= 1)
    return;
  const m = 1 - d, v = d * d, S = v * d, w = m * (m * (m * t + 3 * d * e) + 3 * v * r) + S * i, E = m * (m * (m * s + 3 * d * o) + 3 * v * l) + S * u;
  f[0] = Math.min(f[0], w), f[1] = Math.min(f[1], E), f[2] = Math.max(f[2], w), f[3] = Math.max(f[3], E);
}, l$ = function(t, e, r, i, s, o, l, u, d, f, m, v) {
  if (Math.abs(d) < 1e-12) {
    Math.abs(f) >= 1e-12 && Q(this, gp, IR).call(this, t, e, r, i, s, o, l, u, -m / f, v);
    return;
  }
  const S = f ** 2 - 4 * m * d;
  if (S < 0)
    return;
  const w = Math.sqrt(S), E = 2 * d;
  Q(this, gp, IR).call(this, t, e, r, i, s, o, l, u, (-f + w) / E, v), Q(this, gp, IR).call(this, t, e, r, i, s, o, l, u, (-f - w) / E, v);
}, J(Ft, gp);
function gDe(n) {
  return decodeURIComponent(escape(n));
}
let vF = null, TV = null;
function mDe(n) {
  return vF || (vF = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, TV = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), n.replaceAll(vF, (t, e, r) => e ? e.normalize("NFKC") : TV.get(r));
}
function vDe() {
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
    return crypto.randomUUID();
  const n = new Uint8Array(32);
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
    crypto.getRandomValues(n);
  else
    for (let t = 0; t < 32; t++)
      n[t] = Math.floor(Math.random() * 255);
  return HJ(n);
}
const VJ = "pdfjs_internal_id_", Tf = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
};
class SD {
  constructor() {
    this.constructor === SD && Lr("Cannot initialize BaseFilterFactory.");
  }
  addFilter(t) {
    return "none";
  }
  addHCMFilter(t, e) {
    return "none";
  }
  addAlphaFilter(t) {
    return "none";
  }
  addLuminosityFilter(t) {
    return "none";
  }
  addHighlightHCMFilter(t, e, r, i, s) {
    return "none";
  }
  destroy(t = !1) {
  }
}
var e_;
const tB = class tB {
  constructor({
    enableHWA: t = !1
  } = {}) {
    J(this, e_, !1);
    this.constructor === tB && Lr("Cannot initialize BaseCanvasFactory."), q(this, e_, t);
  }
  create(t, e) {
    if (t <= 0 || e <= 0)
      throw new Error("Invalid canvas size");
    const r = this._createCanvas(t, e);
    return {
      canvas: r,
      context: r.getContext("2d", {
        willReadFrequently: !_(this, e_)
      })
    };
  }
  reset(t, e, r) {
    if (!t.canvas)
      throw new Error("Canvas is not specified");
    if (e <= 0 || r <= 0)
      throw new Error("Invalid canvas size");
    t.canvas.width = e, t.canvas.height = r;
  }
  destroy(t) {
    if (!t.canvas)
      throw new Error("Canvas is not specified");
    t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
  }
  _createCanvas(t, e) {
    Lr("Abstract method `_createCanvas` called.");
  }
};
e_ = new WeakMap();
let WM = tB;
class bD {
  constructor({
    baseUrl: t = null,
    isCompressed: e = !0
  }) {
    this.constructor === bD && Lr("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = e;
  }
  async fetch({
    name: t
  }) {
    if (!this.baseUrl)
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
    if (!t)
      throw new Error("CMap name must be specified.");
    const e = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), r = this.isCompressed ? s$.BINARY : s$.NONE;
    return this._fetchData(e, r).catch((i) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${e}`);
    });
  }
  _fetchData(t, e) {
    Lr("Abstract method `_fetchData` called.");
  }
}
class xD {
  constructor({
    baseUrl: t = null
  }) {
    this.constructor === xD && Lr("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t;
  }
  async fetch({
    filename: t
  }) {
    if (!this.baseUrl)
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
    if (!t)
      throw new Error("Font filename must be specified.");
    const e = `${this.baseUrl}${t}`;
    return this._fetchData(e).catch((r) => {
      throw new Error(`Unable to load font data at: ${e}`);
    });
  }
  _fetchData(t) {
    Lr("Abstract method `_fetchData` called.");
  }
}
class WU {
  constructor() {
    this.constructor === WU && Lr("Cannot initialize BaseSVGFactory.");
  }
  create(t, e, r = !1) {
    if (t <= 0 || e <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), r || (i.setAttribute("width", `${t}px`), i.setAttribute("height", `${e}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${t} ${e}`), i;
  }
  createElement(t) {
    if (typeof t != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(t);
  }
  _createSVG(t) {
    Lr("Abstract method `_createSVG` called.");
  }
}
const If = "http://www.w3.org/2000/svg", Xv = class Xv {
};
T(Xv, "CSS", 96), T(Xv, "PDF", 72), T(Xv, "PDF_TO_CSS_UNITS", Xv.CSS / Xv.PDF);
let Tm = Xv;
var Jv, Zd, jf, _l, JM, ey, kt, oa, P0, A0, RR, WJ, c$, k0, u1, d1, u$, h1;
class yDe extends SD {
  constructor({
    docId: e,
    ownerDocument: r = globalThis.document
  } = {}) {
    super();
    J(this, kt);
    J(this, Jv);
    J(this, Zd);
    J(this, jf);
    J(this, _l);
    J(this, JM);
    J(this, ey, 0);
    q(this, jf, e), q(this, _l, r);
  }
  addFilter(e) {
    if (!e)
      return "none";
    let r = _(this, kt, oa).get(e);
    if (r)
      return r;
    const [i, s, o] = Q(this, kt, RR).call(this, e), l = e.length === 1 ? i : `${i}${s}${o}`;
    if (r = _(this, kt, oa).get(l), r)
      return _(this, kt, oa).set(e, r), r;
    const u = `g_${_(this, jf)}_transfer_map_${ec(this, ey)._++}`, d = `url(#${u})`;
    _(this, kt, oa).set(e, d), _(this, kt, oa).set(l, d);
    const f = Q(this, kt, k0).call(this, u);
    return Q(this, kt, d1).call(this, i, s, o, f), d;
  }
  addHCMFilter(e, r) {
    var w;
    const i = `${e}-${r}`, s = "base";
    let o = _(this, kt, P0).get(s);
    if ((o == null ? void 0 : o.key) === i || (o ? ((w = o.filter) == null || w.remove(), o.key = i, o.url = "none", o.filter = null) : (o = {
      key: i,
      url: "none",
      filter: null
    }, _(this, kt, P0).set(s, o)), !e || !r))
      return o.url;
    const l = Q(this, kt, h1).call(this, e);
    e = Ft.makeHexColor(...l);
    const u = Q(this, kt, h1).call(this, r);
    if (r = Ft.makeHexColor(...u), _(this, kt, A0).style.color = "", e === "#000000" && r === "#ffffff" || e === r)
      return o.url;
    const d = new Array(256);
    for (let E = 0; E <= 255; E++) {
      const A = E / 255;
      d[E] = A <= 0.03928 ? A / 12.92 : ((A + 0.055) / 1.055) ** 2.4;
    }
    const f = d.join(","), m = `g_${_(this, jf)}_hcm_filter`, v = o.filter = Q(this, kt, k0).call(this, m);
    Q(this, kt, d1).call(this, f, f, f, v), Q(this, kt, c$).call(this, v);
    const S = (E, A) => {
      const P = l[E] / 255, R = u[E] / 255, M = new Array(A + 1);
      for (let j = 0; j <= A; j++)
        M[j] = P + j / A * (R - P);
      return M.join(",");
    };
    return Q(this, kt, d1).call(this, S(0, 5), S(1, 5), S(2, 5), v), o.url = `url(#${m})`, o.url;
  }
  addAlphaFilter(e) {
    let r = _(this, kt, oa).get(e);
    if (r)
      return r;
    const [i] = Q(this, kt, RR).call(this, [e]), s = `alpha_${i}`;
    if (r = _(this, kt, oa).get(s), r)
      return _(this, kt, oa).set(e, r), r;
    const o = `g_${_(this, jf)}_alpha_map_${ec(this, ey)._++}`, l = `url(#${o})`;
    _(this, kt, oa).set(e, l), _(this, kt, oa).set(s, l);
    const u = Q(this, kt, k0).call(this, o);
    return Q(this, kt, u$).call(this, i, u), l;
  }
  addLuminosityFilter(e) {
    let r = _(this, kt, oa).get(e || "luminosity");
    if (r)
      return r;
    let i, s;
    if (e ? ([i] = Q(this, kt, RR).call(this, [e]), s = `luminosity_${i}`) : s = "luminosity", r = _(this, kt, oa).get(s), r)
      return _(this, kt, oa).set(e, r), r;
    const o = `g_${_(this, jf)}_luminosity_map_${ec(this, ey)._++}`, l = `url(#${o})`;
    _(this, kt, oa).set(e, l), _(this, kt, oa).set(s, l);
    const u = Q(this, kt, k0).call(this, o);
    return Q(this, kt, WJ).call(this, u), e && Q(this, kt, u$).call(this, i, u), l;
  }
  addHighlightHCMFilter(e, r, i, s, o) {
    var R;
    const l = `${r}-${i}-${s}-${o}`;
    let u = _(this, kt, P0).get(e);
    if ((u == null ? void 0 : u.key) === l || (u ? ((R = u.filter) == null || R.remove(), u.key = l, u.url = "none", u.filter = null) : (u = {
      key: l,
      url: "none",
      filter: null
    }, _(this, kt, P0).set(e, u)), !r || !i))
      return u.url;
    const [d, f] = [r, i].map(Q(this, kt, h1).bind(this));
    let m = Math.round(0.2126 * d[0] + 0.7152 * d[1] + 0.0722 * d[2]), v = Math.round(0.2126 * f[0] + 0.7152 * f[1] + 0.0722 * f[2]), [S, w] = [s, o].map(Q(this, kt, h1).bind(this));
    v < m && ([m, v, S, w] = [v, m, w, S]), _(this, kt, A0).style.color = "";
    const E = (M, j, $) => {
      const U = new Array(256), F = (v - m) / $, B = M / 255, G = (j - M) / (255 * $);
      let X = 0;
      for (let te = 0; te <= $; te++) {
        const ne = Math.round(m + te * F), K = B + te * G;
        for (let Z = X; Z <= ne; Z++)
          U[Z] = K;
        X = ne + 1;
      }
      for (let te = X; te < 256; te++)
        U[te] = U[X - 1];
      return U.join(",");
    }, A = `g_${_(this, jf)}_hcm_${e}_filter`, P = u.filter = Q(this, kt, k0).call(this, A);
    return Q(this, kt, c$).call(this, P), Q(this, kt, d1).call(this, E(S[0], w[0], 5), E(S[1], w[1], 5), E(S[2], w[2], 5), P), u.url = `url(#${A})`, u.url;
  }
  destroy(e = !1) {
    e && _(this, kt, P0).size !== 0 || (_(this, Zd) && (_(this, Zd).parentNode.parentNode.remove(), q(this, Zd, null)), _(this, Jv) && (_(this, Jv).clear(), q(this, Jv, null)), q(this, ey, 0));
  }
}
Jv = new WeakMap(), Zd = new WeakMap(), jf = new WeakMap(), _l = new WeakMap(), JM = new WeakMap(), ey = new WeakMap(), kt = new WeakSet(), oa = function() {
  return _(this, Jv) || q(this, Jv, /* @__PURE__ */ new Map());
}, P0 = function() {
  return _(this, JM) || q(this, JM, /* @__PURE__ */ new Map());
}, A0 = function() {
  if (!_(this, Zd)) {
    const e = _(this, _l).createElement("div"), {
      style: r
    } = e;
    r.visibility = "hidden", r.contain = "strict", r.width = r.height = 0, r.position = "absolute", r.top = r.left = 0, r.zIndex = -1;
    const i = _(this, _l).createElementNS(If, "svg");
    i.setAttribute("width", 0), i.setAttribute("height", 0), q(this, Zd, _(this, _l).createElementNS(If, "defs")), e.append(i), i.append(_(this, Zd)), _(this, _l).body.append(e);
  }
  return _(this, Zd);
}, RR = function(e) {
  if (e.length === 1) {
    const d = e[0], f = new Array(256);
    for (let v = 0; v < 256; v++)
      f[v] = d[v] / 255;
    const m = f.join(",");
    return [m, m, m];
  }
  const [r, i, s] = e, o = new Array(256), l = new Array(256), u = new Array(256);
  for (let d = 0; d < 256; d++)
    o[d] = r[d] / 255, l[d] = i[d] / 255, u[d] = s[d] / 255;
  return [o.join(","), l.join(","), u.join(",")];
}, WJ = function(e) {
  const r = _(this, _l).createElementNS(If, "feColorMatrix");
  r.setAttribute("type", "matrix"), r.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e.append(r);
}, c$ = function(e) {
  const r = _(this, _l).createElementNS(If, "feColorMatrix");
  r.setAttribute("type", "matrix"), r.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e.append(r);
}, k0 = function(e) {
  const r = _(this, _l).createElementNS(If, "filter");
  return r.setAttribute("color-interpolation-filters", "sRGB"), r.setAttribute("id", e), _(this, kt, A0).append(r), r;
}, u1 = function(e, r, i) {
  const s = _(this, _l).createElementNS(If, r);
  s.setAttribute("type", "discrete"), s.setAttribute("tableValues", i), e.append(s);
}, d1 = function(e, r, i, s) {
  const o = _(this, _l).createElementNS(If, "feComponentTransfer");
  s.append(o), Q(this, kt, u1).call(this, o, "feFuncR", e), Q(this, kt, u1).call(this, o, "feFuncG", r), Q(this, kt, u1).call(this, o, "feFuncB", i);
}, u$ = function(e, r) {
  const i = _(this, _l).createElementNS(If, "feComponentTransfer");
  r.append(i), Q(this, kt, u1).call(this, i, "feFuncA", e);
}, h1 = function(e) {
  return _(this, kt, A0).style.color = e, qU(getComputedStyle(_(this, kt, A0)).getPropertyValue("color"));
};
class SDe extends WM {
  constructor({
    ownerDocument: t = globalThis.document,
    enableHWA: e = !1
  } = {}) {
    super({
      enableHWA: e
    }), this._document = t;
  }
  _createCanvas(t, e) {
    const r = this._document.createElement("canvas");
    return r.width = t, r.height = e, r;
  }
}
async function wD(n, t = "text") {
  if (f1(n, document.baseURI)) {
    const e = await fetch(n);
    if (!e.ok)
      throw new Error(e.statusText);
    switch (t) {
      case "arraybuffer":
        return e.arrayBuffer();
      case "blob":
        return e.blob();
      case "json":
        return e.json();
    }
    return e.text();
  }
  return new Promise((e, r) => {
    const i = new XMLHttpRequest();
    i.open("GET", n, !0), i.responseType = t, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (t) {
            case "arraybuffer":
            case "blob":
            case "json":
              e(i.response);
              return;
          }
          e(i.responseText);
          return;
        }
        r(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
class GJ extends bD {
  _fetchData(t, e) {
    return wD(t, this.isCompressed ? "arraybuffer" : "text").then((r) => ({
      cMapData: r instanceof ArrayBuffer ? new Uint8Array(r) : yD(r),
      compressionType: e
    }));
  }
}
class KJ extends xD {
  _fetchData(t) {
    return wD(t, "arraybuffer").then((e) => new Uint8Array(e));
  }
}
class GU extends WU {
  _createSVG(t) {
    return document.createElementNS(If, t);
  }
}
class rP {
  constructor({
    viewBox: t,
    scale: e,
    rotation: r,
    offsetX: i = 0,
    offsetY: s = 0,
    dontFlip: o = !1
  }) {
    this.viewBox = t, this.scale = e, this.rotation = r, this.offsetX = i, this.offsetY = s;
    const l = (t[2] + t[0]) / 2, u = (t[3] + t[1]) / 2;
    let d, f, m, v;
    switch (r %= 360, r < 0 && (r += 360), r) {
      case 180:
        d = -1, f = 0, m = 0, v = 1;
        break;
      case 90:
        d = 0, f = 1, m = 1, v = 0;
        break;
      case 270:
        d = 0, f = -1, m = -1, v = 0;
        break;
      case 0:
        d = 1, f = 0, m = 0, v = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    o && (m = -m, v = -v);
    let S, w, E, A;
    d === 0 ? (S = Math.abs(u - t[1]) * e + i, w = Math.abs(l - t[0]) * e + s, E = (t[3] - t[1]) * e, A = (t[2] - t[0]) * e) : (S = Math.abs(l - t[0]) * e + i, w = Math.abs(u - t[1]) * e + s, E = (t[2] - t[0]) * e, A = (t[3] - t[1]) * e), this.transform = [d * e, f * e, m * e, v * e, S - d * e * l - m * e * u, w - f * e * l - v * e * u], this.width = E, this.height = A;
  }
  get rawDims() {
    const {
      viewBox: t
    } = this;
    return lr(this, "rawDims", {
      pageWidth: t[2] - t[0],
      pageHeight: t[3] - t[1],
      pageX: t[0],
      pageY: t[1]
    });
  }
  clone({
    scale: t = this.scale,
    rotation: e = this.rotation,
    offsetX: r = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: s = !1
  } = {}) {
    return new rP({
      viewBox: this.viewBox.slice(),
      scale: t,
      rotation: e,
      offsetX: r,
      offsetY: i,
      dontFlip: s
    });
  }
  convertToViewportPoint(t, e) {
    return Ft.applyTransform([t, e], this.transform);
  }
  convertToViewportRectangle(t) {
    const e = Ft.applyTransform([t[0], t[1]], this.transform), r = Ft.applyTransform([t[2], t[3]], this.transform);
    return [e[0], e[1], r[0], r[1]];
  }
  convertToPdfPoint(t, e) {
    return Ft.applyInverseTransform([t, e], this.transform);
  }
}
class KU extends Fm {
  constructor(t, e = 0) {
    super(t, "RenderingCancelledException"), this.extraDelay = e;
  }
}
function YU(n) {
  const t = n.length;
  let e = 0;
  for (; e < t && n[e].trim() === ""; )
    e++;
  return n.substring(e, e + 5).toLowerCase() === "data:";
}
function XU(n) {
  return typeof n == "string" && /\.pdf$/i.test(n);
}
function bDe(n) {
  return [n] = n.split(/[#?]/, 1), n.substring(n.lastIndexOf("/") + 1);
}
function xDe(n, t = "document.pdf") {
  if (typeof n != "string")
    return t;
  if (YU(n))
    return In('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t;
  const e = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, r = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = e.exec(n);
  let s = r.exec(i[1]) || r.exec(i[2]) || r.exec(i[3]);
  if (s && (s = s[0], s.includes("%")))
    try {
      s = r.exec(decodeURIComponent(s))[0];
    } catch {
    }
  return s || t;
}
class PV {
  constructor() {
    T(this, "started", /* @__PURE__ */ Object.create(null));
    T(this, "times", []);
  }
  time(t) {
    t in this.started && In(`Timer is already running for ${t}`), this.started[t] = Date.now();
  }
  timeEnd(t) {
    t in this.started || In(`Timer has not been started for ${t}`), this.times.push({
      name: t,
      start: this.started[t],
      end: Date.now()
    }), delete this.started[t];
  }
  toString() {
    const t = [];
    let e = 0;
    for (const {
      name: r
    } of this.times)
      e = Math.max(r.length, e);
    for (const {
      name: r,
      start: i,
      end: s
    } of this.times)
      t.push(`${r.padEnd(e)} ${s - i}ms
`);
    return t.join("");
  }
}
function f1(n, t) {
  try {
    const {
      protocol: e
    } = t ? new URL(n, t) : new URL(n);
    return e === "http:" || e === "https:";
  } catch {
    return !1;
  }
}
function zl(n) {
  n.preventDefault();
}
function YJ(n) {
  console.log("Deprecated API usage: " + n);
}
let AV;
class XJ {
  static toDateObject(t) {
    if (!t || typeof t != "string")
      return null;
    AV || (AV = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const e = AV.exec(t);
    if (!e)
      return null;
    const r = parseInt(e[1], 10);
    let i = parseInt(e[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let s = parseInt(e[3], 10);
    s = s >= 1 && s <= 31 ? s : 1;
    let o = parseInt(e[4], 10);
    o = o >= 0 && o <= 23 ? o : 0;
    let l = parseInt(e[5], 10);
    l = l >= 0 && l <= 59 ? l : 0;
    let u = parseInt(e[6], 10);
    u = u >= 0 && u <= 59 ? u : 0;
    const d = e[7] || "Z";
    let f = parseInt(e[8], 10);
    f = f >= 0 && f <= 23 ? f : 0;
    let m = parseInt(e[9], 10) || 0;
    return m = m >= 0 && m <= 59 ? m : 0, d === "-" ? (o += f, l += m) : d === "+" && (o -= f, l -= m), new Date(Date.UTC(r, i, s, o, l, u));
  }
}
function wDe(n, {
  scale: t = 1,
  rotation: e = 0
}) {
  const {
    width: r,
    height: i
  } = n.attributes.style, s = [0, 0, parseInt(r), parseInt(i)];
  return new rP({
    viewBox: s,
    scale: t,
    rotation: e
  });
}
function qU(n) {
  if (n.startsWith("#")) {
    const t = parseInt(n.slice(1), 16);
    return [(t & 16711680) >> 16, (t & 65280) >> 8, t & 255];
  }
  return n.startsWith("rgb(") ? n.slice(4, -1).split(",").map((t) => parseInt(t)) : n.startsWith("rgba(") ? n.slice(5, -1).split(",").map((t) => parseInt(t)).slice(0, 3) : (In(`Not a valid color format: "${n}"`), [0, 0, 0]);
}
function CDe(n) {
  const t = document.createElement("span");
  t.style.visibility = "hidden", document.body.append(t);
  for (const e of n.keys()) {
    t.style.color = e;
    const r = window.getComputedStyle(t).color;
    n.set(e, qU(r));
  }
  t.remove();
}
function ki(n) {
  const {
    a: t,
    b: e,
    c: r,
    d: i,
    e: s,
    f: o
  } = n.getTransform();
  return [t, e, r, i, s, o];
}
function Pf(n) {
  const {
    a: t,
    b: e,
    c: r,
    d: i,
    e: s,
    f: o
  } = n.getTransform().invertSelf();
  return [t, e, r, i, s, o];
}
function dS(n, t, e = !1, r = !0) {
  if (t instanceof rP) {
    const {
      pageWidth: i,
      pageHeight: s
    } = t.rawDims, {
      style: o
    } = n, l = jl.isCSSRoundSupported, u = `var(--scale-factor) * ${i}px`, d = `var(--scale-factor) * ${s}px`, f = l ? `round(${u}, 1px)` : `calc(${u})`, m = l ? `round(${d}, 1px)` : `calc(${d})`;
    !e || t.rotation % 180 === 0 ? (o.width = f, o.height = m) : (o.width = m, o.height = f);
  }
  r && n.setAttribute("data-main-rotation", t.rotation);
}
var ty, ny, sc, ry, e2, qJ, Ba, ZJ, QJ, MR, JJ, h$;
const t2 = class t2 {
  constructor(t) {
    J(this, Ba);
    J(this, ty, null);
    J(this, ny, null);
    J(this, sc);
    J(this, ry, null);
    q(this, sc, t);
  }
  render() {
    const t = q(this, ty, document.createElement("div"));
    t.className = "editToolbar", t.setAttribute("role", "toolbar");
    const e = _(this, sc)._uiManager._signal;
    t.addEventListener("contextmenu", zl, {
      signal: e
    }), t.addEventListener("pointerdown", Q(t2, e2, qJ), {
      signal: e
    });
    const r = q(this, ry, document.createElement("div"));
    r.className = "buttons", t.append(r);
    const i = _(this, sc).toolbarPosition;
    if (i) {
      const {
        style: s
      } = t, o = _(this, sc)._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      s.insetInlineEnd = `${100 * o}%`, s.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return Q(this, Ba, JJ).call(this), t;
  }
  hide() {
    var t;
    _(this, ty).classList.add("hidden"), (t = _(this, ny)) == null || t.hideDropdown();
  }
  show() {
    _(this, ty).classList.remove("hidden");
  }
  addAltTextButton(t) {
    Q(this, Ba, MR).call(this, t), _(this, ry).prepend(t, _(this, Ba, h$));
  }
  addColorPicker(t) {
    q(this, ny, t);
    const e = t.renderButton();
    Q(this, Ba, MR).call(this, e), _(this, ry).prepend(e, _(this, Ba, h$));
  }
  remove() {
    var t;
    _(this, ty).remove(), (t = _(this, ny)) == null || t.destroy(), q(this, ny, null);
  }
};
ty = new WeakMap(), ny = new WeakMap(), sc = new WeakMap(), ry = new WeakMap(), e2 = new WeakSet(), qJ = function(t) {
  t.stopPropagation();
}, Ba = new WeakSet(), ZJ = function(t) {
  _(this, sc)._focusEventsAllowed = !1, t.preventDefault(), t.stopPropagation();
}, QJ = function(t) {
  _(this, sc)._focusEventsAllowed = !0, t.preventDefault(), t.stopPropagation();
}, MR = function(t) {
  const e = _(this, sc)._uiManager._signal;
  t.addEventListener("focusin", Q(this, Ba, ZJ).bind(this), {
    capture: !0,
    signal: e
  }), t.addEventListener("focusout", Q(this, Ba, QJ).bind(this), {
    capture: !0,
    signal: e
  }), t.addEventListener("contextmenu", zl, {
    signal: e
  });
}, JJ = function() {
  const t = document.createElement("button");
  t.className = "delete", t.tabIndex = 0, t.setAttribute("data-l10n-id", `pdfjs-editor-remove-${_(this, sc).editorType}-button`), Q(this, Ba, MR).call(this, t), t.addEventListener("click", (e) => {
    _(this, sc)._uiManager.delete();
  }, {
    signal: _(this, sc)._uiManager._signal
  }), _(this, ry).append(t);
}, h$ = function() {
  const t = document.createElement("div");
  return t.className = "divider", t;
}, J(t2, e2);
let d$ = t2;
var t_, iy, sy, Pm, eee, tee, nee;
class EDe {
  constructor(t) {
    J(this, Pm);
    J(this, t_, null);
    J(this, iy, null);
    J(this, sy);
    q(this, sy, t);
  }
  show(t, e, r) {
    const [i, s] = Q(this, Pm, tee).call(this, e, r), {
      style: o
    } = _(this, iy) || q(this, iy, Q(this, Pm, eee).call(this));
    t.append(_(this, iy)), o.insetInlineEnd = `${100 * i}%`, o.top = `calc(${100 * s}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    _(this, iy).remove();
  }
}
t_ = new WeakMap(), iy = new WeakMap(), sy = new WeakMap(), Pm = new WeakSet(), eee = function() {
  const t = q(this, iy, document.createElement("div"));
  t.className = "editToolbar", t.setAttribute("role", "toolbar"), t.addEventListener("contextmenu", zl, {
    signal: _(this, sy)._signal
  });
  const e = q(this, t_, document.createElement("div"));
  return e.className = "buttons", t.append(e), Q(this, Pm, nee).call(this), t;
}, tee = function(t, e) {
  let r = 0, i = 0;
  for (const s of t) {
    const o = s.y + s.height;
    if (o < r)
      continue;
    const l = s.x + (e ? s.width : 0);
    if (o > r) {
      i = l, r = o;
      continue;
    }
    e ? l > i && (i = l) : l < i && (i = l);
  }
  return [e ? 1 - i : i, r];
}, nee = function() {
  const t = document.createElement("button");
  t.className = "highlightButton", t.tabIndex = 0, t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const e = document.createElement("span");
  t.append(e), e.className = "visuallyHidden", e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const r = _(this, sy)._signal;
  t.addEventListener("contextmenu", zl, {
    signal: r
  }), t.addEventListener("click", () => {
    _(this, sy).highlightSelection("floating_button");
  }, {
    signal: r
  }), _(this, t_).append(t);
};
function GM(n, t, e) {
  for (const r of e)
    t.addEventListener(r, n[r].bind(n));
}
function _De(n) {
  return Math.round(Math.min(255, Math.max(1, 255 * n))).toString(16).padStart(2, "0");
}
var n2;
class TDe {
  constructor() {
    J(this, n2, 0);
  }
  get id() {
    return `${iDe}${ec(this, n2)._++}`;
  }
}
n2 = new WeakMap();
var n_, r2, Xc, r_, p$;
const nB = class nB {
  constructor() {
    J(this, r_);
    J(this, n_, vDe());
    J(this, r2, 0);
    J(this, Xc, null);
  }
  static get _isSVGFittingCanvas() {
    const t = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', r = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = t;
    const s = i.decode().then(() => (r.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(r.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return lr(this, "_isSVGFittingCanvas", s);
  }
  async getFromFile(t) {
    const {
      lastModified: e,
      name: r,
      size: i,
      type: s
    } = t;
    return Q(this, r_, p$).call(this, `${e}_${r}_${i}_${s}`, t);
  }
  async getFromUrl(t) {
    return Q(this, r_, p$).call(this, t, t);
  }
  async getFromId(t) {
    _(this, Xc) || q(this, Xc, /* @__PURE__ */ new Map());
    const e = _(this, Xc).get(t);
    return e ? e.bitmap ? (e.refCounter += 1, e) : e.file ? this.getFromFile(e.file) : this.getFromUrl(e.url) : null;
  }
  getSvgUrl(t) {
    const e = _(this, Xc).get(t);
    return e != null && e.isSvg ? e.svgUrl : null;
  }
  deleteId(t) {
    _(this, Xc) || q(this, Xc, /* @__PURE__ */ new Map());
    const e = _(this, Xc).get(t);
    e && (e.refCounter -= 1, e.refCounter === 0 && (e.bitmap = null));
  }
  isValidId(t) {
    return t.startsWith(`image_${_(this, n_)}_`);
  }
};
n_ = new WeakMap(), r2 = new WeakMap(), Xc = new WeakMap(), r_ = new WeakSet(), p$ = async function(t, e) {
  _(this, Xc) || q(this, Xc, /* @__PURE__ */ new Map());
  let r = _(this, Xc).get(t);
  if (r === null)
    return null;
  if (r != null && r.bitmap)
    return r.refCounter += 1, r;
  try {
    r || (r = {
      bitmap: null,
      id: `image_${_(this, n_)}_${ec(this, r2)._++}`,
      refCounter: 0,
      isSvg: !1
    });
    let i;
    if (typeof e == "string" ? (r.url = e, i = await wD(e, "blob")) : i = r.file = e, i.type === "image/svg+xml") {
      const s = nB._isSVGFittingCanvas, o = new FileReader(), l = new Image(), u = new Promise((d, f) => {
        l.onload = () => {
          r.bitmap = l, r.isSvg = !0, d();
        }, o.onload = async () => {
          const m = r.svgUrl = o.result;
          l.src = await s ? `${m}#svgView(preserveAspectRatio(none))` : m;
        }, l.onerror = o.onerror = f;
      });
      o.readAsDataURL(i), await u;
    } else
      r.bitmap = await createImageBitmap(i);
    r.refCounter = 1;
  } catch (i) {
    console.error(i), r = null;
  }
  return _(this, Xc).set(t, r), r && _(this, Xc).set(r.id, r), r;
};
let f$ = nB;
var Xs, Vg, i_, qs;
class PDe {
  constructor(t = 128) {
    J(this, Xs, []);
    J(this, Vg, !1);
    J(this, i_);
    J(this, qs, -1);
    q(this, i_, t);
  }
  add({
    cmd: t,
    undo: e,
    post: r,
    mustExec: i,
    type: s = NaN,
    overwriteIfSameType: o = !1,
    keepUndo: l = !1
  }) {
    if (i && t(), _(this, Vg))
      return;
    const u = {
      cmd: t,
      undo: e,
      post: r,
      type: s
    };
    if (_(this, qs) === -1) {
      _(this, Xs).length > 0 && (_(this, Xs).length = 0), q(this, qs, 0), _(this, Xs).push(u);
      return;
    }
    if (o && _(this, Xs)[_(this, qs)].type === s) {
      l && (u.undo = _(this, Xs)[_(this, qs)].undo), _(this, Xs)[_(this, qs)] = u;
      return;
    }
    const d = _(this, qs) + 1;
    d === _(this, i_) ? _(this, Xs).splice(0, 1) : (q(this, qs, d), d < _(this, Xs).length && _(this, Xs).splice(d)), _(this, Xs).push(u);
  }
  undo() {
    if (_(this, qs) === -1)
      return;
    q(this, Vg, !0);
    const {
      undo: t,
      post: e
    } = _(this, Xs)[_(this, qs)];
    t(), e == null || e(), q(this, Vg, !1), q(this, qs, _(this, qs) - 1);
  }
  redo() {
    if (_(this, qs) < _(this, Xs).length - 1) {
      q(this, qs, _(this, qs) + 1), q(this, Vg, !0);
      const {
        cmd: t,
        post: e
      } = _(this, Xs)[_(this, qs)];
      t(), e == null || e(), q(this, Vg, !1);
    }
  }
  hasSomethingToUndo() {
    return _(this, qs) !== -1;
  }
  hasSomethingToRedo() {
    return _(this, qs) < _(this, Xs).length - 1;
  }
  destroy() {
    q(this, Xs, null);
  }
}
Xs = new WeakMap(), Vg = new WeakMap(), i_ = new WeakMap(), qs = new WeakMap();
var i2, ree;
class iP {
  constructor(t) {
    J(this, i2);
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: e
    } = jl.platform;
    for (const [r, i, s = {}] of t)
      for (const o of r) {
        const l = o.startsWith("mac+");
        e && l ? (this.callbacks.set(o.slice(4), {
          callback: i,
          options: s
        }), this.allKeys.add(o.split("+").at(-1))) : !e && !l && (this.callbacks.set(o, {
          callback: i,
          options: s
        }), this.allKeys.add(o.split("+").at(-1)));
      }
  }
  exec(t, e) {
    if (!this.allKeys.has(e.key))
      return;
    const r = this.callbacks.get(Q(this, i2, ree).call(this, e));
    if (!r)
      return;
    const {
      callback: i,
      options: {
        bubbles: s = !1,
        args: o = [],
        checker: l = null
      }
    } = r;
    l && !l(t, e) || (i.bind(t, ...o, e)(), s || (e.stopPropagation(), e.preventDefault()));
  }
}
i2 = new WeakSet(), ree = function(t) {
  t.altKey && this.buffer.push("alt"), t.ctrlKey && this.buffer.push("ctrl"), t.metaKey && this.buffer.push("meta"), t.shiftKey && this.buffer.push("shift"), this.buffer.push(t.key);
  const e = this.buffer.join("+");
  return this.buffer.length = 0, e;
};
const s2 = class s2 {
  get _colors() {
    const t = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return CDe(t), lr(this, "_colors", t);
  }
  convert(t) {
    const e = qU(t);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return e;
    for (const [r, i] of this._colors)
      if (i.every((s, o) => s === e[o]))
        return s2._colorsMapping.get(r);
    return e;
  }
  getHexCode(t) {
    const e = this._colors.get(t);
    return e ? Ft.makeHexColor(...e) : t;
  }
};
T(s2, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
let g$ = s2;
var ex, oc, Ls, Co, tx, Nf, nx, Hu, rx, oy, Qd, Vu, ay, s_, o_, Jd, ix, Wg, eh, o2, Gg, a_, ly, l_, sx, Eo, Tr, Ff, cy, c_, u_, d_, h_, f_, p_, g_, m_, v_, y_, S_, b_, x_, Kg, th, $f, w_, ct, DR, iee, see, OR, oee, aee, lee, m$, cee, v$, y$, uee, ja, $g, dee, hee, S$, fee, p1, b$;
const H0 = class H0 {
  constructor(t, e, r, i, s, o, l, u, d) {
    J(this, ct);
    J(this, ex, new AbortController());
    J(this, oc, null);
    J(this, Ls, /* @__PURE__ */ new Map());
    J(this, Co, /* @__PURE__ */ new Map());
    J(this, tx, null);
    J(this, Nf, null);
    J(this, nx, null);
    J(this, Hu, new PDe());
    J(this, rx, 0);
    J(this, oy, /* @__PURE__ */ new Set());
    J(this, Qd, null);
    J(this, Vu, null);
    J(this, ay, /* @__PURE__ */ new Set());
    J(this, s_, !1);
    J(this, o_, null);
    J(this, Jd, null);
    J(this, ix, null);
    J(this, Wg, !1);
    J(this, eh, null);
    J(this, o2, new TDe());
    J(this, Gg, !1);
    J(this, a_, !1);
    J(this, ly, null);
    J(this, l_, null);
    J(this, sx, null);
    J(this, Eo, ir.NONE);
    J(this, Tr, /* @__PURE__ */ new Set());
    J(this, Ff, null);
    J(this, cy, null);
    J(this, c_, null);
    J(this, u_, this.blur.bind(this));
    J(this, d_, this.focus.bind(this));
    J(this, h_, this.copy.bind(this));
    J(this, f_, this.cut.bind(this));
    J(this, p_, this.paste.bind(this));
    J(this, g_, this.keydown.bind(this));
    J(this, m_, this.keyup.bind(this));
    J(this, v_, this.onEditingAction.bind(this));
    J(this, y_, this.onPageChanging.bind(this));
    J(this, S_, this.onScaleChanging.bind(this));
    J(this, b_, this.onRotationChanging.bind(this));
    J(this, x_, {
      isEditing: !1,
      isEmpty: !0,
      hasSomethingToUndo: !1,
      hasSomethingToRedo: !1,
      hasSelectedEditor: !1,
      hasSelectedText: !1
    });
    J(this, Kg, [0, 0]);
    J(this, th, null);
    J(this, $f, null);
    J(this, w_, null);
    this._signal = _(this, ex).signal, q(this, $f, t), q(this, w_, e), q(this, tx, r), this._eventBus = i, this._eventBus._on("editingaction", _(this, v_)), this._eventBus._on("pagechanging", _(this, y_)), this._eventBus._on("scalechanging", _(this, S_)), this._eventBus._on("rotationchanging", _(this, b_)), Q(this, ct, oee).call(this), Q(this, ct, uee).call(this), Q(this, ct, m$).call(this), q(this, Nf, s.annotationStorage), q(this, o_, s.filterFactory), q(this, cy, o), q(this, ix, l || null), q(this, s_, u), q(this, sx, d || null), this.viewParameters = {
      realScale: Tm.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1;
  }
  static get _keyboardManager() {
    const t = H0.prototype, e = (o) => _(o, $f).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && o.hasSomethingToControl(), r = (o, {
      target: l
    }) => {
      if (l instanceof HTMLInputElement) {
        const {
          type: u
        } = l;
        return u !== "text" && u !== "number";
      }
      return !0;
    }, i = this.TRANSLATE_SMALL, s = this.TRANSLATE_BIG;
    return lr(this, "_keyboardManager", new iP([[["ctrl+a", "mac+meta+a"], t.selectAll, {
      checker: r
    }], [["ctrl+z", "mac+meta+z"], t.undo, {
      checker: r
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], t.redo, {
      checker: r
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], t.delete, {
      checker: r
    }], [["Enter", "mac+Enter"], t.addNewEditorFromKeyboard, {
      checker: (o, {
        target: l
      }) => !(l instanceof HTMLButtonElement) && _(o, $f).contains(l) && !o.isEnterHandled
    }], [[" ", "mac+ "], t.addNewEditorFromKeyboard, {
      checker: (o, {
        target: l
      }) => !(l instanceof HTMLButtonElement) && _(o, $f).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], t.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], t.translateSelectedEditors, {
      args: [-i, 0],
      checker: e
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t.translateSelectedEditors, {
      args: [-s, 0],
      checker: e
    }], [["ArrowRight", "mac+ArrowRight"], t.translateSelectedEditors, {
      args: [i, 0],
      checker: e
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t.translateSelectedEditors, {
      args: [s, 0],
      checker: e
    }], [["ArrowUp", "mac+ArrowUp"], t.translateSelectedEditors, {
      args: [0, -i],
      checker: e
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t.translateSelectedEditors, {
      args: [0, -s],
      checker: e
    }], [["ArrowDown", "mac+ArrowDown"], t.translateSelectedEditors, {
      args: [0, i],
      checker: e
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t.translateSelectedEditors, {
      args: [0, s],
      checker: e
    }]]));
  }
  destroy() {
    var t, e, r;
    (t = _(this, ex)) == null || t.abort(), q(this, ex, null), this._signal = null, this._eventBus._off("editingaction", _(this, v_)), this._eventBus._off("pagechanging", _(this, y_)), this._eventBus._off("scalechanging", _(this, S_)), this._eventBus._off("rotationchanging", _(this, b_));
    for (const i of _(this, Co).values())
      i.destroy();
    _(this, Co).clear(), _(this, Ls).clear(), _(this, ay).clear(), q(this, oc, null), _(this, Tr).clear(), _(this, Hu).destroy(), (e = _(this, tx)) == null || e.destroy(), (r = _(this, eh)) == null || r.hide(), q(this, eh, null), _(this, Jd) && (clearTimeout(_(this, Jd)), q(this, Jd, null)), _(this, th) && (clearTimeout(_(this, th)), q(this, th, null));
  }
  async mlGuess(t) {
    var e;
    return ((e = _(this, sx)) == null ? void 0 : e.guess(t)) || null;
  }
  get hasMLManager() {
    return !!_(this, sx);
  }
  get hcmFilter() {
    return lr(this, "hcmFilter", _(this, cy) ? _(this, o_).addHCMFilter(_(this, cy).foreground, _(this, cy).background) : "none");
  }
  get direction() {
    return lr(this, "direction", getComputedStyle(_(this, $f)).direction);
  }
  get highlightColors() {
    return lr(this, "highlightColors", _(this, ix) ? new Map(_(this, ix).split(",").map((t) => t.split("=").map((e) => e.trim()))) : null);
  }
  get highlightColorNames() {
    return lr(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (t) => t.reverse())) : null);
  }
  setMainHighlightColorPicker(t) {
    q(this, l_, t);
  }
  editAltText(t) {
    var e;
    (e = _(this, tx)) == null || e.editAltText(this, t);
  }
  onPageChanging({
    pageNumber: t
  }) {
    q(this, rx, t - 1);
  }
  focusMainContainer() {
    _(this, $f).focus();
  }
  findParent(t, e) {
    for (const r of _(this, Co).values()) {
      const {
        x: i,
        y: s,
        width: o,
        height: l
      } = r.div.getBoundingClientRect();
      if (t >= i && t <= i + o && e >= s && e <= s + l)
        return r;
    }
    return null;
  }
  disableUserSelect(t = !1) {
    _(this, w_).classList.toggle("noUserSelect", t);
  }
  addShouldRescale(t) {
    _(this, ay).add(t);
  }
  removeShouldRescale(t) {
    _(this, ay).delete(t);
  }
  onScaleChanging({
    scale: t
  }) {
    this.commitOrRemove(), this.viewParameters.realScale = t * Tm.PDF_TO_CSS_UNITS;
    for (const e of _(this, ay))
      e.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: t
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = t;
  }
  highlightSelection(t = "") {
    const e = document.getSelection();
    if (!e || e.isCollapsed)
      return;
    const {
      anchorNode: r,
      anchorOffset: i,
      focusNode: s,
      focusOffset: o
    } = e, l = e.toString(), d = Q(this, ct, DR).call(this, e).closest(".textLayer"), f = this.getSelectionBoxes(d);
    if (f) {
      e.empty(), _(this, Eo) === ir.NONE && (this._eventBus.dispatch("showannotationeditorui", {
        source: this,
        mode: ir.HIGHLIGHT
      }), this.showAllEditors("highlight", !0, !0));
      for (const m of _(this, Co).values())
        if (m.hasTextLayer(d)) {
          m.createAndAddNewEditor({
            x: 0,
            y: 0
          }, !1, {
            methodOfCreation: t,
            boxes: f,
            anchorNode: r,
            anchorOffset: i,
            focusNode: s,
            focusOffset: o,
            text: l
          });
          break;
        }
    }
  }
  addToAnnotationStorage(t) {
    !t.isEmpty() && _(this, Nf) && !_(this, Nf).has(t.id) && _(this, Nf).setValue(t.id, t);
  }
  blur() {
    if (this.isShiftKeyDown = !1, _(this, Wg) && (q(this, Wg, !1), Q(this, ct, OR).call(this, "main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: t
    } = document;
    for (const e of _(this, Tr))
      if (e.div.contains(t)) {
        q(this, ly, [e, t]), e._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!_(this, ly))
      return;
    const [t, e] = _(this, ly);
    q(this, ly, null), e.addEventListener("focusin", () => {
      t._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), e.focus();
  }
  addEditListeners() {
    Q(this, ct, m$).call(this), Q(this, ct, v$).call(this);
  }
  removeEditListeners() {
    Q(this, ct, cee).call(this), Q(this, ct, y$).call(this);
  }
  dragOver(t) {
    for (const {
      type: e
    } of t.dataTransfer.items)
      for (const r of _(this, Vu))
        if (r.isHandlingMimeForPasting(e)) {
          t.dataTransfer.dropEffect = "copy", t.preventDefault();
          return;
        }
  }
  drop(t) {
    for (const e of t.dataTransfer.items)
      for (const r of _(this, Vu))
        if (r.isHandlingMimeForPasting(e.type)) {
          r.paste(e, this.currentLayer), t.preventDefault();
          return;
        }
  }
  copy(t) {
    var r;
    if (t.preventDefault(), (r = _(this, oc)) == null || r.commitOrRemove(), !this.hasSelection)
      return;
    const e = [];
    for (const i of _(this, Tr)) {
      const s = i.serialize(!0);
      s && e.push(s);
    }
    e.length !== 0 && t.clipboardData.setData("application/pdfjs", JSON.stringify(e));
  }
  cut(t) {
    this.copy(t), this.delete();
  }
  paste(t) {
    t.preventDefault();
    const {
      clipboardData: e
    } = t;
    for (const s of e.items)
      for (const o of _(this, Vu))
        if (o.isHandlingMimeForPasting(s.type)) {
          o.paste(s, this.currentLayer);
          return;
        }
    let r = e.getData("application/pdfjs");
    if (!r)
      return;
    try {
      r = JSON.parse(r);
    } catch (s) {
      In(`paste: "${s.message}".`);
      return;
    }
    if (!Array.isArray(r))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const s = [];
      for (const u of r) {
        const d = i.deserialize(u);
        if (!d)
          return;
        s.push(d);
      }
      const o = () => {
        for (const u of s)
          Q(this, ct, S$).call(this, u);
        Q(this, ct, b$).call(this, s);
      }, l = () => {
        for (const u of s)
          u.remove();
      };
      this.addCommands({
        cmd: o,
        undo: l,
        mustExec: !0
      });
    } catch (s) {
      In(`paste: "${s.message}".`);
    }
  }
  keydown(t) {
    !this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !0), _(this, Eo) !== ir.NONE && !this.isEditorHandlingKeyboard && H0._keyboardManager.exec(this, t);
  }
  keyup(t) {
    this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !1, _(this, Wg) && (q(this, Wg, !1), Q(this, ct, OR).call(this, "main_toolbar")));
  }
  onEditingAction({
    name: t
  }) {
    switch (t) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[t]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  setEditingState(t) {
    t ? (Q(this, ct, aee).call(this), Q(this, ct, v$).call(this), Q(this, ct, ja).call(this, {
      isEditing: _(this, Eo) !== ir.NONE,
      isEmpty: Q(this, ct, p1).call(this),
      hasSomethingToUndo: _(this, Hu).hasSomethingToUndo(),
      hasSomethingToRedo: _(this, Hu).hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (Q(this, ct, lee).call(this), Q(this, ct, y$).call(this), Q(this, ct, ja).call(this, {
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(t) {
    if (!_(this, Vu)) {
      q(this, Vu, t);
      for (const e of _(this, Vu))
        Q(this, ct, $g).call(this, e.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return _(this, o2).id;
  }
  get currentLayer() {
    return _(this, Co).get(_(this, rx));
  }
  getLayer(t) {
    return _(this, Co).get(t);
  }
  get currentPageIndex() {
    return _(this, rx);
  }
  addLayer(t) {
    _(this, Co).set(t.pageIndex, t), _(this, Gg) ? t.enable() : t.disable();
  }
  removeLayer(t) {
    _(this, Co).delete(t.pageIndex);
  }
  updateMode(t, e = null, r = !1) {
    if (_(this, Eo) !== t) {
      if (q(this, Eo, t), t === ir.NONE) {
        this.setEditingState(!1), Q(this, ct, hee).call(this);
        return;
      }
      this.setEditingState(!0), Q(this, ct, dee).call(this), this.unselectAll();
      for (const i of _(this, Co).values())
        i.updateMode(t);
      if (!e && r) {
        this.addNewEditorFromKeyboard();
        return;
      }
      if (e) {
        for (const i of _(this, Ls).values())
          if (i.annotationElementId === e) {
            this.setSelected(i), i.enterInEditMode();
            break;
          }
      }
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(t) {
    t !== _(this, Eo) && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode: t
    });
  }
  updateParams(t, e) {
    var r;
    if (_(this, Vu)) {
      switch (t) {
        case gn.CREATE:
          this.currentLayer.addNewEditor();
          return;
        case gn.HIGHLIGHT_DEFAULT_COLOR:
          (r = _(this, l_)) == null || r.updateColor(e);
          break;
        case gn.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (_(this, c_) || q(this, c_, /* @__PURE__ */ new Map())).set(t, e), this.showAllEditors("highlight", e);
          break;
      }
      for (const i of _(this, Tr))
        i.updateParams(t, e);
      for (const i of _(this, Vu))
        i.updateDefaultParams(t, e);
    }
  }
  showAllEditors(t, e, r = !1) {
    var s;
    for (const o of _(this, Ls).values())
      o.editorType === t && o.show(e);
    (((s = _(this, c_)) == null ? void 0 : s.get(gn.HIGHLIGHT_SHOW_ALL)) ?? !0) !== e && Q(this, ct, $g).call(this, [[gn.HIGHLIGHT_SHOW_ALL, e]]);
  }
  enableWaiting(t = !1) {
    if (_(this, a_) !== t) {
      q(this, a_, t);
      for (const e of _(this, Co).values())
        t ? e.disableClick() : e.enableClick(), e.div.classList.toggle("waiting", t);
    }
  }
  getEditors(t) {
    const e = [];
    for (const r of _(this, Ls).values())
      r.pageIndex === t && e.push(r);
    return e;
  }
  getEditor(t) {
    return _(this, Ls).get(t);
  }
  addEditor(t) {
    _(this, Ls).set(t.id, t);
  }
  removeEditor(t) {
    var e;
    t.div.contains(document.activeElement) && (_(this, Jd) && clearTimeout(_(this, Jd)), q(this, Jd, setTimeout(() => {
      this.focusMainContainer(), q(this, Jd, null);
    }, 0))), _(this, Ls).delete(t.id), this.unselect(t), (!t.annotationElementId || !_(this, oy).has(t.annotationElementId)) && ((e = _(this, Nf)) == null || e.remove(t.id));
  }
  addDeletedAnnotationElement(t) {
    _(this, oy).add(t.annotationElementId), this.addChangedExistingAnnotation(t), t.deleted = !0;
  }
  isDeletedAnnotationElement(t) {
    return _(this, oy).has(t);
  }
  removeDeletedAnnotationElement(t) {
    _(this, oy).delete(t.annotationElementId), this.removeChangedExistingAnnotation(t), t.deleted = !1;
  }
  setActiveEditor(t) {
    _(this, oc) !== t && (q(this, oc, t), t && Q(this, ct, $g).call(this, t.propertiesToUpdate));
  }
  updateUI(t) {
    _(this, ct, fee) === t && Q(this, ct, $g).call(this, t.propertiesToUpdate);
  }
  toggleSelected(t) {
    if (_(this, Tr).has(t)) {
      _(this, Tr).delete(t), t.unselect(), Q(this, ct, ja).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    _(this, Tr).add(t), t.select(), Q(this, ct, $g).call(this, t.propertiesToUpdate), Q(this, ct, ja).call(this, {
      hasSelectedEditor: !0
    });
  }
  setSelected(t) {
    for (const e of _(this, Tr))
      e !== t && e.unselect();
    _(this, Tr).clear(), _(this, Tr).add(t), t.select(), Q(this, ct, $g).call(this, t.propertiesToUpdate), Q(this, ct, ja).call(this, {
      hasSelectedEditor: !0
    });
  }
  isSelected(t) {
    return _(this, Tr).has(t);
  }
  get firstSelectedEditor() {
    return _(this, Tr).values().next().value;
  }
  unselect(t) {
    t.unselect(), _(this, Tr).delete(t), Q(this, ct, ja).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return _(this, Tr).size !== 0;
  }
  get isEnterHandled() {
    return _(this, Tr).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    _(this, Hu).undo(), Q(this, ct, ja).call(this, {
      hasSomethingToUndo: _(this, Hu).hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: Q(this, ct, p1).call(this)
    });
  }
  redo() {
    _(this, Hu).redo(), Q(this, ct, ja).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: _(this, Hu).hasSomethingToRedo(),
      isEmpty: Q(this, ct, p1).call(this)
    });
  }
  addCommands(t) {
    _(this, Hu).add(t), Q(this, ct, ja).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: Q(this, ct, p1).call(this)
    });
  }
  delete() {
    if (this.commitOrRemove(), !this.hasSelection)
      return;
    const t = [..._(this, Tr)], e = () => {
      for (const i of t)
        i.remove();
    }, r = () => {
      for (const i of t)
        Q(this, ct, S$).call(this, i);
    };
    this.addCommands({
      cmd: e,
      undo: r,
      mustExec: !0
    });
  }
  commitOrRemove() {
    var t;
    (t = _(this, oc)) == null || t.commitOrRemove();
  }
  hasSomethingToControl() {
    return _(this, oc) || this.hasSelection;
  }
  selectAll() {
    for (const t of _(this, Tr))
      t.commit();
    Q(this, ct, b$).call(this, _(this, Ls).values());
  }
  unselectAll() {
    if (!(_(this, oc) && (_(this, oc).commitOrRemove(), _(this, Eo) !== ir.NONE)) && this.hasSelection) {
      for (const t of _(this, Tr))
        t.unselect();
      _(this, Tr).clear(), Q(this, ct, ja).call(this, {
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(t, e, r = !1) {
    if (r || this.commitOrRemove(), !this.hasSelection)
      return;
    _(this, Kg)[0] += t, _(this, Kg)[1] += e;
    const [i, s] = _(this, Kg), o = [..._(this, Tr)], l = 1e3;
    _(this, th) && clearTimeout(_(this, th)), q(this, th, setTimeout(() => {
      q(this, th, null), _(this, Kg)[0] = _(this, Kg)[1] = 0, this.addCommands({
        cmd: () => {
          for (const u of o)
            _(this, Ls).has(u.id) && u.translateInPage(i, s);
        },
        undo: () => {
          for (const u of o)
            _(this, Ls).has(u.id) && u.translateInPage(-i, -s);
        },
        mustExec: !1
      });
    }, l));
    for (const u of o)
      u.translateInPage(t, e);
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), q(this, Qd, /* @__PURE__ */ new Map());
      for (const t of _(this, Tr))
        _(this, Qd).set(t, {
          savedX: t.x,
          savedY: t.y,
          savedPageIndex: t.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!_(this, Qd))
      return !1;
    this.disableUserSelect(!1);
    const t = _(this, Qd);
    q(this, Qd, null);
    let e = !1;
    for (const [{
      x: i,
      y: s,
      pageIndex: o
    }, l] of t)
      l.newX = i, l.newY = s, l.newPageIndex = o, e || (e = i !== l.savedX || s !== l.savedY || o !== l.savedPageIndex);
    if (!e)
      return !1;
    const r = (i, s, o, l) => {
      if (_(this, Ls).has(i.id)) {
        const u = _(this, Co).get(l);
        u ? i._setParentAndPosition(u, s, o) : (i.pageIndex = l, i.x = s, i.y = o);
      }
    };
    return this.addCommands({
      cmd: () => {
        for (const [i, {
          newX: s,
          newY: o,
          newPageIndex: l
        }] of t)
          r(i, s, o, l);
      },
      undo: () => {
        for (const [i, {
          savedX: s,
          savedY: o,
          savedPageIndex: l
        }] of t)
          r(i, s, o, l);
      },
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(t, e) {
    if (_(this, Qd))
      for (const r of _(this, Qd).keys())
        r.drag(t, e);
  }
  rebuild(t) {
    if (t.parent === null) {
      const e = this.getLayer(t.pageIndex);
      e ? (e.changeParent(t), e.addOrRebuild(t)) : (this.addEditor(t), this.addToAnnotationStorage(t), t.rebuild());
    } else
      t.parent.addOrRebuild(t);
  }
  get isEditorHandlingKeyboard() {
    var t;
    return ((t = this.getActive()) == null ? void 0 : t.shouldGetKeyboardEvents()) || _(this, Tr).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(t) {
    return _(this, oc) === t;
  }
  getActive() {
    return _(this, oc);
  }
  getMode() {
    return _(this, Eo);
  }
  get imageManager() {
    return lr(this, "imageManager", new f$());
  }
  getSelectionBoxes(t) {
    if (!t)
      return null;
    const e = document.getSelection();
    for (let d = 0, f = e.rangeCount; d < f; d++)
      if (!t.contains(e.getRangeAt(d).commonAncestorContainer))
        return null;
    const {
      x: r,
      y: i,
      width: s,
      height: o
    } = t.getBoundingClientRect();
    let l;
    switch (t.getAttribute("data-main-rotation")) {
      case "90":
        l = (d, f, m, v) => ({
          x: (f - i) / o,
          y: 1 - (d + m - r) / s,
          width: v / o,
          height: m / s
        });
        break;
      case "180":
        l = (d, f, m, v) => ({
          x: 1 - (d + m - r) / s,
          y: 1 - (f + v - i) / o,
          width: m / s,
          height: v / o
        });
        break;
      case "270":
        l = (d, f, m, v) => ({
          x: 1 - (f + v - i) / o,
          y: (d - r) / s,
          width: v / o,
          height: m / s
        });
        break;
      default:
        l = (d, f, m, v) => ({
          x: (d - r) / s,
          y: (f - i) / o,
          width: m / s,
          height: v / o
        });
        break;
    }
    const u = [];
    for (let d = 0, f = e.rangeCount; d < f; d++) {
      const m = e.getRangeAt(d);
      if (!m.collapsed)
        for (const {
          x: v,
          y: S,
          width: w,
          height: E
        } of m.getClientRects())
          w === 0 || E === 0 || u.push(l(v, S, w, E));
    }
    return u.length === 0 ? null : u;
  }
  addChangedExistingAnnotation({
    annotationElementId: t,
    id: e
  }) {
    (_(this, nx) || q(this, nx, /* @__PURE__ */ new Map())).set(t, e);
  }
  removeChangedExistingAnnotation({
    annotationElementId: t
  }) {
    var e;
    (e = _(this, nx)) == null || e.delete(t);
  }
  renderAnnotationElement(t) {
    var i;
    const e = (i = _(this, nx)) == null ? void 0 : i.get(t.data.id);
    if (!e)
      return;
    const r = _(this, Nf).getRawValue(e);
    r && (_(this, Eo) === ir.NONE && !r.hasBeenModified || r.renderAnnotationElement(t));
  }
};
ex = new WeakMap(), oc = new WeakMap(), Ls = new WeakMap(), Co = new WeakMap(), tx = new WeakMap(), Nf = new WeakMap(), nx = new WeakMap(), Hu = new WeakMap(), rx = new WeakMap(), oy = new WeakMap(), Qd = new WeakMap(), Vu = new WeakMap(), ay = new WeakMap(), s_ = new WeakMap(), o_ = new WeakMap(), Jd = new WeakMap(), ix = new WeakMap(), Wg = new WeakMap(), eh = new WeakMap(), o2 = new WeakMap(), Gg = new WeakMap(), a_ = new WeakMap(), ly = new WeakMap(), l_ = new WeakMap(), sx = new WeakMap(), Eo = new WeakMap(), Tr = new WeakMap(), Ff = new WeakMap(), cy = new WeakMap(), c_ = new WeakMap(), u_ = new WeakMap(), d_ = new WeakMap(), h_ = new WeakMap(), f_ = new WeakMap(), p_ = new WeakMap(), g_ = new WeakMap(), m_ = new WeakMap(), v_ = new WeakMap(), y_ = new WeakMap(), S_ = new WeakMap(), b_ = new WeakMap(), x_ = new WeakMap(), Kg = new WeakMap(), th = new WeakMap(), $f = new WeakMap(), w_ = new WeakMap(), ct = new WeakSet(), DR = function({
  anchorNode: t
}) {
  return t.nodeType === Node.TEXT_NODE ? t.parentElement : t;
}, iee = function() {
  const t = document.getSelection();
  if (!t || t.isCollapsed)
    return;
  const r = Q(this, ct, DR).call(this, t).closest(".textLayer"), i = this.getSelectionBoxes(r);
  i && (_(this, eh) || q(this, eh, new EDe(this)), _(this, eh).show(r, i, this.direction === "ltr"));
}, see = function() {
  var s, o, l;
  const t = document.getSelection();
  if (!t || t.isCollapsed) {
    _(this, Ff) && ((s = _(this, eh)) == null || s.hide(), q(this, Ff, null), Q(this, ct, ja).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  const {
    anchorNode: e
  } = t;
  if (e === _(this, Ff))
    return;
  if (!Q(this, ct, DR).call(this, t).closest(".textLayer")) {
    _(this, Ff) && ((o = _(this, eh)) == null || o.hide(), q(this, Ff, null), Q(this, ct, ja).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  if ((l = _(this, eh)) == null || l.hide(), q(this, Ff, e), Q(this, ct, ja).call(this, {
    hasSelectedText: !0
  }), !(_(this, Eo) !== ir.HIGHLIGHT && _(this, Eo) !== ir.NONE) && (_(this, Eo) === ir.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), q(this, Wg, this.isShiftKeyDown), !this.isShiftKeyDown)) {
    const u = this._signal, d = (f) => {
      f.type === "pointerup" && f.button !== 0 || (window.removeEventListener("pointerup", d), window.removeEventListener("blur", d), f.type === "pointerup" && Q(this, ct, OR).call(this, "main_toolbar"));
    };
    window.addEventListener("pointerup", d, {
      signal: u
    }), window.addEventListener("blur", d, {
      signal: u
    });
  }
}, OR = function(t = "") {
  _(this, Eo) === ir.HIGHLIGHT ? this.highlightSelection(t) : _(this, s_) && Q(this, ct, iee).call(this);
}, oee = function() {
  document.addEventListener("selectionchange", Q(this, ct, see).bind(this), {
    signal: this._signal
  });
}, aee = function() {
  const t = this._signal;
  window.addEventListener("focus", _(this, d_), {
    signal: t
  }), window.addEventListener("blur", _(this, u_), {
    signal: t
  });
}, lee = function() {
  window.removeEventListener("focus", _(this, d_)), window.removeEventListener("blur", _(this, u_));
}, m$ = function() {
  const t = this._signal;
  window.addEventListener("keydown", _(this, g_), {
    signal: t
  }), window.addEventListener("keyup", _(this, m_), {
    signal: t
  });
}, cee = function() {
  window.removeEventListener("keydown", _(this, g_)), window.removeEventListener("keyup", _(this, m_));
}, v$ = function() {
  const t = this._signal;
  document.addEventListener("copy", _(this, h_), {
    signal: t
  }), document.addEventListener("cut", _(this, f_), {
    signal: t
  }), document.addEventListener("paste", _(this, p_), {
    signal: t
  });
}, y$ = function() {
  document.removeEventListener("copy", _(this, h_)), document.removeEventListener("cut", _(this, f_)), document.removeEventListener("paste", _(this, p_));
}, uee = function() {
  const t = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal: t
  }), document.addEventListener("drop", this.drop.bind(this), {
    signal: t
  });
}, ja = function(t) {
  Object.entries(t).some(([r, i]) => _(this, x_)[r] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
    source: this,
    details: Object.assign(_(this, x_), t)
  }), _(this, Eo) === ir.HIGHLIGHT && t.hasSelectedEditor === !1 && Q(this, ct, $g).call(this, [[gn.HIGHLIGHT_FREE, !0]]));
}, $g = function(t) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details: t
  });
}, dee = function() {
  if (!_(this, Gg)) {
    q(this, Gg, !0);
    for (const t of _(this, Co).values())
      t.enable();
    for (const t of _(this, Ls).values())
      t.enable();
  }
}, hee = function() {
  if (this.unselectAll(), _(this, Gg)) {
    q(this, Gg, !1);
    for (const t of _(this, Co).values())
      t.disable();
    for (const t of _(this, Ls).values())
      t.disable();
  }
}, S$ = function(t) {
  const e = _(this, Co).get(t.pageIndex);
  e ? e.addOrRebuild(t) : (this.addEditor(t), this.addToAnnotationStorage(t));
}, fee = function() {
  let t = null;
  for (t of _(this, Tr))
    ;
  return t;
}, p1 = function() {
  if (_(this, Ls).size === 0)
    return !0;
  if (_(this, Ls).size === 1)
    for (const t of _(this, Ls).values())
      return t.isEmpty();
  return !1;
}, b$ = function(t) {
  for (const e of _(this, Tr))
    e.unselect();
  _(this, Tr).clear();
  for (const e of t)
    e.isEmpty() || (_(this, Tr).add(e), e.select());
  Q(this, ct, ja).call(this, {
    hasSelectedEditor: this.hasSelection
  });
}, T(H0, "TRANSLATE_SMALL", 1), T(H0, "TRANSLATE_BIG", 10);
let hS = H0;
var zf, Uf, Wu, Bf, ac, ox, Gu, C_, x$;
const Mf = class Mf {
  constructor(t) {
    J(this, C_);
    J(this, zf, "");
    J(this, Uf, !1);
    J(this, Wu, null);
    J(this, Bf, null);
    J(this, ac, null);
    J(this, ox, !1);
    J(this, Gu, null);
    q(this, Gu, t);
  }
  static initialize(t) {
    Mf._l10nPromise || (Mf._l10nPromise = t);
  }
  async render() {
    const t = q(this, Wu, document.createElement("button"));
    t.className = "altText";
    const e = await Mf._l10nPromise.get("pdfjs-editor-alt-text-button-label");
    t.textContent = e, t.setAttribute("aria-label", e), t.tabIndex = "0";
    const r = _(this, Gu)._uiManager._signal;
    t.addEventListener("contextmenu", zl, {
      signal: r
    }), t.addEventListener("pointerdown", (s) => s.stopPropagation(), {
      signal: r
    });
    const i = (s) => {
      s.preventDefault(), _(this, Gu)._uiManager.editAltText(_(this, Gu));
    };
    return t.addEventListener("click", i, {
      capture: !0,
      signal: r
    }), t.addEventListener("keydown", (s) => {
      s.target === t && s.key === "Enter" && (q(this, ox, !0), i(s));
    }, {
      signal: r
    }), await Q(this, C_, x$).call(this), t;
  }
  finish() {
    _(this, Wu) && (_(this, Wu).focus({
      focusVisible: _(this, ox)
    }), q(this, ox, !1));
  }
  isEmpty() {
    return !_(this, zf) && !_(this, Uf);
  }
  get data() {
    return {
      altText: _(this, zf),
      decorative: _(this, Uf)
    };
  }
  set data({
    altText: t,
    decorative: e
  }) {
    _(this, zf) === t && _(this, Uf) === e || (q(this, zf, t), q(this, Uf, e), Q(this, C_, x$).call(this));
  }
  toggle(t = !1) {
    _(this, Wu) && (!t && _(this, ac) && (clearTimeout(_(this, ac)), q(this, ac, null)), _(this, Wu).disabled = !t);
  }
  destroy() {
    var t;
    (t = _(this, Wu)) == null || t.remove(), q(this, Wu, null), q(this, Bf, null);
  }
};
zf = new WeakMap(), Uf = new WeakMap(), Wu = new WeakMap(), Bf = new WeakMap(), ac = new WeakMap(), ox = new WeakMap(), Gu = new WeakMap(), C_ = new WeakSet(), x$ = async function() {
  var i;
  const t = _(this, Wu);
  if (!t)
    return;
  if (!_(this, zf) && !_(this, Uf)) {
    t.classList.remove("done"), (i = _(this, Bf)) == null || i.remove();
    return;
  }
  t.classList.add("done"), Mf._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((s) => {
    t.setAttribute("aria-label", s);
  });
  let e = _(this, Bf);
  if (!e) {
    q(this, Bf, e = document.createElement("span")), e.className = "tooltip", e.setAttribute("role", "tooltip");
    const s = e.id = `alt-text-tooltip-${_(this, Gu).id}`;
    t.setAttribute("aria-describedby", s);
    const o = 100, l = _(this, Gu)._uiManager._signal;
    l.addEventListener("abort", () => {
      clearTimeout(_(this, ac)), q(this, ac, null);
    }, {
      once: !0
    }), t.addEventListener("mouseenter", () => {
      q(this, ac, setTimeout(() => {
        q(this, ac, null), _(this, Bf).classList.add("show"), _(this, Gu)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, o));
    }, {
      signal: l
    }), t.addEventListener("mouseleave", () => {
      var u;
      _(this, ac) && (clearTimeout(_(this, ac)), q(this, ac, null)), (u = _(this, Bf)) == null || u.classList.remove("show");
    }, {
      signal: l
    });
  }
  e.innerText = _(this, Uf) ? await Mf._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : _(this, zf), e.parentNode || t.append(e);
  const r = _(this, Gu).getImageForAltText();
  r == null || r.setAttribute("aria-describedby", e.id);
}, T(Mf, "_l10nPromise", null);
let KM = Mf;
var uy, Ku, la, ax, dy, _o, hy, lx, cx, ca, E_, fy, Yg, __, py, Hf, nh, ux, dx, qc, T_, a2, $n, w$, P_, C$, E$, pee, gee, _$, T$, P$, mee, vee, yee, See, A$, g1;
const Hr = class Hr {
  constructor(t) {
    J(this, $n);
    J(this, uy, null);
    J(this, Ku, null);
    J(this, la, null);
    J(this, ax, !1);
    J(this, dy, !1);
    J(this, _o, null);
    J(this, hy, null);
    J(this, lx, this.focusin.bind(this));
    J(this, cx, this.focusout.bind(this));
    J(this, ca, null);
    J(this, E_, "");
    J(this, fy, !1);
    J(this, Yg, null);
    J(this, __, !1);
    J(this, py, !1);
    J(this, Hf, !1);
    J(this, nh, null);
    J(this, ux, 0);
    J(this, dx, 0);
    J(this, qc, null);
    T(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    T(this, "_isVisible", !0);
    T(this, "_uiManager", null);
    T(this, "_focusEventsAllowed", !0);
    T(this, "_l10nPromise", null);
    J(this, T_, !1);
    J(this, a2, Hr._zIndex++);
    this.constructor === Hr && Lr("Cannot initialize AnnotationEditor."), this.parent = t.parent, this.id = t.id, this.width = this.height = null, this.pageIndex = t.parent.pageIndex, this.name = t.name, this.div = null, this._uiManager = t.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = t.isCentered, this._structTreeParentId = null;
    const {
      rotation: e,
      rawDims: {
        pageWidth: r,
        pageHeight: i,
        pageX: s,
        pageY: o
      }
    } = this.parent.viewport;
    this.rotation = e, this.pageRotation = (360 + e - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [r, i], this.pageTranslation = [s, o];
    const [l, u] = this.parentDimensions;
    this.x = t.x / l, this.y = t.y / u, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  static get _resizerKeyboardManager() {
    const t = Hr.prototype._resizeWithKeyboard, e = hS.TRANSLATE_SMALL, r = hS.TRANSLATE_BIG;
    return lr(this, "_resizerKeyboardManager", new iP([[["ArrowLeft", "mac+ArrowLeft"], t, {
      args: [-e, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t, {
      args: [-r, 0]
    }], [["ArrowRight", "mac+ArrowRight"], t, {
      args: [e, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t, {
      args: [r, 0]
    }], [["ArrowUp", "mac+ArrowUp"], t, {
      args: [0, -e]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t, {
      args: [0, -r]
    }], [["ArrowDown", "mac+ArrowDown"], t, {
      args: [0, e]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t, {
      args: [0, r]
    }], [["Escape", "mac+Escape"], Hr.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return lr(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(t) {
    const e = new ADe({
      id: t.parent.getNextId(),
      parent: t.parent,
      uiManager: t._uiManager
    });
    e.annotationElementId = t.annotationElementId, e.deleted = !0, e._uiManager.addToAnnotationStorage(e);
  }
  static initialize(t, e, r) {
    if (Hr._l10nPromise || (Hr._l10nPromise = new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((s) => [s, t.get(s.replaceAll(/([A-Z])/g, (o) => `-${o.toLowerCase()}`))]))), r != null && r.strings)
      for (const s of r.strings)
        Hr._l10nPromise.set(s, t.get(s));
    if (Hr._borderLineWidth !== -1)
      return;
    const i = getComputedStyle(document.documentElement);
    Hr._borderLineWidth = parseFloat(i.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(t, e) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(t) {
    return !1;
  }
  static paste(t, e) {
    Lr("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return _(this, T_);
  }
  set _isDraggable(t) {
    var e;
    q(this, T_, t), (e = this.div) == null || e.classList.toggle("draggable", t);
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [t, e] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * e / (t * 2), this.y += this.width * t / (e * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * e / (t * 2), this.y -= this.width * t / (e * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(t) {
    this._uiManager.addCommands(t);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = _(this, a2);
  }
  setParent(t) {
    t !== null ? (this.pageIndex = t.pageIndex, this.pageDimensions = t.pageDimensions) : Q(this, $n, g1).call(this), this.parent = t;
  }
  focusin(t) {
    this._focusEventsAllowed && (_(this, fy) ? q(this, fy, !1) : this.parent.setSelected(this));
  }
  focusout(t) {
    var r;
    if (!this._focusEventsAllowed || !this.isAttachedToDOM)
      return;
    const e = t.relatedTarget;
    e != null && e.closest(`#${this.id}`) || (t.preventDefault(), (r = this.parent) != null && r.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(t, e, r, i) {
    const [s, o] = this.parentDimensions;
    [r, i] = this.screenToPageTranslation(r, i), this.x = (t + r) / s, this.y = (e + i) / o, this.fixAndSetPosition();
  }
  translate(t, e) {
    Q(this, $n, w$).call(this, this.parentDimensions, t, e);
  }
  translateInPage(t, e) {
    _(this, Yg) || q(this, Yg, [this.x, this.y]), Q(this, $n, w$).call(this, this.pageDimensions, t, e), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(t, e) {
    _(this, Yg) || q(this, Yg, [this.x, this.y]);
    const [r, i] = this.parentDimensions;
    if (this.x += t / r, this.y += e / i, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: d,
        y: f
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, d, f) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: s,
      y: o
    } = this;
    const [l, u] = this.getBaseTranslation();
    s += l, o += u, this.div.style.left = `${(100 * s).toFixed(2)}%`, this.div.style.top = `${(100 * o).toFixed(2)}%`, this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!_(this, Yg) && (_(this, Yg)[0] !== this.x || _(this, Yg)[1] !== this.y);
  }
  getBaseTranslation() {
    const [t, e] = this.parentDimensions, {
      _borderLineWidth: r
    } = Hr, i = r / t, s = r / e;
    switch (this.rotation) {
      case 90:
        return [-i, s];
      case 180:
        return [i, s];
      case 270:
        return [i, -s];
      default:
        return [-i, -s];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(t = this.rotation) {
    const [e, r] = this.pageDimensions;
    let {
      x: i,
      y: s,
      width: o,
      height: l
    } = this;
    if (o *= e, l *= r, i *= e, s *= r, this._mustFixPosition)
      switch (t) {
        case 0:
          i = Math.max(0, Math.min(e - o, i)), s = Math.max(0, Math.min(r - l, s));
          break;
        case 90:
          i = Math.max(0, Math.min(e - l, i)), s = Math.min(r, Math.max(o, s));
          break;
        case 180:
          i = Math.min(e, Math.max(o, i)), s = Math.min(r, Math.max(l, s));
          break;
        case 270:
          i = Math.min(e, Math.max(l, i)), s = Math.max(0, Math.min(r - o, s));
          break;
      }
    this.x = i /= e, this.y = s /= r;
    const [u, d] = this.getBaseTranslation();
    i += u, s += d;
    const {
      style: f
    } = this.div;
    f.left = `${(100 * i).toFixed(2)}%`, f.top = `${(100 * s).toFixed(2)}%`, this.moveInDOM();
  }
  screenToPageTranslation(t, e) {
    var r;
    return Q(r = Hr, P_, C$).call(r, t, e, this.parentRotation);
  }
  pageTranslationToScreen(t, e) {
    var r;
    return Q(r = Hr, P_, C$).call(r, t, e, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: t,
      pageDimensions: [e, r]
    } = this, i = e * t, s = r * t;
    return jl.isCSSRoundSupported ? [Math.round(i), Math.round(s)] : [i, s];
  }
  setDims(t, e) {
    const [r, i] = this.parentDimensions;
    this.div.style.width = `${(100 * t / r).toFixed(2)}%`, _(this, dy) || (this.div.style.height = `${(100 * e / i).toFixed(2)}%`);
  }
  fixDims() {
    const {
      style: t
    } = this.div, {
      height: e,
      width: r
    } = t, i = r.endsWith("%"), s = !_(this, dy) && e.endsWith("%");
    if (i && s)
      return;
    const [o, l] = this.parentDimensions;
    i || (t.width = `${(100 * parseFloat(r) / o).toFixed(2)}%`), !_(this, dy) && !s && (t.height = `${(100 * parseFloat(e) / l).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  altTextFinish() {
    var t;
    (t = _(this, la)) == null || t.finish();
  }
  async addEditToolbar() {
    return _(this, ca) || _(this, py) ? _(this, ca) : (q(this, ca, new d$(this)), this.div.append(_(this, ca).render()), _(this, la) && _(this, ca).addAltTextButton(await _(this, la).render()), _(this, ca));
  }
  removeEditToolbar() {
    var t;
    _(this, ca) && (_(this, ca).remove(), q(this, ca, null), (t = _(this, la)) == null || t.destroy());
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    _(this, la) || (KM.initialize(Hr._l10nPromise), q(this, la, new KM(this)), _(this, uy) && (_(this, la).data = _(this, uy), q(this, uy, null)), await this.addEditToolbar());
  }
  get altTextData() {
    var t;
    return (t = _(this, la)) == null ? void 0 : t.data;
  }
  set altTextData(t) {
    _(this, la) && (_(this, la).data = t);
  }
  hasAltText() {
    var t;
    return !((t = _(this, la)) != null && t.isEmpty());
  }
  render() {
    this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = _(this, ax) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground();
    const t = this._uiManager._signal;
    this.div.addEventListener("focusin", _(this, lx), {
      signal: t
    }), this.div.addEventListener("focusout", _(this, cx), {
      signal: t
    });
    const [e, r] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * r / e).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * e / r).toFixed(2)}%`);
    const [i, s] = this.getInitialTranslation();
    return this.translate(i, s), GM(this, this.div, ["pointerdown"]), this.div;
  }
  pointerdown(t) {
    const {
      isMac: e
    } = jl.platform;
    if (t.button !== 0 || t.ctrlKey && e) {
      t.preventDefault();
      return;
    }
    if (q(this, fy, !0), this._isDraggable) {
      Q(this, $n, mee).call(this, t);
      return;
    }
    Q(this, $n, P$).call(this, t);
  }
  moveInDOM() {
    _(this, nh) && clearTimeout(_(this, nh)), q(this, nh, setTimeout(() => {
      var t;
      q(this, nh, null), (t = this.parent) == null || t.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(t, e, r) {
    t.changeParent(this), this.x = e, this.y = r, this.fixAndSetPosition();
  }
  getRect(t, e, r = this.rotation) {
    const i = this.parentScale, [s, o] = this.pageDimensions, [l, u] = this.pageTranslation, d = t / i, f = e / i, m = this.x * s, v = this.y * o, S = this.width * s, w = this.height * o;
    switch (r) {
      case 0:
        return [m + d + l, o - v - f - w + u, m + d + S + l, o - v - f + u];
      case 90:
        return [m + f + l, o - v + d + u, m + f + w + l, o - v + d + S + u];
      case 180:
        return [m - d - S + l, o - v + f + u, m - d + l, o - v + f + w + u];
      case 270:
        return [m - f - w + l, o - v - d - S + u, m - f + l, o - v - d + u];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(t, e) {
    const [r, i, s, o] = t, l = s - r, u = o - i;
    switch (this.rotation) {
      case 0:
        return [r, e - o, l, u];
      case 90:
        return [r, e - i, u, l];
      case 180:
        return [s, e - i, l, u];
      case 270:
        return [s, e - o, u, l];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    q(this, py, !0);
  }
  disableEditMode() {
    q(this, py, !1);
  }
  isInEditMode() {
    return _(this, py);
  }
  shouldGetKeyboardEvents() {
    return _(this, Hf);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    var e, r;
    const t = this._uiManager._signal;
    (e = this.div) == null || e.addEventListener("focusin", _(this, lx), {
      signal: t
    }), (r = this.div) == null || r.addEventListener("focusout", _(this, cx), {
      signal: t
    });
  }
  rotate(t) {
  }
  serialize(t = !1, e = null) {
    Lr("An editor must be serializable");
  }
  static deserialize(t, e, r) {
    const i = new this.prototype.constructor({
      parent: e,
      id: e.getNextId(),
      uiManager: r
    });
    i.rotation = t.rotation, q(i, uy, t.accessibilityData);
    const [s, o] = i.pageDimensions, [l, u, d, f] = i.getRectInCurrentCoords(t.rect, o);
    return i.x = l / s, i.y = u / o, i.width = d / s, i.height = f / o, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    if (this.div.removeEventListener("focusin", _(this, lx)), this.div.removeEventListener("focusout", _(this, cx)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), _(this, nh) && (clearTimeout(_(this, nh)), q(this, nh, null)), Q(this, $n, g1).call(this), this.removeEditToolbar(), _(this, qc)) {
      for (const t of _(this, qc).values())
        clearTimeout(t);
      q(this, qc, null);
    }
    this.parent = null;
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (Q(this, $n, pee).call(this), _(this, _o).classList.remove("hidden"), GM(this, this.div, ["keydown"]));
  }
  get toolbarPosition() {
    return null;
  }
  keydown(t) {
    if (!this.isResizable || t.target !== this.div || t.key !== "Enter")
      return;
    this._uiManager.setSelected(this), q(this, hy, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const e = _(this, _o).children;
    if (!_(this, Ku)) {
      q(this, Ku, Array.from(e));
      const o = Q(this, $n, vee).bind(this), l = Q(this, $n, yee).bind(this), u = this._uiManager._signal;
      for (const d of _(this, Ku)) {
        const f = d.getAttribute("data-resizer-name");
        d.setAttribute("role", "spinbutton"), d.addEventListener("keydown", o, {
          signal: u
        }), d.addEventListener("blur", l, {
          signal: u
        }), d.addEventListener("focus", Q(this, $n, See).bind(this, f), {
          signal: u
        }), Hr._l10nPromise.get(`pdfjs-editor-resizer-label-${f}`).then((m) => d.setAttribute("aria-label", m));
      }
    }
    const r = _(this, Ku)[0];
    let i = 0;
    for (const o of e) {
      if (o === r)
        break;
      i++;
    }
    const s = (360 - this.rotation + this.parentRotation) % 360 / 90 * (_(this, Ku).length / 4);
    if (s !== i) {
      if (s < i)
        for (let l = 0; l < i - s; l++)
          _(this, _o).append(_(this, _o).firstChild);
      else if (s > i)
        for (let l = 0; l < s - i; l++)
          _(this, _o).firstChild.before(_(this, _o).lastChild);
      let o = 0;
      for (const l of e) {
        const d = _(this, Ku)[o++].getAttribute("data-resizer-name");
        Hr._l10nPromise.get(`pdfjs-editor-resizer-label-${d}`).then((f) => l.setAttribute("aria-label", f));
      }
    }
    Q(this, $n, A$).call(this, 0), q(this, Hf, !0), _(this, _o).firstChild.focus({
      focusVisible: !0
    }), t.preventDefault(), t.stopImmediatePropagation();
  }
  _resizeWithKeyboard(t, e) {
    _(this, Hf) && Q(this, $n, T$).call(this, _(this, E_), {
      movementX: t,
      movementY: e
    });
  }
  _stopResizingWithKeyboard() {
    Q(this, $n, g1).call(this), this.div.focus();
  }
  select() {
    var t, e;
    if (this.makeResizable(), (t = this.div) == null || t.classList.add("selectedEditor"), !_(this, ca)) {
      this.addEditToolbar().then(() => {
        var r, i;
        (r = this.div) != null && r.classList.contains("selectedEditor") && ((i = _(this, ca)) == null || i.show());
      });
      return;
    }
    (e = _(this, ca)) == null || e.show();
  }
  unselect() {
    var t, e, r, i;
    (t = _(this, _o)) == null || t.classList.add("hidden"), (e = this.div) == null || e.classList.remove("selectedEditor"), (r = this.div) != null && r.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), (i = _(this, ca)) == null || i.hide();
  }
  updateParams(t, e) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return _(this, __);
  }
  set isEditing(t) {
    q(this, __, t), this.parent && (t ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  setAspectRatio(t, e) {
    q(this, dy, !0);
    const r = t / e, {
      style: i
    } = this.div;
    i.aspectRatio = r, i.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(t, e = !1) {
    if (e) {
      _(this, qc) || q(this, qc, /* @__PURE__ */ new Map());
      const {
        action: r
      } = t;
      let i = _(this, qc).get(r);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(t), _(this, qc).delete(r), _(this, qc).size === 0 && q(this, qc, null);
      }, Hr._telemetryTimeout), _(this, qc).set(r, i);
      return;
    }
    t.type || (t.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: t
      }
    });
  }
  show(t = this._isVisible) {
    this.div.classList.toggle("hidden", !t), this._isVisible = t;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), q(this, ax, !1);
  }
  disable() {
    this.div && (this.div.tabIndex = -1), q(this, ax, !0);
  }
  renderAnnotationElement(t) {
    let e = t.container.querySelector(".annotationContent");
    if (!e)
      e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), t.container.prepend(e);
    else if (e.nodeName === "CANVAS") {
      const r = e;
      e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), r.before(e);
    }
    return e;
  }
  resetAnnotationElement(t) {
    const {
      firstChild: e
    } = t.container;
    e.nodeName === "DIV" && e.classList.contains("annotationContent") && e.remove();
  }
};
uy = new WeakMap(), Ku = new WeakMap(), la = new WeakMap(), ax = new WeakMap(), dy = new WeakMap(), _o = new WeakMap(), hy = new WeakMap(), lx = new WeakMap(), cx = new WeakMap(), ca = new WeakMap(), E_ = new WeakMap(), fy = new WeakMap(), Yg = new WeakMap(), __ = new WeakMap(), py = new WeakMap(), Hf = new WeakMap(), nh = new WeakMap(), ux = new WeakMap(), dx = new WeakMap(), qc = new WeakMap(), T_ = new WeakMap(), a2 = new WeakMap(), $n = new WeakSet(), w$ = function([t, e], r, i) {
  [r, i] = this.screenToPageTranslation(r, i), this.x += r / t, this.y += i / e, this.fixAndSetPosition();
}, P_ = new WeakSet(), C$ = function(t, e, r) {
  switch (r) {
    case 90:
      return [e, -t];
    case 180:
      return [-t, -e];
    case 270:
      return [-e, t];
    default:
      return [t, e];
  }
}, E$ = function(t) {
  switch (t) {
    case 90: {
      const [e, r] = this.pageDimensions;
      return [0, -e / r, r / e, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [e, r] = this.pageDimensions;
      return [0, e / r, -r / e, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
}, pee = function() {
  if (_(this, _o))
    return;
  q(this, _o, document.createElement("div")), _(this, _o).classList.add("resizers");
  const t = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], e = this._uiManager._signal;
  for (const r of t) {
    const i = document.createElement("div");
    _(this, _o).append(i), i.classList.add("resizer", r), i.setAttribute("data-resizer-name", r), i.addEventListener("pointerdown", Q(this, $n, gee).bind(this, r), {
      signal: e
    }), i.addEventListener("contextmenu", zl, {
      signal: e
    }), i.tabIndex = -1;
  }
  this.div.prepend(_(this, _o));
}, gee = function(t, e) {
  var E;
  e.preventDefault();
  const {
    isMac: r
  } = jl.platform;
  if (e.button !== 0 || e.ctrlKey && r)
    return;
  (E = _(this, la)) == null || E.toggle(!1);
  const i = Q(this, $n, T$).bind(this, t), s = this._isDraggable;
  this._isDraggable = !1;
  const o = this._uiManager._signal, l = {
    passive: !0,
    capture: !0,
    signal: o
  };
  this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", i, l), window.addEventListener("contextmenu", zl, {
    signal: o
  });
  const u = this.x, d = this.y, f = this.width, m = this.height, v = this.parent.div.style.cursor, S = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e.target).cursor;
  const w = () => {
    var A;
    this.parent.togglePointerEvents(!0), (A = _(this, la)) == null || A.toggle(!0), this._isDraggable = s, window.removeEventListener("pointerup", w), window.removeEventListener("blur", w), window.removeEventListener("pointermove", i, l), window.removeEventListener("contextmenu", zl), this.parent.div.style.cursor = v, this.div.style.cursor = S, Q(this, $n, _$).call(this, u, d, f, m);
  };
  window.addEventListener("pointerup", w, {
    signal: o
  }), window.addEventListener("blur", w, {
    signal: o
  });
}, _$ = function(t, e, r, i) {
  const s = this.x, o = this.y, l = this.width, u = this.height;
  s === t && o === e && l === r && u === i || this.addCommands({
    cmd: () => {
      this.width = l, this.height = u, this.x = s, this.y = o;
      const [d, f] = this.parentDimensions;
      this.setDims(d * l, f * u), this.fixAndSetPosition();
    },
    undo: () => {
      this.width = r, this.height = i, this.x = t, this.y = e;
      const [d, f] = this.parentDimensions;
      this.setDims(d * r, f * i), this.fixAndSetPosition();
    },
    mustExec: !0
  });
}, T$ = function(t, e) {
  const [r, i] = this.parentDimensions, s = this.x, o = this.y, l = this.width, u = this.height, d = Hr.MIN_SIZE / r, f = Hr.MIN_SIZE / i, m = (ie) => Math.round(ie * 1e4) / 1e4, v = Q(this, $n, E$).call(this, this.rotation), S = (ie, ue) => [v[0] * ie + v[2] * ue, v[1] * ie + v[3] * ue], w = Q(this, $n, E$).call(this, 360 - this.rotation), E = (ie, ue) => [w[0] * ie + w[2] * ue, w[1] * ie + w[3] * ue];
  let A, P, R = !1, M = !1;
  switch (t) {
    case "topLeft":
      R = !0, A = (ie, ue) => [0, 0], P = (ie, ue) => [ie, ue];
      break;
    case "topMiddle":
      A = (ie, ue) => [ie / 2, 0], P = (ie, ue) => [ie / 2, ue];
      break;
    case "topRight":
      R = !0, A = (ie, ue) => [ie, 0], P = (ie, ue) => [0, ue];
      break;
    case "middleRight":
      M = !0, A = (ie, ue) => [ie, ue / 2], P = (ie, ue) => [0, ue / 2];
      break;
    case "bottomRight":
      R = !0, A = (ie, ue) => [ie, ue], P = (ie, ue) => [0, 0];
      break;
    case "bottomMiddle":
      A = (ie, ue) => [ie / 2, ue], P = (ie, ue) => [ie / 2, 0];
      break;
    case "bottomLeft":
      R = !0, A = (ie, ue) => [0, ue], P = (ie, ue) => [ie, 0];
      break;
    case "middleLeft":
      M = !0, A = (ie, ue) => [0, ue / 2], P = (ie, ue) => [ie, ue / 2];
      break;
  }
  const j = A(l, u), $ = P(l, u);
  let U = S(...$);
  const F = m(s + U[0]), B = m(o + U[1]);
  let G = 1, X = 1, [te, ne] = this.screenToPageTranslation(e.movementX, e.movementY);
  if ([te, ne] = E(te / r, ne / i), R) {
    const ie = Math.hypot(l, u);
    G = X = Math.max(Math.min(Math.hypot($[0] - j[0] - te, $[1] - j[1] - ne) / ie, 1 / l, 1 / u), d / l, f / u);
  } else M ? G = Math.max(d, Math.min(1, Math.abs($[0] - j[0] - te))) / l : X = Math.max(f, Math.min(1, Math.abs($[1] - j[1] - ne))) / u;
  const K = m(l * G), Z = m(u * X);
  U = S(...P(K, Z));
  const oe = F - U[0], fe = B - U[1];
  this.width = K, this.height = Z, this.x = oe, this.y = fe, this.setDims(r * K, i * Z), this.fixAndSetPosition();
}, P$ = function(t) {
  const {
    isMac: e
  } = jl.platform;
  t.ctrlKey && !e || t.shiftKey || t.metaKey && e ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
}, mee = function(t) {
  const e = this._uiManager.isSelected(this);
  this._uiManager.setUpDragSession();
  let r, i;
  const s = this._uiManager._signal;
  e && (this.div.classList.add("moving"), r = {
    passive: !0,
    capture: !0,
    signal: s
  }, q(this, ux, t.clientX), q(this, dx, t.clientY), i = (l) => {
    const {
      clientX: u,
      clientY: d
    } = l, [f, m] = this.screenToPageTranslation(u - _(this, ux), d - _(this, dx));
    q(this, ux, u), q(this, dx, d), this._uiManager.dragSelectedEditors(f, m);
  }, window.addEventListener("pointermove", i, r));
  const o = () => {
    window.removeEventListener("pointerup", o), window.removeEventListener("blur", o), e && (this.div.classList.remove("moving"), window.removeEventListener("pointermove", i, r)), q(this, fy, !1), this._uiManager.endDragSession() || Q(this, $n, P$).call(this, t);
  };
  window.addEventListener("pointerup", o, {
    signal: s
  }), window.addEventListener("blur", o, {
    signal: s
  });
}, vee = function(t) {
  Hr._resizerKeyboardManager.exec(this, t);
}, yee = function(t) {
  var e;
  _(this, Hf) && ((e = t.relatedTarget) == null ? void 0 : e.parentNode) !== _(this, _o) && Q(this, $n, g1).call(this);
}, See = function(t) {
  q(this, E_, _(this, Hf) ? t : "");
}, A$ = function(t) {
  if (_(this, Ku))
    for (const e of _(this, Ku))
      e.tabIndex = t;
}, g1 = function() {
  if (q(this, Hf, !1), Q(this, $n, A$).call(this, -1), _(this, hy)) {
    const {
      savedX: t,
      savedY: e,
      savedWidth: r,
      savedHeight: i
    } = _(this, hy);
    Q(this, $n, _$).call(this, t, e, r, i), q(this, hy, null);
  }
}, J(Hr, P_), T(Hr, "_borderLineWidth", -1), T(Hr, "_colorManager", new g$()), T(Hr, "_zIndex", 1), T(Hr, "_telemetryTimeout", 1e3);
let Pr = Hr;
class ADe extends Pr {
  constructor(t) {
    super(t), this.annotationElementId = t.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex
    };
  }
}
const kV = 3285377520, Yc = 4294901760, Xd = 65535;
class bee {
  constructor(t) {
    this.h1 = t ? t & 4294967295 : kV, this.h2 = t ? t & 4294967295 : kV;
  }
  update(t) {
    let e, r;
    if (typeof t == "string") {
      e = new Uint8Array(t.length * 2), r = 0;
      for (let E = 0, A = t.length; E < A; E++) {
        const P = t.charCodeAt(E);
        P <= 255 ? e[r++] = P : (e[r++] = P >>> 8, e[r++] = P & 255);
      }
    } else if (ArrayBuffer.isView(t))
      e = t.slice(), r = e.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = r >> 2, s = r - i * 4, o = new Uint32Array(e.buffer, 0, i);
    let l = 0, u = 0, d = this.h1, f = this.h2;
    const m = 3432918353, v = 461845907, S = m & Xd, w = v & Xd;
    for (let E = 0; E < i; E++)
      E & 1 ? (l = o[E], l = l * m & Yc | l * S & Xd, l = l << 15 | l >>> 17, l = l * v & Yc | l * w & Xd, d ^= l, d = d << 13 | d >>> 19, d = d * 5 + 3864292196) : (u = o[E], u = u * m & Yc | u * S & Xd, u = u << 15 | u >>> 17, u = u * v & Yc | u * w & Xd, f ^= u, f = f << 13 | f >>> 19, f = f * 5 + 3864292196);
    switch (l = 0, s) {
      case 3:
        l ^= e[i * 4 + 2] << 16;
      case 2:
        l ^= e[i * 4 + 1] << 8;
      case 1:
        l ^= e[i * 4], l = l * m & Yc | l * S & Xd, l = l << 15 | l >>> 17, l = l * v & Yc | l * w & Xd, i & 1 ? d ^= l : f ^= l;
    }
    this.h1 = d, this.h2 = f;
  }
  hexdigest() {
    let t = this.h1, e = this.h2;
    return t ^= e >>> 1, t = t * 3981806797 & Yc | t * 36045 & Xd, e = e * 4283543511 & Yc | ((e << 16 | t >>> 16) * 2950163797 & Yc) >>> 16, t ^= e >>> 1, t = t * 444984403 & Yc | t * 60499 & Xd, e = e * 3301882366 & Yc | ((e << 16 | t >>> 16) * 3120437893 & Yc) >>> 16, t ^= e >>> 1, (t >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
  }
}
const k$ = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var gy, To, l2, xee;
class ZU {
  constructor() {
    J(this, l2);
    J(this, gy, !1);
    J(this, To, /* @__PURE__ */ new Map());
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(t, e) {
    const r = _(this, To).get(t);
    return r === void 0 ? e : Object.assign(e, r);
  }
  getRawValue(t) {
    return _(this, To).get(t);
  }
  remove(t) {
    if (_(this, To).delete(t), _(this, To).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
      for (const e of _(this, To).values())
        if (e instanceof Pr)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(t, e) {
    const r = _(this, To).get(t);
    let i = !1;
    if (r !== void 0)
      for (const [s, o] of Object.entries(e))
        r[s] !== o && (i = !0, r[s] = o);
    else
      i = !0, _(this, To).set(t, e);
    i && Q(this, l2, xee).call(this), e instanceof Pr && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type);
  }
  has(t) {
    return _(this, To).has(t);
  }
  getAll() {
    return _(this, To).size > 0 ? VU(_(this, To)) : null;
  }
  setAll(t) {
    for (const [e, r] of Object.entries(t))
      this.setValue(e, r);
  }
  get size() {
    return _(this, To).size;
  }
  resetModified() {
    _(this, gy) && (q(this, gy, !1), typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new wee(this);
  }
  get serializable() {
    if (_(this, To).size === 0)
      return k$;
    const t = /* @__PURE__ */ new Map(), e = new bee(), r = [], i = /* @__PURE__ */ Object.create(null);
    let s = !1;
    for (const [o, l] of _(this, To)) {
      const u = l instanceof Pr ? l.serialize(!1, i) : l;
      u && (t.set(o, u), e.update(`${o}:${JSON.stringify(u)}`), s || (s = !!u.bitmap));
    }
    if (s)
      for (const o of t.values())
        o.bitmap && r.push(o.bitmap);
    return t.size > 0 ? {
      map: t,
      hash: e.hexdigest(),
      transfer: r
    } : k$;
  }
  get editorStats() {
    let t = null;
    const e = /* @__PURE__ */ new Map();
    for (const r of _(this, To).values()) {
      if (!(r instanceof Pr))
        continue;
      const i = r.telemetryFinalData;
      if (!i)
        continue;
      const {
        type: s
      } = i;
      e.has(s) || e.set(s, Object.getPrototypeOf(r).constructor), t || (t = /* @__PURE__ */ Object.create(null));
      const o = t[s] || (t[s] = /* @__PURE__ */ new Map());
      for (const [l, u] of Object.entries(i)) {
        if (l === "type")
          continue;
        let d = o.get(l);
        d || (d = /* @__PURE__ */ new Map(), o.set(l, d));
        const f = d.get(u) ?? 0;
        d.set(u, f + 1);
      }
    }
    for (const [r, i] of e)
      t[r] = i.computeTelemetryFinalData(t[r]);
    return t;
  }
}
gy = new WeakMap(), To = new WeakMap(), l2 = new WeakSet(), xee = function() {
  _(this, gy) || (q(this, gy, !0), typeof this.onSetModified == "function" && this.onSetModified());
};
var A_;
class wee extends ZU {
  constructor(e) {
    super();
    J(this, A_);
    const {
      map: r,
      hash: i,
      transfer: s
    } = e.serializable, o = structuredClone(r, s ? {
      transfer: s
    } : null);
    q(this, A_, {
      map: o,
      hash: i,
      transfer: s
    });
  }
  get print() {
    Lr("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return _(this, A_);
  }
}
A_ = new WeakMap();
var hx;
class kDe {
  constructor({
    ownerDocument: t = globalThis.document,
    styleElement: e = null
  }) {
    J(this, hx, /* @__PURE__ */ new Set());
    this._document = t, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(t) {
    this.nativeFontFaces.add(t), this._document.fonts.add(t);
  }
  removeNativeFontFace(t) {
    this.nativeFontFaces.delete(t), this._document.fonts.delete(t);
  }
  insertRule(t) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const e = this.styleElement.sheet;
    e.insertRule(t, e.cssRules.length);
  }
  clear() {
    for (const t of this.nativeFontFaces)
      this._document.fonts.delete(t);
    this.nativeFontFaces.clear(), _(this, hx).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: t,
    _inspectFont: e
  }) {
    if (!(!t || _(this, hx).has(t.loadedName))) {
      if (zs(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: r,
          src: i,
          style: s
        } = t, o = new FontFace(r, i, s);
        this.addNativeFontFace(o);
        try {
          await o.load(), _(this, hx).add(r), e == null || e(t);
        } catch {
          In(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(o);
        }
        return;
      }
      Lr("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(t) {
    if (t.attached || t.missingFile && !t.systemFontInfo)
      return;
    if (t.attached = !0, t.systemFontInfo) {
      await this.loadSystemFont(t);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const r = t.createNativeFontFace();
      if (r) {
        this.addNativeFontFace(r);
        try {
          await r.loaded;
        } catch (i) {
          throw In(`Failed to load font '${r.family}': '${i}'.`), t.disableFontFace = !0, i;
        }
      }
      return;
    }
    const e = t.createFontFaceRule();
    if (e) {
      if (this.insertRule(e), this.isSyncFontLoadingSupported)
        return;
      await new Promise((r) => {
        const i = this._queueLoadingCallback(r);
        this._prepareFontLoadEvent(t, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var e;
    const t = !!((e = this._document) != null && e.fonts);
    return lr(this, "isFontLoadingAPISupported", t);
  }
  get isSyncFontLoadingSupported() {
    let t = !1;
    return (va || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (t = !0), lr(this, "isSyncFontLoadingSupported", t);
  }
  _queueLoadingCallback(t) {
    function e() {
      for (zs(!i.done, "completeRequest() cannot be called twice."), i.done = !0; r.length > 0 && r[0].done; ) {
        const s = r.shift();
        setTimeout(s.callback, 0);
      }
    }
    const {
      loadingRequests: r
    } = this, i = {
      done: !1,
      complete: e,
      callback: t
    };
    return r.push(i), i;
  }
  get _loadTestFont() {
    const t = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return lr(this, "_loadTestFont", t);
  }
  _prepareFontLoadEvent(t, e) {
    function r(j, $) {
      return j.charCodeAt($) << 24 | j.charCodeAt($ + 1) << 16 | j.charCodeAt($ + 2) << 8 | j.charCodeAt($ + 3) & 255;
    }
    function i(j, $, U, F) {
      const B = j.substring(0, $), G = j.substring($ + U);
      return B + F + G;
    }
    let s, o;
    const l = this._document.createElement("canvas");
    l.width = 1, l.height = 1;
    const u = l.getContext("2d");
    let d = 0;
    function f(j, $) {
      if (++d > 30) {
        In("Load test font never loaded."), $();
        return;
      }
      if (u.font = "30px " + j, u.fillText(".", 0, 20), u.getImageData(0, 0, 1, 1).data[3] > 0) {
        $();
        return;
      }
      setTimeout(f.bind(null, j, $));
    }
    const m = `lt${Date.now()}${this.loadTestFontId++}`;
    let v = this._loadTestFont;
    v = i(v, 976, m.length, m);
    const w = 16, E = 1482184792;
    let A = r(v, w);
    for (s = 0, o = m.length - 3; s < o; s += 4)
      A = A - E + r(m, s) | 0;
    s < m.length && (A = A - E + r(m + "XXX", s) | 0), v = i(v, w, 4, hDe(A));
    const P = `url(data:font/opentype;base64,${btoa(v)});`, R = `@font-face {font-family:"${m}";src:${P}}`;
    this.insertRule(R);
    const M = this._document.createElement("div");
    M.style.visibility = "hidden", M.style.width = M.style.height = "10px", M.style.position = "absolute", M.style.top = M.style.left = "0px";
    for (const j of [t.loadedName, m]) {
      const $ = this._document.createElement("span");
      $.textContent = "Hi", $.style.fontFamily = j, M.append($);
    }
    this._document.body.append(M), f(m, () => {
      M.remove(), e.complete();
    });
  }
}
hx = new WeakMap();
class IDe {
  constructor(t, {
    disableFontFace: e = !1,
    inspectFont: r = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i in t)
      this[i] = t[i];
    this.disableFontFace = e === !0, this._inspectFont = r;
  }
  createNativeFontFace() {
    var e;
    if (!this.data || this.disableFontFace)
      return null;
    let t;
    if (!this.cssFontInfo)
      t = new FontFace(this.loadedName, this.data, {});
    else {
      const r = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (r.style = `oblique ${this.cssFontInfo.italicAngle}deg`), t = new FontFace(this.cssFontInfo.fontFamily, this.data, r);
    }
    return (e = this._inspectFont) == null || e.call(this, this), t;
  }
  createFontFaceRule() {
    var i;
    if (!this.data || this.disableFontFace)
      return null;
    const t = HJ(this.data), e = `url(data:${this.mimetype};base64,${btoa(t)});`;
    let r;
    if (!this.cssFontInfo)
      r = `@font-face {font-family:"${this.loadedName}";src:${e}}`;
    else {
      let s = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (s += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), r = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${s}src:${e}}`;
    }
    return (i = this._inspectFont) == null || i.call(this, this, e), r;
  }
  getPathGenerator(t, e) {
    if (this.compiledGlyphs[e] !== void 0)
      return this.compiledGlyphs[e];
    let r;
    try {
      r = t.get(this.loadedName + "_path_" + e);
    } catch (s) {
      In(`getPathGenerator - ignoring character: "${s}".`);
    }
    if (!Array.isArray(r) || r.length === 0)
      return this.compiledGlyphs[e] = function(s, o) {
      };
    const i = [];
    for (let s = 0, o = r.length; s < o; )
      switch (r[s++]) {
        case Tf.BEZIER_CURVE_TO:
          {
            const [l, u, d, f, m, v] = r.slice(s, s + 6);
            i.push((S) => S.bezierCurveTo(l, u, d, f, m, v)), s += 6;
          }
          break;
        case Tf.MOVE_TO:
          {
            const [l, u] = r.slice(s, s + 2);
            i.push((d) => d.moveTo(l, u)), s += 2;
          }
          break;
        case Tf.LINE_TO:
          {
            const [l, u] = r.slice(s, s + 2);
            i.push((d) => d.lineTo(l, u)), s += 2;
          }
          break;
        case Tf.QUADRATIC_CURVE_TO:
          {
            const [l, u, d, f] = r.slice(s, s + 4);
            i.push((m) => m.quadraticCurveTo(l, u, d, f)), s += 4;
          }
          break;
        case Tf.RESTORE:
          i.push((l) => l.restore());
          break;
        case Tf.SAVE:
          i.push((l) => l.save());
          break;
        case Tf.SCALE:
          zs(i.length === 2, "Scale command is only valid at the third position.");
          break;
        case Tf.TRANSFORM:
          {
            const [l, u, d, f, m, v] = r.slice(s, s + 6);
            i.push((S) => S.transform(l, u, d, f, m, v)), s += 6;
          }
          break;
        case Tf.TRANSLATE:
          {
            const [l, u] = r.slice(s, s + 2);
            i.push((d) => d.translate(l, u)), s += 2;
          }
          break;
      }
    return this.compiledGlyphs[e] = function(o, l) {
      i[0](o), i[1](o), o.scale(l, -l);
      for (let u = 2, d = i.length; u < d; u++)
        i[u](o);
    };
  }
}
if (va) {
  var I$ = Promise.withResolvers(), D1 = null;
  (async () => {
    const t = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-DYxpcVy9.js"
    ), e = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-DYxpcVy9.js"
    ), r = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-DYxpcVy9.js"
    ), i = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-DYxpcVy9.js"
    );
    let s, o;
    return new Map(Object.entries({
      fs: t,
      http: e,
      https: r,
      url: i,
      canvas: s,
      path2d: o
    }));
  })().then((t) => {
    D1 = t, I$.resolve();
  }, (t) => {
    In(`loadPackages: ${t}`), D1 = /* @__PURE__ */ new Map(), I$.resolve();
  });
}
class Dh {
  static get promise() {
    return I$.promise;
  }
  static get(t) {
    return D1 == null ? void 0 : D1.get(t);
  }
}
const Cee = function(n) {
  return Dh.get("fs").promises.readFile(n).then((e) => new Uint8Array(e));
};
class RDe extends SD {
}
class MDe extends WM {
  _createCanvas(t, e) {
    return Dh.get("canvas").createCanvas(t, e);
  }
}
class DDe extends bD {
  _fetchData(t, e) {
    return Cee(t).then((r) => ({
      cMapData: r,
      compressionType: e
    }));
  }
}
class ODe extends xD {
  _fetchData(t) {
    return Cee(t);
  }
}
const Ua = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function R$(n, t) {
  if (!t)
    return;
  const e = t[2] - t[0], r = t[3] - t[1], i = new Path2D();
  i.rect(t[0], t[1], e, r), n.clip(i);
}
class sP {
  constructor() {
    this.constructor === sP && Lr("Cannot initialize BaseShadingPattern.");
  }
  getPattern() {
    Lr("Abstract method `getPattern` called.");
  }
}
class LDe extends sP {
  constructor(t) {
    super(), this._type = t[1], this._bbox = t[2], this._colorStops = t[3], this._p0 = t[4], this._p1 = t[5], this._r0 = t[6], this._r1 = t[7], this.matrix = null;
  }
  _createGradient(t) {
    let e;
    this._type === "axial" ? e = t.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (e = t.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const r of this._colorStops)
      e.addColorStop(r[0], r[1]);
    return e;
  }
  getPattern(t, e, r, i) {
    let s;
    if (i === Ua.STROKE || i === Ua.FILL) {
      const o = e.current.getClippedPathBoundingBox(i, ki(t)) || [0, 0, 0, 0], l = Math.ceil(o[2] - o[0]) || 1, u = Math.ceil(o[3] - o[1]) || 1, d = e.cachedCanvases.getCanvas("pattern", l, u, !0), f = d.context;
      f.clearRect(0, 0, f.canvas.width, f.canvas.height), f.beginPath(), f.rect(0, 0, f.canvas.width, f.canvas.height), f.translate(-o[0], -o[1]), r = Ft.transform(r, [1, 0, 0, 1, o[0], o[1]]), f.transform(...e.baseTransform), this.matrix && f.transform(...this.matrix), R$(f, this._bbox), f.fillStyle = this._createGradient(f), f.fill(), s = t.createPattern(d.canvas, "no-repeat");
      const m = new DOMMatrix(r);
      s.setTransform(m);
    } else
      R$(t, this._bbox), s = this._createGradient(t);
    return s;
  }
}
function yF(n, t, e, r, i, s, o, l) {
  const u = t.coords, d = t.colors, f = n.data, m = n.width * 4;
  let v;
  u[e + 1] > u[r + 1] && (v = e, e = r, r = v, v = s, s = o, o = v), u[r + 1] > u[i + 1] && (v = r, r = i, i = v, v = o, o = l, l = v), u[e + 1] > u[r + 1] && (v = e, e = r, r = v, v = s, s = o, o = v);
  const S = (u[e] + t.offsetX) * t.scaleX, w = (u[e + 1] + t.offsetY) * t.scaleY, E = (u[r] + t.offsetX) * t.scaleX, A = (u[r + 1] + t.offsetY) * t.scaleY, P = (u[i] + t.offsetX) * t.scaleX, R = (u[i + 1] + t.offsetY) * t.scaleY;
  if (w >= R)
    return;
  const M = d[s], j = d[s + 1], $ = d[s + 2], U = d[o], F = d[o + 1], B = d[o + 2], G = d[l], X = d[l + 1], te = d[l + 2], ne = Math.round(w), K = Math.round(R);
  let Z, oe, fe, ie, ue, Se, ke, ce;
  for (let ye = ne; ye <= K; ye++) {
    if (ye < A) {
      const Ze = ye < w ? 0 : (w - ye) / (w - A);
      Z = S - (S - E) * Ze, oe = M - (M - U) * Ze, fe = j - (j - F) * Ze, ie = $ - ($ - B) * Ze;
    } else {
      let Ze;
      ye > R ? Ze = 1 : A === R ? Ze = 0 : Ze = (A - ye) / (A - R), Z = E - (E - P) * Ze, oe = U - (U - G) * Ze, fe = F - (F - X) * Ze, ie = B - (B - te) * Ze;
    }
    let Fe;
    ye < w ? Fe = 0 : ye > R ? Fe = 1 : Fe = (w - ye) / (w - R), ue = S - (S - P) * Fe, Se = M - (M - G) * Fe, ke = j - (j - X) * Fe, ce = $ - ($ - te) * Fe;
    const Xe = Math.round(Math.min(Z, ue)), je = Math.round(Math.max(Z, ue));
    let nt = m * ye + Xe * 4;
    for (let Ze = Xe; Ze <= je; Ze++)
      Fe = (Z - Ze) / (Z - ue), Fe < 0 ? Fe = 0 : Fe > 1 && (Fe = 1), f[nt++] = oe - (oe - Se) * Fe | 0, f[nt++] = fe - (fe - ke) * Fe | 0, f[nt++] = ie - (ie - ce) * Fe | 0, f[nt++] = 255;
  }
}
function jDe(n, t, e) {
  const r = t.coords, i = t.colors;
  let s, o;
  switch (t.type) {
    case "lattice":
      const l = t.verticesPerRow, u = Math.floor(r.length / l) - 1, d = l - 1;
      for (s = 0; s < u; s++) {
        let f = s * l;
        for (let m = 0; m < d; m++, f++)
          yF(n, e, r[f], r[f + 1], r[f + l], i[f], i[f + 1], i[f + l]), yF(n, e, r[f + l + 1], r[f + 1], r[f + l], i[f + l + 1], i[f + 1], i[f + l]);
      }
      break;
    case "triangles":
      for (s = 0, o = r.length; s < o; s += 3)
        yF(n, e, r[s], r[s + 1], r[s + 2], i[s], i[s + 1], i[s + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class NDe extends sP {
  constructor(t) {
    super(), this._coords = t[2], this._colors = t[3], this._figures = t[4], this._bounds = t[5], this._bbox = t[7], this._background = t[8], this.matrix = null;
  }
  _createMeshCanvas(t, e, r) {
    const l = Math.floor(this._bounds[0]), u = Math.floor(this._bounds[1]), d = Math.ceil(this._bounds[2]) - l, f = Math.ceil(this._bounds[3]) - u, m = Math.min(Math.ceil(Math.abs(d * t[0] * 1.1)), 3e3), v = Math.min(Math.ceil(Math.abs(f * t[1] * 1.1)), 3e3), S = d / m, w = f / v, E = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -l,
      offsetY: -u,
      scaleX: 1 / S,
      scaleY: 1 / w
    }, A = m + 2 * 2, P = v + 2 * 2, R = r.getCanvas("mesh", A, P, !1), M = R.context, j = M.createImageData(m, v);
    if (e) {
      const U = j.data;
      for (let F = 0, B = U.length; F < B; F += 4)
        U[F] = e[0], U[F + 1] = e[1], U[F + 2] = e[2], U[F + 3] = 255;
    }
    for (const U of this._figures)
      jDe(j, U, E);
    return M.putImageData(j, 2, 2), {
      canvas: R.canvas,
      offsetX: l - 2 * S,
      offsetY: u - 2 * w,
      scaleX: S,
      scaleY: w
    };
  }
  getPattern(t, e, r, i) {
    R$(t, this._bbox);
    let s;
    if (i === Ua.SHADING)
      s = Ft.singularValueDecompose2dScale(ki(t));
    else if (s = Ft.singularValueDecompose2dScale(e.baseTransform), this.matrix) {
      const l = Ft.singularValueDecompose2dScale(this.matrix);
      s = [s[0] * l[0], s[1] * l[1]];
    }
    const o = this._createMeshCanvas(s, i === Ua.SHADING ? null : this._background, e.cachedCanvases);
    return i !== Ua.SHADING && (t.setTransform(...e.baseTransform), this.matrix && t.transform(...this.matrix)), t.translate(o.offsetX, o.offsetY), t.scale(o.scaleX, o.scaleY), t.createPattern(o.canvas, "no-repeat");
  }
}
class FDe extends sP {
  getPattern() {
    return "hotpink";
  }
}
function $De(n) {
  switch (n[0]) {
    case "RadialAxial":
      return new LDe(n);
    case "Mesh":
      return new NDe(n);
    case "Dummy":
      return new FDe();
  }
  throw new Error(`Unknown IR type: ${n[0]}`);
}
const IV = {
  COLORED: 1,
  UNCOLORED: 2
}, c2 = class c2 {
  constructor(t, e, r, i, s) {
    this.operatorList = t[2], this.matrix = t[3], this.bbox = t[4], this.xstep = t[5], this.ystep = t[6], this.paintType = t[7], this.tilingType = t[8], this.color = e, this.ctx = r, this.canvasGraphicsFactory = i, this.baseTransform = s;
  }
  createPatternCanvas(t) {
    const e = this.operatorList, r = this.bbox, i = this.xstep, s = this.ystep, o = this.paintType, l = this.tilingType, u = this.color, d = this.canvasGraphicsFactory;
    mD("TilingType: " + l);
    const f = r[0], m = r[1], v = r[2], S = r[3], w = Ft.singularValueDecompose2dScale(this.matrix), E = Ft.singularValueDecompose2dScale(this.baseTransform), A = [w[0] * E[0], w[1] * E[1]], P = this.getSizeAndScale(i, this.ctx.canvas.width, A[0]), R = this.getSizeAndScale(s, this.ctx.canvas.height, A[1]), M = t.cachedCanvases.getCanvas("pattern", P.size, R.size, !0), j = M.context, $ = d.createCanvasGraphics(j);
    $.groupLevel = t.groupLevel, this.setFillAndStrokeStyleToContext($, o, u);
    let U = f, F = m, B = v, G = S;
    return f < 0 && (U = 0, B += Math.abs(f)), m < 0 && (F = 0, G += Math.abs(m)), j.translate(-(P.scale * U), -(R.scale * F)), $.transform(P.scale, 0, 0, R.scale, 0, 0), j.save(), this.clipBbox($, U, F, B, G), $.baseTransform = ki($.ctx), $.executeOperatorList(e), $.endDrawing(), {
      canvas: M.canvas,
      scaleX: P.scale,
      scaleY: R.scale,
      offsetX: U,
      offsetY: F
    };
  }
  getSizeAndScale(t, e, r) {
    t = Math.abs(t);
    const i = Math.max(c2.MAX_PATTERN_SIZE, e);
    let s = Math.ceil(t * r);
    return s >= i ? s = i : r = s / t, {
      scale: r,
      size: s
    };
  }
  clipBbox(t, e, r, i, s) {
    const o = i - e, l = s - r;
    t.ctx.rect(e, r, o, l), t.current.updateRectMinMax(ki(t.ctx), [e, r, i, s]), t.clip(), t.endPath();
  }
  setFillAndStrokeStyleToContext(t, e, r) {
    const i = t.ctx, s = t.current;
    switch (e) {
      case IV.COLORED:
        const o = this.ctx;
        i.fillStyle = o.fillStyle, i.strokeStyle = o.strokeStyle, s.fillColor = o.fillStyle, s.strokeColor = o.strokeStyle;
        break;
      case IV.UNCOLORED:
        const l = Ft.makeHexColor(r[0], r[1], r[2]);
        i.fillStyle = l, i.strokeStyle = l, s.fillColor = l, s.strokeColor = l;
        break;
      default:
        throw new dDe(`Unsupported paint type: ${e}`);
    }
  }
  getPattern(t, e, r, i) {
    let s = r;
    i !== Ua.SHADING && (s = Ft.transform(s, e.baseTransform), this.matrix && (s = Ft.transform(s, this.matrix)));
    const o = this.createPatternCanvas(e);
    let l = new DOMMatrix(s);
    l = l.translate(o.offsetX, o.offsetY), l = l.scale(1 / o.scaleX, 1 / o.scaleY);
    const u = t.createPattern(o.canvas, "repeat");
    return u.setTransform(l), u;
  }
};
T(c2, "MAX_PATTERN_SIZE", 3e3);
let M$ = c2;
function zDe({
  src: n,
  srcPos: t = 0,
  dest: e,
  width: r,
  height: i,
  nonBlackColor: s = 4294967295,
  inverseDecode: o = !1
}) {
  const l = jl.isLittleEndian ? 4278190080 : 255, [u, d] = o ? [s, l] : [l, s], f = r >> 3, m = r & 7, v = n.length;
  e = new Uint32Array(e.buffer);
  let S = 0;
  for (let w = 0; w < i; w++) {
    for (const A = t + f; t < A; t++) {
      const P = t < v ? n[t] : 255;
      e[S++] = P & 128 ? d : u, e[S++] = P & 64 ? d : u, e[S++] = P & 32 ? d : u, e[S++] = P & 16 ? d : u, e[S++] = P & 8 ? d : u, e[S++] = P & 4 ? d : u, e[S++] = P & 2 ? d : u, e[S++] = P & 1 ? d : u;
    }
    if (m === 0)
      continue;
    const E = t < v ? n[t++] : 255;
    for (let A = 0; A < m; A++)
      e[S++] = E & 1 << 7 - A ? d : u;
  }
  return {
    srcPos: t,
    destPos: S
  };
}
const RV = 16, MV = 100, UDe = 15, DV = 10, OV = 1e3, Pl = 16;
function BDe(n, t) {
  if (n._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  n.__originalSave = n.save, n.__originalRestore = n.restore, n.__originalRotate = n.rotate, n.__originalScale = n.scale, n.__originalTranslate = n.translate, n.__originalTransform = n.transform, n.__originalSetTransform = n.setTransform, n.__originalResetTransform = n.resetTransform, n.__originalClip = n.clip, n.__originalMoveTo = n.moveTo, n.__originalLineTo = n.lineTo, n.__originalBezierCurveTo = n.bezierCurveTo, n.__originalRect = n.rect, n.__originalClosePath = n.closePath, n.__originalBeginPath = n.beginPath, n._removeMirroring = () => {
    n.save = n.__originalSave, n.restore = n.__originalRestore, n.rotate = n.__originalRotate, n.scale = n.__originalScale, n.translate = n.__originalTranslate, n.transform = n.__originalTransform, n.setTransform = n.__originalSetTransform, n.resetTransform = n.__originalResetTransform, n.clip = n.__originalClip, n.moveTo = n.__originalMoveTo, n.lineTo = n.__originalLineTo, n.bezierCurveTo = n.__originalBezierCurveTo, n.rect = n.__originalRect, n.closePath = n.__originalClosePath, n.beginPath = n.__originalBeginPath, delete n._removeMirroring;
  }, n.save = function() {
    t.save(), this.__originalSave();
  }, n.restore = function() {
    t.restore(), this.__originalRestore();
  }, n.translate = function(r, i) {
    t.translate(r, i), this.__originalTranslate(r, i);
  }, n.scale = function(r, i) {
    t.scale(r, i), this.__originalScale(r, i);
  }, n.transform = function(r, i, s, o, l, u) {
    t.transform(r, i, s, o, l, u), this.__originalTransform(r, i, s, o, l, u);
  }, n.setTransform = function(r, i, s, o, l, u) {
    t.setTransform(r, i, s, o, l, u), this.__originalSetTransform(r, i, s, o, l, u);
  }, n.resetTransform = function() {
    t.resetTransform(), this.__originalResetTransform();
  }, n.rotate = function(r) {
    t.rotate(r), this.__originalRotate(r);
  }, n.clip = function(r) {
    t.clip(r), this.__originalClip(r);
  }, n.moveTo = function(e, r) {
    t.moveTo(e, r), this.__originalMoveTo(e, r);
  }, n.lineTo = function(e, r) {
    t.lineTo(e, r), this.__originalLineTo(e, r);
  }, n.bezierCurveTo = function(e, r, i, s, o, l) {
    t.bezierCurveTo(e, r, i, s, o, l), this.__originalBezierCurveTo(e, r, i, s, o, l);
  }, n.rect = function(e, r, i, s) {
    t.rect(e, r, i, s), this.__originalRect(e, r, i, s);
  }, n.closePath = function() {
    t.closePath(), this.__originalClosePath();
  }, n.beginPath = function() {
    t.beginPath(), this.__originalBeginPath();
  };
}
class HDe {
  constructor(t) {
    this.canvasFactory = t, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(t, e, r) {
    let i;
    return this.cache[t] !== void 0 ? (i = this.cache[t], this.canvasFactory.reset(i, e, r)) : (i = this.canvasFactory.create(e, r), this.cache[t] = i), i;
  }
  delete(t) {
    delete this.cache[t];
  }
  clear() {
    for (const t in this.cache) {
      const e = this.cache[t];
      this.canvasFactory.destroy(e), delete this.cache[t];
    }
  }
}
function zI(n, t, e, r, i, s, o, l, u, d) {
  const [f, m, v, S, w, E] = ki(n);
  if (m === 0 && v === 0) {
    const R = o * f + w, M = Math.round(R), j = l * S + E, $ = Math.round(j), U = (o + u) * f + w, F = Math.abs(Math.round(U) - M) || 1, B = (l + d) * S + E, G = Math.abs(Math.round(B) - $) || 1;
    return n.setTransform(Math.sign(f), 0, 0, Math.sign(S), M, $), n.drawImage(t, e, r, i, s, 0, 0, F, G), n.setTransform(f, m, v, S, w, E), [F, G];
  }
  if (f === 0 && S === 0) {
    const R = l * v + w, M = Math.round(R), j = o * m + E, $ = Math.round(j), U = (l + d) * v + w, F = Math.abs(Math.round(U) - M) || 1, B = (o + u) * m + E, G = Math.abs(Math.round(B) - $) || 1;
    return n.setTransform(0, Math.sign(m), Math.sign(v), 0, M, $), n.drawImage(t, e, r, i, s, 0, 0, G, F), n.setTransform(f, m, v, S, w, E), [G, F];
  }
  n.drawImage(t, e, r, i, s, o, l, u, d);
  const A = Math.hypot(f, m), P = Math.hypot(v, S);
  return [A * u, P * d];
}
function VDe(n) {
  const {
    width: t,
    height: e
  } = n;
  if (t > OV || e > OV)
    return null;
  const r = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), s = t + 1;
  let o = new Uint8Array(s * (e + 1)), l, u, d;
  const f = t + 7 & -8;
  let m = new Uint8Array(f * e), v = 0;
  for (const P of n.data) {
    let R = 128;
    for (; R > 0; )
      m[v++] = P & R ? 0 : 255, R >>= 1;
  }
  let S = 0;
  for (v = 0, m[v] !== 0 && (o[0] = 1, ++S), u = 1; u < t; u++)
    m[v] !== m[v + 1] && (o[u] = m[v] ? 2 : 1, ++S), v++;
  for (m[v] !== 0 && (o[u] = 2, ++S), l = 1; l < e; l++) {
    v = l * f, d = l * s, m[v - f] !== m[v] && (o[d] = m[v] ? 1 : 8, ++S);
    let P = (m[v] ? 4 : 0) + (m[v - f] ? 8 : 0);
    for (u = 1; u < t; u++)
      P = (P >> 2) + (m[v + 1] ? 4 : 0) + (m[v - f + 1] ? 8 : 0), i[P] && (o[d + u] = i[P], ++S), v++;
    if (m[v - f] !== m[v] && (o[d + u] = m[v] ? 2 : 4, ++S), S > r)
      return null;
  }
  for (v = f * (e - 1), d = l * s, m[v] !== 0 && (o[d] = 8, ++S), u = 1; u < t; u++)
    m[v] !== m[v + 1] && (o[d + u] = m[v] ? 4 : 8, ++S), v++;
  if (m[v] !== 0 && (o[d + u] = 4, ++S), S > r)
    return null;
  const w = new Int32Array([0, s, -1, 0, -s, 0, 0, 0, 1]), E = new Path2D();
  for (l = 0; S && l <= e; l++) {
    let P = l * s;
    const R = P + t;
    for (; P < R && !o[P]; )
      P++;
    if (P === R)
      continue;
    E.moveTo(P % s, l);
    const M = P;
    let j = o[P];
    do {
      const $ = w[j];
      do
        P += $;
      while (!o[P]);
      const U = o[P];
      U !== 5 && U !== 10 ? (j = U, o[P] = 0) : (j = U & 51 * j >> 4, o[P] &= j >> 2 | j << 2), E.lineTo(P % s, P / s | 0), o[P] || --S;
    } while (M !== P);
    --l;
  }
  return m = null, o = null, function(P) {
    P.save(), P.scale(1 / t, -1 / e), P.translate(0, -e), P.fill(E), P.beginPath(), P.restore();
  };
}
class LV {
  constructor(t, e) {
    this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = UJ, this.textMatrixScale = 1, this.fontMatrix = i$, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = sa.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, t, e]);
  }
  clone() {
    const t = Object.create(this);
    return t.clipBox = this.clipBox.slice(), t;
  }
  setCurrentPoint(t, e) {
    this.x = t, this.y = e;
  }
  updatePathMinMax(t, e, r) {
    [e, r] = Ft.applyTransform([e, r], t), this.minX = Math.min(this.minX, e), this.minY = Math.min(this.minY, r), this.maxX = Math.max(this.maxX, e), this.maxY = Math.max(this.maxY, r);
  }
  updateRectMinMax(t, e) {
    const r = Ft.applyTransform(e, t), i = Ft.applyTransform(e.slice(2), t), s = Ft.applyTransform([e[0], e[3]], t), o = Ft.applyTransform([e[2], e[1]], t);
    this.minX = Math.min(this.minX, r[0], i[0], s[0], o[0]), this.minY = Math.min(this.minY, r[1], i[1], s[1], o[1]), this.maxX = Math.max(this.maxX, r[0], i[0], s[0], o[0]), this.maxY = Math.max(this.maxY, r[1], i[1], s[1], o[1]);
  }
  updateScalingPathMinMax(t, e) {
    Ft.scaleMinMax(t, e), this.minX = Math.min(this.minX, e[0]), this.minY = Math.min(this.minY, e[1]), this.maxX = Math.max(this.maxX, e[2]), this.maxY = Math.max(this.maxY, e[3]);
  }
  updateCurvePathMinMax(t, e, r, i, s, o, l, u, d, f) {
    const m = Ft.bezierBoundingBox(e, r, i, s, o, l, u, d, f);
    f || this.updateRectMinMax(t, m);
  }
  getPathBoundingBox(t = Ua.FILL, e = null) {
    const r = [this.minX, this.minY, this.maxX, this.maxY];
    if (t === Ua.STROKE) {
      e || Lr("Stroke bounding box must include transform.");
      const i = Ft.singularValueDecompose2dScale(e), s = i[0] * this.lineWidth / 2, o = i[1] * this.lineWidth / 2;
      r[0] -= s, r[1] -= o, r[2] += s, r[3] += o;
    }
    return r;
  }
  updateClipFromPath() {
    const t = Ft.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(t || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === 1 / 0;
  }
  startNewPathAndClipBox(t) {
    this.clipBox = t, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
  }
  getClippedPathBoundingBox(t = Ua.FILL, e = null) {
    return Ft.intersect(this.clipBox, this.getPathBoundingBox(t, e));
  }
}
function jV(n, t) {
  if (typeof ImageData < "u" && t instanceof ImageData) {
    n.putImageData(t, 0, 0);
    return;
  }
  const e = t.height, r = t.width, i = e % Pl, s = (e - i) / Pl, o = i === 0 ? s : s + 1, l = n.createImageData(r, Pl);
  let u = 0, d;
  const f = t.data, m = l.data;
  let v, S, w, E;
  if (t.kind === kR.GRAYSCALE_1BPP) {
    const A = f.byteLength, P = new Uint32Array(m.buffer, 0, m.byteLength >> 2), R = P.length, M = r + 7 >> 3, j = 4294967295, $ = jl.isLittleEndian ? 4278190080 : 255;
    for (v = 0; v < o; v++) {
      for (w = v < s ? Pl : i, d = 0, S = 0; S < w; S++) {
        const U = A - u;
        let F = 0;
        const B = U > M ? r : U * 8 - 7, G = B & -8;
        let X = 0, te = 0;
        for (; F < G; F += 8)
          te = f[u++], P[d++] = te & 128 ? j : $, P[d++] = te & 64 ? j : $, P[d++] = te & 32 ? j : $, P[d++] = te & 16 ? j : $, P[d++] = te & 8 ? j : $, P[d++] = te & 4 ? j : $, P[d++] = te & 2 ? j : $, P[d++] = te & 1 ? j : $;
        for (; F < B; F++)
          X === 0 && (te = f[u++], X = 128), P[d++] = te & X ? j : $, X >>= 1;
      }
      for (; d < R; )
        P[d++] = 0;
      n.putImageData(l, 0, v * Pl);
    }
  } else if (t.kind === kR.RGBA_32BPP) {
    for (S = 0, E = r * Pl * 4, v = 0; v < s; v++)
      m.set(f.subarray(u, u + E)), u += E, n.putImageData(l, 0, S), S += Pl;
    v < o && (E = r * i * 4, m.set(f.subarray(u, u + E)), n.putImageData(l, 0, S));
  } else if (t.kind === kR.RGB_24BPP)
    for (w = Pl, E = r * w, v = 0; v < o; v++) {
      for (v >= s && (w = i, E = r * w), d = 0, S = E; S--; )
        m[d++] = f[u++], m[d++] = f[u++], m[d++] = f[u++], m[d++] = 255;
      n.putImageData(l, 0, v * Pl);
    }
  else
    throw new Error(`bad image kind: ${t.kind}`);
}
function NV(n, t) {
  if (t.bitmap) {
    n.drawImage(t.bitmap, 0, 0);
    return;
  }
  const e = t.height, r = t.width, i = e % Pl, s = (e - i) / Pl, o = i === 0 ? s : s + 1, l = n.createImageData(r, Pl);
  let u = 0;
  const d = t.data, f = l.data;
  for (let m = 0; m < o; m++) {
    const v = m < s ? Pl : i;
    ({
      srcPos: u
    } = zDe({
      src: d,
      srcPos: u,
      dest: f,
      width: r,
      height: v,
      nonBlackColor: 0
    })), n.putImageData(l, 0, m * Pl);
  }
}
function BE(n, t) {
  const e = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const r of e)
    n[r] !== void 0 && (t[r] = n[r]);
  n.setLineDash !== void 0 && (t.setLineDash(n.getLineDash()), t.lineDashOffset = n.lineDashOffset);
}
function UI(n) {
  if (n.strokeStyle = n.fillStyle = "#000000", n.fillRule = "nonzero", n.globalAlpha = 1, n.lineWidth = 1, n.lineCap = "butt", n.lineJoin = "miter", n.miterLimit = 10, n.globalCompositeOperation = "source-over", n.font = "10px sans-serif", n.setLineDash !== void 0 && (n.setLineDash([]), n.lineDashOffset = 0), !va) {
    const {
      filter: t
    } = n;
    t !== "none" && t !== "" && (n.filter = "none");
  }
}
function FV(n, t) {
  if (t)
    return !0;
  const e = Ft.singularValueDecompose2dScale(n);
  e[0] = Math.fround(e[0]), e[1] = Math.fround(e[1]);
  const r = Math.fround((globalThis.devicePixelRatio || 1) * Tm.PDF_TO_CSS_UNITS);
  return e[0] <= r && e[1] <= r;
}
const WDe = ["butt", "round", "square"], GDe = ["miter", "round", "bevel"], KDe = {}, $V = {};
var Am, D$, O$;
const rB = class rB {
  constructor(t, e, r, i, s, {
    optionalContentConfig: o,
    markedContentStack: l = null
  }, u, d) {
    J(this, Am);
    this.ctx = t, this.current = new LV(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = e, this.objs = r, this.canvasFactory = i, this.filterFactory = s, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = l || [], this.optionalContentConfig = o, this.cachedCanvases = new HDe(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = u, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = d, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(t, e = null) {
    return typeof t == "string" ? t.startsWith("g_") ? this.commonObjs.get(t) : this.objs.get(t) : e;
  }
  beginDrawing({
    transform: t,
    viewport: e,
    transparency: r = !1,
    background: i = null
  }) {
    const s = this.ctx.canvas.width, o = this.ctx.canvas.height, l = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, s, o), this.ctx.fillStyle = l, r) {
      const u = this.cachedCanvases.getCanvas("transparent", s, o);
      this.compositeCtx = this.ctx, this.transparentCanvas = u.canvas, this.ctx = u.context, this.ctx.save(), this.ctx.transform(...ki(this.compositeCtx));
    }
    this.ctx.save(), UI(this.ctx), t && (this.ctx.transform(...t), this.outputScaleX = t[0], this.outputScaleY = t[0]), this.ctx.transform(...e.transform), this.viewportScale = e.scale, this.baseTransform = ki(this.ctx);
  }
  executeOperatorList(t, e, r, i) {
    const s = t.argsArray, o = t.fnArray;
    let l = e || 0;
    const u = s.length;
    if (u === l)
      return l;
    const d = u - l > DV && typeof r == "function", f = d ? Date.now() + UDe : 0;
    let m = 0;
    const v = this.commonObjs, S = this.objs;
    let w;
    for (; ; ) {
      if (i !== void 0 && l === i.nextBreakPoint)
        return i.breakIt(l, r), l;
      if (w = o[l], w !== Bu.dependency)
        this[w].apply(this, s[l]);
      else
        for (const E of s[l]) {
          const A = E.startsWith("g_") ? v : S;
          if (!A.has(E))
            return A.get(E, r), l;
        }
      if (l++, l === u)
        return l;
      if (d && ++m > DV) {
        if (Date.now() > f)
          return r(), l;
        m = 0;
      }
    }
  }
  endDrawing() {
    Q(this, Am, D$).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const t of this._cachedBitmapsMap.values()) {
      for (const e of t.values())
        typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && (e.width = e.height = 0);
      t.clear();
    }
    this._cachedBitmapsMap.clear(), Q(this, Am, O$).call(this);
  }
  _scaleImage(t, e) {
    const r = t.width, i = t.height;
    let s = Math.max(Math.hypot(e[0], e[1]), 1), o = Math.max(Math.hypot(e[2], e[3]), 1), l = r, u = i, d = "prescale1", f, m;
    for (; s > 2 && l > 1 || o > 2 && u > 1; ) {
      let v = l, S = u;
      s > 2 && l > 1 && (v = l >= 16384 ? Math.floor(l / 2) - 1 || 1 : Math.ceil(l / 2), s /= l / v), o > 2 && u > 1 && (S = u >= 16384 ? Math.floor(u / 2) - 1 || 1 : Math.ceil(u) / 2, o /= u / S), f = this.cachedCanvases.getCanvas(d, v, S), m = f.context, m.clearRect(0, 0, v, S), m.drawImage(t, 0, 0, l, u, 0, 0, v, S), t = f.canvas, l = v, u = S, d = d === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: t,
      paintWidth: l,
      paintHeight: u
    };
  }
  _createMaskCanvas(t) {
    const e = this.ctx, {
      width: r,
      height: i
    } = t, s = this.current.fillColor, o = this.current.patternFill, l = ki(e);
    let u, d, f, m;
    if ((t.bitmap || t.data) && t.count > 1) {
      const B = t.bitmap || t.data.buffer;
      d = JSON.stringify(o ? l : [l.slice(0, 4), s]), u = this._cachedBitmapsMap.get(B), u || (u = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(B, u));
      const G = u.get(d);
      if (G && !o) {
        const X = Math.round(Math.min(l[0], l[2]) + l[4]), te = Math.round(Math.min(l[1], l[3]) + l[5]);
        return {
          canvas: G,
          offsetX: X,
          offsetY: te
        };
      }
      f = G;
    }
    f || (m = this.cachedCanvases.getCanvas("maskCanvas", r, i), NV(m.context, t));
    let v = Ft.transform(l, [1 / r, 0, 0, -1 / i, 0, 0]);
    v = Ft.transform(v, [1, 0, 0, 1, 0, -i]);
    const [S, w, E, A] = Ft.getAxialAlignedBoundingBox([0, 0, r, i], v), P = Math.round(E - S) || 1, R = Math.round(A - w) || 1, M = this.cachedCanvases.getCanvas("fillCanvas", P, R), j = M.context, $ = S, U = w;
    j.translate(-$, -U), j.transform(...v), f || (f = this._scaleImage(m.canvas, Pf(j)), f = f.img, u && o && u.set(d, f)), j.imageSmoothingEnabled = FV(ki(j), t.interpolate), zI(j, f, 0, 0, f.width, f.height, 0, 0, r, i), j.globalCompositeOperation = "source-in";
    const F = Ft.transform(Pf(j), [1, 0, 0, 1, -$, -U]);
    return j.fillStyle = o ? s.getPattern(e, this, F, Ua.FILL) : s, j.fillRect(0, 0, r, i), u && !o && (this.cachedCanvases.delete("fillCanvas"), u.set(d, M.canvas)), {
      canvas: M.canvas,
      offsetX: Math.round($),
      offsetY: Math.round(U)
    };
  }
  setLineWidth(t) {
    t !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = t, this.ctx.lineWidth = t;
  }
  setLineCap(t) {
    this.ctx.lineCap = WDe[t];
  }
  setLineJoin(t) {
    this.ctx.lineJoin = GDe[t];
  }
  setMiterLimit(t) {
    this.ctx.miterLimit = t;
  }
  setDash(t, e) {
    const r = this.ctx;
    r.setLineDash !== void 0 && (r.setLineDash(t), r.lineDashOffset = e);
  }
  setRenderingIntent(t) {
  }
  setFlatness(t) {
  }
  setGState(t) {
    for (const [e, r] of t)
      switch (e) {
        case "LW":
          this.setLineWidth(r);
          break;
        case "LC":
          this.setLineCap(r);
          break;
        case "LJ":
          this.setLineJoin(r);
          break;
        case "ML":
          this.setMiterLimit(r);
          break;
        case "D":
          this.setDash(r[0], r[1]);
          break;
        case "RI":
          this.setRenderingIntent(r);
          break;
        case "FL":
          this.setFlatness(r);
          break;
        case "Font":
          this.setFont(r[0], r[1]);
          break;
        case "CA":
          this.current.strokeAlpha = r;
          break;
        case "ca":
          this.current.fillAlpha = r, this.ctx.globalAlpha = r;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = r;
          break;
        case "SMask":
          this.current.activeSMask = r ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(r);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const t = this.inSMaskMode;
    this.current.activeSMask && !t ? this.beginSMaskMode() : !this.current.activeSMask && t && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const t = this.ctx.canvas.width, e = this.ctx.canvas.height, r = "smaskGroupAt" + this.groupLevel, i = this.cachedCanvases.getCanvas(r, t, e);
    this.suspendedCtx = this.ctx, this.ctx = i.context;
    const s = this.ctx;
    s.setTransform(...ki(this.suspendedCtx)), BE(this.suspendedCtx, s), BDe(s, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), BE(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(t) {
    if (!this.current.activeSMask)
      return;
    t ? (t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.ceil(t[2]), t[3] = Math.ceil(t[3])) : t = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const e = this.current.activeSMask, r = this.suspendedCtx;
    this.composeSMask(r, e, this.ctx, t), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(t, e, r, i) {
    const s = i[0], o = i[1], l = i[2] - s, u = i[3] - o;
    l === 0 || u === 0 || (this.genericComposeSMask(e.context, r, l, u, e.subtype, e.backdrop, e.transferMap, s, o, e.offsetX, e.offsetY), t.save(), t.globalAlpha = 1, t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(r.canvas, 0, 0), t.restore());
  }
  genericComposeSMask(t, e, r, i, s, o, l, u, d, f, m) {
    let v = t.canvas, S = u - f, w = d - m;
    if (o) {
      if (S < 0 || w < 0 || S + r > v.width || w + i > v.height) {
        const A = this.cachedCanvases.getCanvas("maskExtension", r, i), P = A.context;
        P.drawImage(v, -S, -w), o.some((R) => R !== 0) && (P.globalCompositeOperation = "destination-atop", P.fillStyle = Ft.makeHexColor(...o), P.fillRect(0, 0, r, i), P.globalCompositeOperation = "source-over"), v = A.canvas, S = w = 0;
      } else if (o.some((A) => A !== 0)) {
        t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0);
        const A = new Path2D();
        A.rect(S, w, r, i), t.clip(A), t.globalCompositeOperation = "destination-atop", t.fillStyle = Ft.makeHexColor(...o), t.fillRect(S, w, r, i), t.restore();
      }
    }
    e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0), s === "Alpha" && l ? e.filter = this.filterFactory.addAlphaFilter(l) : s === "Luminosity" && (e.filter = this.filterFactory.addLuminosityFilter(l));
    const E = new Path2D();
    E.rect(u, d, r, i), e.clip(E), e.globalCompositeOperation = "destination-in", e.drawImage(v, S, w, r, i, u, d, r, i), e.restore();
  }
  save() {
    this.inSMaskMode ? (BE(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
    const t = this.current;
    this.stateStack.push(t), this.current = t.clone();
  }
  restore() {
    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), BE(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
  }
  transform(t, e, r, i, s, o) {
    this.ctx.transform(t, e, r, i, s, o), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(t, e, r) {
    const i = this.ctx, s = this.current;
    let o = s.x, l = s.y, u, d;
    const f = ki(i), m = f[0] === 0 && f[3] === 0 || f[1] === 0 && f[2] === 0, v = m ? r.slice(0) : null;
    for (let S = 0, w = 0, E = t.length; S < E; S++)
      switch (t[S] | 0) {
        case Bu.rectangle:
          o = e[w++], l = e[w++];
          const A = e[w++], P = e[w++], R = o + A, M = l + P;
          i.moveTo(o, l), A === 0 || P === 0 ? i.lineTo(R, M) : (i.lineTo(R, l), i.lineTo(R, M), i.lineTo(o, M)), m || s.updateRectMinMax(f, [o, l, R, M]), i.closePath();
          break;
        case Bu.moveTo:
          o = e[w++], l = e[w++], i.moveTo(o, l), m || s.updatePathMinMax(f, o, l);
          break;
        case Bu.lineTo:
          o = e[w++], l = e[w++], i.lineTo(o, l), m || s.updatePathMinMax(f, o, l);
          break;
        case Bu.curveTo:
          u = o, d = l, o = e[w + 4], l = e[w + 5], i.bezierCurveTo(e[w], e[w + 1], e[w + 2], e[w + 3], o, l), s.updateCurvePathMinMax(f, u, d, e[w], e[w + 1], e[w + 2], e[w + 3], o, l, v), w += 6;
          break;
        case Bu.curveTo2:
          u = o, d = l, i.bezierCurveTo(o, l, e[w], e[w + 1], e[w + 2], e[w + 3]), s.updateCurvePathMinMax(f, u, d, o, l, e[w], e[w + 1], e[w + 2], e[w + 3], v), o = e[w + 2], l = e[w + 3], w += 4;
          break;
        case Bu.curveTo3:
          u = o, d = l, o = e[w + 2], l = e[w + 3], i.bezierCurveTo(e[w], e[w + 1], o, l, o, l), s.updateCurvePathMinMax(f, u, d, e[w], e[w + 1], o, l, o, l, v), w += 4;
          break;
        case Bu.closePath:
          i.closePath();
          break;
      }
    m && s.updateScalingPathMinMax(f, v), s.setCurrentPoint(o, l);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(t = !0) {
    const e = this.ctx, r = this.current.strokeColor;
    e.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof r == "object" && (r != null && r.getPattern) ? (e.save(), e.strokeStyle = r.getPattern(e, this, Pf(e), Ua.STROKE), this.rescaleAndStroke(!1), e.restore()) : this.rescaleAndStroke(!0)), t && this.consumePath(this.current.getClippedPathBoundingBox()), e.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath(), this.stroke();
  }
  fill(t = !0) {
    const e = this.ctx, r = this.current.fillColor, i = this.current.patternFill;
    let s = !1;
    i && (e.save(), e.fillStyle = r.getPattern(e, this, Pf(e), Ua.FILL), s = !0);
    const o = this.current.getClippedPathBoundingBox();
    this.contentVisible && o !== null && (this.pendingEOFill ? (e.fill("evenodd"), this.pendingEOFill = !1) : e.fill()), s && e.restore(), t && this.consumePath(o);
  }
  eoFill() {
    this.pendingEOFill = !0, this.fill();
  }
  fillStroke() {
    this.fill(!1), this.stroke(!1), this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = !0, this.fillStroke();
  }
  closeFillStroke() {
    this.closePath(), this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = !0, this.closePath(), this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = KDe;
  }
  eoClip() {
    this.pendingClip = $V;
  }
  beginText() {
    this.current.textMatrix = UJ, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  endText() {
    const t = this.pendingTextPaths, e = this.ctx;
    if (t === void 0) {
      e.beginPath();
      return;
    }
    e.save(), e.beginPath();
    for (const r of t)
      e.setTransform(...r.transform), e.translate(r.x, r.y), r.addToPath(e, r.fontSize);
    e.restore(), e.clip(), e.beginPath(), delete this.pendingTextPaths;
  }
  setCharSpacing(t) {
    this.current.charSpacing = t;
  }
  setWordSpacing(t) {
    this.current.wordSpacing = t;
  }
  setHScale(t) {
    this.current.textHScale = t / 100;
  }
  setLeading(t) {
    this.current.leading = -t;
  }
  setFont(t, e) {
    var f;
    const r = this.commonObjs.get(t), i = this.current;
    if (!r)
      throw new Error(`Can't find font for ${t}`);
    if (i.fontMatrix = r.fontMatrix || i$, (i.fontMatrix[0] === 0 || i.fontMatrix[3] === 0) && In("Invalid font matrix for font " + t), e < 0 ? (e = -e, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = r, this.current.fontSize = e, r.isType3Font)
      return;
    const s = r.loadedName || "sans-serif", o = ((f = r.systemFontInfo) == null ? void 0 : f.css) || `"${s}", ${r.fallbackName}`;
    let l = "normal";
    r.black ? l = "900" : r.bold && (l = "bold");
    const u = r.italic ? "italic" : "normal";
    let d = e;
    e < RV ? d = RV : e > MV && (d = MV), this.current.fontSizeScale = e / d, this.ctx.font = `${u} ${l} ${d}px ${o}`;
  }
  setTextRenderingMode(t) {
    this.current.textRenderingMode = t;
  }
  setTextRise(t) {
    this.current.textRise = t;
  }
  moveText(t, e) {
    this.current.x = this.current.lineX += t, this.current.y = this.current.lineY += e;
  }
  setLeadingMoveText(t, e) {
    this.setLeading(-e), this.moveText(t, e);
  }
  setTextMatrix(t, e, r, i, s, o) {
    this.current.textMatrix = [t, e, r, i, s, o], this.current.textMatrixScale = Math.hypot(t, e), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(t, e, r, i) {
    const s = this.ctx, o = this.current, l = o.font, u = o.textRenderingMode, d = o.fontSize / o.fontSizeScale, f = u & sa.FILL_STROKE_MASK, m = !!(u & sa.ADD_TO_PATH_FLAG), v = o.patternFill && !l.missingFile;
    let S;
    (l.disableFontFace || m || v) && (S = l.getPathGenerator(this.commonObjs, t)), l.disableFontFace || v ? (s.save(), s.translate(e, r), s.beginPath(), S(s, d), i && s.setTransform(...i), (f === sa.FILL || f === sa.FILL_STROKE) && s.fill(), (f === sa.STROKE || f === sa.FILL_STROKE) && s.stroke(), s.restore()) : ((f === sa.FILL || f === sa.FILL_STROKE) && s.fillText(t, e, r), (f === sa.STROKE || f === sa.FILL_STROKE) && s.strokeText(t, e, r)), m && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
      transform: ki(s),
      x: e,
      y: r,
      fontSize: d,
      addToPath: S
    });
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: t
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    t.scale(1.5, 1), t.fillText("I", 0, 10);
    const e = t.getImageData(0, 0, 10, 10).data;
    let r = !1;
    for (let i = 3; i < e.length; i += 4)
      if (e[i] > 0 && e[i] < 255) {
        r = !0;
        break;
      }
    return lr(this, "isFontSubpixelAAEnabled", r);
  }
  showText(t) {
    const e = this.current, r = e.font;
    if (r.isType3Font)
      return this.showType3Text(t);
    const i = e.fontSize;
    if (i === 0)
      return;
    const s = this.ctx, o = e.fontSizeScale, l = e.charSpacing, u = e.wordSpacing, d = e.fontDirection, f = e.textHScale * d, m = t.length, v = r.vertical, S = v ? 1 : -1, w = r.defaultVMetrics, E = i * e.fontMatrix[0], A = e.textRenderingMode === sa.FILL && !r.disableFontFace && !e.patternFill;
    s.save(), s.transform(...e.textMatrix), s.translate(e.x, e.y + e.textRise), d > 0 ? s.scale(f, -1) : s.scale(f, 1);
    let P;
    if (e.patternFill) {
      s.save();
      const U = e.fillColor.getPattern(s, this, Pf(s), Ua.FILL);
      P = ki(s), s.restore(), s.fillStyle = U;
    }
    let R = e.lineWidth;
    const M = e.textMatrixScale;
    if (M === 0 || R === 0) {
      const U = e.textRenderingMode & sa.FILL_STROKE_MASK;
      (U === sa.STROKE || U === sa.FILL_STROKE) && (R = this.getSinglePixelWidth());
    } else
      R /= M;
    if (o !== 1 && (s.scale(o, o), R /= o), s.lineWidth = R, r.isInvalidPDFjsFont) {
      const U = [];
      let F = 0;
      for (const B of t)
        U.push(B.unicode), F += B.width;
      s.fillText(U.join(""), 0, 0), e.x += F * E * f, s.restore(), this.compose();
      return;
    }
    let j = 0, $;
    for ($ = 0; $ < m; ++$) {
      const U = t[$];
      if (typeof U == "number") {
        j += S * U * i / 1e3;
        continue;
      }
      let F = !1;
      const B = (U.isSpace ? u : 0) + l, G = U.fontChar, X = U.accent;
      let te, ne, K = U.width;
      if (v) {
        const oe = U.vmetric || w, fe = -(U.vmetric ? oe[1] : K * 0.5) * E, ie = oe[2] * E;
        K = oe ? -oe[0] : K, te = fe / o, ne = (j + ie) / o;
      } else
        te = j / o, ne = 0;
      if (r.remeasure && K > 0) {
        const oe = s.measureText(G).width * 1e3 / i * o;
        if (K < oe && this.isFontSubpixelAAEnabled) {
          const fe = K / oe;
          F = !0, s.save(), s.scale(fe, 1), te /= fe;
        } else K !== oe && (te += (K - oe) / 2e3 * i / o);
      }
      if (this.contentVisible && (U.isInFont || r.missingFile)) {
        if (A && !X)
          s.fillText(G, te, ne);
        else if (this.paintChar(G, te, ne, P), X) {
          const oe = te + i * X.offset.x / o, fe = ne - i * X.offset.y / o;
          this.paintChar(X.fontChar, oe, fe, P);
        }
      }
      const Z = v ? K * E - B * d : K * E + B * d;
      j += Z, F && s.restore();
    }
    v ? e.y -= j : e.x += j * f, s.restore(), this.compose();
  }
  showType3Text(t) {
    const e = this.ctx, r = this.current, i = r.font, s = r.fontSize, o = r.fontDirection, l = i.vertical ? 1 : -1, u = r.charSpacing, d = r.wordSpacing, f = r.textHScale * o, m = r.fontMatrix || i$, v = t.length, S = r.textRenderingMode === sa.INVISIBLE;
    let w, E, A, P;
    if (!(S || s === 0)) {
      for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, e.save(), e.transform(...r.textMatrix), e.translate(r.x, r.y), e.scale(f, o), w = 0; w < v; ++w) {
        if (E = t[w], typeof E == "number") {
          P = l * E * s / 1e3, this.ctx.translate(P, 0), r.x += P * f;
          continue;
        }
        const R = (E.isSpace ? d : 0) + u, M = i.charProcOperatorList[E.operatorListId];
        if (!M) {
          In(`Type3 character "${E.operatorListId}" is not available.`);
          continue;
        }
        this.contentVisible && (this.processingType3 = E, this.save(), e.scale(s, s), e.transform(...m), this.executeOperatorList(M), this.restore()), A = Ft.applyTransform([E.width, 0], m)[0] * s + R, e.translate(A, 0), r.x += A * f;
      }
      e.restore(), this.processingType3 = null;
    }
  }
  setCharWidth(t, e) {
  }
  setCharWidthAndBounds(t, e, r, i, s, o) {
    this.ctx.rect(r, i, s - r, o - i), this.ctx.clip(), this.endPath();
  }
  getColorN_Pattern(t) {
    let e;
    if (t[0] === "TilingPattern") {
      const r = t[1], i = this.baseTransform || ki(this.ctx), s = {
        createCanvasGraphics: (o) => new rB(o, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      e = new M$(t, r, this.ctx, s, i);
    } else
      e = this._getPattern(t[1], t[2]);
    return e;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
  }
  setStrokeRGBColor(t, e, r) {
    const i = Ft.makeHexColor(t, e, r);
    this.ctx.strokeStyle = i, this.current.strokeColor = i;
  }
  setFillRGBColor(t, e, r) {
    const i = Ft.makeHexColor(t, e, r);
    this.ctx.fillStyle = i, this.current.fillColor = i, this.current.patternFill = !1;
  }
  _getPattern(t, e = null) {
    let r;
    return this.cachedPatterns.has(t) ? r = this.cachedPatterns.get(t) : (r = $De(this.getObject(t)), this.cachedPatterns.set(t, r)), e && (r.matrix = e), r;
  }
  shadingFill(t) {
    if (!this.contentVisible)
      return;
    const e = this.ctx;
    this.save();
    const r = this._getPattern(t);
    e.fillStyle = r.getPattern(e, this, Pf(e), Ua.SHADING);
    const i = Pf(e);
    if (i) {
      const {
        width: s,
        height: o
      } = e.canvas, [l, u, d, f] = Ft.getAxialAlignedBoundingBox([0, 0, s, o], i);
      this.ctx.fillRect(l, u, d - l, f - u);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox()), this.restore();
  }
  beginInlineImage() {
    Lr("Should not call beginInlineImage");
  }
  beginImageData() {
    Lr("Should not call beginImageData");
  }
  paintFormXObjectBegin(t, e) {
    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), t && this.transform(...t), this.baseTransform = ki(this.ctx), e)) {
      const r = e[2] - e[0], i = e[3] - e[1];
      this.ctx.rect(e[0], e[1], r, i), this.current.updateRectMinMax(ki(this.ctx), e), this.clip(), this.endPath();
    }
  }
  paintFormXObjectEnd() {
    this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(t) {
    if (!this.contentVisible)
      return;
    this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const e = this.ctx;
    t.isolated || mD("TODO: Support non-isolated groups."), t.knockout && In("Knockout groups not supported.");
    const r = ki(e);
    if (t.matrix && e.transform(...t.matrix), !t.bbox)
      throw new Error("Bounding box is required.");
    let i = Ft.getAxialAlignedBoundingBox(t.bbox, ki(e));
    const s = [0, 0, e.canvas.width, e.canvas.height];
    i = Ft.intersect(i, s) || [0, 0, 0, 0];
    const o = Math.floor(i[0]), l = Math.floor(i[1]), u = Math.max(Math.ceil(i[2]) - o, 1), d = Math.max(Math.ceil(i[3]) - l, 1);
    this.current.startNewPathAndClipBox([0, 0, u, d]);
    let f = "groupAt" + this.groupLevel;
    t.smask && (f += "_smask_" + this.smaskCounter++ % 2);
    const m = this.cachedCanvases.getCanvas(f, u, d), v = m.context;
    v.translate(-o, -l), v.transform(...r), t.smask ? this.smaskStack.push({
      canvas: m.canvas,
      context: v,
      offsetX: o,
      offsetY: l,
      subtype: t.smask.subtype,
      backdrop: t.smask.backdrop,
      transferMap: t.smask.transferMap || null,
      startTransformInverse: null
    }) : (e.setTransform(1, 0, 0, 1, 0, 0), e.translate(o, l), e.save()), BE(e, v), this.ctx = v, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(e), this.groupLevel++;
  }
  endGroup(t) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const e = this.ctx, r = this.groupStack.pop();
    if (this.ctx = r, this.ctx.imageSmoothingEnabled = !1, t.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore();
    else {
      this.ctx.restore();
      const i = ki(this.ctx);
      this.restore(), this.ctx.save(), this.ctx.setTransform(...i);
      const s = Ft.getAxialAlignedBoundingBox([0, 0, e.canvas.width, e.canvas.height], i);
      this.ctx.drawImage(e.canvas, 0, 0), this.ctx.restore(), this.compose(s);
    }
  }
  beginAnnotation(t, e, r, i, s) {
    if (Q(this, Am, D$).call(this), UI(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), e) {
      const o = e[2] - e[0], l = e[3] - e[1];
      if (s && this.annotationCanvasMap) {
        r = r.slice(), r[4] -= e[0], r[5] -= e[1], e = e.slice(), e[0] = e[1] = 0, e[2] = o, e[3] = l;
        const [u, d] = Ft.singularValueDecompose2dScale(ki(this.ctx)), {
          viewportScale: f
        } = this, m = Math.ceil(o * this.outputScaleX * f), v = Math.ceil(l * this.outputScaleY * f);
        this.annotationCanvas = this.canvasFactory.create(m, v);
        const {
          canvas: S,
          context: w
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(t, S), this.annotationCanvas.savedCtx = this.ctx, this.ctx = w, this.ctx.save(), this.ctx.setTransform(u, 0, 0, -d, 0, l * d), UI(this.ctx);
      } else
        UI(this.ctx), this.ctx.rect(e[0], e[1], o, l), this.ctx.clip(), this.endPath();
    }
    this.current = new LV(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...r), this.transform(...i);
  }
  endAnnotation() {
    this.annotationCanvas && (this.ctx.restore(), Q(this, Am, O$).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(t) {
    if (!this.contentVisible)
      return;
    const e = t.count;
    t = this.getObject(t.data, t), t.count = e;
    const r = this.ctx, i = this.processingType3;
    if (i && (i.compiled === void 0 && (i.compiled = VDe(t)), i.compiled)) {
      i.compiled(r);
      return;
    }
    const s = this._createMaskCanvas(t), o = s.canvas;
    r.save(), r.setTransform(1, 0, 0, 1, 0, 0), r.drawImage(o, s.offsetX, s.offsetY), r.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(t, e, r = 0, i = 0, s, o) {
    if (!this.contentVisible)
      return;
    t = this.getObject(t.data, t);
    const l = this.ctx;
    l.save();
    const u = ki(l);
    l.transform(e, r, i, s, 0, 0);
    const d = this._createMaskCanvas(t);
    l.setTransform(1, 0, 0, 1, d.offsetX - u[4], d.offsetY - u[5]);
    for (let f = 0, m = o.length; f < m; f += 2) {
      const v = Ft.transform(u, [e, r, i, s, o[f], o[f + 1]]), [S, w] = Ft.applyTransform([0, 0], v);
      l.drawImage(d.canvas, S, w);
    }
    l.restore(), this.compose();
  }
  paintImageMaskXObjectGroup(t) {
    if (!this.contentVisible)
      return;
    const e = this.ctx, r = this.current.fillColor, i = this.current.patternFill;
    for (const s of t) {
      const {
        data: o,
        width: l,
        height: u,
        transform: d
      } = s, f = this.cachedCanvases.getCanvas("maskCanvas", l, u), m = f.context;
      m.save();
      const v = this.getObject(o, s);
      NV(m, v), m.globalCompositeOperation = "source-in", m.fillStyle = i ? r.getPattern(m, this, Pf(e), Ua.FILL) : r, m.fillRect(0, 0, l, u), m.restore(), e.save(), e.transform(...d), e.scale(1, -1), zI(e, f.canvas, 0, 0, l, u, 0, -1, 1, 1), e.restore();
    }
    this.compose();
  }
  paintImageXObject(t) {
    if (!this.contentVisible)
      return;
    const e = this.getObject(t);
    if (!e) {
      In("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(e);
  }
  paintImageXObjectRepeat(t, e, r, i) {
    if (!this.contentVisible)
      return;
    const s = this.getObject(t);
    if (!s) {
      In("Dependent image isn't ready yet");
      return;
    }
    const o = s.width, l = s.height, u = [];
    for (let d = 0, f = i.length; d < f; d += 2)
      u.push({
        transform: [e, 0, 0, r, i[d], i[d + 1]],
        x: 0,
        y: 0,
        w: o,
        h: l
      });
    this.paintInlineImageXObjectGroup(s, u);
  }
  applyTransferMapsToCanvas(t) {
    return this.current.transferMaps !== "none" && (t.filter = this.current.transferMaps, t.drawImage(t.canvas, 0, 0), t.filter = "none"), t.canvas;
  }
  applyTransferMapsToBitmap(t) {
    if (this.current.transferMaps === "none")
      return t.bitmap;
    const {
      bitmap: e,
      width: r,
      height: i
    } = t, s = this.cachedCanvases.getCanvas("inlineImage", r, i), o = s.context;
    return o.filter = this.current.transferMaps, o.drawImage(e, 0, 0), o.filter = "none", s.canvas;
  }
  paintInlineImageXObject(t) {
    if (!this.contentVisible)
      return;
    const e = t.width, r = t.height, i = this.ctx;
    if (this.save(), !va) {
      const {
        filter: l
      } = i;
      l !== "none" && l !== "" && (i.filter = "none");
    }
    i.scale(1 / e, -1 / r);
    let s;
    if (t.bitmap)
      s = this.applyTransferMapsToBitmap(t);
    else if (typeof HTMLElement == "function" && t instanceof HTMLElement || !t.data)
      s = t;
    else {
      const u = this.cachedCanvases.getCanvas("inlineImage", e, r).context;
      jV(u, t), s = this.applyTransferMapsToCanvas(u);
    }
    const o = this._scaleImage(s, Pf(i));
    i.imageSmoothingEnabled = FV(ki(i), t.interpolate), zI(i, o.img, 0, 0, o.paintWidth, o.paintHeight, 0, -r, e, r), this.compose(), this.restore();
  }
  paintInlineImageXObjectGroup(t, e) {
    if (!this.contentVisible)
      return;
    const r = this.ctx;
    let i;
    if (t.bitmap)
      i = t.bitmap;
    else {
      const s = t.width, o = t.height, u = this.cachedCanvases.getCanvas("inlineImage", s, o).context;
      jV(u, t), i = this.applyTransferMapsToCanvas(u);
    }
    for (const s of e)
      r.save(), r.transform(...s.transform), r.scale(1, -1), zI(r, i, s.x, s.y, s.w, s.h, 0, -1, 1, 1), r.restore();
    this.compose();
  }
  paintSolidColorImageMask() {
    this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(t) {
  }
  markPointProps(t, e) {
  }
  beginMarkedContent(t) {
    this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(t, e) {
    t === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(e)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(t) {
    const e = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(t);
    const r = this.ctx;
    this.pendingClip && (e || (this.pendingClip === $V ? r.clip("evenodd") : r.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), r.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const t = ki(this.ctx);
      if (t[1] === 0 && t[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t[0]), Math.abs(t[3]));
      else {
        const e = Math.abs(t[0] * t[3] - t[2] * t[1]), r = Math.hypot(t[0], t[2]), i = Math.hypot(t[1], t[3]);
        this._cachedGetSinglePixelWidth = Math.max(r, i) / e;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: t
      } = this.current, {
        a: e,
        b: r,
        c: i,
        d: s
      } = this.ctx.getTransform();
      let o, l;
      if (r === 0 && i === 0) {
        const u = Math.abs(e), d = Math.abs(s);
        if (u === d)
          if (t === 0)
            o = l = 1 / u;
          else {
            const f = u * t;
            o = l = f < 1 ? 1 / f : 1;
          }
        else if (t === 0)
          o = 1 / u, l = 1 / d;
        else {
          const f = u * t, m = d * t;
          o = f < 1 ? 1 / f : 1, l = m < 1 ? 1 / m : 1;
        }
      } else {
        const u = Math.abs(e * s - r * i), d = Math.hypot(e, r), f = Math.hypot(i, s);
        if (t === 0)
          o = f / u, l = d / u;
        else {
          const m = t * u;
          o = f > m ? f / m : 1, l = d > m ? d / m : 1;
        }
      }
      this._cachedScaleForStroking[0] = o, this._cachedScaleForStroking[1] = l;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(t) {
    const {
      ctx: e
    } = this, {
      lineWidth: r
    } = this.current, [i, s] = this.getScaleForStroking();
    if (e.lineWidth = r || 1, i === 1 && s === 1) {
      e.stroke();
      return;
    }
    const o = e.getLineDash();
    if (t && e.save(), e.scale(i, s), o.length > 0) {
      const l = Math.max(i, s);
      e.setLineDash(o.map((u) => u / l)), e.lineDashOffset /= l;
    }
    e.stroke(), t && e.restore();
  }
  isContentVisible() {
    for (let t = this.markedContentStack.length - 1; t >= 0; t--)
      if (!this.markedContentStack[t].visible)
        return !1;
    return !0;
  }
};
Am = new WeakSet(), D$ = function() {
  for (; this.stateStack.length || this.inSMaskMode; )
    this.restore();
  this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
}, O$ = function() {
  if (this.pageColors) {
    const t = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (t !== "none") {
      const e = this.ctx.filter;
      this.ctx.filter = t, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = e;
    }
  }
};
let q0 = rB;
for (const n in Bu)
  q0.prototype[n] !== void 0 && (q0.prototype[Bu[n]] = q0.prototype[n]);
var k_, I_;
class fp {
  static get workerPort() {
    return _(this, k_);
  }
  static set workerPort(t) {
    if (!(typeof Worker < "u" && t instanceof Worker) && t !== null)
      throw new Error("Invalid `workerPort` type.");
    q(this, k_, t);
  }
  static get workerSrc() {
    return _(this, I_);
  }
  static set workerSrc(t) {
    if (typeof t != "string")
      throw new Error("Invalid `workerSrc` type.");
    q(this, I_, t);
  }
}
k_ = new WeakMap(), I_ = new WeakMap(), J(fp, k_, null), J(fp, I_, "");
const BI = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
}, vs = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function tc(n) {
  switch (n instanceof Error || typeof n == "object" && n !== null || Lr('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), n.name) {
    case "AbortException":
      return new _S(n.message);
    case "MissingPDFException":
      return new ES(n.message);
    case "PasswordException":
      return new o$(n.message, n.code);
    case "UnexpectedResponseException":
      return new vD(n.message, n.status);
    case "UnknownErrorException":
      return new a$(n.message, n.details);
    default:
      return new a$(n.message, n.toString());
  }
}
var Eh, Eee, _ee, LR;
class m1 {
  constructor(t, e, r) {
    J(this, Eh);
    this.sourceName = t, this.targetName = e, this.comObj = r, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (i) => {
      const s = i.data;
      if (s.targetName !== this.sourceName)
        return;
      if (s.stream) {
        Q(this, Eh, _ee).call(this, s);
        return;
      }
      if (s.callback) {
        const l = s.callbackId, u = this.callbackCapabilities[l];
        if (!u)
          throw new Error(`Cannot resolve callback ${l}`);
        if (delete this.callbackCapabilities[l], s.callback === BI.DATA)
          u.resolve(s.data);
        else if (s.callback === BI.ERROR)
          u.reject(tc(s.reason));
        else
          throw new Error("Unexpected callback case");
        return;
      }
      const o = this.actionHandler[s.action];
      if (!o)
        throw new Error(`Unknown action from worker: ${s.action}`);
      if (s.callbackId) {
        const l = this.sourceName, u = s.sourceName;
        new Promise(function(d) {
          d(o(s.data));
        }).then(function(d) {
          r.postMessage({
            sourceName: l,
            targetName: u,
            callback: BI.DATA,
            callbackId: s.callbackId,
            data: d
          });
        }, function(d) {
          r.postMessage({
            sourceName: l,
            targetName: u,
            callback: BI.ERROR,
            callbackId: s.callbackId,
            reason: tc(d)
          });
        });
        return;
      }
      if (s.streamId) {
        Q(this, Eh, Eee).call(this, s);
        return;
      }
      o(s.data);
    }, r.addEventListener("message", this._onComObjOnMessage);
  }
  on(t, e) {
    const r = this.actionHandler;
    if (r[t])
      throw new Error(`There is already an actionName called "${t}"`);
    r[t] = e;
  }
  send(t, e, r) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: t,
      data: e
    }, r);
  }
  sendWithPromise(t, e, r) {
    const i = this.callbackId++, s = Promise.withResolvers();
    this.callbackCapabilities[i] = s;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: t,
        callbackId: i,
        data: e
      }, r);
    } catch (o) {
      s.reject(o);
    }
    return s.promise;
  }
  sendWithStream(t, e, r, i) {
    const s = this.streamId++, o = this.sourceName, l = this.targetName, u = this.comObj;
    return new ReadableStream({
      start: (d) => {
        const f = Promise.withResolvers();
        return this.streamControllers[s] = {
          controller: d,
          startCall: f,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, u.postMessage({
          sourceName: o,
          targetName: l,
          action: t,
          streamId: s,
          data: e,
          desiredSize: d.desiredSize
        }, i), f.promise;
      },
      pull: (d) => {
        const f = Promise.withResolvers();
        return this.streamControllers[s].pullCall = f, u.postMessage({
          sourceName: o,
          targetName: l,
          stream: vs.PULL,
          streamId: s,
          desiredSize: d.desiredSize
        }), f.promise;
      },
      cancel: (d) => {
        zs(d instanceof Error, "cancel must have a valid reason");
        const f = Promise.withResolvers();
        return this.streamControllers[s].cancelCall = f, this.streamControllers[s].isClosed = !0, u.postMessage({
          sourceName: o,
          targetName: l,
          stream: vs.CANCEL,
          streamId: s,
          reason: tc(d)
        }), f.promise;
      }
    }, r);
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
Eh = new WeakSet(), Eee = function(t) {
  const e = t.streamId, r = this.sourceName, i = t.sourceName, s = this.comObj, o = this, l = this.actionHandler[t.action], u = {
    enqueue(d, f = 1, m) {
      if (this.isCancelled)
        return;
      const v = this.desiredSize;
      this.desiredSize -= f, v > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), s.postMessage({
        sourceName: r,
        targetName: i,
        stream: vs.ENQUEUE,
        streamId: e,
        chunk: d
      }, m);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, s.postMessage({
        sourceName: r,
        targetName: i,
        stream: vs.CLOSE,
        streamId: e
      }), delete o.streamSinks[e]);
    },
    error(d) {
      zs(d instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, s.postMessage({
        sourceName: r,
        targetName: i,
        stream: vs.ERROR,
        streamId: e,
        reason: tc(d)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: t.desiredSize,
    ready: null
  };
  u.sinkCapability.resolve(), u.ready = u.sinkCapability.promise, this.streamSinks[e] = u, new Promise(function(d) {
    d(l(t.data, u));
  }).then(function() {
    s.postMessage({
      sourceName: r,
      targetName: i,
      stream: vs.START_COMPLETE,
      streamId: e,
      success: !0
    });
  }, function(d) {
    s.postMessage({
      sourceName: r,
      targetName: i,
      stream: vs.START_COMPLETE,
      streamId: e,
      reason: tc(d)
    });
  });
}, _ee = function(t) {
  const e = t.streamId, r = this.sourceName, i = t.sourceName, s = this.comObj, o = this.streamControllers[e], l = this.streamSinks[e];
  switch (t.stream) {
    case vs.START_COMPLETE:
      t.success ? o.startCall.resolve() : o.startCall.reject(tc(t.reason));
      break;
    case vs.PULL_COMPLETE:
      t.success ? o.pullCall.resolve() : o.pullCall.reject(tc(t.reason));
      break;
    case vs.PULL:
      if (!l) {
        s.postMessage({
          sourceName: r,
          targetName: i,
          stream: vs.PULL_COMPLETE,
          streamId: e,
          success: !0
        });
        break;
      }
      l.desiredSize <= 0 && t.desiredSize > 0 && l.sinkCapability.resolve(), l.desiredSize = t.desiredSize, new Promise(function(u) {
        var d;
        u((d = l.onPull) == null ? void 0 : d.call(l));
      }).then(function() {
        s.postMessage({
          sourceName: r,
          targetName: i,
          stream: vs.PULL_COMPLETE,
          streamId: e,
          success: !0
        });
      }, function(u) {
        s.postMessage({
          sourceName: r,
          targetName: i,
          stream: vs.PULL_COMPLETE,
          streamId: e,
          reason: tc(u)
        });
      });
      break;
    case vs.ENQUEUE:
      if (zs(o, "enqueue should have stream controller"), o.isClosed)
        break;
      o.controller.enqueue(t.chunk);
      break;
    case vs.CLOSE:
      if (zs(o, "close should have stream controller"), o.isClosed)
        break;
      o.isClosed = !0, o.controller.close(), Q(this, Eh, LR).call(this, o, e);
      break;
    case vs.ERROR:
      zs(o, "error should have stream controller"), o.controller.error(tc(t.reason)), Q(this, Eh, LR).call(this, o, e);
      break;
    case vs.CANCEL_COMPLETE:
      t.success ? o.cancelCall.resolve() : o.cancelCall.reject(tc(t.reason)), Q(this, Eh, LR).call(this, o, e);
      break;
    case vs.CANCEL:
      if (!l)
        break;
      new Promise(function(u) {
        var d;
        u((d = l.onCancel) == null ? void 0 : d.call(l, tc(t.reason)));
      }).then(function() {
        s.postMessage({
          sourceName: r,
          targetName: i,
          stream: vs.CANCEL_COMPLETE,
          streamId: e,
          success: !0
        });
      }, function(u) {
        s.postMessage({
          sourceName: r,
          targetName: i,
          stream: vs.CANCEL_COMPLETE,
          streamId: e,
          reason: tc(u)
        });
      }), l.sinkCapability.reject(tc(t.reason)), l.isCancelled = !0, delete this.streamSinks[e];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, LR = async function(t, e) {
  var r, i, s;
  await Promise.allSettled([(r = t.startCall) == null ? void 0 : r.promise, (i = t.pullCall) == null ? void 0 : i.promise, (s = t.cancelCall) == null ? void 0 : s.promise]), delete this.streamControllers[e];
};
var my, R_;
class YDe {
  constructor({
    parsedData: t,
    rawData: e
  }) {
    J(this, my);
    J(this, R_);
    q(this, my, t), q(this, R_, e);
  }
  getRaw() {
    return _(this, R_);
  }
  get(t) {
    return _(this, my).get(t) ?? null;
  }
  getAll() {
    return VU(_(this, my));
  }
  has(t) {
    return _(this, my).has(t);
  }
}
my = new WeakMap(), R_ = new WeakMap();
const zg = Symbol("INTERNAL");
var M_, D_, O_, fx;
class XDe {
  constructor(t, {
    name: e,
    intent: r,
    usage: i
  }) {
    J(this, M_, !1);
    J(this, D_, !1);
    J(this, O_, !1);
    J(this, fx, !0);
    q(this, M_, !!(t & Jc.DISPLAY)), q(this, D_, !!(t & Jc.PRINT)), this.name = e, this.intent = r, this.usage = i;
  }
  get visible() {
    if (_(this, O_))
      return _(this, fx);
    if (!_(this, fx))
      return !1;
    const {
      print: t,
      view: e
    } = this.usage;
    return _(this, M_) ? (e == null ? void 0 : e.viewState) !== "OFF" : _(this, D_) ? (t == null ? void 0 : t.printState) !== "OFF" : !0;
  }
  _setVisible(t, e, r = !1) {
    t !== zg && Lr("Internal method `_setVisible` called."), q(this, O_, r), q(this, fx, e);
  }
}
M_ = new WeakMap(), D_ = new WeakMap(), O_ = new WeakMap(), fx = new WeakMap();
var Xg, Mr, px, gx, L_, L$;
class qDe {
  constructor(t, e = Jc.DISPLAY) {
    J(this, L_);
    J(this, Xg, null);
    J(this, Mr, /* @__PURE__ */ new Map());
    J(this, px, null);
    J(this, gx, null);
    if (this.renderingIntent = e, this.name = null, this.creator = null, t !== null) {
      this.name = t.name, this.creator = t.creator, q(this, gx, t.order);
      for (const r of t.groups)
        _(this, Mr).set(r.id, new XDe(e, r));
      if (t.baseState === "OFF")
        for (const r of _(this, Mr).values())
          r._setVisible(zg, !1);
      for (const r of t.on)
        _(this, Mr).get(r)._setVisible(zg, !0);
      for (const r of t.off)
        _(this, Mr).get(r)._setVisible(zg, !1);
      q(this, px, this.getHash());
    }
  }
  isVisible(t) {
    if (_(this, Mr).size === 0)
      return !0;
    if (!t)
      return mD("Optional content group not defined."), !0;
    if (t.type === "OCG")
      return _(this, Mr).has(t.id) ? _(this, Mr).get(t.id).visible : (In(`Optional content group not found: ${t.id}`), !0);
    if (t.type === "OCMD") {
      if (t.expression)
        return Q(this, L_, L$).call(this, t.expression);
      if (!t.policy || t.policy === "AnyOn") {
        for (const e of t.ids) {
          if (!_(this, Mr).has(e))
            return In(`Optional content group not found: ${e}`), !0;
          if (_(this, Mr).get(e).visible)
            return !0;
        }
        return !1;
      } else if (t.policy === "AllOn") {
        for (const e of t.ids) {
          if (!_(this, Mr).has(e))
            return In(`Optional content group not found: ${e}`), !0;
          if (!_(this, Mr).get(e).visible)
            return !1;
        }
        return !0;
      } else if (t.policy === "AnyOff") {
        for (const e of t.ids) {
          if (!_(this, Mr).has(e))
            return In(`Optional content group not found: ${e}`), !0;
          if (!_(this, Mr).get(e).visible)
            return !0;
        }
        return !1;
      } else if (t.policy === "AllOff") {
        for (const e of t.ids) {
          if (!_(this, Mr).has(e))
            return In(`Optional content group not found: ${e}`), !0;
          if (_(this, Mr).get(e).visible)
            return !1;
        }
        return !0;
      }
      return In(`Unknown optional content policy ${t.policy}.`), !0;
    }
    return In(`Unknown group type ${t.type}.`), !0;
  }
  setVisibility(t, e = !0) {
    const r = _(this, Mr).get(t);
    if (!r) {
      In(`Optional content group not found: ${t}`);
      return;
    }
    r._setVisible(zg, !!e, !0), q(this, Xg, null);
  }
  setOCGState({
    state: t,
    preserveRB: e
  }) {
    let r;
    for (const i of t) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          r = i;
          continue;
      }
      const s = _(this, Mr).get(i);
      if (s)
        switch (r) {
          case "ON":
            s._setVisible(zg, !0);
            break;
          case "OFF":
            s._setVisible(zg, !1);
            break;
          case "Toggle":
            s._setVisible(zg, !s.visible);
            break;
        }
    }
    q(this, Xg, null);
  }
  get hasInitialVisibility() {
    return _(this, px) === null || this.getHash() === _(this, px);
  }
  getOrder() {
    return _(this, Mr).size ? _(this, gx) ? _(this, gx).slice() : [..._(this, Mr).keys()] : null;
  }
  getGroups() {
    return _(this, Mr).size > 0 ? VU(_(this, Mr)) : null;
  }
  getGroup(t) {
    return _(this, Mr).get(t) || null;
  }
  getHash() {
    if (_(this, Xg) !== null)
      return _(this, Xg);
    const t = new bee();
    for (const [e, r] of _(this, Mr))
      t.update(`${e}:${r.visible}`);
    return q(this, Xg, t.hexdigest());
  }
}
Xg = new WeakMap(), Mr = new WeakMap(), px = new WeakMap(), gx = new WeakMap(), L_ = new WeakSet(), L$ = function(t) {
  const e = t.length;
  if (e < 2)
    return !0;
  const r = t[0];
  for (let i = 1; i < e; i++) {
    const s = t[i];
    let o;
    if (Array.isArray(s))
      o = Q(this, L_, L$).call(this, s);
    else if (_(this, Mr).has(s))
      o = _(this, Mr).get(s).visible;
    else
      return In(`Optional content group not found: ${s}`), !0;
    switch (r) {
      case "And":
        if (!o)
          return !1;
        break;
      case "Or":
        if (o)
          return !0;
        break;
      case "Not":
        return !o;
      default:
        return !0;
    }
  }
  return r === "And";
};
class ZDe {
  constructor(t, {
    disableRange: e = !1,
    disableStream: r = !1
  }) {
    zs(t, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: s,
      progressiveDone: o,
      contentDispositionFilename: l
    } = t;
    if (this._queuedChunks = [], this._progressiveDone = o, this._contentDispositionFilename = l, (s == null ? void 0 : s.length) > 0) {
      const u = s instanceof Uint8Array && s.byteLength === s.buffer.byteLength ? s.buffer : new Uint8Array(s).buffer;
      this._queuedChunks.push(u);
    }
    this._pdfDataRangeTransport = t, this._isStreamingSupported = !r, this._isRangeSupported = !e, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], t.addRangeListener((u, d) => {
      this._onReceiveData({
        begin: u,
        chunk: d
      });
    }), t.addProgressListener((u, d) => {
      this._onProgress({
        loaded: u,
        total: d
      });
    }), t.addProgressiveReadListener((u) => {
      this._onReceiveData({
        chunk: u
      });
    }), t.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), t.transportReady();
  }
  _onReceiveData({
    begin: t,
    chunk: e
  }) {
    const r = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer;
    if (t === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(r) : this._queuedChunks.push(r);
    else {
      const i = this._rangeReaders.some(function(s) {
        return s._begin !== t ? !1 : (s._enqueue(r), !0);
      });
      zs(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var t;
    return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
  }
  _onProgress(t) {
    var e, r, i, s;
    t.total === void 0 ? (r = (e = this._rangeReaders[0]) == null ? void 0 : e.onProgress) == null || r.call(e, {
      loaded: t.loaded
    }) : (s = (i = this._fullRequestReader) == null ? void 0 : i.onProgress) == null || s.call(i, {
      loaded: t.loaded,
      total: t.total
    });
  }
  _onProgressiveDone() {
    var t;
    (t = this._fullRequestReader) == null || t.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(t) {
    const e = this._rangeReaders.indexOf(t);
    e >= 0 && this._rangeReaders.splice(e, 1);
  }
  getFullReader() {
    zs(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const t = this._queuedChunks;
    return this._queuedChunks = null, new QDe(this, t, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const r = new JDe(this, t, e);
    return this._pdfDataRangeTransport.requestDataRange(t, e), this._rangeReaders.push(r), r;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const r of this._rangeReaders.slice(0))
      r.cancel(t);
    this._pdfDataRangeTransport.abort();
  }
}
class QDe {
  constructor(t, e, r = !1, i = null) {
    this._stream = t, this._done = r || !1, this._filename = XU(i) ? i : null, this._queuedChunks = e || [], this._loaded = 0;
    for (const s of this._queuedChunks)
      this._loaded += s.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(t) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
}
class JDe {
  constructor(t, e, r) {
    this._stream = t, this._begin = e, this._end = r, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(t) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = t;
      else {
        this._requests.shift().resolve({
          value: t,
          done: !1
        });
        for (const r of this._requests)
          r.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const e = this._queuedChunk;
      return this._queuedChunk = null, {
        value: e,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function eOe(n) {
  let t = !0, e = r("filename\\*", "i").exec(n);
  if (e) {
    e = e[1];
    let f = l(e);
    return f = unescape(f), f = u(f), f = d(f), s(f);
  }
  if (e = o(n), e) {
    const f = d(e);
    return s(f);
  }
  if (e = r("filename", "i").exec(n), e) {
    e = e[1];
    let f = l(e);
    return f = d(f), s(f);
  }
  function r(f, m) {
    return new RegExp("(?:^|;)\\s*" + f + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', m);
  }
  function i(f, m) {
    if (f) {
      if (!/^[\x00-\xFF]+$/.test(m))
        return m;
      try {
        const v = new TextDecoder(f, {
          fatal: !0
        }), S = yD(m);
        m = v.decode(S), t = !1;
      } catch {
      }
    }
    return m;
  }
  function s(f) {
    return t && /[\x80-\xff]/.test(f) && (f = i("utf-8", f), t && (f = i("iso-8859-1", f))), f;
  }
  function o(f) {
    const m = [];
    let v;
    const S = r("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (v = S.exec(f)) !== null; ) {
      let [, E, A, P] = v;
      if (E = parseInt(E, 10), E in m) {
        if (E === 0)
          break;
        continue;
      }
      m[E] = [A, P];
    }
    const w = [];
    for (let E = 0; E < m.length && E in m; ++E) {
      let [A, P] = m[E];
      P = l(P), A && (P = unescape(P), E === 0 && (P = u(P))), w.push(P);
    }
    return w.join("");
  }
  function l(f) {
    if (f.startsWith('"')) {
      const m = f.slice(1).split('\\"');
      for (let v = 0; v < m.length; ++v) {
        const S = m[v].indexOf('"');
        S !== -1 && (m[v] = m[v].slice(0, S), m.length = v + 1), m[v] = m[v].replaceAll(/\\(.)/g, "$1");
      }
      f = m.join('"');
    }
    return f;
  }
  function u(f) {
    const m = f.indexOf("'");
    if (m === -1)
      return f;
    const v = f.slice(0, m), w = f.slice(m + 1).replace(/^[^']*'/, "");
    return i(v, w);
  }
  function d(f) {
    return !f.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(f) ? f : f.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(m, v, S, w) {
      if (S === "q" || S === "Q")
        return w = w.replaceAll("_", " "), w = w.replaceAll(/=([0-9a-fA-F]{2})/g, function(E, A) {
          return String.fromCharCode(parseInt(A, 16));
        }), i(v, w);
      try {
        w = atob(w);
      } catch {
      }
      return i(v, w);
    });
  }
  return "";
}
function QU({
  getResponseHeader: n,
  isHttp: t,
  rangeChunkSize: e,
  disableRange: r
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, s = parseInt(n("Content-Length"), 10);
  return !Number.isInteger(s) || (i.suggestedLength = s, s <= 2 * e) || r || !t || n("Accept-Ranges") !== "bytes" || (n("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
function JU(n) {
  const t = n("Content-Disposition");
  if (t) {
    let e = eOe(t);
    if (e.includes("%"))
      try {
        e = decodeURIComponent(e);
      } catch {
      }
    if (XU(e))
      return e;
  }
  return null;
}
function CD(n, t) {
  return n === 404 || n === 0 && t.startsWith("file:") ? new ES('Missing PDF "' + t + '".') : new vD(`Unexpected server response (${n}) while retrieving PDF "${t}".`, n);
}
function Tee(n) {
  return n === 200 || n === 206;
}
function Pee(n, t, e) {
  return {
    method: "GET",
    headers: n,
    signal: e.signal,
    mode: "cors",
    credentials: t ? "include" : "same-origin",
    redirect: "follow"
  };
}
function Aee(n) {
  const t = new Headers();
  for (const e in n) {
    const r = n[e];
    r !== void 0 && t.append(e, r);
  }
  return t;
}
function kee(n) {
  return n instanceof Uint8Array ? n.buffer : n instanceof ArrayBuffer ? n : (In(`getArrayBuffer - unexpected data format: ${n}`), new Uint8Array(n).buffer);
}
class zV {
  constructor(t) {
    this.source = t, this.isHttp = /^https?:/i.test(t.url), this.httpHeaders = this.isHttp && t.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var t;
    return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
  }
  getFullReader() {
    return zs(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new tOe(this), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const r = new nOe(this, t, e);
    return this._rangeRequestReaders.push(r), r;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const r of this._rangeRequestReaders.slice(0))
      r.cancel(t);
  }
}
class tOe {
  constructor(t) {
    this._stream = t, this._reader = null, this._loaded = 0, this._filename = null;
    const e = t.source;
    this._withCredentials = e.withCredentials || !1, this._contentLength = e.length, this._headersCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._headers = Aee(this._stream.httpHeaders);
    const r = e.url;
    fetch(r, Pee(this._headers, this._withCredentials, this._abortController)).then((i) => {
      if (!Tee(i.status))
        throw CD(i.status, r);
      this._reader = i.body.getReader(), this._headersCapability.resolve();
      const s = (u) => i.headers.get(u), {
        allowRangeRequests: o,
        suggestedLength: l
      } = QU({
        getResponseHeader: s,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = o, this._contentLength = l || this._contentLength, this._filename = JU(s), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new _S("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var r;
    await this._headersCapability.promise;
    const {
      value: t,
      done: e
    } = await this._reader.read();
    return e ? {
      value: t,
      done: e
    } : (this._loaded += t.byteLength, (r = this.onProgress) == null || r.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: kee(t),
      done: !1
    });
  }
  cancel(t) {
    var e;
    (e = this._reader) == null || e.cancel(t), this._abortController.abort();
  }
}
class nOe {
  constructor(t, e, r) {
    this._stream = t, this._reader = null, this._loaded = 0;
    const i = t.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController(), this._headers = Aee(this._stream.httpHeaders), this._headers.append("Range", `bytes=${e}-${r - 1}`);
    const s = i.url;
    fetch(s, Pee(this._headers, this._withCredentials, this._abortController)).then((o) => {
      if (!Tee(o.status))
        throw CD(o.status, s);
      this._readCapability.resolve(), this._reader = o.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var r;
    await this._readCapability.promise;
    const {
      value: t,
      done: e
    } = await this._reader.read();
    return e ? {
      value: t,
      done: e
    } : (this._loaded += t.byteLength, (r = this.onProgress) == null || r.call(this, {
      loaded: this._loaded
    }), {
      value: kee(t),
      done: !1
    });
  }
  cancel(t) {
    var e;
    (e = this._reader) == null || e.cancel(t), this._abortController.abort();
  }
}
const SF = 200, bF = 206;
function rOe(n) {
  const t = n.response;
  return typeof t != "string" ? t : yD(t).buffer;
}
class iOe {
  constructor(t, e = {}) {
    this.url = t, this.isHttp = /^https?:/i.test(t), this.httpHeaders = this.isHttp && e.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = e.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  requestRange(t, e, r) {
    const i = {
      begin: t,
      end: e
    };
    for (const s in r)
      i[s] = r[s];
    return this.request(i);
  }
  requestFull(t) {
    return this.request(t);
  }
  request(t) {
    const e = new XMLHttpRequest(), r = this.currXhrId++, i = this.pendingRequests[r] = {
      xhr: e
    };
    e.open("GET", this.url), e.withCredentials = this.withCredentials;
    for (const s in this.httpHeaders) {
      const o = this.httpHeaders[s];
      o !== void 0 && e.setRequestHeader(s, o);
    }
    return this.isHttp && "begin" in t && "end" in t ? (e.setRequestHeader("Range", `bytes=${t.begin}-${t.end - 1}`), i.expectedStatus = bF) : i.expectedStatus = SF, e.responseType = "arraybuffer", t.onError && (e.onerror = function(s) {
      t.onError(e.status);
    }), e.onreadystatechange = this.onStateChange.bind(this, r), e.onprogress = this.onProgress.bind(this, r), i.onHeadersReceived = t.onHeadersReceived, i.onDone = t.onDone, i.onError = t.onError, i.onProgress = t.onProgress, e.send(null), r;
  }
  onProgress(t, e) {
    var i;
    const r = this.pendingRequests[t];
    r && ((i = r.onProgress) == null || i.call(r, e));
  }
  onStateChange(t, e) {
    var u, d, f;
    const r = this.pendingRequests[t];
    if (!r)
      return;
    const i = r.xhr;
    if (i.readyState >= 2 && r.onHeadersReceived && (r.onHeadersReceived(), delete r.onHeadersReceived), i.readyState !== 4 || !(t in this.pendingRequests))
      return;
    if (delete this.pendingRequests[t], i.status === 0 && this.isHttp) {
      (u = r.onError) == null || u.call(r, i.status);
      return;
    }
    const s = i.status || SF;
    if (!(s === SF && r.expectedStatus === bF) && s !== r.expectedStatus) {
      (d = r.onError) == null || d.call(r, i.status);
      return;
    }
    const l = rOe(i);
    if (s === bF) {
      const m = i.getResponseHeader("Content-Range"), v = /bytes (\d+)-(\d+)\/(\d+)/.exec(m);
      r.onDone({
        begin: parseInt(v[1], 10),
        chunk: l
      });
    } else l ? r.onDone({
      begin: 0,
      chunk: l
    }) : (f = r.onError) == null || f.call(r, i.status);
  }
  getRequestXhr(t) {
    return this.pendingRequests[t].xhr;
  }
  isPendingRequest(t) {
    return t in this.pendingRequests;
  }
  abortRequest(t) {
    const e = this.pendingRequests[t].xhr;
    delete this.pendingRequests[t], e.abort();
  }
}
class sOe {
  constructor(t) {
    this._source = t, this._manager = new iOe(t.url, {
      httpHeaders: t.httpHeaders,
      withCredentials: t.withCredentials
    }), this._rangeChunkSize = t.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(t) {
    const e = this._rangeRequestReaders.indexOf(t);
    e >= 0 && this._rangeRequestReaders.splice(e, 1);
  }
  getFullReader() {
    return zs(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new oOe(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    const r = new aOe(this._manager, t, e);
    return r.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(r), r;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const r of this._rangeRequestReaders.slice(0))
      r.cancel(t);
  }
}
class oOe {
  constructor(t, e) {
    this._manager = t;
    const r = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = e.url, this._fullRequestId = t.requestFull(r), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._contentLength = e.length, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const t = this._fullRequestId, e = this._manager.getRequestXhr(t), r = (o) => e.getResponseHeader(o), {
      allowRangeRequests: i,
      suggestedLength: s
    } = QU({
      getResponseHeader: r,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    i && (this._isRangeSupported = !0), this._contentLength = s || this._contentLength, this._filename = JU(r), this._isRangeSupported && this._manager.abortRequest(t), this._headersReceivedCapability.resolve();
  }
  _onDone(t) {
    if (t && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: t.chunk,
      done: !1
    }) : this._cachedChunks.push(t.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(t) {
    this._storedError = CD(t, this._url), this._headersReceivedCapability.reject(this._storedError);
    for (const e of this._requests)
      e.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(t) {
    var e;
    (e = this.onProgress) == null || e.call(this, {
      loaded: t.loaded,
      total: t.lengthComputable ? t.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersReceivedCapability.promise;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0, this._headersReceivedCapability.reject(t);
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class aOe {
  constructor(t, e, r) {
    this._manager = t;
    const i = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = t.url, this._requestId = t.requestRange(e, r, i), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _close() {
    var t;
    (t = this.onClosed) == null || t.call(this, this);
  }
  _onDone(t) {
    const e = t.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunk = e, this._done = !0;
    for (const r of this._requests)
      r.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(t) {
    this._storedError = CD(t, this._url);
    for (const e of this._requests)
      e.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(t) {
    var e;
    this.isStreamingSupported || (e = this.onProgress) == null || e.call(this, {
      loaded: t.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const e = this._queuedChunk;
      return this._queuedChunk = null, {
        value: e,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const Iee = /^file:\/\/\/[a-zA-Z]:\//;
function lOe(n) {
  const t = Dh.get("url"), e = t.parse(n);
  return e.protocol === "file:" || e.host ? e : /^[a-z]:[/\\]/i.test(n) ? t.parse(`file:///${n}`) : (e.host || (e.protocol = "file:"), e);
}
class cOe {
  constructor(t) {
    this.source = t, this.url = lOe(t.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && t.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var t;
    return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
  }
  getFullReader() {
    return zs(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new hOe(this) : new uOe(this), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const r = this.isFsUrl ? new fOe(this, t, e) : new dOe(this, t, e);
    return this._rangeRequestReaders.push(r), r;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const r of this._rangeRequestReaders.slice(0))
      r.cancel(t);
  }
}
class Ree {
  constructor(t) {
    this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const e = t.source;
    this._contentLength = e.length, this._loaded = 0, this._filename = null, this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var r;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const t = this._readableStream.read();
    return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, (r = this.onProgress) == null || r.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(t).buffer,
      done: !1
    });
  }
  cancel(t) {
    if (!this._readableStream) {
      this._error(t);
      return;
    }
    this._readableStream.destroy(t);
  }
  _error(t) {
    this._storedError = t, this._readCapability.resolve();
  }
  _setReadableStream(t) {
    this._readableStream = t, t.on("readable", () => {
      this._readCapability.resolve();
    }), t.on("end", () => {
      t.destroy(), this._done = !0, this._readCapability.resolve();
    }), t.on("error", (e) => {
      this._error(e);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new _S("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class Mee {
  constructor(t) {
    this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const e = t.source;
    this._isStreamingSupported = !e.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var r;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const t = this._readableStream.read();
    return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, (r = this.onProgress) == null || r.call(this, {
      loaded: this._loaded
    }), {
      value: new Uint8Array(t).buffer,
      done: !1
    });
  }
  cancel(t) {
    if (!this._readableStream) {
      this._error(t);
      return;
    }
    this._readableStream.destroy(t);
  }
  _error(t) {
    this._storedError = t, this._readCapability.resolve();
  }
  _setReadableStream(t) {
    this._readableStream = t, t.on("readable", () => {
      this._readCapability.resolve();
    }), t.on("end", () => {
      t.destroy(), this._done = !0, this._readCapability.resolve();
    }), t.on("error", (e) => {
      this._error(e);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
function YM(n, t) {
  return {
    protocol: n.protocol,
    auth: n.auth,
    host: n.hostname,
    port: n.port,
    path: n.path,
    method: "GET",
    headers: t
  };
}
class uOe extends Ree {
  constructor(t) {
    super(t);
    const e = (r) => {
      if (r.statusCode === 404) {
        const l = new ES(`Missing PDF "${this._url}".`);
        this._storedError = l, this._headersCapability.reject(l);
        return;
      }
      this._headersCapability.resolve(), this._setReadableStream(r);
      const i = (l) => this._readableStream.headers[l.toLowerCase()], {
        allowRangeRequests: s,
        suggestedLength: o
      } = QU({
        getResponseHeader: i,
        isHttp: t.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = s, this._contentLength = o || this._contentLength, this._filename = JU(i);
    };
    if (this._request = null, this._url.protocol === "http:") {
      const r = Dh.get("http");
      this._request = r.request(YM(this._url, t.httpHeaders), e);
    } else {
      const r = Dh.get("https");
      this._request = r.request(YM(this._url, t.httpHeaders), e);
    }
    this._request.on("error", (r) => {
      this._storedError = r, this._headersCapability.reject(r);
    }), this._request.end();
  }
}
class dOe extends Mee {
  constructor(t, e, r) {
    super(t), this._httpHeaders = {};
    for (const s in t.httpHeaders) {
      const o = t.httpHeaders[s];
      o !== void 0 && (this._httpHeaders[s] = o);
    }
    this._httpHeaders.Range = `bytes=${e}-${r - 1}`;
    const i = (s) => {
      if (s.statusCode === 404) {
        const o = new ES(`Missing PDF "${this._url}".`);
        this._storedError = o;
        return;
      }
      this._setReadableStream(s);
    };
    if (this._request = null, this._url.protocol === "http:") {
      const s = Dh.get("http");
      this._request = s.request(YM(this._url, this._httpHeaders), i);
    } else {
      const s = Dh.get("https");
      this._request = s.request(YM(this._url, this._httpHeaders), i);
    }
    this._request.on("error", (s) => {
      this._storedError = s;
    }), this._request.end();
  }
}
class hOe extends Ree {
  constructor(t) {
    super(t);
    let e = decodeURIComponent(this._url.path);
    Iee.test(this._url.href) && (e = e.replace(/^\//, ""));
    const r = Dh.get("fs");
    r.promises.lstat(e).then((i) => {
      this._contentLength = i.size, this._setReadableStream(r.createReadStream(e)), this._headersCapability.resolve();
    }, (i) => {
      i.code === "ENOENT" && (i = new ES(`Missing PDF "${e}".`)), this._storedError = i, this._headersCapability.reject(i);
    });
  }
}
class fOe extends Mee {
  constructor(t, e, r) {
    super(t);
    let i = decodeURIComponent(this._url.path);
    Iee.test(this._url.href) && (i = i.replace(/^\//, ""));
    const s = Dh.get("fs");
    this._setReadableStream(s.createReadStream(i, {
      start: e,
      end: r - 1
    }));
  }
}
const pOe = 1e5, wl = 30, gOe = 0.8;
var JV, qg, Tl, j_, N_, vy, Vf, F_, $_, yy, mx, vx, Zg, yx, z_, Sx, Sy, U_, B_, $s, by, xy, Qg, bx, wp, Dee, Oee, j$, _h, jR, Lee, jee;
let XM = ($s = class {
  constructor({
    textContentSource: t,
    container: e,
    viewport: r
  }) {
    J(this, wp);
    J(this, qg, Promise.withResolvers());
    J(this, Tl, null);
    J(this, j_, !1);
    J(this, N_, !!((JV = globalThis.FontInspector) != null && JV.enabled));
    J(this, vy, null);
    J(this, Vf, null);
    J(this, F_, 0);
    J(this, $_, 0);
    J(this, yy, null);
    J(this, mx, null);
    J(this, vx, 0);
    J(this, Zg, 0);
    J(this, yx, /* @__PURE__ */ Object.create(null));
    J(this, z_, []);
    J(this, Sx, null);
    J(this, Sy, []);
    J(this, U_, /* @__PURE__ */ new WeakMap());
    J(this, B_, null);
    var u;
    if (t instanceof ReadableStream)
      q(this, Sx, t);
    else if (typeof t == "object")
      q(this, Sx, new ReadableStream({
        start(d) {
          d.enqueue(t), d.close();
        }
      }));
    else
      throw new Error('No "textContentSource" parameter specified.');
    q(this, Tl, q(this, mx, e)), q(this, Zg, r.scale * (globalThis.devicePixelRatio || 1)), q(this, vx, r.rotation), q(this, Vf, {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth: i,
      pageHeight: s,
      pageX: o,
      pageY: l
    } = r.rawDims;
    q(this, B_, [1, 0, 0, -1, -o, l + s]), q(this, $_, i), q(this, F_, s), Q(u = $s, _h, Lee).call(u), dS(e, r), _(this, qg).promise.catch(() => {
    }).then(() => {
      _($s, bx).delete(this), q(this, Vf, null), q(this, yx, null);
    });
  }
  render() {
    const t = () => {
      _(this, yy).read().then(({
        value: e,
        done: r
      }) => {
        if (r) {
          _(this, qg).resolve();
          return;
        }
        _(this, vy) ?? q(this, vy, e.lang), Object.assign(_(this, yx), e.styles), Q(this, wp, Dee).call(this, e.items), t();
      }, _(this, qg).reject);
    };
    return q(this, yy, _(this, Sx).getReader()), _($s, bx).add(this), t(), _(this, qg).promise;
  }
  update({
    viewport: t,
    onBefore: e = null
  }) {
    var s;
    const r = t.scale * (globalThis.devicePixelRatio || 1), i = t.rotation;
    if (i !== _(this, vx) && (e == null || e(), q(this, vx, i), dS(_(this, mx), {
      rotation: i
    })), r !== _(this, Zg)) {
      e == null || e(), q(this, Zg, r);
      const o = {
        prevFontSize: null,
        prevFontFamily: null,
        div: null,
        properties: null,
        ctx: Q(s = $s, _h, jR).call(s, _(this, vy))
      };
      for (const l of _(this, Sy))
        o.properties = _(this, U_).get(l), o.div = l, Q(this, wp, j$).call(this, o);
    }
  }
  cancel() {
    var e;
    const t = new _S("TextLayer task cancelled.");
    (e = _(this, yy)) == null || e.cancel(t).catch(() => {
    }), q(this, yy, null), _(this, qg).reject(t);
  }
  get textDivs() {
    return _(this, Sy);
  }
  get textContentItemsStr() {
    return _(this, z_);
  }
  static cleanup() {
    if (!(_(this, bx).size > 0)) {
      _(this, by).clear();
      for (const {
        canvas: t
      } of _(this, xy).values())
        t.remove();
      _(this, xy).clear();
    }
  }
}, qg = new WeakMap(), Tl = new WeakMap(), j_ = new WeakMap(), N_ = new WeakMap(), vy = new WeakMap(), Vf = new WeakMap(), F_ = new WeakMap(), $_ = new WeakMap(), yy = new WeakMap(), mx = new WeakMap(), vx = new WeakMap(), Zg = new WeakMap(), yx = new WeakMap(), z_ = new WeakMap(), Sx = new WeakMap(), Sy = new WeakMap(), U_ = new WeakMap(), B_ = new WeakMap(), by = new WeakMap(), xy = new WeakMap(), Qg = new WeakMap(), bx = new WeakMap(), wp = new WeakSet(), Dee = function(t) {
  var i, s;
  if (_(this, j_))
    return;
  (s = _(this, Vf)).ctx ?? (s.ctx = Q(i = $s, _h, jR).call(i, _(this, vy)));
  const e = _(this, Sy), r = _(this, z_);
  for (const o of t) {
    if (e.length > pOe) {
      In("Ignoring additional textDivs for performance reasons."), q(this, j_, !0);
      return;
    }
    if (o.str === void 0) {
      if (o.type === "beginMarkedContentProps" || o.type === "beginMarkedContent") {
        const l = _(this, Tl);
        q(this, Tl, document.createElement("span")), _(this, Tl).classList.add("markedContent"), o.id !== null && _(this, Tl).setAttribute("id", `${o.id}`), l.append(_(this, Tl));
      } else o.type === "endMarkedContent" && q(this, Tl, _(this, Tl).parentNode);
      continue;
    }
    r.push(o.str), Q(this, wp, Oee).call(this, o);
  }
}, Oee = function(t) {
  var E;
  const e = document.createElement("span"), r = {
    angle: 0,
    canvasWidth: 0,
    hasText: t.str !== "",
    hasEOL: t.hasEOL,
    fontSize: 0
  };
  _(this, Sy).push(e);
  const i = Ft.transform(_(this, B_), t.transform);
  let s = Math.atan2(i[1], i[0]);
  const o = _(this, yx)[t.fontName];
  o.vertical && (s += Math.PI / 2);
  const l = _(this, N_) && o.fontSubstitution || o.fontFamily, u = Math.hypot(i[2], i[3]), d = u * Q(E = $s, _h, jee).call(E, l, _(this, vy));
  let f, m;
  s === 0 ? (f = i[4], m = i[5] - d) : (f = i[4] + d * Math.sin(s), m = i[5] - d * Math.cos(s));
  const v = "calc(var(--scale-factor)*", S = e.style;
  _(this, Tl) === _(this, mx) ? (S.left = `${(100 * f / _(this, $_)).toFixed(2)}%`, S.top = `${(100 * m / _(this, F_)).toFixed(2)}%`) : (S.left = `${v}${f.toFixed(2)}px)`, S.top = `${v}${m.toFixed(2)}px)`), S.fontSize = `${v}${(_($s, Qg) * u).toFixed(2)}px)`, S.fontFamily = l, r.fontSize = u, e.setAttribute("role", "presentation"), e.textContent = t.str, e.dir = t.dir, _(this, N_) && (e.dataset.fontName = o.fontSubstitutionLoadedName || t.fontName), s !== 0 && (r.angle = s * (180 / Math.PI));
  let w = !1;
  if (t.str.length > 1)
    w = !0;
  else if (t.str !== " " && t.transform[0] !== t.transform[3]) {
    const A = Math.abs(t.transform[0]), P = Math.abs(t.transform[3]);
    A !== P && Math.max(A, P) / Math.min(A, P) > 1.5 && (w = !0);
  }
  if (w && (r.canvasWidth = o.vertical ? t.height : t.width), _(this, U_).set(e, r), _(this, Vf).div = e, _(this, Vf).properties = r, Q(this, wp, j$).call(this, _(this, Vf)), r.hasText && _(this, Tl).append(e), r.hasEOL) {
    const A = document.createElement("br");
    A.setAttribute("role", "presentation"), _(this, Tl).append(A);
  }
}, j$ = function(t) {
  const {
    div: e,
    properties: r,
    ctx: i,
    prevFontSize: s,
    prevFontFamily: o
  } = t, {
    style: l
  } = e;
  let u = "";
  if (_($s, Qg) > 1 && (u = `scale(${1 / _($s, Qg)})`), r.canvasWidth !== 0 && r.hasText) {
    const {
      fontFamily: d
    } = l, {
      canvasWidth: f,
      fontSize: m
    } = r;
    (s !== m || o !== d) && (i.font = `${m * _(this, Zg)}px ${d}`, t.prevFontSize = m, t.prevFontFamily = d);
    const {
      width: v
    } = i.measureText(e.textContent);
    v > 0 && (u = `scaleX(${f * _(this, Zg) / v}) ${u}`);
  }
  r.angle !== 0 && (u = `rotate(${r.angle}deg) ${u}`), u.length > 0 && (l.transform = u);
}, _h = new WeakSet(), jR = function(t = null) {
  let e = _(this, xy).get(t || (t = ""));
  if (!e) {
    const r = document.createElement("canvas");
    r.className = "hiddenCanvasElement", r.lang = t, document.body.append(r), e = r.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    }), _(this, xy).set(t, e);
  }
  return e;
}, Lee = function() {
  if (_(this, Qg) !== null)
    return;
  const t = document.createElement("div");
  t.style.opacity = 0, t.style.lineHeight = 1, t.style.fontSize = "1px", t.textContent = "X", document.body.append(t), q(this, Qg, t.getBoundingClientRect().height), t.remove();
}, jee = function(t, e) {
  const r = _(this, by).get(t);
  if (r)
    return r;
  const i = Q(this, _h, jR).call(this, e), s = i.font;
  i.canvas.width = i.canvas.height = wl, i.font = `${wl}px ${t}`;
  const o = i.measureText("");
  let l = o.fontBoundingBoxAscent, u = Math.abs(o.fontBoundingBoxDescent);
  if (l) {
    const m = l / (l + u);
    return _(this, by).set(t, m), i.canvas.width = i.canvas.height = 0, i.font = s, m;
  }
  i.strokeStyle = "red", i.clearRect(0, 0, wl, wl), i.strokeText("g", 0, 0);
  let d = i.getImageData(0, 0, wl, wl).data;
  u = 0;
  for (let m = d.length - 1 - 3; m >= 0; m -= 4)
    if (d[m] > 0) {
      u = Math.ceil(m / 4 / wl);
      break;
    }
  i.clearRect(0, 0, wl, wl), i.strokeText("A", 0, wl), d = i.getImageData(0, 0, wl, wl).data, l = 0;
  for (let m = 0, v = d.length; m < v; m += 4)
    if (d[m] > 0) {
      l = wl - Math.floor(m / 4 / wl);
      break;
    }
  i.canvas.width = i.canvas.height = 0, i.font = s;
  const f = l ? l / (l + u) : gOe;
  return _(this, by).set(t, f), f;
}, J($s, _h), J($s, by, /* @__PURE__ */ new Map()), J($s, xy, /* @__PURE__ */ new Map()), J($s, Qg, null), J($s, bx, /* @__PURE__ */ new Set()), $s);
function mOe() {
  YJ("`renderTextLayer`, please use `TextLayer` instead.");
  const {
    textContentSource: n,
    container: t,
    viewport: e,
    ...r
  } = arguments[0], i = Object.keys(r);
  i.length > 0 && In("Ignoring `renderTextLayer` parameters: " + i.join(", "));
  const s = new XM({
    textContentSource: n,
    container: t,
    viewport: e
  }), {
    textDivs: o,
    textContentItemsStr: l
  } = s;
  return {
    promise: s.render(),
    textDivs: o,
    textContentItemsStr: l
  };
}
function vOe() {
  YJ("`updateTextLayer`, please use `TextLayer` instead.");
}
class J1 {
  static textContent(t) {
    const e = [], r = {
      items: e,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(s) {
      var u;
      if (!s)
        return;
      let o = null;
      const l = s.name;
      if (l === "#text")
        o = s.value;
      else if (J1.shouldBuildText(l))
        (u = s == null ? void 0 : s.attributes) != null && u.textContent ? o = s.attributes.textContent : s.value && (o = s.value);
      else return;
      if (o !== null && e.push({
        str: o
      }), !!s.children)
        for (const d of s.children)
          i(d);
    }
    return i(t), r;
  }
  static shouldBuildText(t) {
    return !(t === "textarea" || t === "input" || t === "option" || t === "select");
  }
}
const yOe = 65536, SOe = 100, bOe = 5e3, xOe = va ? MDe : SDe, wOe = va ? DDe : GJ, COe = va ? RDe : yDe, EOe = va ? ODe : KJ;
function _Oe(n = {}) {
  typeof n == "string" || n instanceof URL ? n = {
    url: n
  } : (n instanceof ArrayBuffer || ArrayBuffer.isView(n)) && (n = {
    data: n
  });
  const t = new N$(), {
    docId: e
  } = t, r = n.url ? TOe(n.url) : null, i = n.data ? POe(n.data) : null, s = n.httpHeaders || null, o = n.withCredentials === !0, l = n.password ?? null, u = n.range instanceof Nee ? n.range : null, d = Number.isInteger(n.rangeChunkSize) && n.rangeChunkSize > 0 ? n.rangeChunkSize : yOe;
  let f = n.worker instanceof Z0 ? n.worker : null;
  const m = n.verbosity, v = typeof n.docBaseUrl == "string" && !YU(n.docBaseUrl) ? n.docBaseUrl : null, S = typeof n.cMapUrl == "string" ? n.cMapUrl : null, w = n.cMapPacked !== !1, E = n.CMapReaderFactory || wOe, A = typeof n.standardFontDataUrl == "string" ? n.standardFontDataUrl : null, P = n.StandardFontDataFactory || EOe, R = n.stopAtErrors !== !0, M = Number.isInteger(n.maxImageSize) && n.maxImageSize > -1 ? n.maxImageSize : -1, j = n.isEvalSupported !== !1, $ = typeof n.isOffscreenCanvasSupported == "boolean" ? n.isOffscreenCanvasSupported : !va, U = Number.isInteger(n.canvasMaxAreaInBytes) ? n.canvasMaxAreaInBytes : -1, F = typeof n.disableFontFace == "boolean" ? n.disableFontFace : va, B = n.fontExtraProperties === !0, G = n.enableXfa === !0, X = n.ownerDocument || globalThis.document, te = n.disableRange === !0, ne = n.disableStream === !0, K = n.disableAutoFetch === !0, Z = n.pdfBug === !0, oe = n.enableHWA === !0, fe = u ? u.length : n.length ?? NaN, ie = typeof n.useSystemFonts == "boolean" ? n.useSystemFonts : !va && !F, ue = typeof n.useWorkerFetch == "boolean" ? n.useWorkerFetch : E === GJ && P === KJ && S && A && f1(S, document.baseURI) && f1(A, document.baseURI), Se = n.canvasFactory || new xOe({
    ownerDocument: X,
    enableHWA: oe
  }), ke = n.filterFactory || new COe({
    docId: e,
    ownerDocument: X
  }), ce = null;
  aDe(m);
  const ye = {
    canvasFactory: Se,
    filterFactory: ke
  };
  if (ue || (ye.cMapReaderFactory = new E({
    baseUrl: S,
    isCompressed: w
  }), ye.standardFontDataFactory = new P({
    baseUrl: A
  })), !f) {
    const je = {
      verbosity: m,
      port: fp.workerPort
    };
    f = je.port ? Z0.fromPort(je) : new Z0(je), t._worker = f;
  }
  const Fe = {
    docId: e,
    apiVersion: "4.4.168",
    data: i,
    password: l,
    disableAutoFetch: K,
    rangeChunkSize: d,
    length: fe,
    docBaseUrl: v,
    enableXfa: G,
    evaluatorOptions: {
      maxImageSize: M,
      disableFontFace: F,
      ignoreErrors: R,
      isEvalSupported: j,
      isOffscreenCanvasSupported: $,
      canvasMaxAreaInBytes: U,
      fontExtraProperties: B,
      useSystemFonts: ie,
      cMapUrl: ue ? S : null,
      standardFontDataUrl: ue ? A : null
    }
  }, Xe = {
    disableFontFace: F,
    fontExtraProperties: B,
    ownerDocument: X,
    pdfBug: Z,
    styleElement: ce,
    loadingParams: {
      disableAutoFetch: K,
      enableXfa: G
    }
  };
  return f.promise.then(function() {
    if (t.destroyed)
      throw new Error("Loading aborted");
    if (f.destroyed)
      throw new Error("Worker was destroyed");
    const je = f.messageHandler.sendWithPromise("GetDocRequest", Fe, i ? [i.buffer] : null);
    let nt;
    if (u)
      nt = new ZDe(u, {
        disableRange: te,
        disableStream: ne
      });
    else if (!i) {
      if (!r)
        throw new Error("getDocument - no `url` parameter provided.");
      nt = ((tt) => va ? function() {
        return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype;
      }() && f1(tt.url) ? new zV(tt) : new cOe(tt) : f1(tt.url) ? new zV(tt) : new sOe(tt))({
        url: r,
        length: fe,
        httpHeaders: s,
        withCredentials: o,
        rangeChunkSize: d,
        disableRange: te,
        disableStream: ne
      });
    }
    return je.then((Ze) => {
      if (t.destroyed)
        throw new Error("Loading aborted");
      if (f.destroyed)
        throw new Error("Worker was destroyed");
      const tt = new m1(e, Ze, f.port), et = new ROe(tt, t, nt, Xe, ye);
      t._transport = et, tt.send("Ready", null);
    });
  }).catch(t._capability.reject), t;
}
function TOe(n) {
  if (n instanceof URL)
    return n.href;
  try {
    return new URL(n, window.location).href;
  } catch {
    if (va && typeof n == "string")
      return n;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function POe(n) {
  if (va && typeof Buffer < "u" && n instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (n instanceof Uint8Array && n.byteLength === n.buffer.byteLength)
    return n;
  if (typeof n == "string")
    return yD(n);
  if (n instanceof ArrayBuffer || ArrayBuffer.isView(n) || typeof n == "object" && !isNaN(n == null ? void 0 : n.length))
    return new Uint8Array(n);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function UV(n) {
  return typeof n == "object" && Number.isInteger(n == null ? void 0 : n.num) && n.num >= 0 && Number.isInteger(n == null ? void 0 : n.gen) && n.gen >= 0;
}
var u2;
const d2 = class d2 {
  constructor() {
    this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${ec(d2, u2)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var t, e, r;
    this.destroyed = !0;
    try {
      (t = this._worker) != null && t.port && (this._worker._pendingDestroy = !0), await ((e = this._transport) == null ? void 0 : e.destroy());
    } catch (i) {
      throw (r = this._worker) != null && r.port && delete this._worker._pendingDestroy, i;
    }
    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
  }
};
u2 = new WeakMap(), J(d2, u2, 0);
let N$ = d2, Nee = class {
  constructor(t, e, r = !1, i = null) {
    this.length = t, this.initialData = e, this.progressiveDone = r, this.contentDispositionFilename = i, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(t) {
    this._rangeListeners.push(t);
  }
  addProgressListener(t) {
    this._progressListeners.push(t);
  }
  addProgressiveReadListener(t) {
    this._progressiveReadListeners.push(t);
  }
  addProgressiveDoneListener(t) {
    this._progressiveDoneListeners.push(t);
  }
  onDataRange(t, e) {
    for (const r of this._rangeListeners)
      r(t, e);
  }
  onDataProgress(t, e) {
    this._readyCapability.promise.then(() => {
      for (const r of this._progressListeners)
        r(t, e);
    });
  }
  onDataProgressiveRead(t) {
    this._readyCapability.promise.then(() => {
      for (const e of this._progressiveReadListeners)
        e(t);
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const t of this._progressiveDoneListeners)
        t();
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(t, e) {
    Lr("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
class AOe {
  constructor(t, e) {
    this._pdfInfo = t, this._transport = e;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return lr(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(t) {
    return this._transport.getPage(t);
  }
  getPageIndex(t) {
    return this._transport.getPageIndex(t);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(t) {
    return this._transport.getDestination(t);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: t = "display"
  } = {}) {
    const {
      renderingIntent: e
    } = this._transport.getRenderingIntent(t);
    return this._transport.getOptionalContentConfig(e);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(t = !1) {
    return this._transport.startCleanup(t || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(t) {
    return this._transport.cachedPageNumber(t);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
var Jg, Wf, iu, I0, NR;
class kOe {
  constructor(t, e, r, i = !1) {
    J(this, iu);
    J(this, Jg, null);
    J(this, Wf, !1);
    this._pageIndex = t, this._pageInfo = e, this._transport = r, this._stats = i ? new PV() : null, this._pdfBug = i, this.commonObjs = r.commonObjs, this.objs = new Fee(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: t,
    rotation: e = this.rotate,
    offsetX: r = 0,
    offsetY: i = 0,
    dontFlip: s = !1
  } = {}) {
    return new rP({
      viewBox: this.view,
      scale: t,
      rotation: e,
      offsetX: r,
      offsetY: i,
      dontFlip: s
    });
  }
  getAnnotations({
    intent: t = "display"
  } = {}) {
    const {
      renderingIntent: e
    } = this._transport.getRenderingIntent(t);
    return this._transport.getAnnotations(this._pageIndex, e);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return lr(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var t;
    return ((t = this._transport._htmlForXfa) == null ? void 0 : t.children[this._pageIndex]) || null;
  }
  render({
    canvasContext: t,
    viewport: e,
    intent: r = "display",
    annotationMode: i = Hg.ENABLE,
    transform: s = null,
    background: o = null,
    optionalContentConfigPromise: l = null,
    annotationCanvasMap: u = null,
    pageColors: d = null,
    printAnnotationStorage: f = null
  }) {
    var M, j;
    (M = this._stats) == null || M.time("Overall");
    const m = this._transport.getRenderingIntent(r, i, f), {
      renderingIntent: v,
      cacheKey: S
    } = m;
    q(this, Wf, !1), Q(this, iu, NR).call(this), l || (l = this._transport.getOptionalContentConfig(v));
    let w = this._intentStates.get(S);
    w || (w = /* @__PURE__ */ Object.create(null), this._intentStates.set(S, w)), w.streamReaderCancelTimeout && (clearTimeout(w.streamReaderCancelTimeout), w.streamReaderCancelTimeout = null);
    const E = !!(v & Jc.PRINT);
    w.displayReadyCapability || (w.displayReadyCapability = Promise.withResolvers(), w.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (j = this._stats) == null || j.time("Page Request"), this._pumpOperatorList(m));
    const A = ($) => {
      var U;
      w.renderTasks.delete(P), (this._maybeCleanupAfterRender || E) && q(this, Wf, !0), Q(this, iu, I0).call(this, !E), $ ? (P.capability.reject($), this._abortOperatorList({
        intentState: w,
        reason: $ instanceof Error ? $ : new Error($)
      })) : P.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (U = globalThis.Stats) != null && U.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, P = new $$({
      callback: A,
      params: {
        canvasContext: t,
        viewport: e,
        transform: s,
        background: o
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: u,
      operatorList: w.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !E,
      pdfBug: this._pdfBug,
      pageColors: d
    });
    (w.renderTasks || (w.renderTasks = /* @__PURE__ */ new Set())).add(P);
    const R = P.task;
    return Promise.all([w.displayReadyCapability.promise, l]).then(([$, U]) => {
      var F;
      if (this.destroyed) {
        A();
        return;
      }
      if ((F = this._stats) == null || F.time("Rendering"), !(U.renderingIntent & v))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      P.initializeGraphics({
        transparency: $,
        optionalContentConfig: U
      }), P.operatorListChanged();
    }).catch(A), R;
  }
  getOperatorList({
    intent: t = "display",
    annotationMode: e = Hg.ENABLE,
    printAnnotationStorage: r = null
  } = {}) {
    var u;
    function i() {
      o.operatorList.lastChunk && (o.opListReadCapability.resolve(o.operatorList), o.renderTasks.delete(l));
    }
    const s = this._transport.getRenderingIntent(t, e, r, !0);
    let o = this._intentStates.get(s.cacheKey);
    o || (o = /* @__PURE__ */ Object.create(null), this._intentStates.set(s.cacheKey, o));
    let l;
    return o.opListReadCapability || (l = /* @__PURE__ */ Object.create(null), l.operatorListChanged = i, o.opListReadCapability = Promise.withResolvers(), (o.renderTasks || (o.renderTasks = /* @__PURE__ */ new Set())).add(l), o.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (u = this._stats) == null || u.time("Page Request"), this._pumpOperatorList(s)), o.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: t = !1,
    disableNormalization: e = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: t === !0,
      disableNormalization: e === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(t = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((r) => J1.textContent(r));
    const e = this.streamTextContent(t);
    return new Promise(function(r, i) {
      function s() {
        o.read().then(function({
          value: u,
          done: d
        }) {
          if (d) {
            r(l);
            return;
          }
          l.lang ?? (l.lang = u.lang), Object.assign(l.styles, u.styles), l.items.push(...u.items), s();
        }, i);
      }
      const o = e.getReader(), l = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      s();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const t = [];
    for (const e of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: e,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !e.opListReadCapability)
        for (const r of e.renderTasks)
          t.push(r.completed), r.cancel();
    return this.objs.clear(), q(this, Wf, !1), Q(this, iu, NR).call(this), Promise.all(t);
  }
  cleanup(t = !1) {
    q(this, Wf, !0);
    const e = Q(this, iu, I0).call(this, !1);
    return t && e && this._stats && (this._stats = new PV()), e;
  }
  _startRenderPage(t, e) {
    var i, s;
    const r = this._intentStates.get(e);
    r && ((i = this._stats) == null || i.timeEnd("Page Request"), (s = r.displayReadyCapability) == null || s.resolve(t));
  }
  _renderPageChunk(t, e) {
    for (let r = 0, i = t.length; r < i; r++)
      e.operatorList.fnArray.push(t.fnArray[r]), e.operatorList.argsArray.push(t.argsArray[r]);
    e.operatorList.lastChunk = t.lastChunk, e.operatorList.separateAnnots = t.separateAnnots;
    for (const r of e.renderTasks)
      r.operatorListChanged();
    t.lastChunk && Q(this, iu, I0).call(this, !0);
  }
  _pumpOperatorList({
    renderingIntent: t,
    cacheKey: e,
    annotationStorageSerializable: r
  }) {
    const {
      map: i,
      transfer: s
    } = r, l = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: t,
      cacheKey: e,
      annotationStorage: i
    }, s).getReader(), u = this._intentStates.get(e);
    u.streamReader = l;
    const d = () => {
      l.read().then(({
        value: f,
        done: m
      }) => {
        if (m) {
          u.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(f, u), d());
      }, (f) => {
        if (u.streamReader = null, !this._transport.destroyed) {
          if (u.operatorList) {
            u.operatorList.lastChunk = !0;
            for (const m of u.renderTasks)
              m.operatorListChanged();
            Q(this, iu, I0).call(this, !0);
          }
          if (u.displayReadyCapability)
            u.displayReadyCapability.reject(f);
          else if (u.opListReadCapability)
            u.opListReadCapability.reject(f);
          else
            throw f;
        }
      });
    };
    d();
  }
  _abortOperatorList({
    intentState: t,
    reason: e,
    force: r = !1
  }) {
    if (t.streamReader) {
      if (t.streamReaderCancelTimeout && (clearTimeout(t.streamReaderCancelTimeout), t.streamReaderCancelTimeout = null), !r) {
        if (t.renderTasks.size > 0)
          return;
        if (e instanceof KU) {
          let i = SOe;
          e.extraDelay > 0 && e.extraDelay < 1e3 && (i += e.extraDelay), t.streamReaderCancelTimeout = setTimeout(() => {
            t.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: t,
              reason: e,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (t.streamReader.cancel(new _S(e.message)).catch(() => {
      }), t.streamReader = null, !this._transport.destroyed) {
        for (const [i, s] of this._intentStates)
          if (s === t) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
Jg = new WeakMap(), Wf = new WeakMap(), iu = new WeakSet(), I0 = function(t = !1) {
  if (Q(this, iu, NR).call(this), !_(this, Wf) || this.destroyed)
    return !1;
  if (t)
    return q(this, Jg, setTimeout(() => {
      q(this, Jg, null), Q(this, iu, I0).call(this, !1);
    }, bOe)), !1;
  for (const {
    renderTasks: e,
    operatorList: r
  } of this._intentStates.values())
    if (e.size > 0 || !r.lastChunk)
      return !1;
  return this._intentStates.clear(), this.objs.clear(), q(this, Wf, !1), !0;
}, NR = function() {
  _(this, Jg) && (clearTimeout(_(this, Jg)), q(this, Jg, null));
};
var wy, h2;
class IOe {
  constructor() {
    J(this, wy, /* @__PURE__ */ new Set());
    J(this, h2, Promise.resolve());
  }
  postMessage(t, e) {
    const r = {
      data: structuredClone(t, e ? {
        transfer: e
      } : null)
    };
    _(this, h2).then(() => {
      for (const i of _(this, wy))
        i.call(this, r);
    });
  }
  addEventListener(t, e) {
    _(this, wy).add(e);
  }
  removeEventListener(t, e) {
    _(this, wy).delete(e);
  }
  terminate() {
    _(this, wy).clear();
  }
}
wy = new WeakMap(), h2 = new WeakMap();
const Lf = {
  isWorkerDisabled: !1,
  fakeWorkerId: 0
};
va && (Lf.isWorkerDisabled = !0, fp.workerSrc || (fp.workerSrc = "./pdf.worker.mjs")), Lf.isSameOrigin = function(n, t) {
  let e;
  try {
    if (e = new URL(n), !e.origin || e.origin === "null")
      return !1;
  } catch {
    return !1;
  }
  const r = new URL(t, e);
  return e.origin === r.origin;
}, Lf.createCDNWrapper = function(n) {
  const t = `await import("${n}");`;
  return URL.createObjectURL(new Blob([t], {
    type: "text/javascript"
  }));
};
var Cy, xx, FR, wx, $R;
const ic = class ic {
  constructor({
    name: t = null,
    port: e = null,
    verbosity: r = lDe()
  } = {}) {
    J(this, xx);
    var i;
    if (this.name = t, this.destroyed = !1, this.verbosity = r, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, e) {
      if ((i = _(ic, Cy)) != null && i.has(e))
        throw new Error("Cannot use more than one PDFWorker per port.");
      (_(ic, Cy) || q(ic, Cy, /* @__PURE__ */ new WeakMap())).set(e, this), this._initializeFromPort(e);
      return;
    }
    this._initialize();
  }
  get promise() {
    return va ? Promise.all([Dh.promise, this._readyCapability.promise]) : this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(t) {
    this._port = t, this._messageHandler = new m1("main", "worker", t), this._messageHandler.on("ready", function() {
    }), Q(this, xx, FR).call(this);
  }
  _initialize() {
    if (Lf.isWorkerDisabled || _(ic, wx, $R)) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc: t
    } = ic;
    try {
      Lf.isSameOrigin(window.location.href, t) || (t = Lf.createCDNWrapper(new URL(t, window.location).href));
      const e = new Worker(t, {
        type: "module"
      }), r = new m1("main", "worker", e), i = () => {
        s.abort(), r.destroy(), e.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
      }, s = new AbortController();
      e.addEventListener("error", () => {
        this._webWorker || i();
      }, {
        signal: s.signal
      }), r.on("test", (l) => {
        if (s.abort(), this.destroyed || !l) {
          i();
          return;
        }
        this._messageHandler = r, this._port = e, this._webWorker = e, Q(this, xx, FR).call(this);
      }), r.on("ready", (l) => {
        if (s.abort(), this.destroyed) {
          i();
          return;
        }
        try {
          o();
        } catch {
          this._setupFakeWorker();
        }
      });
      const o = () => {
        const l = new Uint8Array();
        r.send("test", l, [l.buffer]);
      };
      o();
      return;
    } catch {
      mD("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    Lf.isWorkerDisabled || (In("Setting up fake worker."), Lf.isWorkerDisabled = !0), ic._setupFakeWorkerGlobal.then((t) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const e = new IOe();
      this._port = e;
      const r = `fake${Lf.fakeWorkerId++}`, i = new m1(r + "_worker", r, e);
      t.setup(i, e), this._messageHandler = new m1(r, r + "_worker", e), Q(this, xx, FR).call(this);
    }).catch((t) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t.message}".`));
    });
  }
  destroy() {
    var t;
    this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (t = _(ic, Cy)) == null || t.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
  }
  static fromPort(t) {
    var r;
    if (!(t != null && t.port))
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    const e = (r = _(this, Cy)) == null ? void 0 : r.get(t.port);
    if (e) {
      if (e._pendingDestroy)
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return e;
    }
    return new ic(t);
  }
  static get workerSrc() {
    if (fp.workerSrc)
      return fp.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return lr(this, "_setupFakeWorkerGlobal", (async () => _(this, wx, $R) ? _(this, wx, $R) : (await import(
      /*webpackIgnore: true*/
      this.workerSrc
    )).WorkerMessageHandler)());
  }
};
Cy = new WeakMap(), xx = new WeakSet(), FR = function() {
  this._readyCapability.resolve(), this._messageHandler.send("configure", {
    verbosity: this.verbosity
  });
}, wx = new WeakSet(), $R = function() {
  var t;
  try {
    return ((t = globalThis.pdfjsWorker) == null ? void 0 : t.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
}, J(ic, wx), J(ic, Cy);
let Z0 = ic;
var Gf, rh, Cx, Ex, ih, Ey, v1;
class ROe {
  constructor(t, e, r, i, s) {
    J(this, Ey);
    J(this, Gf, /* @__PURE__ */ new Map());
    J(this, rh, /* @__PURE__ */ new Map());
    J(this, Cx, /* @__PURE__ */ new Map());
    J(this, Ex, /* @__PURE__ */ new Map());
    J(this, ih, null);
    this.messageHandler = t, this.loadingTask = e, this.commonObjs = new Fee(), this.fontLoader = new kDe({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = s.canvasFactory, this.filterFactory = s.filterFactory, this.cMapReaderFactory = s.cMapReaderFactory, this.standardFontDataFactory = s.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = r, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
  }
  get annotationStorage() {
    return lr(this, "annotationStorage", new ZU());
  }
  getRenderingIntent(t, e = Hg.ENABLE, r = null, i = !1) {
    let s = Jc.DISPLAY, o = k$;
    switch (t) {
      case "any":
        s = Jc.ANY;
        break;
      case "display":
        break;
      case "print":
        s = Jc.PRINT;
        break;
      default:
        In(`getRenderingIntent - invalid intent: ${t}`);
    }
    switch (e) {
      case Hg.DISABLE:
        s += Jc.ANNOTATIONS_DISABLE;
        break;
      case Hg.ENABLE:
        break;
      case Hg.ENABLE_FORMS:
        s += Jc.ANNOTATIONS_FORMS;
        break;
      case Hg.ENABLE_STORAGE:
        s += Jc.ANNOTATIONS_STORAGE, o = (s & Jc.PRINT && r instanceof wee ? r : this.annotationStorage).serializable;
        break;
      default:
        In(`getRenderingIntent - invalid annotationMode: ${e}`);
    }
    return i && (s += Jc.OPLIST), {
      renderingIntent: s,
      cacheKey: `${s}_${o.hash}`,
      annotationStorageSerializable: o
    };
  }
  destroy() {
    var r;
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (r = _(this, ih)) == null || r.reject(new Error("Worker was destroyed during onPassword callback"));
    const t = [];
    for (const i of _(this, rh).values())
      t.push(i._destroy());
    _(this, rh).clear(), _(this, Cx).clear(), _(this, Ex).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const e = this.messageHandler.sendWithPromise("Terminate", null);
    return t.push(e), Promise.all(t).then(() => {
      var i;
      this.commonObjs.clear(), this.fontLoader.clear(), _(this, Gf).clear(), this.filterFactory.destroy(), XM.cleanup(), (i = this._networkStream) == null || i.cancelAllRequests(new _S("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: t,
      loadingTask: e
    } = this;
    t.on("GetReader", (r, i) => {
      zs(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (s) => {
        this._lastProgress = {
          loaded: s.loaded,
          total: s.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: s,
          done: o
        }) {
          if (o) {
            i.close();
            return;
          }
          zs(s instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(s), 1, [s]);
        }).catch((s) => {
          i.error(s);
        });
      }, i.onCancel = (s) => {
        this._fullReader.cancel(s), i.ready.catch((o) => {
          if (!this.destroyed)
            throw o;
        });
      };
    }), t.on("ReaderHeadersReady", (r) => {
      const i = Promise.withResolvers(), s = this._fullReader;
      return s.headersReady.then(() => {
        var o;
        (!s.isStreamingSupported || !s.isRangeSupported) && (this._lastProgress && ((o = e.onProgress) == null || o.call(e, this._lastProgress)), s.onProgress = (l) => {
          var u;
          (u = e.onProgress) == null || u.call(e, {
            loaded: l.loaded,
            total: l.total
          });
        }), i.resolve({
          isStreamingSupported: s.isStreamingSupported,
          isRangeSupported: s.isRangeSupported,
          contentLength: s.contentLength
        });
      }, i.reject), i.promise;
    }), t.on("GetRangeReader", (r, i) => {
      zs(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const s = this._networkStream.getRangeReader(r.begin, r.end);
      if (!s) {
        i.close();
        return;
      }
      i.onPull = () => {
        s.read().then(function({
          value: o,
          done: l
        }) {
          if (l) {
            i.close();
            return;
          }
          zs(o instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(o), 1, [o]);
        }).catch((o) => {
          i.error(o);
        });
      }, i.onCancel = (o) => {
        s.cancel(o), i.ready.catch((l) => {
          if (!this.destroyed)
            throw l;
        });
      };
    }), t.on("GetDoc", ({
      pdfInfo: r
    }) => {
      this._numPages = r.numPages, this._htmlForXfa = r.htmlForXfa, delete r.htmlForXfa, e._capability.resolve(new AOe(r, this));
    }), t.on("DocException", function(r) {
      let i;
      switch (r.name) {
        case "PasswordException":
          i = new o$(r.message, r.code);
          break;
        case "InvalidPDFException":
          i = new BJ(r.message);
          break;
        case "MissingPDFException":
          i = new ES(r.message);
          break;
        case "UnexpectedResponseException":
          i = new vD(r.message, r.status);
          break;
        case "UnknownErrorException":
          i = new a$(r.message, r.details);
          break;
        default:
          Lr("DocException - expected a valid Error.");
      }
      e._capability.reject(i);
    }), t.on("PasswordRequest", (r) => {
      if (q(this, ih, Promise.withResolvers()), e.onPassword) {
        const i = (s) => {
          s instanceof Error ? _(this, ih).reject(s) : _(this, ih).resolve({
            password: s
          });
        };
        try {
          e.onPassword(i, r.code);
        } catch (s) {
          _(this, ih).reject(s);
        }
      } else
        _(this, ih).reject(new o$(r.message, r.code));
      return _(this, ih).promise;
    }), t.on("DataLoaded", (r) => {
      var i;
      (i = e.onProgress) == null || i.call(e, {
        loaded: r.length,
        total: r.length
      }), this.downloadInfoCapability.resolve(r);
    }), t.on("StartRenderPage", (r) => {
      if (this.destroyed)
        return;
      _(this, rh).get(r.pageIndex)._startRenderPage(r.transparency, r.cacheKey);
    }), t.on("commonobj", ([r, i, s]) => {
      var o;
      if (this.destroyed || this.commonObjs.has(r))
        return null;
      switch (i) {
        case "Font":
          const {
            disableFontFace: l,
            fontExtraProperties: u,
            pdfBug: d
          } = this._params;
          if ("error" in s) {
            const S = s.error;
            In(`Error during font loading: ${S}`), this.commonObjs.resolve(r, S);
            break;
          }
          const f = d && ((o = globalThis.FontInspector) != null && o.enabled) ? (S, w) => globalThis.FontInspector.fontAdded(S, w) : null, m = new IDe(s, {
            disableFontFace: l,
            inspectFont: f
          });
          this.fontLoader.bind(m).catch(() => t.sendWithPromise("FontFallback", {
            id: r
          })).finally(() => {
            !u && m.data && (m.data = null), this.commonObjs.resolve(r, m);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: v
          } = s;
          zs(v, "The imageRef must be defined.");
          for (const S of _(this, rh).values())
            for (const [, w] of S.objs)
              if ((w == null ? void 0 : w.ref) === v)
                return w.dataLen ? (this.commonObjs.resolve(r, structuredClone(w)), w.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(r, s);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), t.on("obj", ([r, i, s, o]) => {
      var u;
      if (this.destroyed)
        return;
      const l = _(this, rh).get(i);
      if (!l.objs.has(r)) {
        if (l._intentStates.size === 0) {
          (u = o == null ? void 0 : o.bitmap) == null || u.close();
          return;
        }
        switch (s) {
          case "Image":
            l.objs.resolve(r, o), (o == null ? void 0 : o.dataLen) > rDe && (l._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            l.objs.resolve(r, o);
            break;
          default:
            throw new Error(`Got unknown object type ${s}`);
        }
      }
    }), t.on("DocProgress", (r) => {
      var i;
      this.destroyed || (i = e.onProgress) == null || i.call(e, {
        loaded: r.loaded,
        total: r.total
      });
    }), t.on("FetchBuiltInCMap", (r) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(r) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), t.on("FetchStandardFontData", (r) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(r) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var r;
    this.annotationStorage.size <= 0 && In("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: t,
      transfer: e
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: t,
      filename: ((r = this._fullReader) == null ? void 0 : r.filename) ?? null
    }, e).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(t) {
    if (!Number.isInteger(t) || t <= 0 || t > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const e = t - 1, r = _(this, Cx).get(e);
    if (r)
      return r;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: e
    }).then((s) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      s.refStr && _(this, Ex).set(s.refStr, t);
      const o = new kOe(e, s, this, this._params.pdfBug);
      return _(this, rh).set(e, o), o;
    });
    return _(this, Cx).set(e, i), i;
  }
  getPageIndex(t) {
    return UV(t) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: t.num,
      gen: t.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(t, e) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: t,
      intent: e
    });
  }
  getFieldObjects() {
    return Q(this, Ey, v1).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return Q(this, Ey, v1).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(t) {
    return typeof t != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: t
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return Q(this, Ey, v1).call(this, "GetDocJSActions");
  }
  getPageJSActions(t) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: t
    });
  }
  getStructTree(t) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: t
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(t) {
    return Q(this, Ey, v1).call(this, "GetOptionalContentConfig").then((e) => new qDe(e, t));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const t = "GetMetadata", e = _(this, Gf).get(t);
    if (e)
      return e;
    const r = this.messageHandler.sendWithPromise(t, null).then((i) => {
      var s, o;
      return {
        info: i[0],
        metadata: i[1] ? new YDe(i[1]) : null,
        contentDispositionFilename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null,
        contentLength: ((o = this._fullReader) == null ? void 0 : o.contentLength) ?? null
      };
    });
    return _(this, Gf).set(t, r), r;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(t = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const e of _(this, rh).values())
        if (!e.cleanup())
          throw new Error(`startCleanup: Page ${e.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), t || this.fontLoader.clear(), _(this, Gf).clear(), this.filterFactory.destroy(!0), XM.cleanup();
    }
  }
  cachedPageNumber(t) {
    if (!UV(t))
      return null;
    const e = t.gen === 0 ? `${t.num}R` : `${t.num}R${t.gen}`;
    return _(this, Ex).get(e) ?? null;
  }
}
Gf = new WeakMap(), rh = new WeakMap(), Cx = new WeakMap(), Ex = new WeakMap(), ih = new WeakMap(), Ey = new WeakSet(), v1 = function(t, e = null) {
  const r = _(this, Gf).get(t);
  if (r)
    return r;
  const i = this.messageHandler.sendWithPromise(t, e);
  return _(this, Gf).set(t, i), i;
};
const HI = Symbol("INITIAL_DATA");
var Yu, H_, F$;
class Fee {
  constructor() {
    J(this, H_);
    J(this, Yu, /* @__PURE__ */ Object.create(null));
  }
  get(t, e = null) {
    if (e) {
      const i = Q(this, H_, F$).call(this, t);
      return i.promise.then(() => e(i.data)), null;
    }
    const r = _(this, Yu)[t];
    if (!r || r.data === HI)
      throw new Error(`Requesting object that isn't resolved yet ${t}.`);
    return r.data;
  }
  has(t) {
    const e = _(this, Yu)[t];
    return !!e && e.data !== HI;
  }
  resolve(t, e = null) {
    const r = Q(this, H_, F$).call(this, t);
    r.data = e, r.resolve();
  }
  clear() {
    var t;
    for (const e in _(this, Yu)) {
      const {
        data: r
      } = _(this, Yu)[e];
      (t = r == null ? void 0 : r.bitmap) == null || t.close();
    }
    q(this, Yu, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const t in _(this, Yu)) {
      const {
        data: e
      } = _(this, Yu)[t];
      e !== HI && (yield [t, e]);
    }
  }
}
Yu = new WeakMap(), H_ = new WeakSet(), F$ = function(t) {
  var e;
  return (e = _(this, Yu))[t] || (e[t] = {
    ...Promise.withResolvers(),
    data: HI
  });
};
var em;
class MOe {
  constructor(t) {
    J(this, em, null);
    q(this, em, t), this.onContinue = null;
  }
  get promise() {
    return _(this, em).capability.promise;
  }
  cancel(t = 0) {
    _(this, em).cancel(null, t);
  }
  get separateAnnots() {
    const {
      separateAnnots: t
    } = _(this, em).operatorList;
    if (!t)
      return !1;
    const {
      annotationCanvasMap: e
    } = _(this, em);
    return t.form || t.canvas && (e == null ? void 0 : e.size) > 0;
  }
}
em = new WeakMap();
var tm, _y;
const qv = class qv {
  constructor({
    callback: t,
    params: e,
    objs: r,
    commonObjs: i,
    annotationCanvasMap: s,
    operatorList: o,
    pageIndex: l,
    canvasFactory: u,
    filterFactory: d,
    useRequestAnimationFrame: f = !1,
    pdfBug: m = !1,
    pageColors: v = null
  }) {
    J(this, tm, null);
    this.callback = t, this.params = e, this.objs = r, this.commonObjs = i, this.annotationCanvasMap = s, this.operatorListIdx = null, this.operatorList = o, this._pageIndex = l, this.canvasFactory = u, this.filterFactory = d, this._pdfBug = m, this.pageColors = v, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = f === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new MOe(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = e.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: t = !1,
    optionalContentConfig: e
  }) {
    var l, u;
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (_(qv, _y).has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      _(qv, _y).add(this._canvas);
    }
    this._pdfBug && ((l = globalThis.StepperManager) != null && l.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      canvasContext: r,
      viewport: i,
      transform: s,
      background: o
    } = this.params;
    this.gfx = new q0(r, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: e
    }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
      transform: s,
      viewport: i,
      transparency: t,
      background: o
    }), this.operatorListIdx = 0, this.graphicsReady = !0, (u = this.graphicsReadyCallback) == null || u.call(this);
  }
  cancel(t = null, e = 0) {
    var r;
    this.running = !1, this.cancelled = !0, (r = this.gfx) == null || r.endDrawing(), _(this, tm) && (window.cancelAnimationFrame(_(this, tm)), q(this, tm, null)), _(qv, _y).delete(this._canvas), this.callback(t || new KU(`Rendering cancelled, page ${this._pageIndex + 1}`, e));
  }
  operatorListChanged() {
    var t;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (t = this.stepper) == null || t.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? q(this, tm, window.requestAnimationFrame(() => {
      q(this, tm, null), this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), _(qv, _y).delete(this._canvas), this.callback())));
  }
};
tm = new WeakMap(), _y = new WeakMap(), J(qv, _y, /* @__PURE__ */ new WeakSet());
let $$ = qv;
const DOe = "4.4.168", OOe = "19fbc8998";
function BV(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function HE(n) {
  return Math.max(0, Math.min(255, 255 * n));
}
class HV {
  static CMYK_G([t, e, r, i]) {
    return ["G", 1 - Math.min(1, 0.3 * t + 0.59 * r + 0.11 * e + i)];
  }
  static G_CMYK([t]) {
    return ["CMYK", 0, 0, 0, 1 - t];
  }
  static G_RGB([t]) {
    return ["RGB", t, t, t];
  }
  static G_rgb([t]) {
    return t = HE(t), [t, t, t];
  }
  static G_HTML([t]) {
    const e = BV(t);
    return `#${e}${e}${e}`;
  }
  static RGB_G([t, e, r]) {
    return ["G", 0.3 * t + 0.59 * e + 0.11 * r];
  }
  static RGB_rgb(t) {
    return t.map(HE);
  }
  static RGB_HTML(t) {
    return `#${t.map(BV).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([t, e, r, i]) {
    return ["RGB", 1 - Math.min(1, t + i), 1 - Math.min(1, r + i), 1 - Math.min(1, e + i)];
  }
  static CMYK_rgb([t, e, r, i]) {
    return [HE(1 - Math.min(1, t + i)), HE(1 - Math.min(1, r + i)), HE(1 - Math.min(1, e + i))];
  }
  static CMYK_HTML(t) {
    const e = this.CMYK_RGB(t).slice(1);
    return this.RGB_HTML(e);
  }
  static RGB_CMYK([t, e, r]) {
    const i = 1 - t, s = 1 - e, o = 1 - r, l = Math.min(i, s, o);
    return ["CMYK", i, s, o, l];
  }
}
class $ee {
  static setupStorage(t, e, r, i, s) {
    const o = i.getValue(e, {
      value: null
    });
    switch (r.name) {
      case "textarea":
        if (o.value !== null && (t.textContent = o.value), s === "print")
          break;
        t.addEventListener("input", (l) => {
          i.setValue(e, {
            value: l.target.value
          });
        });
        break;
      case "input":
        if (r.attributes.type === "radio" || r.attributes.type === "checkbox") {
          if (o.value === r.attributes.xfaOn ? t.setAttribute("checked", !0) : o.value === r.attributes.xfaOff && t.removeAttribute("checked"), s === "print")
            break;
          t.addEventListener("change", (l) => {
            i.setValue(e, {
              value: l.target.checked ? l.target.getAttribute("xfaOn") : l.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (o.value !== null && t.setAttribute("value", o.value), s === "print")
            break;
          t.addEventListener("input", (l) => {
            i.setValue(e, {
              value: l.target.value
            });
          });
        }
        break;
      case "select":
        if (o.value !== null) {
          t.setAttribute("value", o.value);
          for (const l of r.children)
            l.attributes.value === o.value ? l.attributes.selected = !0 : l.attributes.hasOwnProperty("selected") && delete l.attributes.selected;
        }
        t.addEventListener("input", (l) => {
          const u = l.target.options, d = u.selectedIndex === -1 ? "" : u[u.selectedIndex].value;
          i.setValue(e, {
            value: d
          });
        });
        break;
    }
  }
  static setAttributes({
    html: t,
    element: e,
    storage: r = null,
    intent: i,
    linkService: s
  }) {
    const {
      attributes: o
    } = e, l = t instanceof HTMLAnchorElement;
    o.type === "radio" && (o.name = `${o.name}-${i}`);
    for (const [u, d] of Object.entries(o))
      if (d != null)
        switch (u) {
          case "class":
            d.length && t.setAttribute(u, d.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            t.setAttribute("data-element-id", d);
            break;
          case "style":
            Object.assign(t.style, d);
            break;
          case "textContent":
            t.textContent = d;
            break;
          default:
            (!l || u !== "href" && u !== "newWindow") && t.setAttribute(u, d);
        }
    l && s.addLinkAttributes(t, o.href, o.newWindow), r && o.dataId && this.setupStorage(t, o.dataId, e, r);
  }
  static render(t) {
    var m, v;
    const e = t.annotationStorage, r = t.linkService, i = t.xfaHtml, s = t.intent || "display", o = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: o,
      element: i,
      intent: s,
      linkService: r
    });
    const l = s !== "richText", u = t.div;
    if (u.append(o), t.viewport) {
      const S = `matrix(${t.viewport.transform.join(",")})`;
      u.style.transform = S;
    }
    l && u.setAttribute("class", "xfaLayer xfaFont");
    const d = [];
    if (i.children.length === 0) {
      if (i.value) {
        const S = document.createTextNode(i.value);
        o.append(S), l && J1.shouldBuildText(i.name) && d.push(S);
      }
      return {
        textDivs: d
      };
    }
    const f = [[i, -1, o]];
    for (; f.length > 0; ) {
      const [S, w, E] = f.at(-1);
      if (w + 1 === S.children.length) {
        f.pop();
        continue;
      }
      const A = S.children[++f.at(-1)[1]];
      if (A === null)
        continue;
      const {
        name: P
      } = A;
      if (P === "#text") {
        const M = document.createTextNode(A.value);
        d.push(M), E.append(M);
        continue;
      }
      const R = (m = A == null ? void 0 : A.attributes) != null && m.xmlns ? document.createElementNS(A.attributes.xmlns, P) : document.createElement(P);
      if (E.append(R), A.attributes && this.setAttributes({
        html: R,
        element: A,
        storage: e,
        intent: s,
        linkService: r
      }), ((v = A.children) == null ? void 0 : v.length) > 0)
        f.push([A, -1, R]);
      else if (A.value) {
        const M = document.createTextNode(A.value);
        l && J1.shouldBuildText(P) && d.push(M), R.append(M);
      }
    }
    for (const S of u.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      S.setAttribute("readOnly", !0);
    return {
      textDivs: d
    };
  }
  static update(t) {
    const e = `matrix(${t.viewport.transform.join(",")})`;
    t.div.style.transform = e, t.div.hidden = !1;
  }
}
const oP = 1e3, LOe = 9, fS = /* @__PURE__ */ new WeakSet();
function pp(n) {
  return {
    width: n[2] - n[0],
    height: n[3] - n[1]
  };
}
class jOe {
  static create(t) {
    switch (t.data.annotationType) {
      case Os.LINK:
        return new zee(t);
      case Os.TEXT:
        return new NOe(t);
      case Os.WIDGET:
        switch (t.data.fieldType) {
          case "Tx":
            return new FOe(t);
          case "Btn":
            return t.data.radioButton ? new Hee(t) : t.data.checkBox ? new zOe(t) : new UOe(t);
          case "Ch":
            return new BOe(t);
          case "Sig":
            return new $Oe(t);
        }
        return new TS(t);
      case Os.POPUP:
        return new U$(t);
      case Os.FREETEXT:
        return new Yee(t);
      case Os.LINE:
        return new VOe(t);
      case Os.SQUARE:
        return new WOe(t);
      case Os.CIRCLE:
        return new GOe(t);
      case Os.POLYLINE:
        return new Xee(t);
      case Os.CARET:
        return new YOe(t);
      case Os.INK:
        return new qee(t);
      case Os.POLYGON:
        return new KOe(t);
      case Os.HIGHLIGHT:
        return new XOe(t);
      case Os.UNDERLINE:
        return new qOe(t);
      case Os.SQUIGGLY:
        return new ZOe(t);
      case Os.STRIKEOUT:
        return new QOe(t);
      case Os.STAMP:
        return new Zee(t);
      case Os.FILEATTACHMENT:
        return new JOe(t);
      default:
        return new Ji(t);
    }
  }
}
var Ty, _x, Tx, V_, z$;
const iB = class iB {
  constructor(t, {
    isRenderable: e = !1,
    ignoreBorder: r = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    J(this, V_);
    J(this, Ty, null);
    J(this, _x, !1);
    J(this, Tx, null);
    this.isRenderable = e, this.data = t.data, this.layer = t.layer, this.linkService = t.linkService, this.downloadManager = t.downloadManager, this.imageResourcesPath = t.imageResourcesPath, this.renderForms = t.renderForms, this.svgFactory = t.svgFactory, this.annotationStorage = t.annotationStorage, this.enableScripting = t.enableScripting, this.hasJSActions = t.hasJSActions, this._fieldObjects = t.fieldObjects, this.parent = t.parent, e && (this.container = this._createContainer(r)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    titleObj: t,
    contentsObj: e,
    richText: r
  }) {
    return !!(t != null && t.str || e != null && e.str || r != null && r.str);
  }
  get hasPopupData() {
    return iB._hasPopupData(this.data);
  }
  updateEdited(t) {
    var r;
    if (!this.container)
      return;
    _(this, Ty) || q(this, Ty, {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: e
    } = t;
    e && Q(this, V_, z$).call(this, e), (r = _(this, Tx)) == null || r.popup.updateEdited(t);
  }
  resetEdited() {
    var t;
    _(this, Ty) && (Q(this, V_, z$).call(this, _(this, Ty).rect), (t = _(this, Tx)) == null || t.popup.resetEdited(), q(this, Ty, null));
  }
  _createContainer(t) {
    const {
      data: e,
      parent: {
        page: r,
        viewport: i
      }
    } = this, s = document.createElement("section");
    s.setAttribute("data-annotation-id", e.id), this instanceof TS || (s.tabIndex = oP);
    const {
      style: o
    } = s;
    if (o.zIndex = this.parent.zIndex++, e.popupRef && s.setAttribute("aria-haspopup", "dialog"), e.alternativeText && (s.title = e.alternativeText), e.noRotate && s.classList.add("norotate"), !e.rect || this instanceof U$) {
      const {
        rotation: E
      } = e;
      return !e.hasOwnCanvas && E !== 0 && this.setRotation(E, s), s;
    }
    const {
      width: l,
      height: u
    } = pp(e.rect);
    if (!t && e.borderStyle.width > 0) {
      o.borderWidth = `${e.borderStyle.width}px`;
      const E = e.borderStyle.horizontalCornerRadius, A = e.borderStyle.verticalCornerRadius;
      if (E > 0 || A > 0) {
        const R = `calc(${E}px * var(--scale-factor)) / calc(${A}px * var(--scale-factor))`;
        o.borderRadius = R;
      } else if (this instanceof Hee) {
        const R = `calc(${l}px * var(--scale-factor)) / calc(${u}px * var(--scale-factor))`;
        o.borderRadius = R;
      }
      switch (e.borderStyle.style) {
        case UE.SOLID:
          o.borderStyle = "solid";
          break;
        case UE.DASHED:
          o.borderStyle = "dashed";
          break;
        case UE.BEVELED:
          In("Unimplemented border style: beveled");
          break;
        case UE.INSET:
          In("Unimplemented border style: inset");
          break;
        case UE.UNDERLINE:
          o.borderBottomStyle = "solid";
          break;
      }
      const P = e.borderColor || null;
      P ? (q(this, _x, !0), o.borderColor = Ft.makeHexColor(P[0] | 0, P[1] | 0, P[2] | 0)) : o.borderWidth = 0;
    }
    const d = Ft.normalizeRect([e.rect[0], r.view[3] - e.rect[1] + r.view[1], e.rect[2], r.view[3] - e.rect[3] + r.view[1]]), {
      pageWidth: f,
      pageHeight: m,
      pageX: v,
      pageY: S
    } = i.rawDims;
    o.left = `${100 * (d[0] - v) / f}%`, o.top = `${100 * (d[1] - S) / m}%`;
    const {
      rotation: w
    } = e;
    return e.hasOwnCanvas || w === 0 ? (o.width = `${100 * l / f}%`, o.height = `${100 * u / m}%`) : this.setRotation(w, s), s;
  }
  setRotation(t, e = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: r,
      pageHeight: i
    } = this.parent.viewport.rawDims, {
      width: s,
      height: o
    } = pp(this.data.rect);
    let l, u;
    t % 180 === 0 ? (l = 100 * s / r, u = 100 * o / i) : (l = 100 * o / r, u = 100 * s / i), e.style.width = `${l}%`, e.style.height = `${u}%`, e.setAttribute("data-main-rotation", (360 - t) % 360);
  }
  get _commonActions() {
    const t = (e, r, i) => {
      const s = i.detail[e], o = s[0], l = s.slice(1);
      i.target.style[r] = HV[`${o}_HTML`](l), this.annotationStorage.setValue(this.data.id, {
        [r]: HV[`${o}_rgb`](l)
      });
    };
    return lr(this, "_commonActions", {
      display: (e) => {
        const {
          display: r
        } = e.detail, i = r % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: r === 1 || r === 2
        });
      },
      print: (e) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !e.detail.print
        });
      },
      hidden: (e) => {
        const {
          hidden: r
        } = e.detail;
        this.container.style.visibility = r ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: r,
          noView: r
        });
      },
      focus: (e) => {
        setTimeout(() => e.target.focus({
          preventScroll: !1
        }), 0);
      },
      userName: (e) => {
        e.target.title = e.detail.userName;
      },
      readonly: (e) => {
        e.target.disabled = e.detail.readonly;
      },
      required: (e) => {
        this._setRequired(e.target, e.detail.required);
      },
      bgColor: (e) => {
        t("bgColor", "backgroundColor", e);
      },
      fillColor: (e) => {
        t("fillColor", "backgroundColor", e);
      },
      fgColor: (e) => {
        t("fgColor", "color", e);
      },
      textColor: (e) => {
        t("textColor", "color", e);
      },
      borderColor: (e) => {
        t("borderColor", "borderColor", e);
      },
      strokeColor: (e) => {
        t("strokeColor", "borderColor", e);
      },
      rotation: (e) => {
        const r = e.detail.rotation;
        this.setRotation(r), this.annotationStorage.setValue(this.data.id, {
          rotation: r
        });
      }
    });
  }
  _dispatchEventFromSandbox(t, e) {
    const r = this._commonActions;
    for (const i of Object.keys(e.detail)) {
      const s = t[i] || r[i];
      s == null || s(e);
    }
  }
  _setDefaultPropertiesFromJS(t) {
    if (!this.enableScripting)
      return;
    const e = this.annotationStorage.getRawValue(this.data.id);
    if (!e)
      return;
    const r = this._commonActions;
    for (const [i, s] of Object.entries(e)) {
      const o = r[i];
      if (o) {
        const l = {
          detail: {
            [i]: s
          },
          target: t
        };
        o(l), delete e[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: t
    } = this.data;
    if (!t)
      return;
    const [e, r, i, s] = this.data.rect.map((E) => Math.fround(E));
    if (t.length === 8) {
      const [E, A, P, R] = t.subarray(2, 6);
      if (i === E && s === A && e === P && r === R)
        return;
    }
    const {
      style: o
    } = this.container;
    let l;
    if (_(this, _x)) {
      const {
        borderColor: E,
        borderWidth: A
      } = o;
      o.borderWidth = 0, l = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${E}" stroke-width="${A}">`], this.container.classList.add("hasBorder");
    }
    const u = i - e, d = s - r, {
      svgFactory: f
    } = this, m = f.createElement("svg");
    m.classList.add("quadrilateralsContainer"), m.setAttribute("width", 0), m.setAttribute("height", 0);
    const v = f.createElement("defs");
    m.append(v);
    const S = f.createElement("clipPath"), w = `clippath_${this.data.id}`;
    S.setAttribute("id", w), S.setAttribute("clipPathUnits", "objectBoundingBox"), v.append(S);
    for (let E = 2, A = t.length; E < A; E += 8) {
      const P = t[E], R = t[E + 1], M = t[E + 2], j = t[E + 3], $ = f.createElement("rect"), U = (M - e) / u, F = (s - R) / d, B = (P - M) / u, G = (R - j) / d;
      $.setAttribute("x", U), $.setAttribute("y", F), $.setAttribute("width", B), $.setAttribute("height", G), S.append($), l == null || l.push(`<rect vector-effect="non-scaling-stroke" x="${U}" y="${F}" width="${B}" height="${G}"/>`);
    }
    _(this, _x) && (l.push("</g></svg>')"), o.backgroundImage = l.join("")), this.container.append(m), this.container.style.clipPath = `url(#${w})`;
  }
  _createPopup() {
    const {
      container: t,
      data: e
    } = this;
    t.setAttribute("aria-haspopup", "dialog");
    const r = q(this, Tx, new U$({
      data: {
        color: e.color,
        titleObj: e.titleObj,
        modificationDate: e.modificationDate,
        contentsObj: e.contentsObj,
        richText: e.richText,
        parentRect: e.rect,
        borderStyle: 0,
        id: `popup_${e.id}`,
        rotation: e.rotation
      },
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(r.render());
  }
  render() {
    Lr("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(t, e = null) {
    const r = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[t];
      if (i)
        for (const {
          page: s,
          id: o,
          exportValues: l
        } of i) {
          if (s === -1 || o === e)
            continue;
          const u = typeof l == "string" ? l : null, d = document.querySelector(`[data-element-id="${o}"]`);
          if (d && !fS.has(d)) {
            In(`_getElementsByName - element not allowed: ${o}`);
            continue;
          }
          r.push({
            id: o,
            exportValue: u,
            domElement: d
          });
        }
      return r;
    }
    for (const i of document.getElementsByName(t)) {
      const {
        exportValue: s
      } = i, o = i.getAttribute("data-element-id");
      o !== e && fS.has(i) && r.push({
        id: o,
        exportValue: s,
        domElement: i
      });
    }
    return r;
  }
  show() {
    var t;
    this.container && (this.container.hidden = !1), (t = this.popup) == null || t.maybeShow();
  }
  hide() {
    var t;
    this.container && (this.container.hidden = !0), (t = this.popup) == null || t.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const t = this.getElementsToTriggerPopup();
    if (Array.isArray(t))
      for (const e of t)
        e.classList.add("highlightArea");
    else
      t.classList.add("highlightArea");
  }
  get _isEditable() {
    return !1;
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: t,
      data: {
        id: e
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var r;
      (r = this.linkService.eventBus) == null || r.dispatch("switchannotationeditormode", {
        source: this,
        mode: t,
        editId: e
      });
    });
  }
};
Ty = new WeakMap(), _x = new WeakMap(), Tx = new WeakMap(), V_ = new WeakSet(), z$ = function(t) {
  const {
    container: {
      style: e
    },
    data: {
      rect: r,
      rotation: i
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth: s,
          pageHeight: o,
          pageX: l,
          pageY: u
        }
      }
    }
  } = this;
  r == null || r.splice(0, 4, ...t);
  const {
    width: d,
    height: f
  } = pp(t);
  e.left = `${100 * (t[0] - l) / s}%`, e.top = `${100 * (o - t[3] + u) / o}%`, i === 0 ? (e.width = `${100 * d / s}%`, e.height = `${100 * f / o}%`) : this.setRotation(i);
};
let Ji = iB;
var pc, Gv, Uee, Bee;
class zee extends Ji {
  constructor(e, r = null) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !!(r != null && r.ignoreBorder),
      createQuadrilaterals: !0
    });
    J(this, pc);
    this.isTooltipOnly = e.data.isTooltipOnly;
  }
  render() {
    const {
      data: e,
      linkService: r
    } = this, i = document.createElement("a");
    i.setAttribute("data-element-id", e.id);
    let s = !1;
    return e.url ? (r.addLinkAttributes(i, e.url, e.newWindow), s = !0) : e.action ? (this._bindNamedAction(i, e.action), s = !0) : e.attachment ? (Q(this, pc, Uee).call(this, i, e.attachment, e.attachmentDest), s = !0) : e.setOCGState ? (Q(this, pc, Bee).call(this, i, e.setOCGState), s = !0) : e.dest ? (this._bindLink(i, e.dest), s = !0) : (e.actions && (e.actions.Action || e.actions["Mouse Up"] || e.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, e), s = !0), e.resetForm ? (this._bindResetFormAction(i, e.resetForm), s = !0) : this.isTooltipOnly && !s && (this._bindLink(i, ""), s = !0)), this.container.classList.add("linkAnnotation"), s && this.container.append(i), this.container;
  }
  _bindLink(e, r) {
    e.href = this.linkService.getDestinationHash(r), e.onclick = () => (r && this.linkService.goToDestination(r), !1), (r || r === "") && Q(this, pc, Gv).call(this);
  }
  _bindNamedAction(e, r) {
    e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeNamedAction(r), !1), Q(this, pc, Gv).call(this);
  }
  _bindJSAction(e, r) {
    e.href = this.linkService.getAnchorUrl("");
    const i = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const s of Object.keys(r.actions)) {
      const o = i.get(s);
      o && (e[o] = () => {
        var l;
        return (l = this.linkService.eventBus) == null || l.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: r.id,
            name: s
          }
        }), !1;
      });
    }
    e.onclick || (e.onclick = () => !1), Q(this, pc, Gv).call(this);
  }
  _bindResetFormAction(e, r) {
    const i = e.onclick;
    if (i || (e.href = this.linkService.getAnchorUrl("")), Q(this, pc, Gv).call(this), !this._fieldObjects) {
      In('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), i || (e.onclick = () => !1);
      return;
    }
    e.onclick = () => {
      var m;
      i == null || i();
      const {
        fields: s,
        refs: o,
        include: l
      } = r, u = [];
      if (s.length !== 0 || o.length !== 0) {
        const v = new Set(o);
        for (const S of s) {
          const w = this._fieldObjects[S] || [];
          for (const {
            id: E
          } of w)
            v.add(E);
        }
        for (const S of Object.values(this._fieldObjects))
          for (const w of S)
            v.has(w.id) === l && u.push(w);
      } else
        for (const v of Object.values(this._fieldObjects))
          u.push(...v);
      const d = this.annotationStorage, f = [];
      for (const v of u) {
        const {
          id: S
        } = v;
        switch (f.push(S), v.type) {
          case "text": {
            const E = v.defaultValue || "";
            d.setValue(S, {
              value: E
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const E = v.defaultValue === v.exportValues;
            d.setValue(S, {
              value: E
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const E = v.defaultValue || "";
            d.setValue(S, {
              value: E
            });
            break;
          }
          default:
            continue;
        }
        const w = document.querySelector(`[data-element-id="${S}"]`);
        if (w) {
          if (!fS.has(w)) {
            In(`_bindResetFormAction - element not allowed: ${S}`);
            continue;
          }
        } else continue;
        w.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && ((m = this.linkService.eventBus) == null || m.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: f,
          name: "ResetForm"
        }
      })), !1;
    };
  }
}
pc = new WeakSet(), Gv = function() {
  this.container.setAttribute("data-internal-link", "");
}, Uee = function(e, r, i = null) {
  e.href = this.linkService.getAnchorUrl(""), r.description && (e.title = r.description), e.onclick = () => {
    var s;
    return (s = this.downloadManager) == null || s.openOrDownloadData(r.content, r.filename, i), !1;
  }, Q(this, pc, Gv).call(this);
}, Bee = function(e, r) {
  e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeSetOCGState(r), !1), Q(this, pc, Gv).call(this);
};
class NOe extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const t = document.createElement("img");
    return t.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", t.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), t.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(t), this.container;
  }
}
class TS extends Ji {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(t) {
    var e;
    this.data.hasOwnCanvas && (((e = t.previousSibling) == null ? void 0 : e.nodeName) === "CANVAS" && (t.previousSibling.hidden = !0), t.hidden = !1);
  }
  _getKeyModifier(t) {
    return jl.platform.isMac ? t.metaKey : t.ctrlKey;
  }
  _setEventListener(t, e, r, i, s) {
    r.includes("mouse") ? t.addEventListener(r, (o) => {
      var l;
      (l = this.linkService.eventBus) == null || l.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: s(o),
          shift: o.shiftKey,
          modifier: this._getKeyModifier(o)
        }
      });
    }) : t.addEventListener(r, (o) => {
      var l;
      if (r === "blur") {
        if (!e.focused || !o.relatedTarget)
          return;
        e.focused = !1;
      } else if (r === "focus") {
        if (e.focused)
          return;
        e.focused = !0;
      }
      s && ((l = this.linkService.eventBus) == null || l.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: s(o)
        }
      }));
    });
  }
  _setEventListeners(t, e, r, i) {
    var s, o, l;
    for (const [u, d] of r)
      (d === "Action" || (s = this.data.actions) != null && s[d]) && ((d === "Focus" || d === "Blur") && (e || (e = {
        focused: !1
      })), this._setEventListener(t, e, u, d, i), d === "Focus" && !((o = this.data.actions) != null && o.Blur) ? this._setEventListener(t, e, "blur", "Blur", null) : d === "Blur" && !((l = this.data.actions) != null && l.Focus) && this._setEventListener(t, e, "focus", "Focus", null));
  }
  _setBackgroundColor(t) {
    const e = this.data.backgroundColor || null;
    t.style.backgroundColor = e === null ? "transparent" : Ft.makeHexColor(e[0], e[1], e[2]);
  }
  _setTextStyle(t) {
    const e = ["left", "center", "right"], {
      fontColor: r
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || LOe, s = t.style;
    let o;
    const l = 2, u = (d) => Math.round(10 * d) / 10;
    if (this.data.multiLine) {
      const d = Math.abs(this.data.rect[3] - this.data.rect[1] - l), f = Math.round(d / (gF * i)) || 1, m = d / f;
      o = Math.min(i, u(m / gF));
    } else {
      const d = Math.abs(this.data.rect[3] - this.data.rect[1] - l);
      o = Math.min(i, u(d / gF));
    }
    s.fontSize = `calc(${o}px * var(--scale-factor))`, s.color = Ft.makeHexColor(r[0], r[1], r[2]), this.data.textAlignment !== null && (s.textAlign = e[this.data.textAlignment]);
  }
  _setRequired(t, e) {
    e ? t.setAttribute("required", !0) : t.removeAttribute("required"), t.setAttribute("aria-required", e);
  }
}
class FOe extends TS {
  constructor(t) {
    const e = t.renderForms || t.data.hasOwnCanvas || !t.data.hasAppearance && !!t.data.fieldValue;
    super(t, {
      isRenderable: e
    });
  }
  setPropertyOnSiblings(t, e, r, i) {
    const s = this.annotationStorage;
    for (const o of this._getElementsByName(t.name, t.id))
      o.domElement && (o.domElement[e] = r), s.setValue(o.id, {
        [i]: r
      });
  }
  render() {
    var i, s;
    const t = this.annotationStorage, e = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let r = null;
    if (this.renderForms) {
      const o = t.getValue(e, {
        value: this.data.fieldValue
      });
      let l = o.value || "";
      const u = t.getValue(e, {
        charLimit: this.data.maxLen
      }).charLimit;
      u && l.length > u && (l = l.slice(0, u));
      let d = o.formattedValue || ((i = this.data.textContent) == null ? void 0 : i.join(`
`)) || null;
      d && this.data.comb && (d = d.replaceAll(/\s+/g, ""));
      const f = {
        userValue: l,
        formattedValue: d,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (r = document.createElement("textarea"), r.textContent = d ?? l, this.data.doNotScroll && (r.style.overflowY = "hidden")) : (r = document.createElement("input"), r.type = "text", r.setAttribute("value", d ?? l), this.data.doNotScroll && (r.style.overflowX = "hidden")), this.data.hasOwnCanvas && (r.hidden = !0), fS.add(r), r.setAttribute("data-element-id", e), r.disabled = this.data.readOnly, r.name = this.data.fieldName, r.tabIndex = oP, this._setRequired(r, this.data.required), u && (r.maxLength = u), r.addEventListener("input", (v) => {
        t.setValue(e, {
          value: v.target.value
        }), this.setPropertyOnSiblings(r, "value", v.target.value, "value"), f.formattedValue = null;
      }), r.addEventListener("resetform", (v) => {
        const S = this.data.defaultFieldValue ?? "";
        r.value = f.userValue = S, f.formattedValue = null;
      });
      let m = (v) => {
        const {
          formattedValue: S
        } = f;
        S != null && (v.target.value = S), v.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        r.addEventListener("focus", (S) => {
          var E;
          if (f.focused)
            return;
          const {
            target: w
          } = S;
          f.userValue && (w.value = f.userValue), f.lastCommittedValue = w.value, f.commitKey = 1, (E = this.data.actions) != null && E.Focus || (f.focused = !0);
        }), r.addEventListener("updatefromsandbox", (S) => {
          this.showElementAndHideCanvas(S.target);
          const w = {
            value(E) {
              f.userValue = E.detail.value ?? "", t.setValue(e, {
                value: f.userValue.toString()
              }), E.target.value = f.userValue;
            },
            formattedValue(E) {
              const {
                formattedValue: A
              } = E.detail;
              f.formattedValue = A, A != null && E.target !== document.activeElement && (E.target.value = A), t.setValue(e, {
                formattedValue: A
              });
            },
            selRange(E) {
              E.target.setSelectionRange(...E.detail.selRange);
            },
            charLimit: (E) => {
              var M;
              const {
                charLimit: A
              } = E.detail, {
                target: P
              } = E;
              if (A === 0) {
                P.removeAttribute("maxLength");
                return;
              }
              P.setAttribute("maxLength", A);
              let R = f.userValue;
              !R || R.length <= A || (R = R.slice(0, A), P.value = f.userValue = R, t.setValue(e, {
                value: R
              }), (M = this.linkService.eventBus) == null || M.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: e,
                  name: "Keystroke",
                  value: R,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: P.selectionStart,
                  selEnd: P.selectionEnd
                }
              }));
            }
          };
          this._dispatchEventFromSandbox(w, S);
        }), r.addEventListener("keydown", (S) => {
          var A;
          f.commitKey = 1;
          let w = -1;
          if (S.key === "Escape" ? w = 0 : S.key === "Enter" && !this.data.multiLine ? w = 2 : S.key === "Tab" && (f.commitKey = 3), w === -1)
            return;
          const {
            value: E
          } = S.target;
          f.lastCommittedValue !== E && (f.lastCommittedValue = E, f.userValue = E, (A = this.linkService.eventBus) == null || A.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: E,
              willCommit: !0,
              commitKey: w,
              selStart: S.target.selectionStart,
              selEnd: S.target.selectionEnd
            }
          }));
        });
        const v = m;
        m = null, r.addEventListener("blur", (S) => {
          var E, A;
          if (!f.focused || !S.relatedTarget)
            return;
          (E = this.data.actions) != null && E.Blur || (f.focused = !1);
          const {
            value: w
          } = S.target;
          f.userValue = w, f.lastCommittedValue !== w && ((A = this.linkService.eventBus) == null || A.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: w,
              willCommit: !0,
              commitKey: f.commitKey,
              selStart: S.target.selectionStart,
              selEnd: S.target.selectionEnd
            }
          })), v(S);
        }), (s = this.data.actions) != null && s.Keystroke && r.addEventListener("beforeinput", (S) => {
          var $;
          f.lastCommittedValue = null;
          const {
            data: w,
            target: E
          } = S, {
            value: A,
            selectionStart: P,
            selectionEnd: R
          } = E;
          let M = P, j = R;
          switch (S.inputType) {
            case "deleteWordBackward": {
              const U = A.substring(0, P).match(/\w*[^\w]*$/);
              U && (M -= U[0].length);
              break;
            }
            case "deleteWordForward": {
              const U = A.substring(P).match(/^[^\w]*\w*/);
              U && (j += U[0].length);
              break;
            }
            case "deleteContentBackward":
              P === R && (M -= 1);
              break;
            case "deleteContentForward":
              P === R && (j += 1);
              break;
          }
          S.preventDefault(), ($ = this.linkService.eventBus) == null || $.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: A,
              change: w || "",
              willCommit: !1,
              selStart: M,
              selEnd: j
            }
          });
        }), this._setEventListeners(r, f, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (S) => S.target.value);
      }
      if (m && r.addEventListener("blur", m), this.data.comb) {
        const S = (this.data.rect[2] - this.data.rect[0]) / u;
        r.classList.add("comb"), r.style.letterSpacing = `calc(${S}px * var(--scale-factor) - 1ch)`;
      }
    } else
      r = document.createElement("div"), r.textContent = this.data.fieldValue, r.style.verticalAlign = "middle", r.style.display = "table-cell", this.data.hasOwnCanvas && (r.hidden = !0);
    return this._setTextStyle(r), this._setBackgroundColor(r), this._setDefaultPropertiesFromJS(r), this.container.append(r), this.container;
  }
}
class $Oe extends TS {
  constructor(t) {
    super(t, {
      isRenderable: !!t.data.hasOwnCanvas
    });
  }
}
class zOe extends TS {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    const t = this.annotationStorage, e = this.data, r = e.id;
    let i = t.getValue(r, {
      value: e.exportValue === e.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", t.setValue(r, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const s = document.createElement("input");
    return fS.add(s), s.setAttribute("data-element-id", r), s.disabled = e.readOnly, this._setRequired(s, this.data.required), s.type = "checkbox", s.name = e.fieldName, i && s.setAttribute("checked", !0), s.setAttribute("exportValue", e.exportValue), s.tabIndex = oP, s.addEventListener("change", (o) => {
      const {
        name: l,
        checked: u
      } = o.target;
      for (const d of this._getElementsByName(l, r)) {
        const f = u && d.exportValue === e.exportValue;
        d.domElement && (d.domElement.checked = f), t.setValue(d.id, {
          value: f
        });
      }
      t.setValue(r, {
        value: u
      });
    }), s.addEventListener("resetform", (o) => {
      const l = e.defaultFieldValue || "Off";
      o.target.checked = l === e.exportValue;
    }), this.enableScripting && this.hasJSActions && (s.addEventListener("updatefromsandbox", (o) => {
      const l = {
        value(u) {
          u.target.checked = u.detail.value !== "Off", t.setValue(r, {
            value: u.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(l, o);
    }), this._setEventListeners(s, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (o) => o.target.checked)), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class Hee extends TS {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const t = this.annotationStorage, e = this.data, r = e.id;
    let i = t.getValue(r, {
      value: e.fieldValue === e.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== e.buttonValue, t.setValue(r, {
      value: i
    })), i)
      for (const o of this._getElementsByName(e.fieldName, r))
        t.setValue(o.id, {
          value: !1
        });
    const s = document.createElement("input");
    if (fS.add(s), s.setAttribute("data-element-id", r), s.disabled = e.readOnly, this._setRequired(s, this.data.required), s.type = "radio", s.name = e.fieldName, i && s.setAttribute("checked", !0), s.tabIndex = oP, s.addEventListener("change", (o) => {
      const {
        name: l,
        checked: u
      } = o.target;
      for (const d of this._getElementsByName(l, r))
        t.setValue(d.id, {
          value: !1
        });
      t.setValue(r, {
        value: u
      });
    }), s.addEventListener("resetform", (o) => {
      const l = e.defaultFieldValue;
      o.target.checked = l != null && l === e.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const o = e.buttonValue;
      s.addEventListener("updatefromsandbox", (l) => {
        const u = {
          value: (d) => {
            const f = o === d.detail.value;
            for (const m of this._getElementsByName(d.target.name)) {
              const v = f && m.id === r;
              m.domElement && (m.domElement.checked = v), t.setValue(m.id, {
                value: v
              });
            }
          }
        };
        this._dispatchEventFromSandbox(u, l);
      }), this._setEventListeners(s, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (l) => l.target.checked);
    }
    return this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class UOe extends zee {
  constructor(t) {
    super(t, {
      ignoreBorder: t.data.hasAppearance
    });
  }
  render() {
    const t = super.render();
    t.classList.add("buttonWidgetAnnotation", "pushButton");
    const e = t.lastChild;
    return this.enableScripting && this.hasJSActions && e && (this._setDefaultPropertiesFromJS(e), e.addEventListener("updatefromsandbox", (r) => {
      this._dispatchEventFromSandbox({}, r);
    })), t;
  }
}
class BOe extends TS {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const t = this.annotationStorage, e = this.data.id, r = t.getValue(e, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    fS.add(i), i.setAttribute("data-element-id", e), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = oP;
    let s = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (f) => {
      const m = this.data.defaultFieldValue;
      for (const v of i.options)
        v.selected = v.value === m;
    });
    for (const f of this.data.options) {
      const m = document.createElement("option");
      m.textContent = f.displayValue, m.value = f.exportValue, r.value.includes(f.exportValue) && (m.setAttribute("selected", !0), s = !1), i.append(m);
    }
    let o = null;
    if (s) {
      const f = document.createElement("option");
      f.value = " ", f.setAttribute("hidden", !0), f.setAttribute("selected", !0), i.prepend(f), o = () => {
        f.remove(), i.removeEventListener("input", o), o = null;
      }, i.addEventListener("input", o);
    }
    const l = (f) => {
      const m = f ? "value" : "textContent", {
        options: v,
        multiple: S
      } = i;
      return S ? Array.prototype.filter.call(v, (w) => w.selected).map((w) => w[m]) : v.selectedIndex === -1 ? null : v[v.selectedIndex][m];
    };
    let u = l(!1);
    const d = (f) => {
      const m = f.target.options;
      return Array.prototype.map.call(m, (v) => ({
        displayValue: v.textContent,
        exportValue: v.value
      }));
    };
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (f) => {
      const m = {
        value(v) {
          o == null || o();
          const S = v.detail.value, w = new Set(Array.isArray(S) ? S : [S]);
          for (const E of i.options)
            E.selected = w.has(E.value);
          t.setValue(e, {
            value: l(!0)
          }), u = l(!1);
        },
        multipleSelection(v) {
          i.multiple = !0;
        },
        remove(v) {
          const S = i.options, w = v.detail.remove;
          S[w].selected = !1, i.remove(w), S.length > 0 && Array.prototype.findIndex.call(S, (A) => A.selected) === -1 && (S[0].selected = !0), t.setValue(e, {
            value: l(!0),
            items: d(v)
          }), u = l(!1);
        },
        clear(v) {
          for (; i.length !== 0; )
            i.remove(0);
          t.setValue(e, {
            value: null,
            items: []
          }), u = l(!1);
        },
        insert(v) {
          const {
            index: S,
            displayValue: w,
            exportValue: E
          } = v.detail.insert, A = i.children[S], P = document.createElement("option");
          P.textContent = w, P.value = E, A ? A.before(P) : i.append(P), t.setValue(e, {
            value: l(!0),
            items: d(v)
          }), u = l(!1);
        },
        items(v) {
          const {
            items: S
          } = v.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const w of S) {
            const {
              displayValue: E,
              exportValue: A
            } = w, P = document.createElement("option");
            P.textContent = E, P.value = A, i.append(P);
          }
          i.options.length > 0 && (i.options[0].selected = !0), t.setValue(e, {
            value: l(!0),
            items: d(v)
          }), u = l(!1);
        },
        indices(v) {
          const S = new Set(v.detail.indices);
          for (const w of v.target.options)
            w.selected = S.has(w.index);
          t.setValue(e, {
            value: l(!0)
          }), u = l(!1);
        },
        editable(v) {
          v.target.disabled = !v.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(m, f);
    }), i.addEventListener("input", (f) => {
      var S;
      const m = l(!0), v = l(!1);
      t.setValue(e, {
        value: m
      }), f.preventDefault(), (S = this.linkService.eventBus) == null || S.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: e,
          name: "Keystroke",
          value: u,
          change: v,
          changeEx: m,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (f) => f.target.value)) : i.addEventListener("input", function(f) {
      t.setValue(e, {
        value: l(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
}
class U$ extends Ji {
  constructor(t) {
    const {
      data: e,
      elements: r
    } = t;
    super(t, {
      isRenderable: Ji._hasPopupData(e)
    }), this.elements = r, this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const t = this.popup = new HOe({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    }), e = [];
    for (const r of this.elements)
      r.popup = t, e.push(r.data.id), r.addHighlightArea();
    return this.container.setAttribute("aria-controls", e.map((r) => `${VJ}${r}`).join(",")), this.container;
  }
}
var Px, f2, p2, Ax, Py, $i, Kf, Ay, W_, G_, kx, Yf, Xu, Xf, K_, qf, Y_, ky, Iy, jr, zR, B$, Vee, Wee, Gee, Kee, UR, BR, H$;
class HOe {
  constructor({
    container: t,
    color: e,
    elements: r,
    titleObj: i,
    modificationDate: s,
    contentsObj: o,
    richText: l,
    parent: u,
    rect: d,
    parentRect: f,
    open: m
  }) {
    J(this, jr);
    J(this, Px, Q(this, jr, Gee).bind(this));
    J(this, f2, Q(this, jr, H$).bind(this));
    J(this, p2, Q(this, jr, BR).bind(this));
    J(this, Ax, Q(this, jr, UR).bind(this));
    J(this, Py, null);
    J(this, $i, null);
    J(this, Kf, null);
    J(this, Ay, null);
    J(this, W_, null);
    J(this, G_, null);
    J(this, kx, null);
    J(this, Yf, !1);
    J(this, Xu, null);
    J(this, Xf, null);
    J(this, K_, null);
    J(this, qf, null);
    J(this, Y_, null);
    J(this, ky, null);
    J(this, Iy, !1);
    var v;
    q(this, $i, t), q(this, Y_, i), q(this, Kf, o), q(this, qf, l), q(this, G_, u), q(this, Py, e), q(this, K_, d), q(this, kx, f), q(this, W_, r), q(this, Ay, XJ.toDateObject(s)), this.trigger = r.flatMap((S) => S.getElementsToTriggerPopup());
    for (const S of this.trigger)
      S.addEventListener("click", _(this, Ax)), S.addEventListener("mouseenter", _(this, p2)), S.addEventListener("mouseleave", _(this, f2)), S.classList.add("popupTriggerArea");
    for (const S of r)
      (v = S.container) == null || v.addEventListener("keydown", _(this, Px));
    _(this, $i).hidden = !0, m && Q(this, jr, UR).call(this);
  }
  render() {
    if (_(this, Xu))
      return;
    const t = q(this, Xu, document.createElement("div"));
    if (t.className = "popup", _(this, Py)) {
      const s = t.style.outlineColor = Ft.makeHexColor(..._(this, Py));
      CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? t.style.backgroundColor = `color-mix(in srgb, ${s} 30%, white)` : t.style.backgroundColor = Ft.makeHexColor(..._(this, Py).map((l) => Math.floor(0.7 * (255 - l) + l)));
    }
    const e = document.createElement("span");
    e.className = "header";
    const r = document.createElement("h1");
    if (e.append(r), {
      dir: r.dir,
      str: r.textContent
    } = _(this, Y_), t.append(e), _(this, Ay)) {
      const s = document.createElement("span");
      s.classList.add("popupDate"), s.setAttribute("data-l10n-id", "pdfjs-annotation-date-string"), s.setAttribute("data-l10n-args", JSON.stringify({
        date: _(this, Ay).toLocaleDateString(),
        time: _(this, Ay).toLocaleTimeString()
      })), e.append(s);
    }
    const i = _(this, jr, zR);
    if (i)
      $ee.render({
        xfaHtml: i,
        intent: "richText",
        div: t
      }), t.lastChild.classList.add("richText", "popupContent");
    else {
      const s = this._formatContents(_(this, Kf));
      t.append(s);
    }
    _(this, $i).append(t);
  }
  _formatContents({
    str: t,
    dir: e
  }) {
    const r = document.createElement("p");
    r.classList.add("popupContent"), r.dir = e;
    const i = t.split(/(?:\r\n?|\n)/);
    for (let s = 0, o = i.length; s < o; ++s) {
      const l = i[s];
      r.append(document.createTextNode(l)), s < o - 1 && r.append(document.createElement("br"));
    }
    return r;
  }
  updateEdited({
    rect: t,
    popupContent: e
  }) {
    var r;
    _(this, ky) || q(this, ky, {
      contentsObj: _(this, Kf),
      richText: _(this, qf)
    }), t && q(this, Xf, null), e && (q(this, qf, Q(this, jr, Wee).call(this, e)), q(this, Kf, null)), (r = _(this, Xu)) == null || r.remove(), q(this, Xu, null);
  }
  resetEdited() {
    var t;
    _(this, ky) && ({
      contentsObj: ec(this, Kf)._,
      richText: ec(this, qf)._
    } = _(this, ky), q(this, ky, null), (t = _(this, Xu)) == null || t.remove(), q(this, Xu, null), q(this, Xf, null));
  }
  forceHide() {
    q(this, Iy, this.isVisible), _(this, Iy) && (_(this, $i).hidden = !0);
  }
  maybeShow() {
    _(this, Iy) && (_(this, Xu) || Q(this, jr, BR).call(this), q(this, Iy, !1), _(this, $i).hidden = !1);
  }
  get isVisible() {
    return _(this, $i).hidden === !1;
  }
}
Px = new WeakMap(), f2 = new WeakMap(), p2 = new WeakMap(), Ax = new WeakMap(), Py = new WeakMap(), $i = new WeakMap(), Kf = new WeakMap(), Ay = new WeakMap(), W_ = new WeakMap(), G_ = new WeakMap(), kx = new WeakMap(), Yf = new WeakMap(), Xu = new WeakMap(), Xf = new WeakMap(), K_ = new WeakMap(), qf = new WeakMap(), Y_ = new WeakMap(), ky = new WeakMap(), Iy = new WeakMap(), jr = new WeakSet(), zR = function() {
  const t = _(this, qf), e = _(this, Kf);
  return t != null && t.str && (!(e != null && e.str) || e.str === t.str) && _(this, qf).html || null;
}, B$ = function() {
  var t, e, r;
  return ((r = (e = (t = _(this, jr, zR)) == null ? void 0 : t.attributes) == null ? void 0 : e.style) == null ? void 0 : r.fontSize) || 0;
}, Vee = function() {
  var t, e, r;
  return ((r = (e = (t = _(this, jr, zR)) == null ? void 0 : t.attributes) == null ? void 0 : e.style) == null ? void 0 : r.color) || null;
}, Wee = function(t) {
  const e = [], r = {
    str: t,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: e
      }]
    }
  }, i = {
    style: {
      color: _(this, jr, Vee),
      fontSize: _(this, jr, B$) ? `calc(${_(this, jr, B$)}px * var(--scale-factor))` : ""
    }
  };
  for (const s of t.split(`
`))
    e.push({
      name: "span",
      value: s,
      attributes: i
    });
  return r;
}, Gee = function(t) {
  t.altKey || t.shiftKey || t.ctrlKey || t.metaKey || (t.key === "Enter" || t.key === "Escape" && _(this, Yf)) && Q(this, jr, UR).call(this);
}, Kee = function() {
  if (_(this, Xf) !== null)
    return;
  const {
    page: {
      view: t
    },
    viewport: {
      rawDims: {
        pageWidth: e,
        pageHeight: r,
        pageX: i,
        pageY: s
      }
    }
  } = _(this, G_);
  let o = !!_(this, kx), l = o ? _(this, kx) : _(this, K_);
  for (const w of _(this, W_))
    if (!l || Ft.intersect(w.data.rect, l) !== null) {
      l = w.data.rect, o = !0;
      break;
    }
  const u = Ft.normalizeRect([l[0], t[3] - l[1] + t[1], l[2], t[3] - l[3] + t[1]]), f = o ? l[2] - l[0] + 5 : 0, m = u[0] + f, v = u[1];
  q(this, Xf, [100 * (m - i) / e, 100 * (v - s) / r]);
  const {
    style: S
  } = _(this, $i);
  S.left = `${_(this, Xf)[0]}%`, S.top = `${_(this, Xf)[1]}%`;
}, UR = function() {
  q(this, Yf, !_(this, Yf)), _(this, Yf) ? (Q(this, jr, BR).call(this), _(this, $i).addEventListener("click", _(this, Ax)), _(this, $i).addEventListener("keydown", _(this, Px))) : (Q(this, jr, H$).call(this), _(this, $i).removeEventListener("click", _(this, Ax)), _(this, $i).removeEventListener("keydown", _(this, Px)));
}, BR = function() {
  _(this, Xu) || this.render(), this.isVisible ? _(this, Yf) && _(this, $i).classList.add("focused") : (Q(this, jr, Kee).call(this), _(this, $i).hidden = !1, _(this, $i).style.zIndex = parseInt(_(this, $i).style.zIndex) + 1e3);
}, H$ = function() {
  _(this, $i).classList.remove("focused"), !(_(this, Yf) || !this.isVisible) && (_(this, $i).hidden = !0, _(this, $i).style.zIndex = parseInt(_(this, $i).style.zIndex) - 1e3);
};
class Yee extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = t.data.textContent, this.textPosition = t.data.textPosition, this.annotationEditorType = ir.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const t = document.createElement("div");
      t.classList.add("annotationTextContent"), t.setAttribute("role", "comment");
      for (const e of this.textContent) {
        const r = document.createElement("span");
        r.textContent = e, t.append(r);
      }
      this.container.append(t);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
  get _isEditable() {
    return this.data.hasOwnCanvas;
  }
}
var X_;
class VOe extends Ji {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    J(this, X_, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const e = this.data, {
      width: r,
      height: i
    } = pp(e.rect), s = this.svgFactory.create(r, i, !0), o = q(this, X_, this.svgFactory.createElement("svg:line"));
    return o.setAttribute("x1", e.rect[2] - e.lineCoordinates[0]), o.setAttribute("y1", e.rect[3] - e.lineCoordinates[1]), o.setAttribute("x2", e.rect[2] - e.lineCoordinates[2]), o.setAttribute("y2", e.rect[3] - e.lineCoordinates[3]), o.setAttribute("stroke-width", e.borderStyle.width || 1), o.setAttribute("stroke", "transparent"), o.setAttribute("fill", "transparent"), s.append(o), this.container.append(s), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return _(this, X_);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
X_ = new WeakMap();
var q_;
class WOe extends Ji {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    J(this, q_, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const e = this.data, {
      width: r,
      height: i
    } = pp(e.rect), s = this.svgFactory.create(r, i, !0), o = e.borderStyle.width, l = q(this, q_, this.svgFactory.createElement("svg:rect"));
    return l.setAttribute("x", o / 2), l.setAttribute("y", o / 2), l.setAttribute("width", r - o), l.setAttribute("height", i - o), l.setAttribute("stroke-width", o || 1), l.setAttribute("stroke", "transparent"), l.setAttribute("fill", "transparent"), s.append(l), this.container.append(s), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return _(this, q_);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
q_ = new WeakMap();
var Z_;
class GOe extends Ji {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    J(this, Z_, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const e = this.data, {
      width: r,
      height: i
    } = pp(e.rect), s = this.svgFactory.create(r, i, !0), o = e.borderStyle.width, l = q(this, Z_, this.svgFactory.createElement("svg:ellipse"));
    return l.setAttribute("cx", r / 2), l.setAttribute("cy", i / 2), l.setAttribute("rx", r / 2 - o / 2), l.setAttribute("ry", i / 2 - o / 2), l.setAttribute("stroke-width", o || 1), l.setAttribute("stroke", "transparent"), l.setAttribute("fill", "transparent"), s.append(l), this.container.append(s), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return _(this, Z_);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Z_ = new WeakMap();
var Q_;
class Xee extends Ji {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    J(this, Q_, null);
    this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: e,
        vertices: r,
        borderStyle: i,
        popupRef: s
      }
    } = this;
    if (!r)
      return this.container;
    const {
      width: o,
      height: l
    } = pp(e), u = this.svgFactory.create(o, l, !0);
    let d = [];
    for (let m = 0, v = r.length; m < v; m += 2) {
      const S = r[m] - e[0], w = e[3] - r[m + 1];
      d.push(`${S},${w}`);
    }
    d = d.join(" ");
    const f = q(this, Q_, this.svgFactory.createElement(this.svgElementName));
    return f.setAttribute("points", d), f.setAttribute("stroke-width", i.width || 1), f.setAttribute("stroke", "transparent"), f.setAttribute("fill", "transparent"), u.append(f), this.container.append(u), !s && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return _(this, Q_);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
Q_ = new WeakMap();
class KOe extends Xee {
  constructor(t) {
    super(t), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class YOe extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var J_;
class qee extends Ji {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    J(this, J_, []);
    this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = ir.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: e,
        inkLists: r,
        borderStyle: i,
        popupRef: s
      }
    } = this, {
      width: o,
      height: l
    } = pp(e), u = this.svgFactory.create(o, l, !0);
    for (const d of r) {
      let f = [];
      for (let v = 0, S = d.length; v < S; v += 2) {
        const w = d[v] - e[0], E = e[3] - d[v + 1];
        f.push(`${w},${E}`);
      }
      f = f.join(" ");
      const m = this.svgFactory.createElement(this.svgElementName);
      _(this, J_).push(m), m.setAttribute("points", f), m.setAttribute("stroke-width", i.width || 1), m.setAttribute("stroke", "transparent"), m.setAttribute("fill", "transparent"), !s && this.hasPopupData && this._createPopup(), u.append(m);
    }
    return this.container.append(u), this.container;
  }
  getElementsToTriggerPopup() {
    return _(this, J_);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
J_ = new WeakMap();
class XOe extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
  }
}
class qOe extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
  }
}
class ZOe extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
  }
}
class QOe extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
  }
}
class Zee extends Ji {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var eT, tT, V$;
class JOe extends Ji {
  constructor(e) {
    var i;
    super(e, {
      isRenderable: !0
    });
    J(this, tT);
    J(this, eT, null);
    const {
      file: r
    } = this.data;
    this.filename = r.filename, this.content = r.content, (i = this.linkService.eventBus) == null || i.dispatch("fileattachmentannotation", {
      source: this,
      ...r
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: e,
      data: r
    } = this;
    let i;
    r.hasAppearance || r.fillAlpha === 0 ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(r.name) ? "paperclip" : "pushpin"}.svg`, r.fillAlpha && r.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(r.fillAlpha * 100)}%);`)), i.addEventListener("dblclick", Q(this, tT, V$).bind(this)), q(this, eT, i);
    const {
      isMac: s
    } = jl.platform;
    return e.addEventListener("keydown", (o) => {
      o.key === "Enter" && (s ? o.metaKey : o.ctrlKey) && Q(this, tT, V$).call(this);
    }), !r.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), e.append(i), e;
  }
  getElementsToTriggerPopup() {
    return _(this, eT);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
eT = new WeakMap(), tT = new WeakSet(), V$ = function() {
  var e;
  (e = this.downloadManager) == null || e.openOrDownloadData(this.content, this.filename);
};
var nT, Ry, Ix, gS, Qee, W$, eW;
let eLe = (eW = class {
  constructor({
    div: t,
    accessibilityManager: e,
    annotationCanvasMap: r,
    annotationEditorUIManager: i,
    page: s,
    viewport: o
  }) {
    J(this, gS);
    J(this, nT, null);
    J(this, Ry, null);
    J(this, Ix, /* @__PURE__ */ new Map());
    this.div = t, q(this, nT, e), q(this, Ry, r), this.page = s, this.viewport = o, this.zIndex = 0, this._annotationEditorUIManager = i;
  }
  async render(t) {
    var o;
    const {
      annotations: e
    } = t, r = this.div;
    dS(r, this.viewport);
    const i = /* @__PURE__ */ new Map(), s = {
      data: null,
      layer: r,
      linkService: t.linkService,
      downloadManager: t.downloadManager,
      imageResourcesPath: t.imageResourcesPath || "",
      renderForms: t.renderForms !== !1,
      svgFactory: new GU(),
      annotationStorage: t.annotationStorage || new ZU(),
      enableScripting: t.enableScripting === !0,
      hasJSActions: t.hasJSActions,
      fieldObjects: t.fieldObjects,
      parent: this,
      elements: null
    };
    for (const l of e) {
      if (l.noHTML)
        continue;
      const u = l.annotationType === Os.POPUP;
      if (u) {
        const m = i.get(l.id);
        if (!m)
          continue;
        s.elements = m;
      } else {
        const {
          width: m,
          height: v
        } = pp(l.rect);
        if (m <= 0 || v <= 0)
          continue;
      }
      s.data = l;
      const d = jOe.create(s);
      if (!d.isRenderable)
        continue;
      if (!u && l.popupRef) {
        const m = i.get(l.popupRef);
        m ? m.push(d) : i.set(l.popupRef, [d]);
      }
      const f = d.render();
      l.hidden && (f.style.visibility = "hidden"), Q(this, gS, Qee).call(this, f, l.id), d.annotationEditorType > 0 && (_(this, Ix).set(d.data.id, d), (o = this._annotationEditorUIManager) == null || o.renderAnnotationElement(d));
    }
    Q(this, gS, W$).call(this);
  }
  update({
    viewport: t
  }) {
    const e = this.div;
    this.viewport = t, dS(e, {
      rotation: t.rotation
    }), Q(this, gS, W$).call(this), e.hidden = !1;
  }
  getEditableAnnotations() {
    return Array.from(_(this, Ix).values());
  }
  getEditableAnnotation(t) {
    return _(this, Ix).get(t);
  }
}, nT = new WeakMap(), Ry = new WeakMap(), Ix = new WeakMap(), gS = new WeakSet(), Qee = function(t, e) {
  var i;
  const r = t.firstChild || t;
  r.id = `${VJ}${e}`, this.div.append(t), (i = _(this, nT)) == null || i.moveElementInDOM(this.div, t, r, !1);
}, W$ = function() {
  if (!_(this, Ry))
    return;
  const t = this.div;
  for (const [e, r] of _(this, Ry)) {
    const i = t.querySelector(`[data-annotation-id="${e}"]`);
    if (!i)
      continue;
    r.className = "annotationContent";
    const {
      firstChild: s
    } = i;
    s ? s.nodeName === "CANVAS" ? s.replaceWith(r) : s.classList.contains("annotationContent") ? s.after(r) : s.before(r) : i.append(r);
  }
  _(this, Ry).clear();
}, eW);
const VI = /\r\n?|\n/g;
var rT, iT, sT, oT, aT, qu, lc, lT, cc, Rx, ys, Jee, ete, tte, HR, mp, VR, WR, nte, K$, rte;
const Jr = class Jr extends Pr {
  constructor(e) {
    super({
      ...e,
      name: "freeTextEditor"
    });
    J(this, ys);
    J(this, rT, this.editorDivBlur.bind(this));
    J(this, iT, this.editorDivFocus.bind(this));
    J(this, sT, this.editorDivInput.bind(this));
    J(this, oT, this.editorDivKeydown.bind(this));
    J(this, aT, this.editorDivPaste.bind(this));
    J(this, qu);
    J(this, lc, "");
    J(this, lT, `${this.id}-editor`);
    J(this, cc);
    J(this, Rx, null);
    q(this, qu, e.color || Jr._defaultColor || Pr._defaultLineColor), q(this, cc, e.fontSize || Jr._defaultFontSize);
  }
  static get _keyboardManager() {
    const e = Jr.prototype, r = (o) => o.isEmpty(), i = hS.TRANSLATE_SMALL, s = hS.TRANSLATE_BIG;
    return lr(this, "_keyboardManager", new iP([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e._translateEmpty, {
      args: [-i, 0],
      checker: r
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e._translateEmpty, {
      args: [-s, 0],
      checker: r
    }], [["ArrowRight", "mac+ArrowRight"], e._translateEmpty, {
      args: [i, 0],
      checker: r
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e._translateEmpty, {
      args: [s, 0],
      checker: r
    }], [["ArrowUp", "mac+ArrowUp"], e._translateEmpty, {
      args: [0, -i],
      checker: r
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e._translateEmpty, {
      args: [0, -s],
      checker: r
    }], [["ArrowDown", "mac+ArrowDown"], e._translateEmpty, {
      args: [0, i],
      checker: r
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e._translateEmpty, {
      args: [0, s],
      checker: r
    }]]));
  }
  static initialize(e, r) {
    Pr.initialize(e, r, {
      strings: ["pdfjs-free-text-default-content"]
    });
    const i = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(e, r) {
    switch (e) {
      case gn.FREETEXT_SIZE:
        Jr._defaultFontSize = r;
        break;
      case gn.FREETEXT_COLOR:
        Jr._defaultColor = r;
        break;
    }
  }
  updateParams(e, r) {
    switch (e) {
      case gn.FREETEXT_SIZE:
        Q(this, ys, Jee).call(this, r);
        break;
      case gn.FREETEXT_COLOR:
        Q(this, ys, ete).call(this, r);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[gn.FREETEXT_SIZE, Jr._defaultFontSize], [gn.FREETEXT_COLOR, Jr._defaultColor || Pr._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[gn.FREETEXT_SIZE, _(this, cc)], [gn.FREETEXT_COLOR, _(this, qu)]];
  }
  _translateEmpty(e, r) {
    this._uiManager.translateSelectedEditors(e, r, !0);
  }
  getInitialTranslation() {
    const e = this.parentScale;
    return [-Jr._internalPadding * e, -(Jr._internalPadding + _(this, cc)) * e];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (this.isInEditMode())
      return;
    this.parent.setEditingState(!1), this.parent.updateToolbar(ir.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant");
    const e = this._uiManager._signal;
    this.editorDiv.addEventListener("keydown", _(this, oT), {
      signal: e
    }), this.editorDiv.addEventListener("focus", _(this, iT), {
      signal: e
    }), this.editorDiv.addEventListener("blur", _(this, rT), {
      signal: e
    }), this.editorDiv.addEventListener("input", _(this, sT), {
      signal: e
    }), this.editorDiv.addEventListener("paste", _(this, aT), {
      signal: e
    });
  }
  disableEditMode() {
    this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", _(this, lT)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", _(this, oT)), this.editorDiv.removeEventListener("focus", _(this, iT)), this.editorDiv.removeEventListener("blur", _(this, rT)), this.editorDiv.removeEventListener("input", _(this, sT)), this.editorDiv.removeEventListener("paste", _(this, aT)), this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
  }
  focusin(e) {
    this._focusEventsAllowed && (super.focusin(e), e.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded() {
    var e;
    this.width || (this.enableEditMode(), this.editorDiv.focus(), (e = this._initialOptions) != null && e.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const e = _(this, lc), r = q(this, lc, Q(this, ys, tte).call(this).trimEnd());
    if (e === r)
      return;
    const i = (s) => {
      if (q(this, lc, s), !s) {
        this.remove();
        return;
      }
      Q(this, ys, WR).call(this), this._uiManager.rebuild(this), Q(this, ys, HR).call(this);
    };
    this.addCommands({
      cmd: () => {
        i(r);
      },
      undo: () => {
        i(e);
      },
      mustExec: !1
    }), Q(this, ys, HR).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  dblclick(e) {
    this.enterInEditMode();
  }
  keydown(e) {
    e.target === this.div && e.key === "Enter" && (this.enterInEditMode(), e.preventDefault());
  }
  editorDivKeydown(e) {
    Jr._keyboardManager.exec(this, e);
  }
  editorDivFocus(e) {
    this.isEditing = !0;
  }
  editorDivBlur(e) {
    this.isEditing = !1;
  }
  editorDivInput(e) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  render() {
    if (this.div)
      return this.div;
    let e, r;
    this.width && (e = this.x, r = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", _(this, lT)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), Pr._l10nPromise.get("pdfjs-free-text-default-content").then((s) => {
      var o;
      return (o = this.editorDiv) == null ? void 0 : o.setAttribute("default-content", s);
    }), this.editorDiv.contentEditable = !0;
    const {
      style: i
    } = this.editorDiv;
    if (i.fontSize = `calc(${_(this, cc)}px * var(--scale-factor))`, i.color = _(this, qu), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), GM(this, this.div, ["dblclick", "keydown"]), this.width) {
      const [s, o] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: l
        } = _(this, Rx);
        let [u, d] = this.getInitialTranslation();
        [u, d] = this.pageTranslationToScreen(u, d);
        const [f, m] = this.pageDimensions, [v, S] = this.pageTranslation;
        let w, E;
        switch (this.rotation) {
          case 0:
            w = e + (l[0] - v) / f, E = r + this.height - (l[1] - S) / m;
            break;
          case 90:
            w = e + (l[0] - v) / f, E = r - (l[1] - S) / m, [u, d] = [d, -u];
            break;
          case 180:
            w = e - this.width + (l[0] - v) / f, E = r - (l[1] - S) / m, [u, d] = [-u, -d];
            break;
          case 270:
            w = e + (l[0] - v - this.height * m) / f, E = r + (l[1] - S - this.width * f) / m, [u, d] = [-d, u];
            break;
        }
        this.setAt(w * s, E * o, u, d);
      } else
        this.setAt(e * s, r * o, this.width * s, this.height * o);
      Q(this, ys, WR).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  editorDivPaste(e) {
    var w, E, A;
    const r = e.clipboardData || window.clipboardData, {
      types: i
    } = r;
    if (i.length === 1 && i[0] === "text/plain")
      return;
    e.preventDefault();
    const s = Q(w = Jr, mp, K$).call(w, r.getData("text") || "").replaceAll(VI, `
`);
    if (!s)
      return;
    const o = window.getSelection();
    if (!o.rangeCount)
      return;
    this.editorDiv.normalize(), o.deleteFromDocument();
    const l = o.getRangeAt(0);
    if (!s.includes(`
`)) {
      l.insertNode(document.createTextNode(s)), this.editorDiv.normalize(), o.collapseToStart();
      return;
    }
    const {
      startContainer: u,
      startOffset: d
    } = l, f = [], m = [];
    if (u.nodeType === Node.TEXT_NODE) {
      const P = u.parentElement;
      if (m.push(u.nodeValue.slice(d).replaceAll(VI, "")), P !== this.editorDiv) {
        let R = f;
        for (const M of this.editorDiv.childNodes) {
          if (M === P) {
            R = m;
            continue;
          }
          R.push(Q(E = Jr, mp, VR).call(E, M));
        }
      }
      f.push(u.nodeValue.slice(0, d).replaceAll(VI, ""));
    } else if (u === this.editorDiv) {
      let P = f, R = 0;
      for (const M of this.editorDiv.childNodes)
        R++ === d && (P = m), P.push(Q(A = Jr, mp, VR).call(A, M));
    }
    q(this, lc, `${f.join(`
`)}${s}${m.join(`
`)}`), Q(this, ys, WR).call(this);
    const v = new Range();
    let S = f.reduce((P, R) => P + R.length, 0);
    for (const {
      firstChild: P
    } of this.editorDiv.childNodes)
      if (P.nodeType === Node.TEXT_NODE) {
        const R = P.nodeValue.length;
        if (S <= R) {
          v.setStart(P, S), v.setEnd(P, S);
          break;
        }
        S -= R;
      }
    o.removeAllRanges(), o.addRange(v);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static deserialize(e, r, i) {
    var l;
    let s = null;
    if (e instanceof Yee) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: u,
            fontColor: d
          },
          rect: f,
          rotation: m,
          id: v
        },
        textContent: S,
        textPosition: w,
        parent: {
          page: {
            pageNumber: E
          }
        }
      } = e;
      if (!S || S.length === 0)
        return null;
      s = e = {
        annotationType: ir.FREETEXT,
        color: Array.from(d),
        fontSize: u,
        value: S.join(`
`),
        position: w,
        pageIndex: E - 1,
        rect: f.slice(0),
        rotation: m,
        id: v,
        deleted: !1
      };
    }
    const o = super.deserialize(e, r, i);
    return q(o, cc, e.fontSize), q(o, qu, Ft.makeHexColor(...e.color)), q(o, lc, Q(l = Jr, mp, K$).call(l, e.value)), o.annotationElementId = e.id || null, q(o, Rx, s), o;
  }
  serialize(e = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return {
        pageIndex: this.pageIndex,
        id: this.annotationElementId,
        deleted: !0
      };
    const r = Jr._internalPadding * this.parentScale, i = this.getRect(r, r), s = Pr._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : _(this, qu)), o = {
      annotationType: ir.FREETEXT,
      color: s,
      fontSize: _(this, cc),
      value: Q(this, ys, nte).call(this),
      pageIndex: this.pageIndex,
      rect: i,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return e ? o : this.annotationElementId && !Q(this, ys, rte).call(this, o) ? null : (o.id = this.annotationElementId, o);
  }
  renderAnnotationElement(e) {
    const r = super.renderAnnotationElement(e);
    if (this.deleted)
      return r;
    const {
      style: i
    } = r;
    i.fontSize = `calc(${_(this, cc)}px * var(--scale-factor))`, i.color = _(this, qu), r.replaceChildren();
    for (const o of _(this, lc).split(`
`)) {
      const l = document.createElement("div");
      l.append(o ? document.createTextNode(o) : document.createElement("br")), r.append(l);
    }
    const s = Jr._internalPadding * this.parentScale;
    return e.updateEdited({
      rect: this.getRect(s, s),
      popupContent: _(this, lc)
    }), r;
  }
  resetAnnotationElement(e) {
    super.resetAnnotationElement(e), e.resetEdited();
  }
};
rT = new WeakMap(), iT = new WeakMap(), sT = new WeakMap(), oT = new WeakMap(), aT = new WeakMap(), qu = new WeakMap(), lc = new WeakMap(), lT = new WeakMap(), cc = new WeakMap(), Rx = new WeakMap(), ys = new WeakSet(), Jee = function(e) {
  const r = (s) => {
    this.editorDiv.style.fontSize = `calc(${s}px * var(--scale-factor))`, this.translate(0, -(s - _(this, cc)) * this.parentScale), q(this, cc, s), Q(this, ys, HR).call(this);
  }, i = _(this, cc);
  this.addCommands({
    cmd: r.bind(this, e),
    undo: r.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.FREETEXT_SIZE,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, ete = function(e) {
  const r = (s) => {
    q(this, qu, this.editorDiv.style.color = s);
  }, i = _(this, qu);
  this.addCommands({
    cmd: r.bind(this, e),
    undo: r.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.FREETEXT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, tte = function() {
  var r;
  const e = [];
  this.editorDiv.normalize();
  for (const i of this.editorDiv.childNodes)
    e.push(Q(r = Jr, mp, VR).call(r, i));
  return e.join(`
`);
}, HR = function() {
  const [e, r] = this.parentDimensions;
  let i;
  if (this.isAttachedToDOM)
    i = this.div.getBoundingClientRect();
  else {
    const {
      currentLayer: s,
      div: o
    } = this, l = o.style.display, u = o.classList.contains("hidden");
    o.classList.remove("hidden"), o.style.display = "hidden", s.div.append(this.div), i = o.getBoundingClientRect(), o.remove(), o.style.display = l, o.classList.toggle("hidden", u);
  }
  this.rotation % 180 === this.parentRotation % 180 ? (this.width = i.width / e, this.height = i.height / r) : (this.width = i.height / e, this.height = i.width / r), this.fixAndSetPosition();
}, mp = new WeakSet(), VR = function(e) {
  return (e.nodeType === Node.TEXT_NODE ? e.nodeValue : e.innerText).replaceAll(VI, "");
}, WR = function() {
  if (this.editorDiv.replaceChildren(), !!_(this, lc))
    for (const e of _(this, lc).split(`
`)) {
      const r = document.createElement("div");
      r.append(e ? document.createTextNode(e) : document.createElement("br")), this.editorDiv.append(r);
    }
}, nte = function() {
  return _(this, lc).replaceAll(" ", " ");
}, K$ = function(e) {
  return e.replaceAll(" ", " ");
}, rte = function(e) {
  const {
    value: r,
    fontSize: i,
    color: s,
    pageIndex: o
  } = _(this, Rx);
  return this._hasBeenMoved || e.value !== r || e.fontSize !== i || e.color.some((l, u) => l !== s[u]) || e.pageIndex !== o;
}, J(Jr, mp), T(Jr, "_freeTextDefaultContent", ""), T(Jr, "_internalPadding", 0), T(Jr, "_defaultColor", null), T(Jr, "_defaultFontSize", 10), T(Jr, "_type", "freetext"), T(Jr, "_editorType", ir.FREETEXT);
let G$ = Jr;
var cT, nm, Zu, Ha, ite, GR, ste, ote, X$;
class Y$ {
  constructor(t, e = 0, r = 0, i = !0) {
    J(this, Ha);
    J(this, cT);
    J(this, nm, []);
    J(this, Zu, []);
    let s = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0;
    const f = 10 ** -4;
    for (const {
      x: P,
      y: R,
      width: M,
      height: j
    } of t) {
      const $ = Math.floor((P - e) / f) * f, U = Math.ceil((P + M + e) / f) * f, F = Math.floor((R - e) / f) * f, B = Math.ceil((R + j + e) / f) * f, G = [$, F, B, !0], X = [U, F, B, !1];
      _(this, nm).push(G, X), s = Math.min(s, $), o = Math.max(o, U), l = Math.min(l, F), u = Math.max(u, B);
    }
    const m = o - s + 2 * r, v = u - l + 2 * r, S = s - r, w = l - r, E = _(this, nm).at(i ? -1 : -2), A = [E[0], E[2]];
    for (const P of _(this, nm)) {
      const [R, M, j] = P;
      P[0] = (R - S) / m, P[1] = (M - w) / v, P[2] = (j - w) / v;
    }
    q(this, cT, {
      x: S,
      y: w,
      width: m,
      height: v,
      lastPoint: A
    });
  }
  getOutlines() {
    _(this, nm).sort((e, r) => e[0] - r[0] || e[1] - r[1] || e[2] - r[2]);
    const t = [];
    for (const e of _(this, nm))
      e[3] ? (t.push(...Q(this, Ha, X$).call(this, e)), Q(this, Ha, ste).call(this, e)) : (Q(this, Ha, ote).call(this, e), t.push(...Q(this, Ha, X$).call(this, e)));
    return Q(this, Ha, ite).call(this, t);
  }
}
cT = new WeakMap(), nm = new WeakMap(), Zu = new WeakMap(), Ha = new WeakSet(), ite = function(t) {
  const e = [], r = /* @__PURE__ */ new Set();
  for (const o of t) {
    const [l, u, d] = o;
    e.push([l, u, o], [l, d, o]);
  }
  e.sort((o, l) => o[1] - l[1] || o[0] - l[0]);
  for (let o = 0, l = e.length; o < l; o += 2) {
    const u = e[o][2], d = e[o + 1][2];
    u.push(d), d.push(u), r.add(u), r.add(d);
  }
  const i = [];
  let s;
  for (; r.size > 0; ) {
    const o = r.values().next().value;
    let [l, u, d, f, m] = o;
    r.delete(o);
    let v = l, S = u;
    for (s = [l, d], i.push(s); ; ) {
      let w;
      if (r.has(f))
        w = f;
      else if (r.has(m))
        w = m;
      else
        break;
      r.delete(w), [l, u, d, f, m] = w, v !== l && (s.push(v, S, l, S === u ? u : d), v = l), S = S === u ? d : u;
    }
    s.push(v, S);
  }
  return new tLe(i, _(this, cT));
}, GR = function(t) {
  const e = _(this, Zu);
  let r = 0, i = e.length - 1;
  for (; r <= i; ) {
    const s = r + i >> 1, o = e[s][0];
    if (o === t)
      return s;
    o < t ? r = s + 1 : i = s - 1;
  }
  return i + 1;
}, ste = function([, t, e]) {
  const r = Q(this, Ha, GR).call(this, t);
  _(this, Zu).splice(r, 0, [t, e]);
}, ote = function([, t, e]) {
  const r = Q(this, Ha, GR).call(this, t);
  for (let i = r; i < _(this, Zu).length; i++) {
    const [s, o] = _(this, Zu)[i];
    if (s !== t)
      break;
    if (s === t && o === e) {
      _(this, Zu).splice(i, 1);
      return;
    }
  }
  for (let i = r - 1; i >= 0; i--) {
    const [s, o] = _(this, Zu)[i];
    if (s !== t)
      break;
    if (s === t && o === e) {
      _(this, Zu).splice(i, 1);
      return;
    }
  }
}, X$ = function(t) {
  const [e, r, i] = t, s = [[e, r, i]], o = Q(this, Ha, GR).call(this, i);
  for (let l = 0; l < o; l++) {
    const [u, d] = _(this, Zu)[l];
    for (let f = 0, m = s.length; f < m; f++) {
      const [, v, S] = s[f];
      if (!(d <= v || S <= u)) {
        if (v >= u) {
          if (S > d)
            s[f][1] = d;
          else {
            if (m === 1)
              return [];
            s.splice(f, 1), f--, m--;
          }
          continue;
        }
        s[f][2] = u, S > d && s.push([e, d, S]);
      }
    }
  }
  return s;
};
class ate {
  toSVGPath() {
    throw new Error("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    throw new Error("Abstract getter `box` must be implemented.");
  }
  serialize(t, e) {
    throw new Error("Abstract method `serialize` must be implemented.");
  }
  get free() {
    return this instanceof Z$;
  }
}
var uT, Mx;
class tLe extends ate {
  constructor(e, r) {
    super();
    J(this, uT);
    J(this, Mx);
    q(this, Mx, e), q(this, uT, r);
  }
  toSVGPath() {
    const e = [];
    for (const r of _(this, Mx)) {
      let [i, s] = r;
      e.push(`M${i} ${s}`);
      for (let o = 2; o < r.length; o += 2) {
        const l = r[o], u = r[o + 1];
        l === i ? (e.push(`V${u}`), s = u) : u === s && (e.push(`H${l}`), i = l);
      }
      e.push("Z");
    }
    return e.join(" ");
  }
  serialize([e, r, i, s], o) {
    const l = [], u = i - e, d = s - r;
    for (const f of _(this, Mx)) {
      const m = new Array(f.length);
      for (let v = 0; v < f.length; v += 2)
        m[v] = e + f[v] * u, m[v + 1] = s - f[v + 1] * d;
      l.push(m);
    }
    return l;
  }
  get box() {
    return _(this, uT);
  }
}
uT = new WeakMap(), Mx = new WeakMap();
var sh, Zf, Dx, Ox, oh, Xn, My, Dy, dT, hT, Lx, jx, rm, fT, g2, m2, pT, q$;
const Df = class Df {
  constructor({
    x: t,
    y: e
  }, r, i, s, o, l = 0) {
    J(this, pT);
    J(this, sh);
    J(this, Zf, []);
    J(this, Dx);
    J(this, Ox);
    J(this, oh, []);
    J(this, Xn, new Float64Array(18));
    J(this, My);
    J(this, Dy);
    J(this, dT);
    J(this, hT);
    J(this, Lx);
    J(this, jx);
    J(this, rm, []);
    q(this, sh, r), q(this, jx, s * i), q(this, Ox, o), _(this, Xn).set([NaN, NaN, NaN, NaN, t, e], 6), q(this, Dx, l), q(this, hT, _(Df, fT) * i), q(this, dT, _(Df, m2) * i), q(this, Lx, i), _(this, rm).push(t, e);
  }
  get free() {
    return !0;
  }
  isEmpty() {
    return isNaN(_(this, Xn)[8]);
  }
  add({
    x: t,
    y: e
  }) {
    var G;
    q(this, My, t), q(this, Dy, e);
    const [r, i, s, o] = _(this, sh);
    let [l, u, d, f] = _(this, Xn).subarray(8, 12);
    const m = t - d, v = e - f, S = Math.hypot(m, v);
    if (S < _(this, dT))
      return !1;
    const w = S - _(this, hT), E = w / S, A = E * m, P = E * v;
    let R = l, M = u;
    l = d, u = f, d += A, f += P, (G = _(this, rm)) == null || G.push(t, e);
    const j = -P / w, $ = A / w, U = j * _(this, jx), F = $ * _(this, jx);
    return _(this, Xn).set(_(this, Xn).subarray(2, 8), 0), _(this, Xn).set([d + U, f + F], 4), _(this, Xn).set(_(this, Xn).subarray(14, 18), 12), _(this, Xn).set([d - U, f - F], 16), isNaN(_(this, Xn)[6]) ? (_(this, oh).length === 0 && (_(this, Xn).set([l + U, u + F], 2), _(this, oh).push(NaN, NaN, NaN, NaN, (l + U - r) / s, (u + F - i) / o), _(this, Xn).set([l - U, u - F], 14), _(this, Zf).push(NaN, NaN, NaN, NaN, (l - U - r) / s, (u - F - i) / o)), _(this, Xn).set([R, M, l, u, d, f], 6), !this.isEmpty()) : (_(this, Xn).set([R, M, l, u, d, f], 6), Math.abs(Math.atan2(M - u, R - l) - Math.atan2(P, A)) < Math.PI / 2 ? ([l, u, d, f] = _(this, Xn).subarray(2, 6), _(this, oh).push(NaN, NaN, NaN, NaN, ((l + d) / 2 - r) / s, ((u + f) / 2 - i) / o), [l, u, R, M] = _(this, Xn).subarray(14, 18), _(this, Zf).push(NaN, NaN, NaN, NaN, ((R + l) / 2 - r) / s, ((M + u) / 2 - i) / o), !0) : ([R, M, l, u, d, f] = _(this, Xn).subarray(0, 6), _(this, oh).push(((R + 5 * l) / 6 - r) / s, ((M + 5 * u) / 6 - i) / o, ((5 * l + d) / 6 - r) / s, ((5 * u + f) / 6 - i) / o, ((l + d) / 2 - r) / s, ((u + f) / 2 - i) / o), [d, f, l, u, R, M] = _(this, Xn).subarray(12, 18), _(this, Zf).push(((R + 5 * l) / 6 - r) / s, ((M + 5 * u) / 6 - i) / o, ((5 * l + d) / 6 - r) / s, ((5 * u + f) / 6 - i) / o, ((l + d) / 2 - r) / s, ((u + f) / 2 - i) / o), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const t = _(this, oh), e = _(this, Zf), r = _(this, Xn).subarray(4, 6), i = _(this, Xn).subarray(16, 18), [s, o, l, u] = _(this, sh), [d, f, m, v] = Q(this, pT, q$).call(this);
    if (isNaN(_(this, Xn)[6]) && !this.isEmpty())
      return `M${(_(this, Xn)[2] - s) / l} ${(_(this, Xn)[3] - o) / u} L${(_(this, Xn)[4] - s) / l} ${(_(this, Xn)[5] - o) / u} L${d} ${f} L${m} ${v} L${(_(this, Xn)[16] - s) / l} ${(_(this, Xn)[17] - o) / u} L${(_(this, Xn)[14] - s) / l} ${(_(this, Xn)[15] - o) / u} Z`;
    const S = [];
    S.push(`M${t[4]} ${t[5]}`);
    for (let w = 6; w < t.length; w += 6)
      isNaN(t[w]) ? S.push(`L${t[w + 4]} ${t[w + 5]}`) : S.push(`C${t[w]} ${t[w + 1]} ${t[w + 2]} ${t[w + 3]} ${t[w + 4]} ${t[w + 5]}`);
    S.push(`L${(r[0] - s) / l} ${(r[1] - o) / u} L${d} ${f} L${m} ${v} L${(i[0] - s) / l} ${(i[1] - o) / u}`);
    for (let w = e.length - 6; w >= 6; w -= 6)
      isNaN(e[w]) ? S.push(`L${e[w + 4]} ${e[w + 5]}`) : S.push(`C${e[w]} ${e[w + 1]} ${e[w + 2]} ${e[w + 3]} ${e[w + 4]} ${e[w + 5]}`);
    return S.push(`L${e[4]} ${e[5]} Z`), S.join(" ");
  }
  getOutlines() {
    var P;
    const t = _(this, oh), e = _(this, Zf), r = _(this, Xn), i = r.subarray(4, 6), s = r.subarray(16, 18), [o, l, u, d] = _(this, sh), f = new Float64Array((((P = _(this, rm)) == null ? void 0 : P.length) ?? 0) + 2);
    for (let R = 0, M = f.length - 2; R < M; R += 2)
      f[R] = (_(this, rm)[R] - o) / u, f[R + 1] = (_(this, rm)[R + 1] - l) / d;
    f[f.length - 2] = (_(this, My) - o) / u, f[f.length - 1] = (_(this, Dy) - l) / d;
    const [m, v, S, w] = Q(this, pT, q$).call(this);
    if (isNaN(r[6]) && !this.isEmpty()) {
      const R = new Float64Array(36);
      return R.set([NaN, NaN, NaN, NaN, (r[2] - o) / u, (r[3] - l) / d, NaN, NaN, NaN, NaN, (r[4] - o) / u, (r[5] - l) / d, NaN, NaN, NaN, NaN, m, v, NaN, NaN, NaN, NaN, S, w, NaN, NaN, NaN, NaN, (r[16] - o) / u, (r[17] - l) / d, NaN, NaN, NaN, NaN, (r[14] - o) / u, (r[15] - l) / d], 0), new Z$(R, f, _(this, sh), _(this, Lx), _(this, Dx), _(this, Ox));
    }
    const E = new Float64Array(_(this, oh).length + 24 + _(this, Zf).length);
    let A = t.length;
    for (let R = 0; R < A; R += 2) {
      if (isNaN(t[R])) {
        E[R] = E[R + 1] = NaN;
        continue;
      }
      E[R] = t[R], E[R + 1] = t[R + 1];
    }
    E.set([NaN, NaN, NaN, NaN, (i[0] - o) / u, (i[1] - l) / d, NaN, NaN, NaN, NaN, m, v, NaN, NaN, NaN, NaN, S, w, NaN, NaN, NaN, NaN, (s[0] - o) / u, (s[1] - l) / d], A), A += 24;
    for (let R = e.length - 6; R >= 6; R -= 6)
      for (let M = 0; M < 6; M += 2) {
        if (isNaN(e[R + M])) {
          E[A] = E[A + 1] = NaN, A += 2;
          continue;
        }
        E[A] = e[R + M], E[A + 1] = e[R + M + 1], A += 2;
      }
    return E.set([NaN, NaN, NaN, NaN, e[4], e[5]], A), new Z$(E, f, _(this, sh), _(this, Lx), _(this, Dx), _(this, Ox));
  }
};
sh = new WeakMap(), Zf = new WeakMap(), Dx = new WeakMap(), Ox = new WeakMap(), oh = new WeakMap(), Xn = new WeakMap(), My = new WeakMap(), Dy = new WeakMap(), dT = new WeakMap(), hT = new WeakMap(), Lx = new WeakMap(), jx = new WeakMap(), rm = new WeakMap(), fT = new WeakMap(), g2 = new WeakMap(), m2 = new WeakMap(), pT = new WeakSet(), q$ = function() {
  const t = _(this, Xn).subarray(4, 6), e = _(this, Xn).subarray(16, 18), [r, i, s, o] = _(this, sh);
  return [(_(this, My) + (t[0] - e[0]) / 2 - r) / s, (_(this, Dy) + (t[1] - e[1]) / 2 - i) / o, (_(this, My) + (e[0] - t[0]) / 2 - r) / s, (_(this, Dy) + (e[1] - t[1]) / 2 - i) / o];
}, J(Df, fT, 8), J(Df, g2, 2), J(Df, m2, _(Df, fT) + _(Df, g2));
let qM = Df;
var Nx, Oy, Qf, gT, uc, mT, Yi, Nl, y1, S1, lte;
class Z$ extends ate {
  constructor(e, r, i, s, o, l) {
    super();
    J(this, Nl);
    J(this, Nx);
    J(this, Oy, null);
    J(this, Qf);
    J(this, gT);
    J(this, uc);
    J(this, mT);
    J(this, Yi);
    q(this, Yi, e), q(this, uc, r), q(this, Nx, i), q(this, mT, s), q(this, Qf, o), q(this, gT, l), Q(this, Nl, lte).call(this, l);
    const {
      x: u,
      y: d,
      width: f,
      height: m
    } = _(this, Oy);
    for (let v = 0, S = e.length; v < S; v += 2)
      e[v] = (e[v] - u) / f, e[v + 1] = (e[v + 1] - d) / m;
    for (let v = 0, S = r.length; v < S; v += 2)
      r[v] = (r[v] - u) / f, r[v + 1] = (r[v + 1] - d) / m;
  }
  toSVGPath() {
    const e = [`M${_(this, Yi)[4]} ${_(this, Yi)[5]}`];
    for (let r = 6, i = _(this, Yi).length; r < i; r += 6) {
      if (isNaN(_(this, Yi)[r])) {
        e.push(`L${_(this, Yi)[r + 4]} ${_(this, Yi)[r + 5]}`);
        continue;
      }
      e.push(`C${_(this, Yi)[r]} ${_(this, Yi)[r + 1]} ${_(this, Yi)[r + 2]} ${_(this, Yi)[r + 3]} ${_(this, Yi)[r + 4]} ${_(this, Yi)[r + 5]}`);
    }
    return e.push("Z"), e.join(" ");
  }
  serialize([e, r, i, s], o) {
    const l = i - e, u = s - r;
    let d, f;
    switch (o) {
      case 0:
        d = Q(this, Nl, y1).call(this, _(this, Yi), e, s, l, -u), f = Q(this, Nl, y1).call(this, _(this, uc), e, s, l, -u);
        break;
      case 90:
        d = Q(this, Nl, S1).call(this, _(this, Yi), e, r, l, u), f = Q(this, Nl, S1).call(this, _(this, uc), e, r, l, u);
        break;
      case 180:
        d = Q(this, Nl, y1).call(this, _(this, Yi), i, r, -l, u), f = Q(this, Nl, y1).call(this, _(this, uc), i, r, -l, u);
        break;
      case 270:
        d = Q(this, Nl, S1).call(this, _(this, Yi), i, s, -l, -u), f = Q(this, Nl, S1).call(this, _(this, uc), i, s, -l, -u);
        break;
    }
    return {
      outline: Array.from(d),
      points: [Array.from(f)]
    };
  }
  get box() {
    return _(this, Oy);
  }
  getNewOutline(e, r) {
    const {
      x: i,
      y: s,
      width: o,
      height: l
    } = _(this, Oy), [u, d, f, m] = _(this, Nx), v = o * f, S = l * m, w = i * f + u, E = s * m + d, A = new qM({
      x: _(this, uc)[0] * v + w,
      y: _(this, uc)[1] * S + E
    }, _(this, Nx), _(this, mT), e, _(this, gT), r ?? _(this, Qf));
    for (let P = 2; P < _(this, uc).length; P += 2)
      A.add({
        x: _(this, uc)[P] * v + w,
        y: _(this, uc)[P + 1] * S + E
      });
    return A.getOutlines();
  }
}
Nx = new WeakMap(), Oy = new WeakMap(), Qf = new WeakMap(), gT = new WeakMap(), uc = new WeakMap(), mT = new WeakMap(), Yi = new WeakMap(), Nl = new WeakSet(), y1 = function(e, r, i, s, o) {
  const l = new Float64Array(e.length);
  for (let u = 0, d = e.length; u < d; u += 2)
    l[u] = r + e[u] * s, l[u + 1] = i + e[u + 1] * o;
  return l;
}, S1 = function(e, r, i, s, o) {
  const l = new Float64Array(e.length);
  for (let u = 0, d = e.length; u < d; u += 2)
    l[u] = r + e[u + 1] * s, l[u + 1] = i + e[u] * o;
  return l;
}, lte = function(e) {
  const r = _(this, Yi);
  let i = r[4], s = r[5], o = i, l = s, u = i, d = s, f = i, m = s;
  const v = e ? Math.max : Math.min;
  for (let P = 6, R = r.length; P < R; P += 6) {
    if (isNaN(r[P]))
      o = Math.min(o, r[P + 4]), l = Math.min(l, r[P + 5]), u = Math.max(u, r[P + 4]), d = Math.max(d, r[P + 5]), m < r[P + 5] ? (f = r[P + 4], m = r[P + 5]) : m === r[P + 5] && (f = v(f, r[P + 4]));
    else {
      const M = Ft.bezierBoundingBox(i, s, ...r.slice(P, P + 6));
      o = Math.min(o, M[0]), l = Math.min(l, M[1]), u = Math.max(u, M[2]), d = Math.max(d, M[3]), m < M[3] ? (f = M[2], m = M[3]) : m === M[3] && (f = v(f, M[2]));
    }
    i = r[P + 4], s = r[P + 5];
  }
  const S = o - _(this, Qf), w = l - _(this, Qf), E = u - o + 2 * _(this, Qf), A = d - l + 2 * _(this, Qf);
  q(this, Oy, {
    x: S,
    y: w,
    width: E,
    height: A,
    lastPoint: [f, m]
  });
};
var vT, yT, Qu, Ly, Fx, js, ST, $x, bT, xT, Ju, zx, Wr, Q$, J$, cte, Kv, ute, Ug;
const Of = class Of {
  constructor({
    editor: t = null,
    uiManager: e = null
  }) {
    J(this, Wr);
    J(this, vT, Q(this, Wr, cte).bind(this));
    J(this, yT, Q(this, Wr, ute).bind(this));
    J(this, Qu, null);
    J(this, Ly, null);
    J(this, Fx);
    J(this, js, null);
    J(this, ST, !1);
    J(this, $x, !1);
    J(this, bT, null);
    J(this, xT);
    J(this, Ju, null);
    J(this, zx);
    var r;
    t ? (q(this, $x, !1), q(this, zx, gn.HIGHLIGHT_COLOR), q(this, bT, t)) : (q(this, $x, !0), q(this, zx, gn.HIGHLIGHT_DEFAULT_COLOR)), q(this, Ju, (t == null ? void 0 : t._uiManager) || e), q(this, xT, _(this, Ju)._eventBus), q(this, Fx, (t == null ? void 0 : t.color) || ((r = _(this, Ju)) == null ? void 0 : r.highlightColors.values().next().value) || "#FFFF98");
  }
  static get _keyboardManager() {
    return lr(this, "_keyboardManager", new iP([[["Escape", "mac+Escape"], Of.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], Of.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], Of.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], Of.prototype._moveToPrevious], [["Home", "mac+Home"], Of.prototype._moveToBeginning], [["End", "mac+End"], Of.prototype._moveToEnd]]));
  }
  renderButton() {
    const t = q(this, Qu, document.createElement("button"));
    t.className = "colorPicker", t.tabIndex = "0", t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), t.setAttribute("aria-haspopup", !0);
    const e = _(this, Ju)._signal;
    t.addEventListener("click", Q(this, Wr, Kv).bind(this), {
      signal: e
    }), t.addEventListener("keydown", _(this, vT), {
      signal: e
    });
    const r = q(this, Ly, document.createElement("span"));
    return r.className = "swatch", r.setAttribute("aria-hidden", !0), r.style.backgroundColor = _(this, Fx), t.append(r), t;
  }
  renderMainDropdown() {
    const t = q(this, js, Q(this, Wr, Q$).call(this));
    return t.setAttribute("aria-orientation", "horizontal"), t.setAttribute("aria-labelledby", "highlightColorPickerLabel"), t;
  }
  _colorSelectFromKeyboard(t) {
    if (t.target === _(this, Qu)) {
      Q(this, Wr, Kv).call(this, t);
      return;
    }
    const e = t.target.getAttribute("data-color");
    e && Q(this, Wr, J$).call(this, e, t);
  }
  _moveToNext(t) {
    var e, r;
    if (!_(this, Wr, Ug)) {
      Q(this, Wr, Kv).call(this, t);
      return;
    }
    if (t.target === _(this, Qu)) {
      (e = _(this, js).firstChild) == null || e.focus();
      return;
    }
    (r = t.target.nextSibling) == null || r.focus();
  }
  _moveToPrevious(t) {
    var e, r;
    if (t.target === ((e = _(this, js)) == null ? void 0 : e.firstChild) || t.target === _(this, Qu)) {
      _(this, Wr, Ug) && this._hideDropdownFromKeyboard();
      return;
    }
    _(this, Wr, Ug) || Q(this, Wr, Kv).call(this, t), (r = t.target.previousSibling) == null || r.focus();
  }
  _moveToBeginning(t) {
    var e;
    if (!_(this, Wr, Ug)) {
      Q(this, Wr, Kv).call(this, t);
      return;
    }
    (e = _(this, js).firstChild) == null || e.focus();
  }
  _moveToEnd(t) {
    var e;
    if (!_(this, Wr, Ug)) {
      Q(this, Wr, Kv).call(this, t);
      return;
    }
    (e = _(this, js).lastChild) == null || e.focus();
  }
  hideDropdown() {
    var t;
    (t = _(this, js)) == null || t.classList.add("hidden"), window.removeEventListener("pointerdown", _(this, yT));
  }
  _hideDropdownFromKeyboard() {
    var t;
    if (!_(this, $x)) {
      if (!_(this, Wr, Ug)) {
        (t = _(this, bT)) == null || t.unselect();
        return;
      }
      this.hideDropdown(), _(this, Qu).focus({
        preventScroll: !0,
        focusVisible: _(this, ST)
      });
    }
  }
  updateColor(t) {
    if (_(this, Ly) && (_(this, Ly).style.backgroundColor = t), !_(this, js))
      return;
    const e = _(this, Ju).highlightColors.values();
    for (const r of _(this, js).children)
      r.setAttribute("aria-selected", e.next().value === t);
  }
  destroy() {
    var t, e;
    (t = _(this, Qu)) == null || t.remove(), q(this, Qu, null), q(this, Ly, null), (e = _(this, js)) == null || e.remove(), q(this, js, null);
  }
};
vT = new WeakMap(), yT = new WeakMap(), Qu = new WeakMap(), Ly = new WeakMap(), Fx = new WeakMap(), js = new WeakMap(), ST = new WeakMap(), $x = new WeakMap(), bT = new WeakMap(), xT = new WeakMap(), Ju = new WeakMap(), zx = new WeakMap(), Wr = new WeakSet(), Q$ = function() {
  const t = document.createElement("div"), e = _(this, Ju)._signal;
  t.addEventListener("contextmenu", zl, {
    signal: e
  }), t.className = "dropdown", t.role = "listbox", t.setAttribute("aria-multiselectable", !1), t.setAttribute("aria-orientation", "vertical"), t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [r, i] of _(this, Ju).highlightColors) {
    const s = document.createElement("button");
    s.tabIndex = "0", s.role = "option", s.setAttribute("data-color", i), s.title = r, s.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${r}`);
    const o = document.createElement("span");
    s.append(o), o.className = "swatch", o.style.backgroundColor = i, s.setAttribute("aria-selected", i === _(this, Fx)), s.addEventListener("click", Q(this, Wr, J$).bind(this, i), {
      signal: e
    }), t.append(s);
  }
  return t.addEventListener("keydown", _(this, vT), {
    signal: e
  }), t;
}, J$ = function(t, e) {
  e.stopPropagation(), _(this, xT).dispatch("switchannotationeditorparams", {
    source: this,
    type: _(this, zx),
    value: t
  });
}, cte = function(t) {
  Of._keyboardManager.exec(this, t);
}, Kv = function(t) {
  if (_(this, Wr, Ug)) {
    this.hideDropdown();
    return;
  }
  if (q(this, ST, t.detail === 0), window.addEventListener("pointerdown", _(this, yT), {
    signal: _(this, Ju)._signal
  }), _(this, js)) {
    _(this, js).classList.remove("hidden");
    return;
  }
  const e = q(this, js, Q(this, Wr, Q$).call(this));
  _(this, Qu).append(e);
}, ute = function(t) {
  var e;
  (e = _(this, js)) != null && e.contains(t.target) || this.hideDropdown();
}, Ug = function() {
  return _(this, js) && !_(this, js).classList.contains("hidden");
};
let ZM = Of;
var Ux, wT, im, jy, Bx, Zc, CT, ET, Ny, ed, Fa, dc, v2, Hx, Fy, Ns, Vx, ah, _T, zn, ez, tz, dte, hte, fte, nz, b1, su, R0, pte, KR, x1, gte, mte, vte, yte;
const mr = class mr extends Pr {
  constructor(e) {
    super({
      ...e,
      name: "highlightEditor"
    });
    J(this, zn);
    J(this, Ux, null);
    J(this, wT, 0);
    J(this, im);
    J(this, jy, null);
    J(this, Bx, null);
    J(this, Zc, null);
    J(this, CT, null);
    J(this, ET, 0);
    J(this, Ny, null);
    J(this, ed, null);
    J(this, Fa, null);
    J(this, dc, !1);
    J(this, v2, Q(this, zn, pte).bind(this));
    J(this, Hx, null);
    J(this, Fy);
    J(this, Ns, null);
    J(this, Vx, "");
    J(this, ah);
    J(this, _T, "");
    this.color = e.color || mr._defaultColor, q(this, ah, e.thickness || mr._defaultThickness), q(this, Fy, e.opacity || mr._defaultOpacity), q(this, im, e.boxes || null), q(this, _T, e.methodOfCreation || ""), q(this, Vx, e.text || ""), this._isDraggable = !1, e.highlightId > -1 ? (q(this, dc, !0), Q(this, zn, tz).call(this, e), Q(this, zn, b1).call(this)) : (q(this, Ux, e.anchorNode), q(this, wT, e.anchorOffset), q(this, CT, e.focusNode), q(this, ET, e.focusOffset), Q(this, zn, ez).call(this), Q(this, zn, b1).call(this), this.rotate(this.rotation));
  }
  static get _keyboardManager() {
    const e = mr.prototype;
    return lr(this, "_keyboardManager", new iP([[["ArrowLeft", "mac+ArrowLeft"], e._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], e._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], e._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], e._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: _(this, dc) ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: _(this, ah),
      methodOfCreation: _(this, _T)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(e) {
    return {
      numberOfColors: e.get("color").size
    };
  }
  static initialize(e, r) {
    var i;
    Pr.initialize(e, r), mr._defaultColor || (mr._defaultColor = ((i = r.highlightColors) == null ? void 0 : i.values().next().value) || "#fff066");
  }
  static updateDefaultParams(e, r) {
    switch (e) {
      case gn.HIGHLIGHT_DEFAULT_COLOR:
        mr._defaultColor = r;
        break;
      case gn.HIGHLIGHT_THICKNESS:
        mr._defaultThickness = r;
        break;
    }
  }
  translateInPage(e, r) {
  }
  get toolbarPosition() {
    return _(this, Hx);
  }
  updateParams(e, r) {
    switch (e) {
      case gn.HIGHLIGHT_COLOR:
        Q(this, zn, dte).call(this, r);
        break;
      case gn.HIGHLIGHT_THICKNESS:
        Q(this, zn, hte).call(this, r);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[gn.HIGHLIGHT_DEFAULT_COLOR, mr._defaultColor], [gn.HIGHLIGHT_THICKNESS, mr._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[gn.HIGHLIGHT_COLOR, this.color || mr._defaultColor], [gn.HIGHLIGHT_THICKNESS, _(this, ah) || mr._defaultThickness], [gn.HIGHLIGHT_FREE, _(this, dc)]];
  }
  async addEditToolbar() {
    const e = await super.addEditToolbar();
    return e ? (this._uiManager.highlightColors && (q(this, Bx, new ZM({
      editor: this
    })), e.addColorPicker(_(this, Bx))), e) : null;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(Q(this, zn, x1).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(e, r) {
    return super.getRect(e, r, Q(this, zn, x1).call(this));
  }
  onceAdded() {
    this.parent.addUndoableEditor(this), this.div.focus();
  }
  remove() {
    Q(this, zn, nz).call(this), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (Q(this, zn, b1).call(this), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(e) {
    var i;
    let r = !1;
    this.parent && !e ? Q(this, zn, nz).call(this) : e && (Q(this, zn, b1).call(this, e), r = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(e), this.show(this._isVisible), r && this.select();
  }
  rotate(e) {
    var s, o, l;
    const {
      drawLayer: r
    } = this.parent;
    let i;
    _(this, dc) ? (e = (e - this.rotation + 360) % 360, i = Q(s = mr, su, R0).call(s, _(this, ed).box, e)) : i = Q(o = mr, su, R0).call(o, this, e), r.rotate(_(this, Fa), e), r.rotate(_(this, Ns), e), r.updateBox(_(this, Fa), i), r.updateBox(_(this, Ns), Q(l = mr, su, R0).call(l, _(this, Zc).box, e));
  }
  render() {
    if (this.div)
      return this.div;
    const e = super.render();
    _(this, Vx) && (e.setAttribute("aria-label", _(this, Vx)), e.setAttribute("role", "mark")), _(this, dc) ? e.classList.add("free") : this.div.addEventListener("keydown", _(this, v2), {
      signal: this._uiManager._signal
    });
    const r = q(this, Ny, document.createElement("div"));
    e.append(r), r.setAttribute("aria-hidden", "true"), r.className = "internal", r.style.clipPath = _(this, jy);
    const [i, s] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * s), GM(this, _(this, Ny), ["pointerover", "pointerleave"]), this.enableEditing(), e;
  }
  pointerover() {
    this.parent.drawLayer.addClass(_(this, Ns), "hovered");
  }
  pointerleave() {
    this.parent.drawLayer.removeClass(_(this, Ns), "hovered");
  }
  _moveCaret(e) {
    switch (this.parent.unselect(this), e) {
      case 0:
      case 2:
        Q(this, zn, KR).call(this, !0);
        break;
      case 1:
      case 3:
        Q(this, zn, KR).call(this, !1);
        break;
    }
  }
  select() {
    var e, r;
    super.select(), _(this, Ns) && ((e = this.parent) == null || e.drawLayer.removeClass(_(this, Ns), "hovered"), (r = this.parent) == null || r.drawLayer.addClass(_(this, Ns), "selected"));
  }
  unselect() {
    var e;
    super.unselect(), _(this, Ns) && ((e = this.parent) == null || e.drawLayer.removeClass(_(this, Ns), "selected"), _(this, dc) || Q(this, zn, KR).call(this, !1));
  }
  get _mustFixPosition() {
    return !_(this, dc);
  }
  show(e = this._isVisible) {
    super.show(e), this.parent && (this.parent.drawLayer.show(_(this, Fa), e), this.parent.drawLayer.show(_(this, Ns), e));
  }
  static startHighlighting(e, r, {
    target: i,
    x: s,
    y: o
  }) {
    const {
      x: l,
      y: u,
      width: d,
      height: f
    } = i.getBoundingClientRect(), m = (A) => {
      Q(this, su, vte).call(this, e, A);
    }, v = e._signal, S = {
      capture: !0,
      passive: !1,
      signal: v
    }, w = (A) => {
      A.preventDefault(), A.stopPropagation();
    }, E = (A) => {
      i.removeEventListener("pointermove", m), window.removeEventListener("blur", E), window.removeEventListener("pointerup", E), window.removeEventListener("pointerdown", w, S), window.removeEventListener("contextmenu", zl), Q(this, su, yte).call(this, e, A);
    };
    window.addEventListener("blur", E, {
      signal: v
    }), window.addEventListener("pointerup", E, {
      signal: v
    }), window.addEventListener("pointerdown", w, S), window.addEventListener("contextmenu", zl, {
      signal: v
    }), i.addEventListener("pointermove", m, {
      signal: v
    }), this._freeHighlight = new qM({
      x: s,
      y: o
    }, [l, u, d, f], e.scale, this._defaultThickness / 2, r, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = e.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
  }
  static deserialize(e, r, i) {
    var E;
    const s = super.deserialize(e, r, i), {
      rect: [o, l, u, d],
      color: f,
      quadPoints: m
    } = e;
    s.color = Ft.makeHexColor(...f), q(s, Fy, e.opacity);
    const [v, S] = s.pageDimensions;
    s.width = (u - o) / v, s.height = (d - l) / S;
    const w = q(s, im, []);
    for (let A = 0; A < m.length; A += 8)
      w.push({
        x: (m[4] - u) / v,
        y: (d - (1 - m[A + 5])) / S,
        width: (m[A + 2] - m[A]) / v,
        height: (m[A + 5] - m[A + 1]) / S
      });
    return Q(E = s, zn, ez).call(E), s;
  }
  serialize(e = !1) {
    if (this.isEmpty() || e)
      return null;
    const r = this.getRect(0, 0), i = Pr._colorManager.convert(this.color);
    return {
      annotationType: ir.HIGHLIGHT,
      color: i,
      opacity: _(this, Fy),
      thickness: _(this, ah),
      quadPoints: Q(this, zn, gte).call(this),
      outlines: Q(this, zn, mte).call(this, r),
      pageIndex: this.pageIndex,
      rect: r,
      rotation: Q(this, zn, x1).call(this),
      structTreeParentId: this._structTreeParentId
    };
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
Ux = new WeakMap(), wT = new WeakMap(), im = new WeakMap(), jy = new WeakMap(), Bx = new WeakMap(), Zc = new WeakMap(), CT = new WeakMap(), ET = new WeakMap(), Ny = new WeakMap(), ed = new WeakMap(), Fa = new WeakMap(), dc = new WeakMap(), v2 = new WeakMap(), Hx = new WeakMap(), Fy = new WeakMap(), Ns = new WeakMap(), Vx = new WeakMap(), ah = new WeakMap(), _T = new WeakMap(), zn = new WeakSet(), ez = function() {
  const e = new Y$(_(this, im), 1e-3);
  q(this, ed, e.getOutlines()), {
    x: this.x,
    y: this.y,
    width: this.width,
    height: this.height
  } = _(this, ed).box;
  const r = new Y$(_(this, im), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  q(this, Zc, r.getOutlines());
  const {
    lastPoint: i
  } = _(this, Zc).box;
  q(this, Hx, [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height]);
}, tz = function({
  highlightOutlines: e,
  highlightId: r,
  clipPathId: i
}) {
  var m, v;
  if (q(this, ed, e), q(this, Zc, e.getNewOutline(_(this, ah) / 2 + 1.5, 25e-4)), r >= 0)
    q(this, Fa, r), q(this, jy, i), this.parent.drawLayer.finalizeLine(r, e), q(this, Ns, this.parent.drawLayer.highlightOutline(_(this, Zc)));
  else if (this.parent) {
    const S = this.parent.viewport.rotation;
    this.parent.drawLayer.updateLine(_(this, Fa), e), this.parent.drawLayer.updateBox(_(this, Fa), Q(m = mr, su, R0).call(m, _(this, ed).box, (S - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(_(this, Ns), _(this, Zc)), this.parent.drawLayer.updateBox(_(this, Ns), Q(v = mr, su, R0).call(v, _(this, Zc).box, S));
  }
  const {
    x: o,
    y: l,
    width: u,
    height: d
  } = e.box;
  switch (this.rotation) {
    case 0:
      this.x = o, this.y = l, this.width = u, this.height = d;
      break;
    case 90: {
      const [S, w] = this.parentDimensions;
      this.x = l, this.y = 1 - o, this.width = u * w / S, this.height = d * S / w;
      break;
    }
    case 180:
      this.x = 1 - o, this.y = 1 - l, this.width = u, this.height = d;
      break;
    case 270: {
      const [S, w] = this.parentDimensions;
      this.x = 1 - l, this.y = o, this.width = u * w / S, this.height = d * S / w;
      break;
    }
  }
  const {
    lastPoint: f
  } = _(this, Zc).box;
  q(this, Hx, [(f[0] - o) / u, (f[1] - l) / d]);
}, dte = function(e) {
  const r = (s) => {
    var o, l;
    this.color = s, (o = this.parent) == null || o.drawLayer.changeColor(_(this, Fa), s), (l = _(this, Bx)) == null || l.updateColor(s);
  }, i = this.color;
  this.addCommands({
    cmd: r.bind(this, e),
    undo: r.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.HIGHLIGHT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.highlightColorNames.get(e)
  }, !0);
}, hte = function(e) {
  const r = _(this, ah), i = (s) => {
    q(this, ah, s), Q(this, zn, fte).call(this, s);
  };
  this.addCommands({
    cmd: i.bind(this, e),
    undo: i.bind(this, r),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "thickness_changed",
    thickness: e
  }, !0);
}, fte = function(e) {
  if (!_(this, dc))
    return;
  Q(this, zn, tz).call(this, {
    highlightOutlines: _(this, ed).getNewOutline(e / 2)
  }), this.fixAndSetPosition();
  const [r, i] = this.parentDimensions;
  this.setDims(this.width * r, this.height * i);
}, nz = function() {
  _(this, Fa) === null || !this.parent || (this.parent.drawLayer.remove(_(this, Fa)), q(this, Fa, null), this.parent.drawLayer.remove(_(this, Ns)), q(this, Ns, null));
}, b1 = function(e = this.parent) {
  _(this, Fa) === null && ({
    id: ec(this, Fa)._,
    clipPathId: ec(this, jy)._
  } = e.drawLayer.highlight(_(this, ed), this.color, _(this, Fy)), q(this, Ns, e.drawLayer.highlightOutline(_(this, Zc))), _(this, Ny) && (_(this, Ny).style.clipPath = _(this, jy)));
}, su = new WeakSet(), R0 = function({
  x: e,
  y: r,
  width: i,
  height: s
}, o) {
  switch (o) {
    case 90:
      return {
        x: 1 - r - s,
        y: e,
        width: s,
        height: i
      };
    case 180:
      return {
        x: 1 - e - i,
        y: 1 - r - s,
        width: i,
        height: s
      };
    case 270:
      return {
        x: r,
        y: 1 - e - i,
        width: s,
        height: i
      };
  }
  return {
    x: e,
    y: r,
    width: i,
    height: s
  };
}, pte = function(e) {
  mr._keyboardManager.exec(this, e);
}, KR = function(e) {
  if (!_(this, Ux))
    return;
  const r = window.getSelection();
  e ? r.setPosition(_(this, Ux), _(this, wT)) : r.setPosition(_(this, CT), _(this, ET));
}, x1 = function() {
  return _(this, dc) ? this.rotation : 0;
}, gte = function() {
  if (_(this, dc))
    return null;
  const [e, r] = this.pageDimensions, i = _(this, im), s = new Float32Array(i.length * 8);
  let o = 0;
  for (const {
    x: l,
    y: u,
    width: d,
    height: f
  } of i) {
    const m = l * e, v = (1 - u - f) * r;
    s[o] = s[o + 4] = m, s[o + 1] = s[o + 3] = v, s[o + 2] = s[o + 6] = m + d * e, s[o + 5] = s[o + 7] = v + f * r, o += 8;
  }
  return s;
}, mte = function(e) {
  return _(this, ed).serialize(e, Q(this, zn, x1).call(this));
}, vte = function(e, r) {
  this._freeHighlight.add(r) && e.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
}, yte = function(e, r) {
  this._freeHighlight.isEmpty() ? e.drawLayer.removeFreeHighlight(this._freeHighlightId) : e.createAndAddNewEditor(r, !1, {
    highlightId: this._freeHighlightId,
    highlightOutlines: this._freeHighlight.getOutlines(),
    clipPathId: this._freeHighlightClipId,
    methodOfCreation: "main_toolbar"
  }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
}, J(mr, su), T(mr, "_defaultColor", null), T(mr, "_defaultOpacity", 1), T(mr, "_defaultThickness", 12), T(mr, "_l10nPromise"), T(mr, "_type", "highlight"), T(mr, "_editorType", ir.HIGHLIGHT), T(mr, "_freeHighlightId", -1), T(mr, "_freeHighlight", null), T(mr, "_freeHighlightClipId", "");
let QM = mr;
var $y, zy, TT, PT, AT, Uy, lh, Jf, Qc, By, Hy, ep, Vy, Wy, sm, ut, Ste, bte, xte, wte, iz, Cte, sz, Ete, _te, Tte, Pte, Ate, Yv, oz, YR, XR, M0, az, qR, Cp, kte, lz, Ite, Rte, cz, ZR, w1;
const Ai = class Ai extends Pr {
  constructor(e) {
    super({
      ...e,
      name: "inkEditor"
    });
    J(this, ut);
    J(this, $y, 0);
    J(this, zy, 0);
    J(this, TT, this.canvasPointermove.bind(this));
    J(this, PT, this.canvasPointerleave.bind(this));
    J(this, AT, this.canvasPointerup.bind(this));
    J(this, Uy, this.canvasPointerdown.bind(this));
    J(this, lh, null);
    J(this, Jf, new Path2D());
    J(this, Qc, !1);
    J(this, By, !1);
    J(this, Hy, !1);
    J(this, ep, null);
    J(this, Vy, 0);
    J(this, Wy, 0);
    J(this, sm, null);
    this.color = e.color || null, this.thickness = e.thickness || null, this.opacity = e.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
  }
  static initialize(e, r) {
    Pr.initialize(e, r);
  }
  static updateDefaultParams(e, r) {
    switch (e) {
      case gn.INK_THICKNESS:
        Ai._defaultThickness = r;
        break;
      case gn.INK_COLOR:
        Ai._defaultColor = r;
        break;
      case gn.INK_OPACITY:
        Ai._defaultOpacity = r / 100;
        break;
    }
  }
  updateParams(e, r) {
    switch (e) {
      case gn.INK_THICKNESS:
        Q(this, ut, Ste).call(this, r);
        break;
      case gn.INK_COLOR:
        Q(this, ut, bte).call(this, r);
        break;
      case gn.INK_OPACITY:
        Q(this, ut, xte).call(this, r);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[gn.INK_THICKNESS, Ai._defaultThickness], [gn.INK_COLOR, Ai._defaultColor || Pr._defaultLineColor], [gn.INK_OPACITY, Math.round(Ai._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[gn.INK_THICKNESS, this.thickness || Ai._defaultThickness], [gn.INK_COLOR, this.color || Ai._defaultColor || Pr._defaultLineColor], [gn.INK_OPACITY, Math.round(100 * (this.opacity ?? Ai._defaultOpacity))]];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.canvas || (Q(this, ut, YR).call(this), Q(this, ut, XR).call(this)), this.isAttachedToDOM || (this.parent.add(this), Q(this, ut, M0).call(this)), Q(this, ut, w1).call(this)));
  }
  remove() {
    var e;
    this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, _(this, lh) && (clearTimeout(_(this, lh)), q(this, lh, null)), (e = _(this, ep)) == null || e.disconnect(), q(this, ep, null), super.remove());
  }
  setParent(e) {
    !this.parent && e ? this._uiManager.removeShouldRescale(this) : this.parent && e === null && this._uiManager.addShouldRescale(this), super.setParent(e);
  }
  onScaleChanging() {
    const [e, r] = this.parentDimensions, i = this.width * e, s = this.height * r;
    this.setDimensions(i, s);
  }
  enableEditMode() {
    _(this, Qc) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", _(this, Uy), {
      signal: this._uiManager._signal
    }));
  }
  disableEditMode() {
    !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", _(this, Uy)));
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  commit() {
    _(this, Qc) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), q(this, Qc, !0), this.div.classList.add("disabled"), Q(this, ut, w1).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
      preventScroll: !0
    }));
  }
  focusin(e) {
    this._focusEventsAllowed && (super.focusin(e), this.enableEditMode());
  }
  canvasPointerdown(e) {
    e.button !== 0 || !this.isInEditMode() || _(this, Qc) || (this.setInForeground(), e.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
      preventScroll: !0
    }), Q(this, ut, Cte).call(this, e.offsetX, e.offsetY));
  }
  canvasPointermove(e) {
    e.preventDefault(), Q(this, ut, sz).call(this, e.offsetX, e.offsetY);
  }
  canvasPointerup(e) {
    e.preventDefault(), Q(this, ut, oz).call(this, e);
  }
  canvasPointerleave(e) {
    Q(this, ut, oz).call(this, e);
  }
  get isResizable() {
    return !this.isEmpty() && _(this, Qc);
  }
  render() {
    if (this.div)
      return this.div;
    let e, r;
    this.width && (e = this.x, r = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [i, s, o, l] = Q(this, ut, wte).call(this);
    if (this.setAt(i, s, 0, 0), this.setDims(o, l), Q(this, ut, YR).call(this), this.width) {
      const [u, d] = this.parentDimensions;
      this.setAspectRatio(this.width * u, this.height * d), this.setAt(e * u, r * d, this.width * u, this.height * d), q(this, Hy, !0), Q(this, ut, M0).call(this), this.setDims(this.width * u, this.height * d), Q(this, ut, Yv).call(this), this.div.classList.add("disabled");
    } else
      this.div.classList.add("editing"), this.enableEditMode();
    return Q(this, ut, XR).call(this), this.div;
  }
  setDimensions(e, r) {
    const i = Math.round(e), s = Math.round(r);
    if (_(this, Vy) === i && _(this, Wy) === s)
      return;
    q(this, Vy, i), q(this, Wy, s), this.canvas.style.visibility = "hidden";
    const [o, l] = this.parentDimensions;
    this.width = e / o, this.height = r / l, this.fixAndSetPosition(), _(this, Qc) && Q(this, ut, az).call(this, e, r), Q(this, ut, M0).call(this), Q(this, ut, Yv).call(this), this.canvas.style.visibility = "visible", this.fixDims();
  }
  static deserialize(e, r, i) {
    var A, P, R;
    if (e instanceof qee)
      return null;
    const s = super.deserialize(e, r, i);
    s.thickness = e.thickness, s.color = Ft.makeHexColor(...e.color), s.opacity = e.opacity;
    const [o, l] = s.pageDimensions, u = s.width * o, d = s.height * l, f = s.parentScale, m = e.thickness / 2;
    q(s, Qc, !0), q(s, Vy, Math.round(u)), q(s, Wy, Math.round(d));
    const {
      paths: v,
      rect: S,
      rotation: w
    } = e;
    for (let {
      bezier: M
    } of v) {
      M = Q(A = Ai, Cp, Ite).call(A, M, S, w);
      const j = [];
      s.paths.push(j);
      let $ = f * (M[0] - m), U = f * (M[1] - m);
      for (let B = 2, G = M.length; B < G; B += 6) {
        const X = f * (M[B] - m), te = f * (M[B + 1] - m), ne = f * (M[B + 2] - m), K = f * (M[B + 3] - m), Z = f * (M[B + 4] - m), oe = f * (M[B + 5] - m);
        j.push([[$, U], [X, te], [ne, K], [Z, oe]]), $ = Z, U = oe;
      }
      const F = Q(this, Cp, kte).call(this, j);
      s.bezierPath2D.push(F);
    }
    const E = Q(P = s, ut, cz).call(P);
    return q(s, zy, Math.max(Pr.MIN_SIZE, E[2] - E[0])), q(s, $y, Math.max(Pr.MIN_SIZE, E[3] - E[1])), Q(R = s, ut, az).call(R, u, d), s;
  }
  serialize() {
    if (this.isEmpty())
      return null;
    const e = this.getRect(0, 0), r = Pr._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: ir.INK,
      color: r,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: Q(this, ut, Rte).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, e),
      pageIndex: this.pageIndex,
      rect: e,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
};
$y = new WeakMap(), zy = new WeakMap(), TT = new WeakMap(), PT = new WeakMap(), AT = new WeakMap(), Uy = new WeakMap(), lh = new WeakMap(), Jf = new WeakMap(), Qc = new WeakMap(), By = new WeakMap(), Hy = new WeakMap(), ep = new WeakMap(), Vy = new WeakMap(), Wy = new WeakMap(), sm = new WeakMap(), ut = new WeakSet(), Ste = function(e) {
  const r = (s) => {
    this.thickness = s, Q(this, ut, w1).call(this);
  }, i = this.thickness;
  this.addCommands({
    cmd: r.bind(this, e),
    undo: r.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, bte = function(e) {
  const r = (s) => {
    this.color = s, Q(this, ut, Yv).call(this);
  }, i = this.color;
  this.addCommands({
    cmd: r.bind(this, e),
    undo: r.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.INK_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, xte = function(e) {
  const r = (s) => {
    this.opacity = s, Q(this, ut, Yv).call(this);
  };
  e /= 100;
  const i = this.opacity;
  this.addCommands({
    cmd: r.bind(this, e),
    undo: r.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: gn.INK_OPACITY,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, wte = function() {
  const {
    parentRotation: e,
    parentDimensions: [r, i]
  } = this;
  switch (e) {
    case 90:
      return [0, i, i, r];
    case 180:
      return [r, i, r, i];
    case 270:
      return [r, 0, i, r];
    default:
      return [0, 0, r, i];
  }
}, iz = function() {
  const {
    ctx: e,
    color: r,
    opacity: i,
    thickness: s,
    parentScale: o,
    scaleFactor: l
  } = this;
  e.lineWidth = s * o / l, e.lineCap = "round", e.lineJoin = "round", e.miterLimit = 10, e.strokeStyle = `${r}${_De(i)}`;
}, Cte = function(e, r) {
  const i = this._uiManager._signal;
  this.canvas.addEventListener("contextmenu", zl, {
    signal: i
  }), this.canvas.addEventListener("pointerleave", _(this, PT), {
    signal: i
  }), this.canvas.addEventListener("pointermove", _(this, TT), {
    signal: i
  }), this.canvas.addEventListener("pointerup", _(this, AT), {
    signal: i
  }), this.canvas.removeEventListener("pointerdown", _(this, Uy)), this.isEditing = !0, _(this, Hy) || (q(this, Hy, !0), Q(this, ut, M0).call(this), this.thickness || (this.thickness = Ai._defaultThickness), this.color || (this.color = Ai._defaultColor || Pr._defaultLineColor), this.opacity ?? (this.opacity = Ai._defaultOpacity)), this.currentPath.push([e, r]), q(this, By, !1), Q(this, ut, iz).call(this), q(this, sm, () => {
    Q(this, ut, Tte).call(this), _(this, sm) && window.requestAnimationFrame(_(this, sm));
  }), window.requestAnimationFrame(_(this, sm));
}, sz = function(e, r) {
  const [i, s] = this.currentPath.at(-1);
  if (this.currentPath.length > 1 && e === i && r === s)
    return;
  const o = this.currentPath;
  let l = _(this, Jf);
  if (o.push([e, r]), q(this, By, !0), o.length <= 2) {
    l.moveTo(...o[0]), l.lineTo(e, r);
    return;
  }
  o.length === 3 && (q(this, Jf, l = new Path2D()), l.moveTo(...o[0])), Q(this, ut, Pte).call(this, l, ...o.at(-3), ...o.at(-2), e, r);
}, Ete = function() {
  if (this.currentPath.length === 0)
    return;
  const e = this.currentPath.at(-1);
  _(this, Jf).lineTo(...e);
}, _te = function(e, r) {
  q(this, sm, null), e = Math.min(Math.max(e, 0), this.canvas.width), r = Math.min(Math.max(r, 0), this.canvas.height), Q(this, ut, sz).call(this, e, r), Q(this, ut, Ete).call(this);
  let i;
  if (this.currentPath.length !== 1)
    i = Q(this, ut, Ate).call(this);
  else {
    const d = [e, r];
    i = [[d, d.slice(), d.slice(), d]];
  }
  const s = _(this, Jf), o = this.currentPath;
  this.currentPath = [], q(this, Jf, new Path2D());
  const l = () => {
    this.allRawPaths.push(o), this.paths.push(i), this.bezierPath2D.push(s), this._uiManager.rebuild(this);
  }, u = () => {
    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (Q(this, ut, YR).call(this), Q(this, ut, XR).call(this)), Q(this, ut, w1).call(this));
  };
  this.addCommands({
    cmd: l,
    undo: u,
    mustExec: !0
  });
}, Tte = function() {
  if (!_(this, By))
    return;
  q(this, By, !1);
  const e = Math.ceil(this.thickness * this.parentScale), r = this.currentPath.slice(-3), i = r.map((l) => l[0]), s = r.map((l) => l[1]);
  Math.min(...i) - e, Math.max(...i) + e, Math.min(...s) - e, Math.max(...s) + e;
  const {
    ctx: o
  } = this;
  o.save(), o.clearRect(0, 0, this.canvas.width, this.canvas.height);
  for (const l of this.bezierPath2D)
    o.stroke(l);
  o.stroke(_(this, Jf)), o.restore();
}, Pte = function(e, r, i, s, o, l, u) {
  const d = (r + s) / 2, f = (i + o) / 2, m = (s + l) / 2, v = (o + u) / 2;
  e.bezierCurveTo(d + 2 * (s - d) / 3, f + 2 * (o - f) / 3, m + 2 * (s - m) / 3, v + 2 * (o - v) / 3, m, v);
}, Ate = function() {
  const e = this.currentPath;
  if (e.length <= 2)
    return [[e[0], e[0], e.at(-1), e.at(-1)]];
  const r = [];
  let i, [s, o] = e[0];
  for (i = 1; i < e.length - 2; i++) {
    const [S, w] = e[i], [E, A] = e[i + 1], P = (S + E) / 2, R = (w + A) / 2, M = [s + 2 * (S - s) / 3, o + 2 * (w - o) / 3], j = [P + 2 * (S - P) / 3, R + 2 * (w - R) / 3];
    r.push([[s, o], M, j, [P, R]]), [s, o] = [P, R];
  }
  const [l, u] = e[i], [d, f] = e[i + 1], m = [s + 2 * (l - s) / 3, o + 2 * (u - o) / 3], v = [d + 2 * (l - d) / 3, f + 2 * (u - f) / 3];
  return r.push([[s, o], m, v, [d, f]]), r;
}, Yv = function() {
  if (this.isEmpty()) {
    Q(this, ut, qR).call(this);
    return;
  }
  Q(this, ut, iz).call(this);
  const {
    canvas: e,
    ctx: r
  } = this;
  r.setTransform(1, 0, 0, 1, 0, 0), r.clearRect(0, 0, e.width, e.height), Q(this, ut, qR).call(this);
  for (const i of this.bezierPath2D)
    r.stroke(i);
}, oz = function(e) {
  this.canvas.removeEventListener("pointerleave", _(this, PT)), this.canvas.removeEventListener("pointermove", _(this, TT)), this.canvas.removeEventListener("pointerup", _(this, AT)), this.canvas.addEventListener("pointerdown", _(this, Uy), {
    signal: this._uiManager._signal
  }), _(this, lh) && clearTimeout(_(this, lh)), q(this, lh, setTimeout(() => {
    q(this, lh, null), this.canvas.removeEventListener("contextmenu", zl);
  }, 10)), Q(this, ut, _te).call(this, e.offsetX, e.offsetY), this.addToAnnotationStorage(), this.setInBackground();
}, YR = function() {
  this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
}, XR = function() {
  q(this, ep, new ResizeObserver((e) => {
    const r = e[0].contentRect;
    r.width && r.height && this.setDimensions(r.width, r.height);
  })), _(this, ep).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var e;
    (e = _(this, ep)) == null || e.disconnect(), q(this, ep, null);
  }, {
    once: !0
  });
}, M0 = function() {
  if (!_(this, Hy))
    return;
  const [e, r] = this.parentDimensions;
  this.canvas.width = Math.ceil(this.width * e), this.canvas.height = Math.ceil(this.height * r), Q(this, ut, qR).call(this);
}, az = function(e, r) {
  const i = Q(this, ut, ZR).call(this), s = (e - i) / _(this, zy), o = (r - i) / _(this, $y);
  this.scaleFactor = Math.min(s, o);
}, qR = function() {
  const e = Q(this, ut, ZR).call(this) / 2;
  this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + e, this.translationY * this.scaleFactor + e);
}, Cp = new WeakSet(), kte = function(e) {
  const r = new Path2D();
  for (let i = 0, s = e.length; i < s; i++) {
    const [o, l, u, d] = e[i];
    i === 0 && r.moveTo(...o), r.bezierCurveTo(l[0], l[1], u[0], u[1], d[0], d[1]);
  }
  return r;
}, lz = function(e, r, i) {
  const [s, o, l, u] = r;
  switch (i) {
    case 0:
      for (let d = 0, f = e.length; d < f; d += 2)
        e[d] += s, e[d + 1] = u - e[d + 1];
      break;
    case 90:
      for (let d = 0, f = e.length; d < f; d += 2) {
        const m = e[d];
        e[d] = e[d + 1] + s, e[d + 1] = m + o;
      }
      break;
    case 180:
      for (let d = 0, f = e.length; d < f; d += 2)
        e[d] = l - e[d], e[d + 1] += o;
      break;
    case 270:
      for (let d = 0, f = e.length; d < f; d += 2) {
        const m = e[d];
        e[d] = l - e[d + 1], e[d + 1] = u - m;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return e;
}, Ite = function(e, r, i) {
  const [s, o, l, u] = r;
  switch (i) {
    case 0:
      for (let d = 0, f = e.length; d < f; d += 2)
        e[d] -= s, e[d + 1] = u - e[d + 1];
      break;
    case 90:
      for (let d = 0, f = e.length; d < f; d += 2) {
        const m = e[d];
        e[d] = e[d + 1] - o, e[d + 1] = m - s;
      }
      break;
    case 180:
      for (let d = 0, f = e.length; d < f; d += 2)
        e[d] = l - e[d], e[d + 1] -= o;
      break;
    case 270:
      for (let d = 0, f = e.length; d < f; d += 2) {
        const m = e[d];
        e[d] = u - e[d + 1], e[d + 1] = l - m;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return e;
}, Rte = function(e, r, i, s) {
  var f, m;
  const o = [], l = this.thickness / 2, u = e * r + l, d = e * i + l;
  for (const v of this.paths) {
    const S = [], w = [];
    for (let E = 0, A = v.length; E < A; E++) {
      const [P, R, M, j] = v[E];
      if (P[0] === j[0] && P[1] === j[1] && A === 1) {
        const K = e * P[0] + u, Z = e * P[1] + d;
        S.push(K, Z), w.push(K, Z);
        break;
      }
      const $ = e * P[0] + u, U = e * P[1] + d, F = e * R[0] + u, B = e * R[1] + d, G = e * M[0] + u, X = e * M[1] + d, te = e * j[0] + u, ne = e * j[1] + d;
      E === 0 && (S.push($, U), w.push($, U)), S.push(F, B, G, X, te, ne), w.push(F, B), E === A - 1 && w.push(te, ne);
    }
    o.push({
      bezier: Q(f = Ai, Cp, lz).call(f, S, s, this.rotation),
      points: Q(m = Ai, Cp, lz).call(m, w, s, this.rotation)
    });
  }
  return o;
}, cz = function() {
  let e = 1 / 0, r = -1 / 0, i = 1 / 0, s = -1 / 0;
  for (const o of this.paths)
    for (const [l, u, d, f] of o) {
      const m = Ft.bezierBoundingBox(...l, ...u, ...d, ...f);
      e = Math.min(e, m[0]), i = Math.min(i, m[1]), r = Math.max(r, m[2]), s = Math.max(s, m[3]);
    }
  return [e, i, r, s];
}, ZR = function() {
  return _(this, Qc) ? Math.ceil(this.thickness * this.parentScale) : 0;
}, w1 = function(e = !1) {
  if (this.isEmpty())
    return;
  if (!_(this, Qc)) {
    Q(this, ut, Yv).call(this);
    return;
  }
  const r = Q(this, ut, cz).call(this), i = Q(this, ut, ZR).call(this);
  q(this, zy, Math.max(Pr.MIN_SIZE, r[2] - r[0])), q(this, $y, Math.max(Pr.MIN_SIZE, r[3] - r[1]));
  const s = Math.ceil(i + _(this, zy) * this.scaleFactor), o = Math.ceil(i + _(this, $y) * this.scaleFactor), [l, u] = this.parentDimensions;
  this.width = s / l, this.height = o / u, this.setAspectRatio(s, o);
  const d = this.translationX, f = this.translationY;
  this.translationX = -r[0], this.translationY = -r[1], Q(this, ut, M0).call(this), Q(this, ut, Yv).call(this), q(this, Vy, s), q(this, Wy, o), this.setDims(s, o);
  const m = e ? i / this.scaleFactor / 2 : 0;
  this.translate(d - this.translationX - m, f - this.translationY - m);
}, J(Ai, Cp), T(Ai, "_defaultColor", null), T(Ai, "_defaultOpacity", 1), T(Ai, "_defaultThickness", 1), T(Ai, "_type", "ink"), T(Ai, "_editorType", ir.INK);
let rz = Ai;
var Po, Ao, om, tp, am, Wx, ch, np, uh, td, kT, hr, C1, E1, QR, dz, Mte, Dte, hz, JR, Ote;
const L1 = class L1 extends Pr {
  constructor(e) {
    super({
      ...e,
      name: "stampEditor"
    });
    J(this, hr);
    J(this, Po, null);
    J(this, Ao, null);
    J(this, om, null);
    J(this, tp, null);
    J(this, am, null);
    J(this, Wx, "");
    J(this, ch, null);
    J(this, np, null);
    J(this, uh, null);
    J(this, td, !1);
    J(this, kT, !1);
    q(this, tp, e.bitmapUrl), q(this, am, e.bitmapFile);
  }
  static initialize(e, r) {
    Pr.initialize(e, r);
  }
  static get supportedTypes() {
    return lr(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((r) => `image/${r}`));
  }
  static get supportedTypesStr() {
    return lr(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(e) {
    return this.supportedTypes.includes(e);
  }
  static paste(e, r) {
    r.pasteEditor(ir.STAMP, {
      bitmapFile: e.getAsFile()
    });
  }
  remove() {
    var e, r;
    _(this, Ao) && (q(this, Po, null), this._uiManager.imageManager.deleteId(_(this, Ao)), (e = _(this, ch)) == null || e.remove(), q(this, ch, null), (r = _(this, np)) == null || r.disconnect(), q(this, np, null), _(this, uh) && (clearTimeout(_(this, uh)), q(this, uh, null))), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      _(this, Ao) && Q(this, hr, QR).call(this);
      return;
    }
    super.rebuild(), this.div !== null && (_(this, Ao) && _(this, ch) === null && Q(this, hr, QR).call(this), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded() {
    this._isDraggable = !0, this.div.focus();
  }
  isEmpty() {
    return !(_(this, om) || _(this, Po) || _(this, tp) || _(this, am) || _(this, Ao));
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let e, r;
    if (this.width && (e = this.x, r = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), _(this, Po) ? Q(this, hr, dz).call(this) : Q(this, hr, QR).call(this), this.width) {
      const [i, s] = this.parentDimensions;
      this.setAt(e * i, r * s, this.width * i, this.height * s);
    }
    return this.div;
  }
  getImageForAltText() {
    return _(this, ch);
  }
  static deserialize(e, r, i) {
    if (e instanceof Zee)
      return null;
    const s = super.deserialize(e, r, i), {
      rect: o,
      bitmapUrl: l,
      bitmapId: u,
      isSvg: d,
      accessibilityData: f
    } = e;
    u && i.imageManager.isValidId(u) ? q(s, Ao, u) : q(s, tp, l), q(s, td, d);
    const [m, v] = s.pageDimensions;
    return s.width = (o[2] - o[0]) / m, s.height = (o[3] - o[1]) / v, f && (s.altTextData = f), s;
  }
  serialize(e = !1, r = null) {
    if (this.isEmpty())
      return null;
    const i = {
      annotationType: ir.STAMP,
      bitmapId: _(this, Ao),
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: _(this, td),
      structTreeParentId: this._structTreeParentId
    };
    if (e)
      return i.bitmapUrl = Q(this, hr, JR).call(this, !0), i.accessibilityData = this.altTextData, i;
    const {
      decorative: s,
      altText: o
    } = this.altTextData;
    if (!s && o && (i.accessibilityData = {
      type: "Figure",
      alt: o
    }), r === null)
      return i;
    r.stamps || (r.stamps = /* @__PURE__ */ new Map());
    const l = _(this, td) ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
    if (!r.stamps.has(_(this, Ao)))
      r.stamps.set(_(this, Ao), {
        area: l,
        serialized: i
      }), i.bitmap = Q(this, hr, JR).call(this, !1);
    else if (_(this, td)) {
      const u = r.stamps.get(_(this, Ao));
      l > u.area && (u.area = l, u.serialized.bitmap.close(), u.serialized.bitmap = Q(this, hr, JR).call(this, !1));
    }
    return i;
  }
};
Po = new WeakMap(), Ao = new WeakMap(), om = new WeakMap(), tp = new WeakMap(), am = new WeakMap(), Wx = new WeakMap(), ch = new WeakMap(), np = new WeakMap(), uh = new WeakMap(), td = new WeakMap(), kT = new WeakMap(), hr = new WeakSet(), C1 = function(e, r = !1) {
  if (!e) {
    this.remove();
    return;
  }
  q(this, Po, e.bitmap), r || (q(this, Ao, e.id), q(this, td, e.isSvg)), e.file && q(this, Wx, e.file.name), Q(this, hr, dz).call(this);
}, E1 = function() {
  q(this, om, null), this._uiManager.enableWaiting(!1), _(this, ch) && this.div.focus();
}, QR = function() {
  if (_(this, Ao)) {
    this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(_(this, Ao)).then((i) => Q(this, hr, C1).call(this, i, !0)).finally(() => Q(this, hr, E1).call(this));
    return;
  }
  if (_(this, tp)) {
    const i = _(this, tp);
    q(this, tp, null), this._uiManager.enableWaiting(!0), q(this, om, this._uiManager.imageManager.getFromUrl(i).then((s) => Q(this, hr, C1).call(this, s)).finally(() => Q(this, hr, E1).call(this)));
    return;
  }
  if (_(this, am)) {
    const i = _(this, am);
    q(this, am, null), this._uiManager.enableWaiting(!0), q(this, om, this._uiManager.imageManager.getFromFile(i).then((s) => Q(this, hr, C1).call(this, s)).finally(() => Q(this, hr, E1).call(this)));
    return;
  }
  const e = document.createElement("input");
  e.type = "file", e.accept = L1.supportedTypesStr;
  const r = this._uiManager._signal;
  q(this, om, new Promise((i) => {
    e.addEventListener("change", async () => {
      if (!e.files || e.files.length === 0)
        this.remove();
      else {
        this._uiManager.enableWaiting(!0);
        const s = await this._uiManager.imageManager.getFromFile(e.files[0]);
        Q(this, hr, C1).call(this, s);
      }
      i();
    }, {
      signal: r
    }), e.addEventListener("cancel", () => {
      this.remove(), i();
    }, {
      signal: r
    });
  }).finally(() => Q(this, hr, E1).call(this))), e.click();
}, dz = function() {
  const {
    div: e
  } = this;
  let {
    width: r,
    height: i
  } = _(this, Po);
  const [s, o] = this.pageDimensions, l = 0.75;
  if (this.width)
    r = this.width * s, i = this.height * o;
  else if (r > l * s || i > l * o) {
    const m = Math.min(l * s / r, l * o / i);
    r *= m, i *= m;
  }
  const [u, d] = this.parentDimensions;
  this.setDims(r * u / s, i * d / o), this._uiManager.enableWaiting(!1);
  const f = q(this, ch, document.createElement("canvas"));
  e.append(f), e.hidden = !1, Q(this, hr, hz).call(this, r, i), Q(this, hr, Ote).call(this), _(this, kT) || (this.parent.addUndoableEditor(this), q(this, kT, !0)), this._reportTelemetry({
    action: "inserted_image"
  }), _(this, Wx) && f.setAttribute("aria-label", _(this, Wx));
}, Mte = function(e, r) {
  var l;
  const [i, s] = this.parentDimensions;
  this.width = e / i, this.height = r / s, this.setDims(e, r), (l = this._initialOptions) != null && l.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, _(this, uh) !== null && clearTimeout(_(this, uh)), q(this, uh, setTimeout(() => {
    q(this, uh, null), Q(this, hr, hz).call(this, e, r);
  }, 200));
}, Dte = function(e, r) {
  const {
    width: i,
    height: s
  } = _(this, Po);
  let o = i, l = s, u = _(this, Po);
  for (; o > 2 * e || l > 2 * r; ) {
    const d = o, f = l;
    o > 2 * e && (o = o >= 16384 ? Math.floor(o / 2) - 1 : Math.ceil(o / 2)), l > 2 * r && (l = l >= 16384 ? Math.floor(l / 2) - 1 : Math.ceil(l / 2));
    const m = new OffscreenCanvas(o, l);
    m.getContext("2d").drawImage(u, 0, 0, d, f, 0, 0, o, l), u = m.transferToImageBitmap();
  }
  return u;
}, hz = function(e, r) {
  e = Math.ceil(e), r = Math.ceil(r);
  const i = _(this, ch);
  if (!i || i.width === e && i.height === r)
    return;
  i.width = e, i.height = r;
  const s = _(this, td) ? _(this, Po) : Q(this, hr, Dte).call(this, e, r);
  if (this._uiManager.hasMLManager && !this.hasAltText()) {
    const u = new OffscreenCanvas(e, r).getContext("2d");
    u.drawImage(s, 0, 0, s.width, s.height, 0, 0, e, r), this._uiManager.mlGuess({
      service: "image-to-text",
      request: {
        data: u.getImageData(0, 0, e, r).data,
        width: e,
        height: r,
        channels: 4
      }
    }).then((d) => {
      const f = (d == null ? void 0 : d.output) || "";
      this.parent && f && !this.hasAltText() && (this.altTextData = {
        altText: f,
        decorative: !1
      });
    });
  }
  const o = i.getContext("2d");
  o.filter = this._uiManager.hcmFilter, o.drawImage(s, 0, 0, s.width, s.height, 0, 0, e, r);
}, JR = function(e) {
  if (e) {
    if (_(this, td)) {
      const s = this._uiManager.imageManager.getSvgUrl(_(this, Ao));
      if (s)
        return s;
    }
    const r = document.createElement("canvas");
    return {
      width: r.width,
      height: r.height
    } = _(this, Po), r.getContext("2d").drawImage(_(this, Po), 0, 0), r.toDataURL();
  }
  if (_(this, td)) {
    const [r, i] = this.pageDimensions, s = Math.round(this.width * r * Tm.PDF_TO_CSS_UNITS), o = Math.round(this.height * i * Tm.PDF_TO_CSS_UNITS), l = new OffscreenCanvas(s, o);
    return l.getContext("2d").drawImage(_(this, Po), 0, 0, _(this, Po).width, _(this, Po).height, 0, 0, s, o), l.transferToImageBitmap();
  }
  return structuredClone(_(this, Po));
}, Ote = function() {
  this._uiManager._signal && (q(this, np, new ResizeObserver((e) => {
    const r = e[0].contentRect;
    r.width && r.height && Q(this, hr, Mte).call(this, r.width, r.height);
  })), _(this, np).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var e;
    (e = _(this, np)) == null || e.disconnect(), q(this, np, null);
  }, {
    once: !0
  }));
}, T(L1, "_type", "stamp"), T(L1, "_editorType", ir.STAMP);
let uz = L1;
var Gy, Gx, dh, Ky, rp, ip, sp, hc, lm, Kx, Yx, $a, Gt, cm, Lo, Lte, pz, gz, mz, eM;
const Uu = class Uu {
  constructor({
    uiManager: t,
    pageIndex: e,
    div: r,
    accessibilityManager: i,
    annotationLayer: s,
    drawLayer: o,
    textLayer: l,
    viewport: u,
    l10n: d
  }) {
    J(this, Lo);
    J(this, Gy);
    J(this, Gx, !1);
    J(this, dh, null);
    J(this, Ky, null);
    J(this, rp, null);
    J(this, ip, null);
    J(this, sp, null);
    J(this, hc, /* @__PURE__ */ new Map());
    J(this, lm, !1);
    J(this, Kx, !1);
    J(this, Yx, !1);
    J(this, $a, null);
    J(this, Gt);
    const f = [..._(Uu, cm).values()];
    if (!Uu._initialized) {
      Uu._initialized = !0;
      for (const m of f)
        m.initialize(d, t);
    }
    t.registerEditorTypes(f), q(this, Gt, t), this.pageIndex = e, this.div = r, q(this, Gy, i), q(this, dh, s), this.viewport = u, q(this, $a, l), this.drawLayer = o, _(this, Gt).addLayer(this);
  }
  get isEmpty() {
    return _(this, hc).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && _(this, Gt).getMode() === ir.NONE;
  }
  updateToolbar(t) {
    _(this, Gt).updateToolbar(t);
  }
  updateMode(t = _(this, Gt).getMode()) {
    switch (Q(this, Lo, eM).call(this), t) {
      case ir.NONE:
        this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case ir.INK:
        this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
        break;
      case ir.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: e
    } = this.div;
    for (const r of _(Uu, cm).values())
      e.toggle(`${r._type}Editing`, t === r._editorType);
    this.div.hidden = !1;
  }
  hasTextLayer(t) {
    var e;
    return t === ((e = _(this, $a)) == null ? void 0 : e.div);
  }
  addInkEditorIfNeeded(t) {
    if (_(this, Gt).getMode() !== ir.INK)
      return;
    if (!t) {
      for (const r of _(this, hc).values())
        if (r.isEmpty()) {
          r.setInBackground();
          return;
        }
    }
    this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, !1).setInBackground();
  }
  setEditingState(t) {
    _(this, Gt).setEditingState(t);
  }
  addCommands(t) {
    _(this, Gt).addCommands(t);
  }
  togglePointerEvents(t = !1) {
    this.div.classList.toggle("disabled", !t);
  }
  toggleAnnotationLayerPointerEvents(t = !1) {
    var e;
    (e = _(this, dh)) == null || e.div.classList.toggle("disabled", !t);
  }
  enable() {
    this.div.tabIndex = 0, this.togglePointerEvents(!0);
    const t = /* @__PURE__ */ new Set();
    for (const r of _(this, hc).values())
      r.enableEditing(), r.show(!0), r.annotationElementId && (_(this, Gt).removeChangedExistingAnnotation(r), t.add(r.annotationElementId));
    if (!_(this, dh))
      return;
    const e = _(this, dh).getEditableAnnotations();
    for (const r of e) {
      if (r.hide(), _(this, Gt).isDeletedAnnotationElement(r.data.id) || t.has(r.data.id))
        continue;
      const i = this.deserialize(r);
      i && (this.addOrRebuild(i), i.enableEditing());
    }
  }
  disable() {
    var i;
    q(this, Yx, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
    const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
    for (const s of _(this, hc).values())
      if (s.disableEditing(), !!s.annotationElementId) {
        if (s.serialize() !== null) {
          t.set(s.annotationElementId, s);
          continue;
        } else
          e.set(s.annotationElementId, s);
        (i = this.getEditableAnnotation(s.annotationElementId)) == null || i.show(), s.remove();
      }
    if (_(this, dh)) {
      const s = _(this, dh).getEditableAnnotations();
      for (const o of s) {
        const {
          id: l
        } = o.data;
        if (_(this, Gt).isDeletedAnnotationElement(l))
          continue;
        let u = e.get(l);
        if (u) {
          u.resetAnnotationElement(o), u.show(!1), o.show();
          continue;
        }
        u = t.get(l), u && (_(this, Gt).addChangedExistingAnnotation(u), u.renderAnnotationElement(o), u.show(!1)), o.show();
      }
    }
    Q(this, Lo, eM).call(this), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: r
    } = this.div;
    for (const s of _(Uu, cm).values())
      r.remove(`${s._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), q(this, Yx, !1);
  }
  getEditableAnnotation(t) {
    var e;
    return ((e = _(this, dh)) == null ? void 0 : e.getEditableAnnotation(t)) || null;
  }
  setActiveEditor(t) {
    _(this, Gt).getActive() !== t && _(this, Gt).setActiveEditor(t);
  }
  enableTextSelection() {
    var t;
    this.div.tabIndex = -1, (t = _(this, $a)) != null && t.div && !_(this, ip) && (q(this, ip, Q(this, Lo, Lte).bind(this)), _(this, $a).div.addEventListener("pointerdown", _(this, ip), {
      signal: _(this, Gt)._signal
    }), _(this, $a).div.classList.add("highlighting"));
  }
  disableTextSelection() {
    var t;
    this.div.tabIndex = 0, (t = _(this, $a)) != null && t.div && _(this, ip) && (_(this, $a).div.removeEventListener("pointerdown", _(this, ip)), q(this, ip, null), _(this, $a).div.classList.remove("highlighting"));
  }
  enableClick() {
    if (_(this, rp))
      return;
    const t = _(this, Gt)._signal;
    q(this, rp, this.pointerdown.bind(this)), q(this, Ky, this.pointerup.bind(this)), this.div.addEventListener("pointerdown", _(this, rp), {
      signal: t
    }), this.div.addEventListener("pointerup", _(this, Ky), {
      signal: t
    });
  }
  disableClick() {
    _(this, rp) && (this.div.removeEventListener("pointerdown", _(this, rp)), this.div.removeEventListener("pointerup", _(this, Ky)), q(this, rp, null), q(this, Ky, null));
  }
  attach(t) {
    _(this, hc).set(t.id, t);
    const {
      annotationElementId: e
    } = t;
    e && _(this, Gt).isDeletedAnnotationElement(e) && _(this, Gt).removeDeletedAnnotationElement(t);
  }
  detach(t) {
    var e;
    _(this, hc).delete(t.id), (e = _(this, Gy)) == null || e.removePointerInTextLayer(t.contentDiv), !_(this, Yx) && t.annotationElementId && _(this, Gt).addDeletedAnnotationElement(t);
  }
  remove(t) {
    this.detach(t), _(this, Gt).removeEditor(t), t.div.remove(), t.isAttachedToDOM = !1, _(this, Kx) || this.addInkEditorIfNeeded(!1);
  }
  changeParent(t) {
    var e;
    t.parent !== this && (t.parent && t.annotationElementId && (_(this, Gt).addDeletedAnnotationElement(t.annotationElementId), Pr.deleteAnnotationElement(t), t.annotationElementId = null), this.attach(t), (e = t.parent) == null || e.detach(t), t.setParent(this), t.div && t.isAttachedToDOM && (t.div.remove(), this.div.append(t.div)));
  }
  add(t) {
    if (!(t.parent === this && t.isAttachedToDOM)) {
      if (this.changeParent(t), _(this, Gt).addEditor(t), this.attach(t), !t.isAttachedToDOM) {
        const e = t.render();
        this.div.append(e), t.isAttachedToDOM = !0;
      }
      t.fixAndSetPosition(), t.onceAdded(), _(this, Gt).addToAnnotationStorage(t), t._reportTelemetry(t.telemetryInitialData);
    }
  }
  moveEditorInDOM(t) {
    var r;
    if (!t.isAttachedToDOM)
      return;
    const {
      activeElement: e
    } = document;
    t.div.contains(e) && !_(this, sp) && (t._focusEventsAllowed = !1, q(this, sp, setTimeout(() => {
      q(this, sp, null), t.div.contains(document.activeElement) ? t._focusEventsAllowed = !0 : (t.div.addEventListener("focusin", () => {
        t._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: _(this, Gt)._signal
      }), e.focus());
    }, 0))), t._structTreeParentId = (r = _(this, Gy)) == null ? void 0 : r.moveElementInDOM(this.div, t.div, t.contentDiv, !0);
  }
  addOrRebuild(t) {
    t.needsToBeRebuilt() ? (t.parent || (t.parent = this), t.rebuild(), t.show()) : this.add(t);
  }
  addUndoableEditor(t) {
    const e = () => t._uiManager.rebuild(t), r = () => {
      t.remove();
    };
    this.addCommands({
      cmd: e,
      undo: r,
      mustExec: !1
    });
  }
  getNextId() {
    return _(this, Gt).getId();
  }
  get _signal() {
    return _(this, Gt)._signal;
  }
  canCreateNewEmptyEditor() {
    var t;
    return (t = _(this, Lo, pz)) == null ? void 0 : t.canCreateNewEmptyEditor();
  }
  pasteEditor(t, e) {
    _(this, Gt).updateToolbar(t), _(this, Gt).updateMode(t);
    const {
      offsetX: r,
      offsetY: i
    } = Q(this, Lo, mz).call(this), s = this.getNextId(), o = Q(this, Lo, gz).call(this, {
      parent: this,
      id: s,
      x: r,
      y: i,
      uiManager: _(this, Gt),
      isCentered: !0,
      ...e
    });
    o && this.add(o);
  }
  deserialize(t) {
    var e;
    return ((e = _(Uu, cm).get(t.annotationType ?? t.annotationEditorType)) == null ? void 0 : e.deserialize(t, this, _(this, Gt))) || null;
  }
  createAndAddNewEditor(t, e, r = {}) {
    const i = this.getNextId(), s = Q(this, Lo, gz).call(this, {
      parent: this,
      id: i,
      x: t.offsetX,
      y: t.offsetY,
      uiManager: _(this, Gt),
      isCentered: e,
      ...r
    });
    return s && this.add(s), s;
  }
  addNewEditor() {
    this.createAndAddNewEditor(Q(this, Lo, mz).call(this), !0);
  }
  setSelected(t) {
    _(this, Gt).setSelected(t);
  }
  toggleSelected(t) {
    _(this, Gt).toggleSelected(t);
  }
  isSelected(t) {
    return _(this, Gt).isSelected(t);
  }
  unselect(t) {
    _(this, Gt).unselect(t);
  }
  pointerup(t) {
    const {
      isMac: e
    } = jl.platform;
    if (!(t.button !== 0 || t.ctrlKey && e) && t.target === this.div && _(this, lm)) {
      if (q(this, lm, !1), !_(this, Gx)) {
        q(this, Gx, !0);
        return;
      }
      if (_(this, Gt).getMode() === ir.STAMP) {
        _(this, Gt).unselectAll();
        return;
      }
      this.createAndAddNewEditor(t, !1);
    }
  }
  pointerdown(t) {
    if (_(this, Gt).getMode() === ir.HIGHLIGHT && this.enableTextSelection(), _(this, lm)) {
      q(this, lm, !1);
      return;
    }
    const {
      isMac: e
    } = jl.platform;
    if (t.button !== 0 || t.ctrlKey && e || t.target !== this.div)
      return;
    q(this, lm, !0);
    const r = _(this, Gt).getActive();
    q(this, Gx, !r || r.isEmpty());
  }
  findNewParent(t, e, r) {
    const i = _(this, Gt).findParent(e, r);
    return i === null || i === this ? !1 : (i.changeParent(t), !0);
  }
  destroy() {
    var t, e;
    ((t = _(this, Gt).getActive()) == null ? void 0 : t.parent) === this && (_(this, Gt).commitOrRemove(), _(this, Gt).setActiveEditor(null)), _(this, sp) && (clearTimeout(_(this, sp)), q(this, sp, null));
    for (const r of _(this, hc).values())
      (e = _(this, Gy)) == null || e.removePointerInTextLayer(r.contentDiv), r.setParent(null), r.isAttachedToDOM = !1, r.div.remove();
    this.div = null, _(this, hc).clear(), _(this, Gt).removeLayer(this);
  }
  render({
    viewport: t
  }) {
    this.viewport = t, dS(this.div, t);
    for (const e of _(this, Gt).getEditors(this.pageIndex))
      this.add(e), e.rebuild();
    this.updateMode();
  }
  update({
    viewport: t
  }) {
    _(this, Gt).commitOrRemove(), Q(this, Lo, eM).call(this);
    const e = this.viewport.rotation, r = t.rotation;
    if (this.viewport = t, dS(this.div, {
      rotation: r
    }), e !== r)
      for (const i of _(this, hc).values())
        i.rotate(r);
    this.addInkEditorIfNeeded(!1);
  }
  get pageDimensions() {
    const {
      pageWidth: t,
      pageHeight: e
    } = this.viewport.rawDims;
    return [t, e];
  }
  get scale() {
    return _(this, Gt).viewParameters.realScale;
  }
};
Gy = new WeakMap(), Gx = new WeakMap(), dh = new WeakMap(), Ky = new WeakMap(), rp = new WeakMap(), ip = new WeakMap(), sp = new WeakMap(), hc = new WeakMap(), lm = new WeakMap(), Kx = new WeakMap(), Yx = new WeakMap(), $a = new WeakMap(), Gt = new WeakMap(), cm = new WeakMap(), Lo = new WeakSet(), Lte = function(t) {
  if (_(this, Gt).unselectAll(), t.target === _(this, $a).div) {
    const {
      isMac: e
    } = jl.platform;
    if (t.button !== 0 || t.ctrlKey && e)
      return;
    _(this, Gt).showAllEditors("highlight", !0, !0), _(this, $a).div.classList.add("free"), QM.startHighlighting(this, _(this, Gt).direction === "ltr", t), _(this, $a).div.addEventListener("pointerup", () => {
      _(this, $a).div.classList.remove("free");
    }, {
      once: !0,
      signal: _(this, Gt)._signal
    }), t.preventDefault();
  }
}, pz = function() {
  return _(Uu, cm).get(_(this, Gt).getMode());
}, gz = function(t) {
  const e = _(this, Lo, pz);
  return e ? new e.prototype.constructor(t) : null;
}, mz = function() {
  const {
    x: t,
    y: e,
    width: r,
    height: i
  } = this.div.getBoundingClientRect(), s = Math.max(0, t), o = Math.max(0, e), l = Math.min(window.innerWidth, t + r), u = Math.min(window.innerHeight, e + i), d = (s + l) / 2 - t, f = (o + u) / 2 - e, [m, v] = this.viewport.rotation % 180 === 0 ? [d, f] : [f, d];
  return {
    offsetX: m,
    offsetY: v
  };
}, eM = function() {
  q(this, Kx, !0);
  for (const t of _(this, hc).values())
    t.isEmpty() && t.remove();
  q(this, Kx, !1);
}, T(Uu, "_initialized", !1), J(Uu, cm, new Map([G$, rz, uz, QM].map((t) => [t._editorType, t])));
let fz = Uu;
var hh, IT, Fs, um, RT, yz, mS, Sz, jte;
const wo = class wo {
  constructor({
    pageIndex: t
  }) {
    J(this, mS);
    J(this, hh, null);
    J(this, IT, 0);
    J(this, Fs, /* @__PURE__ */ new Map());
    J(this, um, /* @__PURE__ */ new Map());
    this.pageIndex = t;
  }
  setParent(t) {
    if (!_(this, hh)) {
      q(this, hh, t);
      return;
    }
    if (_(this, hh) !== t) {
      if (_(this, Fs).size > 0)
        for (const e of _(this, Fs).values())
          e.remove(), t.append(e);
      q(this, hh, t);
    }
  }
  static get _svgFactory() {
    return lr(this, "_svgFactory", new GU());
  }
  highlight(t, e, r, i = !1) {
    const s = ec(this, IT)._++, o = Q(this, mS, Sz).call(this, t.box);
    o.classList.add("highlight"), t.free && o.classList.add("free");
    const l = wo._svgFactory.createElement("defs");
    o.append(l);
    const u = wo._svgFactory.createElement("path");
    l.append(u);
    const d = `path_p${this.pageIndex}_${s}`;
    u.setAttribute("id", d), u.setAttribute("d", t.toSVGPath()), i && _(this, um).set(s, u);
    const f = Q(this, mS, jte).call(this, l, d), m = wo._svgFactory.createElement("use");
    return o.append(m), o.setAttribute("fill", e), o.setAttribute("fill-opacity", r), m.setAttribute("href", `#${d}`), _(this, Fs).set(s, o), {
      id: s,
      clipPathId: `url(#${f})`
    };
  }
  highlightOutline(t) {
    const e = ec(this, IT)._++, r = Q(this, mS, Sz).call(this, t.box);
    r.classList.add("highlightOutline");
    const i = wo._svgFactory.createElement("defs");
    r.append(i);
    const s = wo._svgFactory.createElement("path");
    i.append(s);
    const o = `path_p${this.pageIndex}_${e}`;
    s.setAttribute("id", o), s.setAttribute("d", t.toSVGPath()), s.setAttribute("vector-effect", "non-scaling-stroke");
    let l;
    if (t.free) {
      r.classList.add("free");
      const f = wo._svgFactory.createElement("mask");
      i.append(f), l = `mask_p${this.pageIndex}_${e}`, f.setAttribute("id", l), f.setAttribute("maskUnits", "objectBoundingBox");
      const m = wo._svgFactory.createElement("rect");
      f.append(m), m.setAttribute("width", "1"), m.setAttribute("height", "1"), m.setAttribute("fill", "white");
      const v = wo._svgFactory.createElement("use");
      f.append(v), v.setAttribute("href", `#${o}`), v.setAttribute("stroke", "none"), v.setAttribute("fill", "black"), v.setAttribute("fill-rule", "nonzero"), v.classList.add("mask");
    }
    const u = wo._svgFactory.createElement("use");
    r.append(u), u.setAttribute("href", `#${o}`), l && u.setAttribute("mask", `url(#${l})`);
    const d = u.cloneNode();
    return r.append(d), u.classList.add("mainOutline"), d.classList.add("secondaryOutline"), _(this, Fs).set(e, r), e;
  }
  finalizeLine(t, e) {
    const r = _(this, um).get(t);
    _(this, um).delete(t), this.updateBox(t, e.box), r.setAttribute("d", e.toSVGPath());
  }
  updateLine(t, e) {
    _(this, Fs).get(t).firstChild.firstChild.setAttribute("d", e.toSVGPath());
  }
  removeFreeHighlight(t) {
    this.remove(t), _(this, um).delete(t);
  }
  updatePath(t, e) {
    _(this, um).get(t).setAttribute("d", e.toSVGPath());
  }
  updateBox(t, e) {
    var r;
    Q(r = wo, RT, yz).call(r, _(this, Fs).get(t), e);
  }
  show(t, e) {
    _(this, Fs).get(t).classList.toggle("hidden", !e);
  }
  rotate(t, e) {
    _(this, Fs).get(t).setAttribute("data-main-rotation", e);
  }
  changeColor(t, e) {
    _(this, Fs).get(t).setAttribute("fill", e);
  }
  changeOpacity(t, e) {
    _(this, Fs).get(t).setAttribute("fill-opacity", e);
  }
  addClass(t, e) {
    _(this, Fs).get(t).classList.add(e);
  }
  removeClass(t, e) {
    _(this, Fs).get(t).classList.remove(e);
  }
  remove(t) {
    _(this, hh) !== null && (_(this, Fs).get(t).remove(), _(this, Fs).delete(t));
  }
  destroy() {
    q(this, hh, null);
    for (const t of _(this, Fs).values())
      t.remove();
    _(this, Fs).clear();
  }
};
hh = new WeakMap(), IT = new WeakMap(), Fs = new WeakMap(), um = new WeakMap(), RT = new WeakSet(), yz = function(t, {
  x: e = 0,
  y: r = 0,
  width: i = 1,
  height: s = 1
} = {}) {
  const {
    style: o
  } = t;
  o.top = `${100 * r}%`, o.left = `${100 * e}%`, o.width = `${100 * i}%`, o.height = `${100 * s}%`;
}, mS = new WeakSet(), Sz = function(t) {
  var r;
  const e = wo._svgFactory.create(1, 1, !0);
  return _(this, hh).append(e), e.setAttribute("aria-hidden", !0), Q(r = wo, RT, yz).call(r, e, t), e;
}, jte = function(t, e) {
  const r = wo._svgFactory.createElement("clipPath");
  t.append(r);
  const i = `clip_${e}`;
  r.setAttribute("id", i), r.setAttribute("clipPathUnits", "objectBoundingBox");
  const s = wo._svgFactory.createElement("use");
  return r.append(s), s.setAttribute("href", `#${e}`), s.classList.add("clip"), i;
}, J(wo, RT);
let vz = wo;
var nLe = un.AbortException, rLe = un.AnnotationEditorLayer, iLe = un.AnnotationEditorParamsType, sLe = un.AnnotationEditorType, oLe = un.AnnotationEditorUIManager, Nte = un.AnnotationLayer, Fte = un.AnnotationMode, aLe = un.CMapCompressionType, lLe = un.ColorPicker, cLe = un.DOMSVGFactory, uLe = un.DrawLayer, dLe = un.FeatureTest, eB = un.GlobalWorkerOptions, hLe = un.ImageKind, fLe = un.InvalidPDFException, pLe = un.MissingPDFException, gLe = un.OPS, mLe = un.Outliner, vLe = un.PDFDataRangeTransport, yLe = un.PDFDateString, SLe = un.PDFWorker, bLe = un.PasswordResponses, xLe = un.PermissionFlag, wLe = un.PixelsPerInch, CLe = un.RenderingCancelledException, $te = un.TextLayer, ELe = un.UnexpectedResponseException, _Le = un.Util, TLe = un.VerbosityLevel, PLe = un.XfaLayer, ALe = un.build, kLe = un.createValidAbsoluteUrl, ILe = un.fetchData, zte = un.getDocument, RLe = un.getFilenameFromUrl, MLe = un.getPdfFilenameFromUrl, DLe = un.getXfaPageViewport, OLe = un.isDataScheme, LLe = un.isPdfFile, jLe = un.noContextMenu, NLe = un.normalizeUnicode, FLe = un.renderTextLayer, $Le = un.setLayerDimensions, zLe = un.shadow, ULe = un.updateTextLayer, Ute = un.version;
const BLe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortException: nLe,
  AnnotationEditorLayer: rLe,
  AnnotationEditorParamsType: iLe,
  AnnotationEditorType: sLe,
  AnnotationEditorUIManager: oLe,
  AnnotationLayer: Nte,
  AnnotationMode: Fte,
  CMapCompressionType: aLe,
  ColorPicker: lLe,
  DOMSVGFactory: cLe,
  DrawLayer: uLe,
  FeatureTest: dLe,
  GlobalWorkerOptions: eB,
  ImageKind: hLe,
  InvalidPDFException: fLe,
  MissingPDFException: pLe,
  OPS: gLe,
  Outliner: mLe,
  PDFDataRangeTransport: vLe,
  PDFDateString: yLe,
  PDFWorker: SLe,
  PasswordResponses: bLe,
  PermissionFlag: xLe,
  PixelsPerInch: wLe,
  RenderingCancelledException: CLe,
  TextLayer: $te,
  UnexpectedResponseException: ELe,
  Util: _Le,
  VerbosityLevel: TLe,
  XfaLayer: PLe,
  build: ALe,
  createValidAbsoluteUrl: kLe,
  fetchData: ILe,
  getDocument: zte,
  getFilenameFromUrl: RLe,
  getPdfFilenameFromUrl: MLe,
  getXfaPageViewport: DLe,
  isDataScheme: OLe,
  isPdfFile: LLe,
  noContextMenu: jLe,
  normalizeUnicode: NLe,
  renderTextLayer: FLe,
  setLayerDimensions: $Le,
  shadow: zLe,
  updateTextLayer: ULe,
  version: Ute
}, Symbol.toStringTag, { value: "Module" }));
var Ys = function(n, t, e) {
  if (e || arguments.length === 2) for (var r = 0, i = t.length, s; r < i; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return n.concat(s || Array.prototype.slice.call(t));
}, HLe = ["onCopy", "onCut", "onPaste"], VLe = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
], WLe = ["onFocus", "onBlur"], GLe = ["onInput", "onInvalid", "onReset", "onSubmit"], KLe = ["onLoad", "onError"], YLe = ["onKeyDown", "onKeyPress", "onKeyUp"], XLe = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
], qLe = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
], ZLe = [
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop"
], QLe = ["onSelect"], JLe = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], eje = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
], tje = ["onScroll"], nje = ["onWheel"], rje = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
], ije = ["onTransitionEnd"], sje = ["onToggle"], oje = ["onChange"], aje = Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys(Ys([], HLe, !0), VLe, !0), WLe, !0), GLe, !0), KLe, !0), YLe, !0), XLe, !0), qLe, !0), ZLe, !0), QLe, !0), JLe, !0), eje, !0), tje, !0), nje, !0), rje, !0), ije, !0), oje, !0), sje, !0);
function Bte(n, t) {
  var e = {};
  return aje.forEach(function(r) {
    var i = n[r];
    i && (t ? e[r] = function(s) {
      return i(s, t(r));
    } : e[r] = i);
  }), e;
}
function aP(n) {
  var t = !1, e = new Promise(function(r, i) {
    n.then(function(s) {
      return !t && r(s);
    }).catch(function(s) {
      return !t && i(s);
    });
  });
  return {
    promise: e,
    cancel: function() {
      t = !0;
    }
  };
}
function Hte(n) {
  var t, e, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var i = n.length;
    for (t = 0; t < i; t++) n[t] && (e = Hte(n[t])) && (r && (r += " "), r += e);
  } else for (e in n) n[e] && (r && (r += " "), r += e);
  return r;
}
function ED() {
  for (var n, t, e = 0, r = "", i = arguments.length; e < i; e++) (n = arguments[e]) && (t = Hte(n)) && (r && (r += " "), r += t);
  return r;
}
var lje = process.env.NODE_ENV === "production", xF = "Invariant failed";
function Vr(n, t) {
  if (!n) {
    if (lje)
      throw new Error(xF);
    var e = typeof t == "function" ? t() : t, r = e ? "".concat(xF, ": ").concat(e) : xF;
    throw new Error(r);
  }
}
var cje = process.env.NODE_ENV !== "production", Vte = function() {
};
if (cje) {
  var uje = function(t, e) {
    var r = arguments.length;
    e = new Array(r > 1 ? r - 1 : 0);
    for (var i = 1; i < r; i++)
      e[i - 1] = arguments[i];
    var s = 0, o = "Warning: " + t.replace(/%s/g, function() {
      return e[s++];
    });
    typeof console < "u" && console.error(o);
    try {
      throw new Error(o);
    } catch {
    }
  };
  Vte = function(n, t, e) {
    var r = arguments.length;
    e = new Array(r > 2 ? r - 2 : 0);
    for (var i = 2; i < r; i++)
      e[i - 2] = arguments[i];
    if (t === void 0)
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    n || uje.apply(null, [t].concat(e));
  };
}
var dje = Vte;
const pa = /* @__PURE__ */ Ep(dje);
var VV = Object.prototype.hasOwnProperty;
function WV(n, t, e) {
  for (e of n.keys())
    if (Q0(e, t)) return e;
}
function Q0(n, t) {
  var e, r, i;
  if (n === t) return !0;
  if (n && t && (e = n.constructor) === t.constructor) {
    if (e === Date) return n.getTime() === t.getTime();
    if (e === RegExp) return n.toString() === t.toString();
    if (e === Array) {
      if ((r = n.length) === t.length)
        for (; r-- && Q0(n[r], t[r]); ) ;
      return r === -1;
    }
    if (e === Set) {
      if (n.size !== t.size)
        return !1;
      for (r of n)
        if (i = r, i && typeof i == "object" && (i = WV(t, i), !i) || !t.has(i)) return !1;
      return !0;
    }
    if (e === Map) {
      if (n.size !== t.size)
        return !1;
      for (r of n)
        if (i = r[0], i && typeof i == "object" && (i = WV(t, i), !i) || !Q0(r[1], t.get(i)))
          return !1;
      return !0;
    }
    if (e === ArrayBuffer)
      n = new Uint8Array(n), t = new Uint8Array(t);
    else if (e === DataView) {
      if ((r = n.byteLength) === t.byteLength)
        for (; r-- && n.getInt8(r) === t.getInt8(r); ) ;
      return r === -1;
    }
    if (ArrayBuffer.isView(n)) {
      if ((r = n.byteLength) === t.byteLength)
        for (; r-- && n[r] === t[r]; ) ;
      return r === -1;
    }
    if (!e || typeof n == "object") {
      r = 0;
      for (e in n)
        if (VV.call(n, e) && ++r && !VV.call(t, e) || !(e in t) || !Q0(n[e], t[e])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return n !== n && t !== t;
}
const Wte = D.createContext(null);
function J0({ children: n, type: t }) {
  return y.jsx("div", { className: `react-pdf__message react-pdf__message--${t}`, children: n });
}
const hje = "noopener noreferrer nofollow";
class fje {
  constructor() {
    this.externalLinkEnabled = !0, this.externalLinkRel = void 0, this.externalLinkTarget = void 0, this.isInPresentationMode = !1, this.pdfDocument = void 0, this.pdfViewer = void 0;
  }
  setDocument(t) {
    this.pdfDocument = t;
  }
  setViewer(t) {
    this.pdfViewer = t;
  }
  setExternalLinkRel(t) {
    this.externalLinkRel = t;
  }
  setExternalLinkTarget(t) {
    this.externalLinkTarget = t;
  }
  setHistory() {
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return Vr(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber || 0;
  }
  set page(t) {
    Vr(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber = t;
  }
  get rotation() {
    return 0;
  }
  set rotation(t) {
  }
  goToDestination(t) {
    return new Promise((e) => {
      Vr(this.pdfDocument, "PDF document not loaded."), Vr(t, "Destination is not specified."), typeof t == "string" ? this.pdfDocument.getDestination(t).then(e) : Array.isArray(t) ? e(t) : t.then(e);
    }).then((e) => {
      Vr(Array.isArray(e), `"${e}" is not a valid destination array.`);
      const r = e[0];
      new Promise((i) => {
        Vr(this.pdfDocument, "PDF document not loaded."), r instanceof Object ? this.pdfDocument.getPageIndex(r).then((s) => {
          i(s);
        }).catch(() => {
          Vr(!1, `"${r}" is not a valid page reference.`);
        }) : typeof r == "number" ? i(r) : Vr(!1, `"${r}" is not a valid destination reference.`);
      }).then((i) => {
        const s = i + 1;
        Vr(this.pdfViewer, "PDF viewer is not initialized."), Vr(s >= 1 && s <= this.pagesCount, `"${s}" is not a valid page number.`), this.pdfViewer.scrollPageIntoView({
          dest: e,
          pageIndex: i,
          pageNumber: s
        });
      });
    });
  }
  navigateTo(t) {
    this.goToDestination(t);
  }
  goToPage(t) {
    const e = t - 1;
    Vr(this.pdfViewer, "PDF viewer is not initialized."), Vr(t >= 1 && t <= this.pagesCount, `"${t}" is not a valid page number.`), this.pdfViewer.scrollPageIntoView({
      pageIndex: e,
      pageNumber: t
    });
  }
  addLinkAttributes(t, e, r) {
    t.href = e, t.rel = this.externalLinkRel || hje, t.target = r ? "_blank" : this.externalLinkTarget || "";
  }
  getDestinationHash() {
    return "#";
  }
  getAnchorUrl() {
    return "#";
  }
  setHash() {
  }
  executeNamedAction() {
  }
  cachePageRef() {
  }
  isPageVisible() {
    return !0;
  }
  isPageCached() {
    return !0;
  }
  executeSetOCGState() {
  }
}
const GV = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
}, _D = typeof document < "u", Gte = _D && window.location.protocol === "file:";
function pje(n) {
  return typeof n < "u";
}
function Vv(n) {
  return pje(n) && n !== null;
}
function gje(n) {
  return typeof n == "string";
}
function mje(n) {
  return n instanceof ArrayBuffer;
}
function vje(n) {
  return Vr(_D, "isBlob can only be used in a browser environment"), n instanceof Blob;
}
function bz(n) {
  return gje(n) && /^data:/.test(n);
}
function KV(n) {
  Vr(bz(n), "Invalid data URI.");
  const [t = "", e = ""] = n.split(",");
  return t.split(";").indexOf("base64") !== -1 ? atob(e) : unescape(e);
}
function yje() {
  return _D && window.devicePixelRatio || 1;
}
const Kte = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function YV() {
  pa(!Gte, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${Kte}`);
}
function Sje() {
  pa(!Gte, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${Kte}`);
}
function pS(n) {
  n != null && n.cancel && n.cancel();
}
function xz(n, t) {
  return Object.defineProperty(n, "width", {
    get() {
      return this.view[2] * t;
    },
    configurable: !0
  }), Object.defineProperty(n, "height", {
    get() {
      return this.view[3] * t;
    },
    configurable: !0
  }), Object.defineProperty(n, "originalWidth", {
    get() {
      return this.view[2];
    },
    configurable: !0
  }), Object.defineProperty(n, "originalHeight", {
    get() {
      return this.view[3];
    },
    configurable: !0
  }), n;
}
function bje(n) {
  return n.name === "RenderingCancelledException";
}
function xje(n) {
  return new Promise((t, e) => {
    const r = new FileReader();
    r.onload = () => {
      if (!r.result)
        return e(new Error("Error while reading a file."));
      t(r.result);
    }, r.onerror = (i) => {
      if (!i.target)
        return e(new Error("Error while reading a file."));
      const { error: s } = i.target;
      if (!s)
        return e(new Error("Error while reading a file."));
      switch (s.code) {
        case s.NOT_FOUND_ERR:
          return e(new Error("Error while reading a file: File not found."));
        case s.SECURITY_ERR:
          return e(new Error("Error while reading a file: Security error."));
        case s.ABORT_ERR:
          return e(new Error("Error while reading a file: Aborted."));
        default:
          return e(new Error("Error while reading a file."));
      }
    }, r.readAsArrayBuffer(n);
  });
}
function wje(n, t) {
  switch (t.type) {
    case "RESOLVE":
      return { value: t.value, error: void 0 };
    case "REJECT":
      return { value: !1, error: t.error };
    case "RESET":
      return { value: void 0, error: void 0 };
    default:
      return n;
  }
}
function sw() {
  return D.useReducer(wje, { value: void 0, error: void 0 });
}
var Cje = function(n, t, e, r) {
  function i(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function l(f) {
      try {
        d(r.next(f));
      } catch (m) {
        o(m);
      }
    }
    function u(f) {
      try {
        d(r.throw(f));
      } catch (m) {
        o(m);
      }
    }
    function d(f) {
      f.done ? s(f.value) : i(f.value).then(l, u);
    }
    d((r = r.apply(n, t || [])).next());
  });
}, XV = function(n, t) {
  var e = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && t.indexOf(r) < 0 && (e[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (e[r[i]] = n[r[i]]);
  return e;
};
const { PDFDataRangeTransport: Eje } = BLe, _je = (n, t) => {
  switch (t) {
    case GV.NEED_PASSWORD: {
      const e = prompt("Enter the password to open this PDF file.");
      n(e);
      break;
    }
    case GV.INCORRECT_PASSWORD: {
      const e = prompt("Invalid password. Please try again.");
      n(e);
      break;
    }
  }
};
function qV(n) {
  return typeof n == "object" && n !== null && ("data" in n || "range" in n || "url" in n);
}
const Tje = D.forwardRef(function(t, e) {
  var { children: r, className: i, error: s = "Failed to load PDF file.", externalLinkRel: o, externalLinkTarget: l, file: u, inputRef: d, imageResourcesPath: f, loading: m = "Loading PDF…", noData: v = "No PDF file specified.", onItemClick: S, onLoadError: w, onLoadProgress: E, onLoadSuccess: A, onPassword: P = _je, onSourceError: R, onSourceSuccess: M, options: j, renderMode: $, rotate: U } = t, F = XV(t, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]);
  const [B, G] = sw(), { value: X, error: te } = B, [ne, K] = sw(), { value: Z, error: oe } = ne, fe = D.useRef(new fje()), ie = D.useRef([]), ue = D.useRef(void 0), Se = D.useRef(void 0);
  u && u !== ue.current && qV(u) && (pa(!Q0(u, ue.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`), ue.current = u), j && j !== Se.current && (pa(!Q0(j, Se.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`), Se.current = j);
  const ke = D.useRef({
    // Handling jumping to internal links target
    scrollPageIntoView: (pt) => {
      const { dest: Ut, pageNumber: jt, pageIndex: $t = jt - 1 } = pt;
      if (S) {
        S({ dest: Ut, pageIndex: $t, pageNumber: jt });
        return;
      }
      const yn = ie.current[$t];
      if (yn) {
        yn.scrollIntoView();
        return;
      }
      pa(!1, `An internal link leading to page ${jt} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);
    }
  });
  D.useImperativeHandle(e, () => ({
    linkService: fe,
    pages: ie,
    viewer: ke
  }), []);
  function ce() {
    M && M();
  }
  function ye() {
    te && (pa(!1, te.toString()), R && R(te));
  }
  function Fe() {
    G({ type: "RESET" });
  }
  D.useEffect(Fe, [u, G]);
  const Xe = D.useCallback(() => Cje(this, void 0, void 0, function* () {
    if (!u)
      return null;
    if (typeof u == "string")
      return bz(u) ? { data: KV(u) } : (YV(), { url: u });
    if (u instanceof Eje)
      return { range: u };
    if (mje(u))
      return { data: u };
    if (_D && vje(u))
      return { data: yield xje(u) };
    if (Vr(typeof u == "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object"), Vr(qV(u), "Invalid parameter object: need either .data, .range or .url"), "url" in u && typeof u.url == "string") {
      if (bz(u.url)) {
        const { url: pt } = u, Ut = XV(u, ["url"]), jt = KV(pt);
        return Object.assign({ data: jt }, Ut);
      }
      YV();
    }
    return u;
  }), [u]);
  D.useEffect(() => {
    const pt = aP(Xe());
    return pt.promise.then((Ut) => {
      G({ type: "RESOLVE", value: Ut });
    }).catch((Ut) => {
      G({ type: "REJECT", error: Ut });
    }), () => {
      pS(pt);
    };
  }, [Xe, G]), D.useEffect(() => {
    if (!(typeof X > "u")) {
      if (X === !1) {
        ye();
        return;
      }
      ce();
    }
  }, [X]);
  function je() {
    Z && (A && A(Z), ie.current = new Array(Z.numPages), fe.current.setDocument(Z));
  }
  function nt() {
    oe && (pa(!1, oe.toString()), w && w(oe));
  }
  D.useEffect(function() {
    K({ type: "RESET" });
  }, [K, X]), D.useEffect(function() {
    if (!X)
      return;
    const Ut = Object.assign(Object.assign({}, X), j), jt = zte(Ut);
    E && (jt.onProgress = E), P && (jt.onPassword = P);
    const $t = jt;
    return $t.promise.then((yn) => {
      K({ type: "RESOLVE", value: yn });
    }).catch((yn) => {
      $t.destroyed || K({ type: "REJECT", error: yn });
    }), () => {
      $t.destroy();
    };
  }, [j, K, X]), D.useEffect(() => {
    if (!(typeof Z > "u")) {
      if (Z === !1) {
        nt();
        return;
      }
      je();
    }
  }, [Z]), D.useEffect(function() {
    fe.current.setViewer(ke.current), fe.current.setExternalLinkRel(o), fe.current.setExternalLinkTarget(l);
  }, [o, l]);
  const Ze = D.useCallback((pt, Ut) => {
    ie.current[pt] = Ut;
  }, []), tt = D.useCallback((pt) => {
    delete ie.current[pt];
  }, []), et = D.useMemo(() => ({
    imageResourcesPath: f,
    linkService: fe.current,
    onItemClick: S,
    pdf: Z,
    registerPage: Ze,
    renderMode: $,
    rotate: U,
    unregisterPage: tt
  }), [f, S, Z, Ze, $, U, tt]), at = D.useMemo(
    () => Bte(F, () => Z),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [F, Z]
  );
  function Yt() {
    return y.jsx(Wte.Provider, { value: et, children: r });
  }
  function Un() {
    return u ? Z == null ? y.jsx(J0, { type: "loading", children: typeof m == "function" ? m() : m }) : Z === !1 ? y.jsx(J0, { type: "error", children: typeof s == "function" ? s() : s }) : Yt() : y.jsx(J0, { type: "no-data", children: typeof v == "function" ? v() : v });
  }
  return y.jsx("div", Object.assign({
    className: ED("react-pdf__Document", i),
    // Assertion is needed for React 18 compatibility
    ref: d,
    style: {
      "--scale-factor": "1"
    }
  }, at, { children: Un() }));
});
function Yte() {
  return D.useContext(Wte);
}
function Xte() {
  for (var n = [], t = 0; t < arguments.length; t++)
    n[t] = arguments[t];
  var e = n.filter(Boolean);
  if (e.length <= 1) {
    var r = e[0];
    return r || null;
  }
  return function(s) {
    e.forEach(function(o) {
      typeof o == "function" ? o(s) : o && (o.current = s);
    });
  };
}
const qte = D.createContext(null), Zte = {
  // Document level structure types
  Document: null,
  // There's a "document" role, but it doesn't make sense here.
  DocumentFragment: null,
  // Grouping level structure types
  Part: "group",
  Sect: "group",
  // XXX: There's a "section" role, but it's abstract.
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  // Block level structure types
  P: null,
  // H<n>,
  H: "heading",
  Title: null,
  FENote: "note",
  // Sub-block level structure type
  Sub: "group",
  // General inline level structure types
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  // Ruby and Warichu structure types
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  // List standard structure types
  L: "list",
  LI: "listitem",
  LBody: null,
  // Table standard structure types
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  // Standard structure type Caption
  Caption: null,
  // Standard structure type Figure
  Figure: "figure",
  // Standard structure type Formula
  Formula: null,
  // standard structure type Artifact
  Artifact: null
}, Pje = /^H(\d+)$/;
function Aje(n) {
  return n in Zte;
}
function TD(n) {
  return "children" in n;
}
function Qte(n) {
  return TD(n) ? n.children.length === 1 && 0 in n.children && "id" in n.children[0] : !1;
}
function kje(n) {
  const t = {};
  if (TD(n)) {
    const { role: e } = n, r = e.match(Pje);
    if (r)
      t.role = "heading", t["aria-level"] = Number(r[1]);
    else if (Aje(e)) {
      const i = Zte[e];
      i && (t.role = i);
    }
  }
  return t;
}
function Jte(n) {
  const t = {};
  if (TD(n)) {
    if (n.alt !== void 0 && (t["aria-label"] = n.alt), n.lang !== void 0 && (t.lang = n.lang), Qte(n)) {
      const [e] = n.children;
      if (e) {
        const r = Jte(e);
        return Object.assign(Object.assign({}, t), r);
      }
    }
  } else
    "id" in n && (t["aria-owns"] = n.id);
  return t;
}
function Ije(n) {
  return n ? Object.assign(Object.assign({}, kje(n)), Jte(n)) : null;
}
function ene({ className: n, node: t }) {
  const e = D.useMemo(() => Ije(t), [t]), r = D.useMemo(() => !TD(t) || Qte(t) ? null : t.children.map((i, s) => (
    // biome-ignore lint/suspicious/noArrayIndexKey: index is stable here
    y.jsx(ene, { node: i }, s)
  )), [t]);
  return y.jsx("span", Object.assign({ className: n }, e, { children: r }));
}
function PD() {
  return D.useContext(qte);
}
function Rje() {
  const n = PD();
  Vr(n, "Unable to find Page context.");
  const { onGetStructTreeError: t, onGetStructTreeSuccess: e } = n, [r, i] = sw(), { value: s, error: o } = r, { customTextRenderer: l, page: u } = n;
  function d() {
    s && e && e(s);
  }
  function f() {
    o && (pa(!1, o.toString()), t && t(o));
  }
  return D.useEffect(function() {
    i({ type: "RESET" });
  }, [i, u]), D.useEffect(function() {
    if (l || !u)
      return;
    const v = aP(u.getStructTree()), S = v;
    return v.promise.then((w) => {
      i({ type: "RESOLVE", value: w });
    }).catch((w) => {
      i({ type: "REJECT", error: w });
    }), () => pS(S);
  }, [l, u, i]), D.useEffect(() => {
    if (s !== void 0) {
      if (s === !1) {
        f();
        return;
      }
      d();
    }
  }, [s]), s ? y.jsx(ene, { className: "react-pdf__Page__structTree structTree", node: s }) : null;
}
const ZV = Fte;
function Mje(n) {
  const t = PD();
  Vr(t, "Unable to find Page context.");
  const e = Object.assign(Object.assign({}, t), n), { _className: r, canvasBackground: i, devicePixelRatio: s = yje(), onRenderError: o, onRenderSuccess: l, page: u, renderForms: d, renderTextLayer: f, rotate: m, scale: v } = e, { canvasRef: S } = n;
  Vr(u, "Attempted to render page canvas, but no page was specified.");
  const w = D.useRef(null);
  function E() {
    u && l && l(xz(u, v));
  }
  function A(j) {
    bje(j) || (pa(!1, j.toString()), o && o(j));
  }
  const P = D.useMemo(() => u.getViewport({ scale: v * s, rotation: m }), [s, u, m, v]), R = D.useMemo(() => u.getViewport({ scale: v, rotation: m }), [u, m, v]);
  D.useEffect(function() {
    if (!u)
      return;
    u.cleanup();
    const { current: $ } = w;
    if (!$)
      return;
    $.width = P.width, $.height = P.height, $.style.width = `${Math.floor(R.width)}px`, $.style.height = `${Math.floor(R.height)}px`, $.style.visibility = "hidden";
    const U = {
      annotationMode: d ? ZV.ENABLE_FORMS : ZV.ENABLE,
      canvasContext: $.getContext("2d", { alpha: !1 }),
      viewport: P
    };
    i && (U.background = i);
    const F = u.render(U), B = F;
    return F.promise.then(() => {
      $.style.visibility = "", E();
    }).catch(A), () => pS(B);
  }, [i, u, d, P, R]);
  const M = D.useCallback(() => {
    const { current: j } = w;
    j && (j.width = 0, j.height = 0);
  }, []);
  return D.useEffect(() => M, [M]), y.jsx("canvas", { className: `${r}__canvas`, dir: "ltr", ref: Xte(S, w), style: {
    display: "block",
    userSelect: "none"
  }, children: f ? y.jsx(Rje, {}) : null });
}
function Dje(n) {
  return "str" in n;
}
function Oje() {
  const n = PD();
  Vr(n, "Unable to find Page context.");
  const { customTextRenderer: t, onGetTextError: e, onGetTextSuccess: r, onRenderTextLayerError: i, onRenderTextLayerSuccess: s, page: o, pageIndex: l, pageNumber: u, rotate: d, scale: f } = n;
  Vr(o, "Attempted to load page text content, but no page was specified.");
  const [m, v] = sw(), { value: S, error: w } = m, E = D.useRef(null), A = D.useRef(void 0);
  pa(Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer");
  function P() {
    S && r && r(S);
  }
  function R() {
    w && (pa(!1, w.toString()), e && e(w));
  }
  D.useEffect(function() {
    v({ type: "RESET" });
  }, [o, v]), D.useEffect(function() {
    if (!o)
      return;
    const G = aP(o.getTextContent()), X = G;
    return G.promise.then((te) => {
      v({ type: "RESOLVE", value: te });
    }).catch((te) => {
      v({ type: "REJECT", error: te });
    }), () => pS(X);
  }, [o, v]), D.useEffect(() => {
    if (S !== void 0) {
      if (S === !1) {
        R();
        return;
      }
      P();
    }
  }, [S]);
  const M = D.useCallback(() => {
    s && s();
  }, [s]), j = D.useCallback((B) => {
    pa(!1, B.toString()), i && i(B);
  }, [i]);
  function $() {
    const B = A.current;
    B && B.classList.add("active");
  }
  function U() {
    const B = A.current;
    B && B.classList.remove("active");
  }
  const F = D.useMemo(() => o.getViewport({ scale: f, rotation: d }), [o, d, f]);
  return D.useLayoutEffect(function() {
    if (!o || !S)
      return;
    const { current: G } = E;
    if (!G)
      return;
    G.innerHTML = "";
    const X = o.streamTextContent({ includeMarkedContent: !0 }), te = {
      container: G,
      textContentSource: X,
      viewport: F
    }, ne = new $te(te), K = ne;
    return ne.render().then(() => {
      const Z = document.createElement("div");
      Z.className = "endOfContent", G.append(Z), A.current = Z;
      const oe = G.querySelectorAll('[role="presentation"]');
      if (t) {
        let fe = 0;
        S.items.forEach((ie, ue) => {
          if (!Dje(ie))
            return;
          const Se = oe[fe];
          if (!Se)
            return;
          const ke = t(Object.assign({
            pageIndex: l,
            pageNumber: u,
            itemIndex: ue
          }, ie));
          Se.innerHTML = ke, fe += ie.str && ie.hasEOL ? 2 : 1;
        });
      }
      M();
    }).catch(j), () => pS(K);
  }, [
    t,
    j,
    M,
    o,
    l,
    u,
    S,
    F
  ]), y.jsx("div", { className: ED("react-pdf__Page__textContent", "textLayer"), onMouseUp: U, onMouseDown: $, ref: E });
}
function Lje() {
  const n = Yte(), t = PD();
  Vr(t, "Unable to find Page context.");
  const e = Object.assign(Object.assign({}, n), t), { imageResourcesPath: r, linkService: i, onGetAnnotationsError: s, onGetAnnotationsSuccess: o, onRenderAnnotationLayerError: l, onRenderAnnotationLayerSuccess: u, page: d, pdf: f, renderForms: m, rotate: v, scale: S = 1 } = e;
  Vr(f, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."), Vr(d, "Attempted to load page annotations, but no page was specified."), Vr(i, "Attempted to load page annotations, but no linkService was specified.");
  const [w, E] = sw(), { value: A, error: P } = w, R = D.useRef(null);
  pa(Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations");
  function M() {
    A && o && o(A);
  }
  function j() {
    P && (pa(!1, P.toString()), s && s(P));
  }
  D.useEffect(function() {
    E({ type: "RESET" });
  }, [E, d]), D.useEffect(function() {
    if (!d)
      return;
    const G = aP(d.getAnnotations()), X = G;
    return G.promise.then((te) => {
      E({ type: "RESOLVE", value: te });
    }).catch((te) => {
      E({ type: "REJECT", error: te });
    }), () => {
      pS(X);
    };
  }, [E, d]), D.useEffect(() => {
    if (A !== void 0) {
      if (A === !1) {
        j();
        return;
      }
      M();
    }
  }, [A]);
  function $() {
    u && u();
  }
  function U(B) {
    pa(!1, `${B}`), l && l(B);
  }
  const F = D.useMemo(() => d.getViewport({ scale: S, rotation: v }), [d, v, S]);
  return D.useEffect(function() {
    if (!f || !d || !i || !A)
      return;
    const { current: G } = R;
    if (!G)
      return;
    const X = F.clone({ dontFlip: !0 }), te = {
      accessibilityManager: null,
      // TODO: Implement this
      annotationCanvasMap: null,
      // TODO: Implement this
      annotationEditorUIManager: null,
      // TODO: Implement this
      div: G,
      l10n: null,
      // TODO: Implement this
      page: d,
      viewport: X
    }, ne = {
      annotations: A,
      annotationStorage: f.annotationStorage,
      div: G,
      imageResourcesPath: r,
      linkService: i,
      page: d,
      renderForms: m,
      viewport: X
    };
    G.innerHTML = "";
    try {
      new Nte(te).render(ne), $();
    } catch (K) {
      U(K);
    }
    return () => {
    };
  }, [A, r, i, d, f, m, F]), y.jsx("div", { className: ED("react-pdf__Page__annotations", "annotationLayer"), ref: R });
}
var jje = function(n, t) {
  var e = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && t.indexOf(r) < 0 && (e[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (e[r[i]] = n[r[i]]);
  return e;
};
const QV = 1;
function Nje(n) {
  const t = Yte(), e = Object.assign(Object.assign({}, t), n), { _className: r = "react-pdf__Page", _enableRegisterUnregisterPage: i = !0, canvasBackground: s, canvasRef: o, children: l, className: u, customRenderer: d, customTextRenderer: f, devicePixelRatio: m, error: v = "Failed to load the page.", height: S, inputRef: w, loading: E = "Loading page…", noData: A = "No page specified.", onGetAnnotationsError: P, onGetAnnotationsSuccess: R, onGetStructTreeError: M, onGetStructTreeSuccess: j, onGetTextError: $, onGetTextSuccess: U, onLoadError: F, onLoadSuccess: B, onRenderAnnotationLayerError: G, onRenderAnnotationLayerSuccess: X, onRenderError: te, onRenderSuccess: ne, onRenderTextLayerError: K, onRenderTextLayerSuccess: Z, pageIndex: oe, pageNumber: fe, pdf: ie, registerPage: ue, renderAnnotationLayer: Se = !0, renderForms: ke = !1, renderMode: ce = "canvas", renderTextLayer: ye = !0, rotate: Fe, scale: Xe = QV, unregisterPage: je, width: nt } = e, Ze = jje(e, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]), [tt, et] = sw(), { value: at, error: Yt } = tt, Un = D.useRef(null);
  Vr(ie, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  const pt = Vv(fe) ? fe - 1 : oe ?? null, Ut = fe ?? (Vv(oe) ? oe + 1 : null), jt = Fe ?? (at ? at.rotate : null), $t = D.useMemo(() => {
    if (!at)
      return null;
    let On = 1;
    const Kr = Xe ?? QV;
    if (nt || S) {
      const ns = at.getViewport({ scale: 1, rotation: jt });
      nt ? On = nt / ns.width : S && (On = S / ns.height);
    }
    return Kr * On;
  }, [S, at, jt, Xe, nt]);
  D.useEffect(function() {
    return () => {
      Vv(pt) && i && je && je(pt);
    };
  }, [i, ie, pt, je]);
  function yn() {
    if (B) {
      if (!at || !$t)
        return;
      B(xz(at, $t));
    }
    if (i && ue) {
      if (!Vv(pt) || !Un.current)
        return;
      ue(pt, Un.current);
    }
  }
  function hi() {
    Yt && (pa(!1, Yt.toString()), F && F(Yt));
  }
  D.useEffect(function() {
    et({ type: "RESET" });
  }, [et, ie, pt]), D.useEffect(function() {
    if (!ie || !Ut)
      return;
    const Kr = aP(ie.getPage(Ut)), ns = Kr;
    return Kr.promise.then((vr) => {
      et({ type: "RESOLVE", value: vr });
    }).catch((vr) => {
      et({ type: "REJECT", error: vr });
    }), () => pS(ns);
  }, [et, ie, Ut]), D.useEffect(() => {
    if (at !== void 0) {
      if (at === !1) {
        hi();
        return;
      }
      yn();
    }
  }, [at, $t]);
  const Nr = D.useMemo(() => (
    // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that
    at && Vv(pt) && Ut && Vv(jt) && Vv($t) ? {
      _className: r,
      canvasBackground: s,
      customTextRenderer: f,
      devicePixelRatio: m,
      onGetAnnotationsError: P,
      onGetAnnotationsSuccess: R,
      onGetStructTreeError: M,
      onGetStructTreeSuccess: j,
      onGetTextError: $,
      onGetTextSuccess: U,
      onRenderAnnotationLayerError: G,
      onRenderAnnotationLayerSuccess: X,
      onRenderError: te,
      onRenderSuccess: ne,
      onRenderTextLayerError: K,
      onRenderTextLayerSuccess: Z,
      page: at,
      pageIndex: pt,
      pageNumber: Ut,
      renderForms: ke,
      renderTextLayer: ye,
      rotate: jt,
      scale: $t
    } : null
  ), [
    r,
    s,
    f,
    m,
    P,
    R,
    M,
    j,
    $,
    U,
    G,
    X,
    te,
    ne,
    K,
    Z,
    at,
    pt,
    Ut,
    ke,
    ye,
    jt,
    $t
  ]), fi = D.useMemo(
    () => Bte(Ze, () => at && ($t ? xz(at, $t) : void 0)),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [Ze, at, $t]
  ), oi = `${pt}@${$t}/${jt}`;
  function es() {
    switch (ce) {
      case "custom":
        return Vr(d, 'renderMode was set to "custom", but no customRenderer was passed.'), y.jsx(d, {}, `${oi}_custom`);
      case "none":
        return null;
      case "canvas":
      default:
        return y.jsx(Mje, { canvasRef: o }, `${oi}_canvas`);
    }
  }
  function Di() {
    return ye ? y.jsx(Oje, {}, `${oi}_text`) : null;
  }
  function Ss() {
    return Se ? y.jsx(Lje, {}, `${oi}_annotations`) : null;
  }
  function wi() {
    return y.jsxs(qte.Provider, { value: Nr, children: [es(), Di(), Ss(), l] });
  }
  function ts() {
    return Ut ? ie === null || at === void 0 || at === null ? y.jsx(J0, { type: "loading", children: typeof E == "function" ? E() : E }) : ie === !1 || at === !1 ? y.jsx(J0, { type: "error", children: typeof v == "function" ? v() : v }) : wi() : y.jsx(J0, { type: "no-data", children: typeof A == "function" ? A() : A });
  }
  return y.jsx("div", Object.assign({
    className: ED(r, u),
    "data-page-number": Ut,
    // Assertion is needed for React 18 compatibility
    ref: Xte(w, Un),
    style: {
      "--scale-factor": `${$t}`,
      backgroundColor: s || "white",
      position: "relative",
      minWidth: "min-content",
      minHeight: "min-content"
    }
  }, fi, { children: ts() }));
}
Sje();
eB.workerSrc = "pdf.worker.mjs";
eB.workerSrc = `//unpkg.com/pdfjs-dist@${Ute}/build/pdf.worker.min.mjs`;
const Fje = ({
  pdfDocumentURL: n,
  pdfPageIndex: t,
  pdfRenderWidth: e,
  pdfRenderHeight: r,
  pdfRenderScale: i,
  onPdfDocumentChange: s = () => {
  },
  onPdfPageChange: o = () => {
  },
  onPdfItemClick: l = () => {
  }
}) => {
  const u = D.useCallback(
    (A) => {
      s(A);
    },
    [s]
  ), d = D.useCallback(
    (A) => {
      o(A);
    },
    [o]
  ), f = D.useCallback(
    (A) => {
      console.log(`Unable to load PDF document: ${A}`), s(null);
    },
    [s]
  ), m = D.useCallback(
    (A) => {
      console.log(`Unable to load PDF page: ${A}`), o(null);
    },
    [o]
  ), v = D.useCallback(
    ({ pageIndex: A, dest: P }) => {
      Array.isArray(P) ? l({
        pageIndex: A,
        destination: P
      }) : l({
        pageIndex: A
      });
    },
    [l]
  ), S = D.useCallback(
    (A) => /* @__PURE__ */ y.jsx(
      "div",
      {
        style: {
          display: "flex",
          width: e,
          height: r,
          justifyContent: "center",
          alignItems: "center"
        },
        children: A
      }
    ),
    [e, r]
  ), w = D.useMemo(() => S(
    /* @__PURE__ */ y.jsx(
      "div",
      {
        style: {
          fontSize: "1.2em"
        },
        children: "불러오는 중..."
      }
    )
  ), [S]), E = D.useMemo(() => S(
    /* @__PURE__ */ y.jsx(
      "div",
      {
        style: {
          fontSize: "1.2em"
        },
        children: "오류가 발생하였습니다."
      }
    )
  ), [S]);
  return /* @__PURE__ */ y.jsx(Tje, { file: n, onLoadSuccess: u, onLoadError: f, onItemClick: v, children: /* @__PURE__ */ y.jsx(
    Nje,
    {
      loading: w,
      error: E,
      noData: E,
      width: e,
      height: r,
      scale: i,
      pageIndex: t,
      onLoadSuccess: d,
      onLoadError: m
    }
  ) });
}, $je = D.memo(Fje), zje = ({
  pdfDocumentURL: n,
  pdfPageIndex: t = 0,
  pdfRenderOptions: e = {
    width: 0,
    height: 0,
    baseX: 0,
    baseY: 0,
    scale: 1
  },
  pdfInteractionEnabled: r = !0,
  pdfItemClickEnabled: i = !0,
  onPdfDocumentChange: s = () => {
  },
  onPdfPageChange: o = () => {
  },
  onPdfItemClick: l = () => {
  }
}) => /* @__PURE__ */ y.jsx(
  "div",
  {
    style: {
      width: e.width,
      height: e.height,
      overflow: "hidden",
      userSelect: r ? "unset" : "none",
      pointerEvents: r ? "unset" : "none",
      "--annotation-pointer-events": r && i ? "auto" : "none"
    },
    children: /* @__PURE__ */ y.jsx(
      "div",
      {
        style: {
          transform: `translate(${-e.baseX * e.scale}px, ${-e.baseY * e.scale}px)`
        },
        children: /* @__PURE__ */ y.jsx(
          $je,
          {
            pdfDocumentURL: n,
            pdfPageIndex: t,
            pdfRenderWidth: e.width,
            pdfRenderHeight: e.height,
            pdfRenderScale: e.scale,
            onPdfDocumentChange: s,
            onPdfPageChange: o,
            onPdfItemClick: l
          }
        )
      }
    )
  }
), Uje = D.memo(zje), Bje = ({ pdfDocumentURL: n, pdfViewerControllerHook: t }) => {
  const e = D.useRef(null), r = zJ(), { pdfViewerController: i, onPdfDocumentChange: s, onPdfPageChange: o, onPdfItemClick: l, onPdfMouseMoveEvent: u, onPdfWheelEvent: d } = t || r;
  return D.useEffect(() => {
    if (e.current) {
      const f = e.current;
      return f.addEventListener("mousemove", u), () => f.removeEventListener("mousemove", u);
    }
  }, [u]), D.useEffect(() => {
    if (e.current) {
      const f = e.current;
      return f.addEventListener("wheel", d), () => f.removeEventListener("wheel", d);
    }
  }, [d]), /* @__PURE__ */ y.jsx(
    "div",
    {
      ref: e,
      style: {
        cursor: i.isDragModeEnabled() ? "move" : "default"
      },
      children: /* @__PURE__ */ y.jsx(
        Uje,
        {
          pdfDocumentURL: n,
          pdfPageIndex: i.getPageIndex(),
          pdfRenderOptions: i.getRenderOptions(),
          pdfInteractionEnabled: !i.isDragModeEnabled(),
          pdfItemClickEnabled: i.isItemClickEnabled(),
          onPdfDocumentChange: s,
          onPdfPageChange: o,
          onPdfItemClick: l
        }
      )
    }
  );
}, Hje = D.memo(Bje), Vje = {
  store: {
    "document:document": {
      gridSize: 10,
      name: "",
      meta: {},
      id: "document:document",
      typeName: "document"
    },
    "page:page": {
      meta: {},
      id: "page:page",
      name: "Page 1",
      index: "a1",
      typeName: "page"
    }
  },
  schema: {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": 4,
      "com.tldraw.asset": 1,
      "com.tldraw.camera": 1,
      "com.tldraw.document": 2,
      "com.tldraw.instance": 25,
      "com.tldraw.instance_page_state": 5,
      "com.tldraw.page": 1,
      "com.tldraw.instance_presence": 5,
      "com.tldraw.pointer": 1,
      "com.tldraw.shape": 4,
      "com.tldraw.asset.bookmark": 2,
      "com.tldraw.asset.image": 5,
      "com.tldraw.asset.video": 5,
      "com.tldraw.shape.group": 0,
      "com.tldraw.shape.text": 2,
      "com.tldraw.shape.bookmark": 2,
      "com.tldraw.shape.draw": 2,
      "com.tldraw.shape.geo": 9,
      "com.tldraw.shape.note": 7,
      "com.tldraw.shape.line": 5,
      "com.tldraw.shape.frame": 0,
      "com.tldraw.shape.arrow": 5,
      "com.tldraw.shape.highlight": 1,
      "com.tldraw.shape.embed": 4,
      "com.tldraw.shape.image": 4,
      "com.tldraw.shape.video": 2,
      "com.tldraw.binding.arrow": 0
    }
  }
}, Wje = {
  version: 0,
  currentPageId: "page:page",
  exportBackground: !0,
  isFocusMode: !1,
  isDebugMode: !1,
  isToolLocked: !1,
  isGridMode: !1,
  pageStates: [
    {
      pageId: "page:page",
      camera: {
        x: 0,
        y: 0,
        z: 1
      },
      selectedShapeIds: [],
      focusedGroupId: null
    }
  ]
}, Gje = {
  document: Vje,
  session: Wje
}, Kje = ({
  painterId: n,
  externalAssetStore: t = null
}) => {
  const { pdfViewerController: e, onPdfDocumentChange: r, onPdfPageChange: i, onPdfItemClick: s, onPdfMouseMoveEvent: o, onPdfWheelEvent: l } = zJ(), [u, d] = D.useState("default"), f = D.useRef({}), m = D.useRef(null);
  D.useEffect(() => {
    e.setDragModeEnabled(u === "move"), Object.values(f.current).forEach((ne) => {
      ne.selectNone();
    });
  }, [e, u]);
  const v = D.useCallback((ne) => ne in f.current ? f.current[ne] : null, []), S = D.useCallback(
    (ne, K) => `${n}_${ne}_${K}`,
    [n]
  ), w = D.useCallback(
    (ne, K) => {
      const Z = S(ne, K);
      console.log(`[Editor: ${ne} - Page: ${K}] Get Editor Snapshot: ${Z}`);
      const oe = localStorage.getItem(Z);
      if (oe !== null)
        try {
          return JSON.parse(oe);
        } catch (fe) {
          console.log(`[Editor: ${ne} - Page: ${K}] Invalid Snapshot: ${Z}`), console.log(fe);
        }
      return null;
    },
    [S]
  ), E = D.useCallback(
    (ne, K, Z) => {
      const oe = S(ne, K);
      console.log(`[Editor: ${ne} - Page: ${K}] Set Editor Snapshot: ${oe}`), localStorage.setItem(oe, JSON.stringify(Z));
    },
    [S]
  ), A = D.useCallback(
    (ne, K) => {
      const Z = S(ne, K);
      console.log(`[Editor: ${ne} - Page: ${K}] Clear Editor Snapshot: ${Z}`), localStorage.removeItem(Z);
    },
    [S]
  ), P = D.useCallback(
    (ne) => {
      const K = v(ne);
      if (K !== null) {
        console.log(`[Editor: ${ne}] Load empty snapshot.`);
        try {
          K.loadSnapshot(Gje);
        } catch {
          console.log(`[Editor: ${ne}] Unable to load empty snapshot.`);
        }
      }
    },
    [v]
  ), R = D.useCallback(
    (ne, K) => {
      const Z = v(ne);
      if (Z === null)
        return;
      const oe = S(ne, K);
      console.log(`[Editor: ${ne} - Page: ${K}] Load snapshot: ${oe}`);
      const fe = w(ne, K);
      if (fe === null)
        console.log(`[Editor: ${ne} - Page: ${K}] Snapshot not found: ${oe}`), P(ne);
      else
        try {
          Z.loadSnapshot(fe);
        } catch {
          console.log(`[Editor: ${ne} - Page: ${K}] Unable to load snapshot: ${oe}`), P(ne);
        }
    },
    [v, S, w, P]
  ), M = D.useCallback(
    (ne) => {
      for (const K of Object.keys(f.current))
        R(K, ne);
    },
    [R]
  ), j = D.useCallback(
    (ne, K) => {
      const Z = v(ne);
      if (Z === null)
        return;
      const oe = S(ne, K);
      console.log(`[Editor: ${ne} - Page: ${K}] Save snapshot: ${oe}`);
      try {
        Z.selectNone(), E(ne, K, Z.getSnapshot());
      } catch {
        console.log(`[Editor: ${ne} - Page: ${K}] Unable to save snapshot: ${oe}`);
      }
    },
    [v, S, E]
  ), $ = D.useCallback(
    (ne) => {
      for (const K of Object.keys(f.current))
        j(K, ne);
    },
    [j]
  ), U = D.useCallback(
    (ne, K) => {
      K.updateInstanceState({
        isDebugMode: !1
      }), K.setCameraOptions({
        isLocked: !0
      }), ne in f.current ? f.current[ne] = K : (f.current[ne] = K, m.current !== null && R(ne, m.current));
    },
    [R]
  ), F = D.useCallback((ne) => {
    ne in f.current && delete f.current[ne];
  }, []);
  D.useEffect(() => {
    m.current !== e.getPageIndex() && (m.current !== null && $(m.current), m.current = e.getPageIndex(), M(m.current));
  }, [e, M, $]), D.useEffect(() => {
    var ke, ce;
    console.log("Update Camera");
    const { width: ne, height: K, baseX: Z, baseY: oe, scale: fe } = e.getRenderOptions(), ie = ne / (((ke = e.getPage()) == null ? void 0 : ke.originalWidth) || 0) || 1, ue = K / (((ce = e.getPage()) == null ? void 0 : ce.originalHeight) || 0) || 1, Se = (ie + ue) / 2;
    for (const ye of Object.values(f.current))
      ye.setCamera(
        {
          x: -Z / Se,
          y: -oe / Se,
          z: fe * Se
        },
        {
          force: !0
        }
      );
  }, [e]);
  const B = D.useCallback(
    (ne, K) => (j(ne, K), w(ne, K)),
    [j, w]
  ), G = D.useCallback(
    (ne, K, Z) => {
      E(ne, K, Z), R(ne, K);
    },
    [R, E]
  ), X = D.useCallback(
    (ne, K) => {
      A(ne, K), R(ne, K);
    },
    [R, A]
  );
  return {
    pdfPainterController: D.useMemo(() => ({
      ...e,
      getPaintMode: () => u,
      setPaintMode: (ne) => {
        d(ne);
      },
      registerEditor: U,
      unregisterEditor: F,
      getEditor: v,
      getEditorSnapshot: B,
      setEditorSnapshot: G,
      clearEditorSnapshot: X
    }), [e, u, U, F, v, B, G, X]),
    onPdfDocumentChange: r,
    onPdfPageChange: i,
    onPdfItemClick: s,
    onPdfMouseMoveEvent: o,
    onPdfWheelEvent: l,
    externalAssetStore: t
  };
}, Yje = ({
  editorId: n,
  pdfPainterController: t,
  onStoreUpdate: e = () => {
  }
}) => {
  const r = D.useCallback(
    (s) => {
      t.registerEditor(n, s), s.store.listen(({ changes: o }) => e(o), { source: "user", scope: "document" });
    },
    [n, t, e]
  );
  return {
    pdfPainterInstanceController: D.useMemo(() => ({
      getEditor: () => t.getEditor(n),
      getEditorSnapshot: (s) => t.getEditorSnapshot(n, s),
      setEditorSnapshot: (s, o) => t.setEditorSnapshot(n, s, o),
      clearEditorSnapshot: (s) => t.clearEditorSnapshot(n, s),
      getPaintElement: (s) => {
        const o = t.getEditor(n);
        return o === null ? null : o.store.has(s) ? o.store.get(s) : null;
      },
      setPaintElement: (s, o) => {
        const l = t.getEditor(n);
        l !== null && (s === null ? o && l.store.put([o]) : l.store.has(s) && (o ? l.store.update(s, () => o) : l.store.remove([s])));
      },
      updatePaintElementByGenerator: (s, o) => {
        const l = t.getEditor(n);
        l !== null && l.store.has(s) && l.store.update(s, o);
      }
    }), [n, t]),
    onEditorLoad: r
  };
}, Xje = ({
  instanceId: n,
  readOnly: t = !1,
  customPdfPainterInstanceControllerHook: e
}) => /* @__PURE__ */ y.jsxs("div", { children: [
  /* @__PURE__ */ y.jsx("div", { children: n }),
  /* @__PURE__ */ y.jsx("div", { children: t }),
  /* @__PURE__ */ y.jsx("div", { children: String(e) })
] }), UNe = D.memo(Xje), qje = ({
  instanceId: n,
  readOnly: t = !1,
  pdfPainterControllerHook: e,
  customPdfPainterInstanceControllerHook: r
}) => {
  const { pdfPainterController: i } = e, s = Yje({
    editorId: n,
    pdfPainterController: i
  }), o = r || s;
  return /* @__PURE__ */ y.jsx(
    nDe,
    {
      readOnly: t,
      externalAssetStore: e.externalAssetStore,
      onEditorLoad: (l) => {
        o.onEditorLoad(l);
      }
    }
  );
}, Zje = D.memo(qje), Qje = ({ onClick: n, disabled: t, icon: e, alt: r }) => /* @__PURE__ */ y.jsx(
  "button",
  {
    style: {
      padding: "0.4em 0.8em",
      userSelect: "none"
    },
    onClick: n,
    disabled: t,
    children: /* @__PURE__ */ y.jsx(
      "img",
      {
        style: {
          width: "1.6em",
          height: "1.6em"
        },
        src: e,
        alt: r
      }
    )
  }
), VE = D.memo(Qje), Jje = "data:image/svg+xml,%3csvg%20width='30'%20height='30'%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M17.0715%2028.7126L21.3174%2026.7784L16.902%2017.0768L24.9392%2016.7223L7.12329%201.28723V24.8366L12.6484%2019.011L17.0715%2028.7126Z'%20stroke='black'%20stroke-width='2'%20stroke-linejoin='round'/%3e%3c/svg%3e", eNe = "data:image/svg+xml,%3csvg%20width='30'%20height='30'%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M8.63587%2016.0218C8.44552%2015.2986%208.25517%2014.4043%207.85544%2013.0722C7.09942%2010.5825%205.78137%208.27199%205.13345%205.74583C4.70752%203.93612%206.2521%202.10299%208.17903%202.77722C11.1279%203.81302%2012.0474%208.88558%2012.4619%2011.4547L12.6142%2012.311C12.4106%208.60372%2012.1453%206.1853%2012.6142%203.13878C13.0768%200.248065%2017.5022%200.313862%2017.8678%203.17684C18.0568%205.25596%2018.0581%207.33084%2018.0581%209.41852C18.0581%209.8562%2018.0581%2012.5013%2018.0962%2012.2159C18.2104%2010.9599%2018.2675%206.14545%2018.7434%204.71823C19.7824%201.52792%2023.6363%202.68984%2023.8257%205.59359C23.9832%207.69327%2023.7641%209.8847%2023.7115%2011.9875C23.7115%2012.0636%2023.6924%2012.5584%2023.7495%2012.33C24.3238%2010.544%2023.8257%205.59359%2026.9373%206.21128C27.9639%206.41508%2029.8685%207.80123%2028.4794%2012.5C26.5191%2019.131%2023.9795%2021.9981%2023.9795%2029H9.97947C9.97947%2024%203.36858%2020.1796%201.47943%2016.4024C1.06067%2015.6031%200.852976%2014.5946%201.11946%2013.8714C1.55727%2012.7487%202.37339%2012.1588%203.6868%2012.292C5.8293%2012.4979%206.69503%2014.3244%208.63587%2016.0218Z'%20stroke='black'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", tNe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20stroke='currentColor'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'%20class='feather%20feather-edit-2'%3e%3cpath%20d='M17%203a2.828%202.828%200%201%201%204%204L7.5%2020.5%202%2022l1.5-5.5L17%203z'%3e%3c/path%3e%3c/svg%3e", nNe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20stroke='currentColor'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'%20class='feather%20feather-arrow-left'%3e%3cline%20x1='19'%20y1='12'%20x2='5'%20y2='12'%3e%3c/line%3e%3cpolyline%20points='12%2019%205%2012%2012%205'%3e%3c/polyline%3e%3c/svg%3e", rNe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20stroke='currentColor'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'%20class='feather%20feather-arrow-right'%3e%3cline%20x1='5'%20y1='12'%20x2='19'%20y2='12'%3e%3c/line%3e%3cpolyline%20points='12%205%2019%2012%2012%2019'%3e%3c/polyline%3e%3c/svg%3e", iNe = ({ pdfPainterController: n }) => (D.useEffect(() => {
  n.setDragModeEnabled(n.getPaintMode() === "move");
}, [n]), /* @__PURE__ */ y.jsxs(
  "div",
  {
    style: {
      display: "flex",
      padding: "1em",
      color: "#ffffff",
      backgroundColor: "#aaaaaa",
      justifyContent: "center",
      alignItems: "center",
      gap: "1em"
    },
    children: [
      /* @__PURE__ */ y.jsx(
        VE,
        {
          onClick: () => n.setPaintMode("default"),
          disabled: n.getPaintMode() === "default",
          icon: Jje,
          alt: "기본"
        }
      ),
      /* @__PURE__ */ y.jsx(
        VE,
        {
          onClick: () => n.setPaintMode("move"),
          disabled: n.getPaintMode() === "move",
          icon: eNe,
          alt: "이동"
        }
      ),
      /* @__PURE__ */ y.jsx(
        VE,
        {
          onClick: () => n.setPaintMode("draw"),
          disabled: n.getPaintMode() === "draw",
          icon: tNe,
          alt: "그리기"
        }
      ),
      /* @__PURE__ */ y.jsx(VE, { onClick: n.moveToPreviousPage, disabled: !n.hasPreviousPage(), icon: nNe, alt: "이전 페이지" }),
      /* @__PURE__ */ y.jsxs("div", { children: [
        n.getPageIndex() + 1,
        "/",
        n.getPageCount()
      ] }),
      /* @__PURE__ */ y.jsxs("div", { children: [
        Math.round(n.getRenderOptions().scale * 100),
        "%"
      ] }),
      /* @__PURE__ */ y.jsx(VE, { onClick: n.moveToNextPage, disabled: !n.hasNextPage(), icon: rNe, alt: "다음 페이지" })
    ]
  }
)), sNe = D.memo(iNe), oNe = ({
  painterId: n,
  pdfDocumentURL: t,
  customPdfPainterControllerHook: e,
  children: r
}) => {
  const i = D.useRef(null), s = Kje({ painterId: n }), o = e || s, { pdfPainterController: l } = o, u = D.useCallback(() => {
    const d = l.getPage();
    if (i.current && d) {
      const f = i.current.offsetWidth, m = i.current.offsetHeight, v = d.originalWidth, S = d.originalHeight, w = f / m, E = v / S;
      let A;
      E > w ? A = {
        width: f,
        height: f / E
      } : A = {
        width: m * E,
        height: m
      };
      const P = l.getRenderSize();
      (A.width !== P.width || A.height !== P.height) && l.setRenderSize(A);
    }
  }, [l]);
  return D.useEffect(() => {
    const d = new ResizeObserver(() => {
      u();
    });
    return i.current && d.observe(i.current), () => {
      d.disconnect();
    };
  }, [u]), /* @__PURE__ */ y.jsxs(
    "div",
    {
      style: {
        display: "flex",
        width: "100%",
        height: "100%",
        flexDirection: "column"
      },
      children: [
        /* @__PURE__ */ y.jsx(
          "div",
          {
            ref: i,
            style: {
              flex: 1,
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              overflow: "hidden"
            },
            children: /* @__PURE__ */ y.jsxs(
              "div",
              {
                style: {
                  position: "relative",
                  width: "fit-content",
                  height: "fit-content"
                },
                children: [
                  /* @__PURE__ */ y.jsx(
                    Hje,
                    {
                      pdfDocumentURL: t,
                      pdfViewerControllerHook: {
                        pdfViewerController: o.pdfPainterController,
                        onPdfDocumentChange: o.onPdfDocumentChange,
                        onPdfPageChange: o.onPdfPageChange,
                        onPdfItemClick: o.onPdfItemClick,
                        onPdfMouseMoveEvent: o.onPdfMouseMoveEvent,
                        onPdfWheelEvent: o.onPdfWheelEvent
                      }
                    }
                  ),
                  D.Children.toArray(r).map((d) => D.isValidElement(d) ? /* @__PURE__ */ y.jsx(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        top: 0,
                        left: 0,
                        width: l.getRenderSize().width,
                        height: l.getRenderSize().height,
                        pointerEvents: l.getPaintMode() === "draw" ? "unset" : "none"
                      },
                      children: /* @__PURE__ */ y.jsx(
                        Zje,
                        {
                          instanceId: d.props.instanceId,
                          readOnly: d.props.readOnly || l.getPaintMode() !== "draw",
                          pdfPainterControllerHook: o,
                          customPdfPainterInstanceControllerHook: d.props.customPdfPainterInstanceControllerHook
                        }
                      )
                    },
                    d.props.instanceId
                  ) : d)
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ y.jsx(sNe, { pdfPainterController: l })
      ]
    }
  );
}, BNe = D.memo(oNe);
export {
  $je as BasePDFRenderer,
  BNe as PDFPainter,
  sNe as PDFPainterControlBar,
  VE as PDFPainterControlBarButton,
  Uje as PDFRenderer,
  Hje as PDFViewer,
  nDe as Painter,
  Zje as PainterInstance,
  UNe as PainterInstanceGenerator,
  Kje as usePDFPainterController,
  Yje as usePDFPainterInstanceController,
  zJ as usePDFViewerController
};
